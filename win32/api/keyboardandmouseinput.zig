//! NOTE: this source file is autogenerated, DO NOT MODIFY

//
// constants
//

//
// types
//
// --------------------------------------------------------
// Type: MOUSEMOVEPOINT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const MOUSEMOVEPOINT = extern struct {
    x: i32,
    y: i32,
    time: u32,
    dwExtraInfo: ?*opaque{},
};
// --------------------------------------------------------
// Type: TRACKMOUSEEVENT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TRACKMOUSEEVENT = extern struct {
    cbSize: u32,
    dwFlags: u32,
    hwndTrack: HWND,
    dwHoverTime: u32,
};
// --------------------------------------------------------
// Type: MOUSEINPUT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const MOUSEINPUT = extern struct {
    dx: i32,
    dy: i32,
    mouseData: u32,
    dwFlags: u32,
    time: u32,
    dwExtraInfo: ?*opaque{},
};
// --------------------------------------------------------
// Type: KEYBDINPUT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const KEYBDINPUT = extern struct {
    wVk: u16,
    wScan: u16,
    dwFlags: u32,
    time: u32,
    dwExtraInfo: ?*opaque{},
};
// --------------------------------------------------------
// Type: HARDWAREINPUT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HARDWAREINPUT = extern struct {
    uMsg: u32,
    wParamL: u16,
    wParamH: u16,
};
// --------------------------------------------------------
// Type: INPUT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const INPUT = extern struct {
    type: u32,
    Anonymous: _Anonymous_e__Union,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: LASTINPUTINFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const LASTINPUTINFO = extern struct {
    cbSize: u32,
    dwTime: u32,
};
// --------------------------------------------------------
// Type: RAWINPUTHEADER
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const RAWINPUTHEADER = extern struct {
    dwType: u32,
    dwSize: u32,
    hDevice: HANDLE,
    wParam: WPARAM,
};
// --------------------------------------------------------
// Type: RAWMOUSE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const RAWMOUSE = extern struct {
    usFlags: u16,
    Anonymous: _Anonymous_e__Union,
    ulRawButtons: u32,
    lLastX: i32,
    lLastY: i32,
    ulExtraInformation: u32,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
        // --------------------------------------------------------
        // Type: _Anonymous_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _Anonymous_e__Struct = extern struct {
            usButtonFlags: u16,
            usButtonData: u16,
        };
    };
};
// --------------------------------------------------------
// Type: RAWKEYBOARD
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const RAWKEYBOARD = extern struct {
    MakeCode: u16,
    Flags: u16,
    Reserved: u16,
    VKey: u16,
    Message: u32,
    ExtraInformation: u32,
};
// --------------------------------------------------------
// Type: RAWHID
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const RAWHID = extern struct {
    dwSizeHid: u32,
    dwCount: u32,
    bRawData: ?[*]u8,
};
// --------------------------------------------------------
// Type: RAWINPUT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const RAWINPUT = extern struct {
    header: RAWINPUTHEADER,
    data: _data_e__Union,
    // --------------------------------------------------------
    // Type: _data_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _data_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: RID_DEVICE_INFO_MOUSE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const RID_DEVICE_INFO_MOUSE = extern struct {
    dwId: u32,
    dwNumberOfButtons: u32,
    dwSampleRate: u32,
    fHasHorizontalWheel: BOOL,
};
// --------------------------------------------------------
// Type: RID_DEVICE_INFO_KEYBOARD
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const RID_DEVICE_INFO_KEYBOARD = extern struct {
    dwType: u32,
    dwSubType: u32,
    dwKeyboardMode: u32,
    dwNumberOfFunctionKeys: u32,
    dwNumberOfIndicators: u32,
    dwNumberOfKeysTotal: u32,
};
// --------------------------------------------------------
// Type: RID_DEVICE_INFO_HID
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const RID_DEVICE_INFO_HID = extern struct {
    dwVendorId: u32,
    dwProductId: u32,
    dwVersionNumber: u32,
    usUsagePage: u16,
    usUsage: u16,
};
// --------------------------------------------------------
// Type: RID_DEVICE_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const RID_DEVICE_INFO = extern struct {
    cbSize: u32,
    dwType: u32,
    Anonymous: _Anonymous_e__Union,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: RAWINPUTDEVICE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const RAWINPUTDEVICE = extern struct {
    usUsagePage: u16,
    usUsage: u16,
    dwFlags: u32,
    hwndTarget: HWND,
};
// --------------------------------------------------------
// Type: RAWINPUTDEVICELIST
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const RAWINPUTDEVICELIST = extern struct {
    hDevice: HANDLE,
    dwType: u32,
};

//
// functions
//

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn LoadKeyboardLayoutA(
    pwszKLID: ?*i8,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn LoadKeyboardLayoutW(
    pwszKLID: ?*u16,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn ActivateKeyboardLayout(
    hkl: ?*opaque{},
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn ToUnicodeEx(
    wVirtKey: u32,
    wScanCode: u32,
    lpKeyState: ?*u8,
    pwszBuff: ?*u16,
    cchBuff: i32,
    wFlags: u32,
    dwhkl: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn UnloadKeyboardLayout(
    hkl: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn GetKeyboardLayoutNameA(
    pwszKLID: ?*i8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn GetKeyboardLayoutNameW(
    pwszKLID: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn GetKeyboardLayoutList(
    nBuff: i32,
    lpList: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn GetKeyboardLayout(
    idThread: u32,
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn GetMouseMovePointsEx(
    cbSize: u32,
    lppt: ?*MOUSEMOVEPOINT,
    lpptBuf: ?*MOUSEMOVEPOINT,
    nBufPoints: i32,
    resolution: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn TrackMouseEvent(
    lpEventTrack: ?*TRACKMOUSEEVENT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn RegisterHotKey(
    hWnd: HWND,
    id: i32,
    fsModifiers: u32,
    vk: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn UnregisterHotKey(
    hWnd: HWND,
    id: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn SwapMouseButton(
    fSwap: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn GetDoubleClickTime(
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn SetDoubleClickTime(
    param0: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn SetFocus(
    hWnd: HWND,
) callconv(@import("std").os.windows.WINAPI) HWND;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn GetActiveWindow(
) callconv(@import("std").os.windows.WINAPI) HWND;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn GetFocus(
) callconv(@import("std").os.windows.WINAPI) HWND;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn GetKBCodePage(
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn GetKeyState(
    nVirtKey: i32,
) callconv(@import("std").os.windows.WINAPI) i16;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn GetAsyncKeyState(
    vKey: i32,
) callconv(@import("std").os.windows.WINAPI) i16;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn GetKeyboardState(
    lpKeyState: ?*u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn SetKeyboardState(
    lpKeyState: ?*u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn GetKeyNameTextA(
    lParam: i32,
    lpString: ?*i8,
    cchSize: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn GetKeyNameTextW(
    lParam: i32,
    lpString: ?*u16,
    cchSize: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn GetKeyboardType(
    nTypeFlag: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn ToAscii(
    uVirtKey: u32,
    uScanCode: u32,
    lpKeyState: ?*u8,
    lpChar: ?*u16,
    uFlags: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn ToAsciiEx(
    uVirtKey: u32,
    uScanCode: u32,
    lpKeyState: ?*u8,
    lpChar: ?*u16,
    uFlags: u32,
    dwhkl: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn ToUnicode(
    wVirtKey: u32,
    wScanCode: u32,
    lpKeyState: ?*u8,
    pwszBuff: ?*u16,
    cchBuff: i32,
    wFlags: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn OemKeyScan(
    wOemChar: u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn VkKeyScanA(
    ch: i8,
) callconv(@import("std").os.windows.WINAPI) i16;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn VkKeyScanW(
    ch: u16,
) callconv(@import("std").os.windows.WINAPI) i16;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn VkKeyScanExA(
    ch: i8,
    dwhkl: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) i16;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn VkKeyScanExW(
    ch: u16,
    dwhkl: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) i16;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn keybd_event(
    bVk: u8,
    bScan: u8,
    dwFlags: u32,
    dwExtraInfo: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn mouse_event(
    dwFlags: u32,
    dx: u32,
    dy: u32,
    dwData: u32,
    dwExtraInfo: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn SendInput(
    cInputs: u32,
    pInputs: ?*INPUT,
    cbSize: i32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn GetLastInputInfo(
    plii: ?*LASTINPUTINFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn MapVirtualKeyA(
    uCode: u32,
    uMapType: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn MapVirtualKeyW(
    uCode: u32,
    uMapType: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn MapVirtualKeyExA(
    uCode: u32,
    uMapType: u32,
    dwhkl: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn MapVirtualKeyExW(
    uCode: u32,
    uMapType: u32,
    dwhkl: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn GetCapture(
) callconv(@import("std").os.windows.WINAPI) HWND;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn SetCapture(
    hWnd: HWND,
) callconv(@import("std").os.windows.WINAPI) HWND;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn ReleaseCapture(
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn EnableWindow(
    hWnd: HWND,
    bEnable: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn IsWindowEnabled(
    hWnd: HWND,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn DragDetect(
    hwnd: HWND,
    pt: POINT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn SetActiveWindow(
    hWnd: HWND,
) callconv(@import("std").os.windows.WINAPI) HWND;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn BlockInput(
    fBlockIt: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn GetRawInputData(
    hRawInput: ?*opaque{},
    uiCommand: u32,
    pData: ?*opaque{},
    pcbSize: ?*u32,
    cbSizeHeader: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn GetRawInputDeviceInfoA(
    hDevice: HANDLE,
    uiCommand: u32,
    pData: ?*opaque{},
    pcbSize: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn GetRawInputDeviceInfoW(
    hDevice: HANDLE,
    uiCommand: u32,
    pData: ?*opaque{},
    pcbSize: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn GetRawInputBuffer(
    pData: ?*RAWINPUT,
    pcbSize: ?*u32,
    cbSizeHeader: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn RegisterRawInputDevices(
    pRawInputDevices: ?*RAWINPUTDEVICE,
    uiNumDevices: u32,
    cbSize: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn GetRegisteredRawInputDevices(
    pRawInputDevices: ?*RAWINPUTDEVICE,
    puiNumDevices: ?*u32,
    cbSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn GetRawInputDeviceList(
    pRawInputDeviceList: ?*RAWINPUTDEVICELIST,
    puiNumDevices: ?*u32,
    cbSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn DefRawInputProc(
    paRawInput: ?*?*RAWINPUT,
    nInput: i32,
    cbSizeHeader: u32,
) callconv(@import("std").os.windows.WINAPI) LRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "COMCTL32" fn _TrackMouseEvent(
    lpEventTrack: ?*TRACKMOUSEEVENT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

//
// Unicode Symbol Aliases
//
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {
        pub const LoadKeyboardLayout = LoadKeyboardLayoutA;
        pub const GetKeyboardLayoutName = GetKeyboardLayoutNameA;
        pub const GetKeyNameText = GetKeyNameTextA;
        pub const VkKeyScan = VkKeyScanA;
        pub const VkKeyScanEx = VkKeyScanExA;
        pub const MapVirtualKey = MapVirtualKeyA;
        pub const MapVirtualKeyEx = MapVirtualKeyExA;
        pub const GetRawInputDeviceInfo = GetRawInputDeviceInfoA;
    },
    .wide => struct {
        pub const LoadKeyboardLayout = LoadKeyboardLayoutW;
        pub const GetKeyboardLayoutName = GetKeyboardLayoutNameW;
        pub const GetKeyNameText = GetKeyNameTextW;
        pub const VkKeyScan = VkKeyScanW;
        pub const VkKeyScanEx = VkKeyScanExW;
        pub const MapVirtualKey = MapVirtualKeyW;
        pub const MapVirtualKeyEx = MapVirtualKeyExW;
        pub const GetRawInputDeviceInfo = GetRawInputDeviceInfoW;
    },
    else => if (@import("builtin").is_test) struct {
        pub const LoadKeyboardLayout = *opaque{};
        pub const GetKeyboardLayoutName = *opaque{};
        pub const GetKeyNameText = *opaque{};
        pub const VkKeyScan = *opaque{};
        pub const VkKeyScanEx = *opaque{};
        pub const MapVirtualKey = *opaque{};
        pub const MapVirtualKeyEx = *opaque{};
        pub const GetRawInputDeviceInfo = *opaque{};
    } else struct {
        pub const LoadKeyboardLayout = @compileError("'LoadKeyboardLayout' requires that UNICODE be set to true or false in the root module");
        pub const GetKeyboardLayoutName = @compileError("'GetKeyboardLayoutName' requires that UNICODE be set to true or false in the root module");
        pub const GetKeyNameText = @compileError("'GetKeyNameText' requires that UNICODE be set to true or false in the root module");
        pub const VkKeyScan = @compileError("'VkKeyScan' requires that UNICODE be set to true or false in the root module");
        pub const VkKeyScanEx = @compileError("'VkKeyScanEx' requires that UNICODE be set to true or false in the root module");
        pub const MapVirtualKey = @compileError("'MapVirtualKey' requires that UNICODE be set to true or false in the root module");
        pub const MapVirtualKeyEx = @compileError("'MapVirtualKeyEx' requires that UNICODE be set to true or false in the root module");
        pub const GetRawInputDeviceInfo = @compileError("'GetRawInputDeviceInfo' requires that UNICODE be set to true or false in the root module");
    },
};

//
// type imports
//
const HWND = @import("windowsandmessaging.zig").HWND;
const HANDLE = @import("systemservices.zig").HANDLE;
const WPARAM = @import("windowsandmessaging.zig").WPARAM;
const BOOL = @import("systemservices.zig").BOOL;
const POINT = @import("displaydevices.zig").POINT;
const LRESULT = @import("systemservices.zig").LRESULT;

test "" {
    const constant_export_count = 0;
    const type_export_count = 18;
    const func_count = 60;
    const unicode_alias_count = 8;
    const type_import_count = 6;
    @setEvalBranchQuota(0
        + constant_export_count
        + type_export_count
        + func_count
        + unicode_alias_count
        + type_import_count
        + 2 // TODO: why do I need these extra 2?
    );
    @import("std").testing.refAllDecls(@This());
}
