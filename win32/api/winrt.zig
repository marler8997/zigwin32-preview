//! NOTE: this source file is autogenerated, DO NOT MODIFY

//
// constants
//
pub const CastingSourceInfo_Property_PreferredSourceUriScheme = "PreferredSourceUriScheme";
pub const CastingSourceInfo_Property_CastingTypes = "CastingTypes";
pub const CastingSourceInfo_Property_ProtectedMedia = "ProtectedMedia";
pub const InterfaceName_Windows_UI_Xaml_Interop_IBindableIterable = "Windows.UI.Xaml.Interop.IBindableIterable";
pub const InterfaceName_Windows_UI_Xaml_Interop_IBindableIterator = "Windows.UI.Xaml.Interop.IBindableIterator";
pub const InterfaceName_Windows_UI_Xaml_Interop_IBindableObservableVector = "Windows.UI.Xaml.Interop.IBindableObservableVector";
pub const InterfaceName_Windows_UI_Xaml_Interop_IBindableVector = "Windows.UI.Xaml.Interop.IBindableVector";
pub const InterfaceName_Windows_UI_Xaml_Interop_IBindableVectorView = "Windows.UI.Xaml.Interop.IBindableVectorView";
pub const InterfaceName_Windows_UI_Xaml_Interop_INotifyCollectionChanged = "Windows.UI.Xaml.Interop.INotifyCollectionChanged";
pub const InterfaceName_Windows_UI_Xaml_Interop_INotifyCollectionChangedEventArgs = "Windows.UI.Xaml.Interop.INotifyCollectionChangedEventArgs";
pub const InterfaceName_Windows_UI_Xaml_Interop_INotifyCollectionChangedEventArgsFactory = "Windows.UI.Xaml.Interop.INotifyCollectionChangedEventArgsFactory";
pub const RuntimeClass_Windows_UI_Xaml_Interop_NotifyCollectionChangedEventArgs = "Windows.UI.Xaml.Interop.NotifyCollectionChangedEventArgs";

//
// types
//
// --------------------------------------------------------
// Type: EventRegistrationToken
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const EventRegistrationToken = extern struct {
    value: i64,
};
// --------------------------------------------------------
// Type: ACTIVATIONTYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const ACTIVATIONTYPE = *opaque{
};
// --------------------------------------------------------
// Type: IAgileReference
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IAgileReference = *opaque{
    // TODO: Method 'Resolve'
};
// --------------------------------------------------------
// Type: ServerInformation
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const ServerInformation = extern struct {
    dwServerPid: u32,
    dwServerTid: u32,
    ui64ServerAddress: u64,
};
// --------------------------------------------------------
// Type: AgileReferenceOptions
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const AgileReferenceOptions = *opaque{
};
// --------------------------------------------------------
// Type: IApartmentShutdown
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IApartmentShutdown = *opaque{
    // TODO: Method 'OnUninitialize'
};
// --------------------------------------------------------
// Type: HSTRING__
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HSTRING__ = extern struct {
    unused: i32,
};
// --------------------------------------------------------
// Type: HSTRING_HEADER
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HSTRING_HEADER = extern struct {
    Reserved: _Reserved_e__Union,
    // --------------------------------------------------------
    // Type: _Reserved_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Reserved_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: HSTRING_BUFFER__
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HSTRING_BUFFER__ = extern struct {
    unused: i32,
};
// --------------------------------------------------------
// Type: TrustLevel
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const TrustLevel = *opaque{
};
// --------------------------------------------------------
// Type: IInspectable
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IInspectable = *opaque{
    // TODO: Method 'GetIids'
    // TODO: Method 'GetRuntimeClassName'
    // TODO: Method 'GetTrustLevel'
};
// --------------------------------------------------------
// Type: IAccountsSettingsPaneInterop
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IAccountsSettingsPaneInterop = *opaque{
    // TODO: Method 'GetForWindow'
    // TODO: Method 'ShowManageAccountsForWindowAsync'
    // TODO: Method 'ShowAddAccountForWindowAsync'
};
// --------------------------------------------------------
// Type: IAppServiceConnectionExtendedExecution
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IAppServiceConnectionExtendedExecution = *opaque{
    // TODO: Method 'OpenForExtendedExecutionAsync'
};
// --------------------------------------------------------
// Type: ICorrelationVectorSource
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ICorrelationVectorSource = *opaque{
    // TODO: Method 'get_CorrelationVector'
};
// --------------------------------------------------------
// Type: CASTING_CONNECTION_ERROR_STATUS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const CASTING_CONNECTION_ERROR_STATUS = *opaque{
};
// --------------------------------------------------------
// Type: CASTING_CONNECTION_STATE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const CASTING_CONNECTION_STATE = *opaque{
};
// --------------------------------------------------------
// Type: ICastingEventHandler
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ICastingEventHandler = *opaque{
    // TODO: Method 'OnStateChanged'
    // TODO: Method 'OnError'
};
// --------------------------------------------------------
// Type: ICastingController
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ICastingController = *opaque{
    // TODO: Method 'Initialize'
    // TODO: Method 'Connect'
    // TODO: Method 'Disconnect'
    // TODO: Method 'Advise'
    // TODO: Method 'UnAdvise'
};
// --------------------------------------------------------
// Type: ICastingSourceInfo
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ICastingSourceInfo = *opaque{
    // TODO: Method 'GetController'
    // TODO: Method 'GetProperties'
};
// --------------------------------------------------------
// Type: IDragDropManagerInterop
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IDragDropManagerInterop = *opaque{
    // TODO: Method 'GetForWindow'
};
// --------------------------------------------------------
// Type: IInputPaneInterop
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IInputPaneInterop = *opaque{
    // TODO: Method 'GetForWindow'
};
// --------------------------------------------------------
// Type: IPlayToManagerInterop
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IPlayToManagerInterop = *opaque{
    // TODO: Method 'GetForWindow'
    // TODO: Method 'ShowPlayToUIForWindow'
};
// --------------------------------------------------------
// Type: IPrinting3DManagerInterop
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IPrinting3DManagerInterop = *opaque{
    // TODO: Method 'GetForWindow'
    // TODO: Method 'ShowPrintUIForWindowAsync'
};
// --------------------------------------------------------
// Type: IPrintManagerInterop
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IPrintManagerInterop = *opaque{
    // TODO: Method 'GetForWindow'
    // TODO: Method 'ShowPrintUIForWindowAsync'
};
// --------------------------------------------------------
// Type: ICorrelationVectorInformation
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ICorrelationVectorInformation = *opaque{
    // TODO: Method 'get_LastCorrelationVectorForThread'
    // TODO: Method 'get_NextCorrelationVectorForThread'
    // TODO: Method 'put_NextCorrelationVectorForThread'
};
// --------------------------------------------------------
// Type: IUIViewSettingsInterop
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IUIViewSettingsInterop = *opaque{
    // TODO: Method 'GetForWindow'
};
// --------------------------------------------------------
// Type: IUserActivityInterop
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IUserActivityInterop = *opaque{
    // TODO: Method 'CreateSessionForWindow'
};
// --------------------------------------------------------
// Type: IUserActivitySourceHostInterop
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IUserActivitySourceHostInterop = *opaque{
    // TODO: Method 'SetActivitySourceHost'
};
// --------------------------------------------------------
// Type: IUserActivityRequestManagerInterop
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IUserActivityRequestManagerInterop = *opaque{
    // TODO: Method 'GetForWindow'
};
// --------------------------------------------------------
// Type: IUserConsentVerifierInterop
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IUserConsentVerifierInterop = *opaque{
    // TODO: Method 'RequestVerificationForWindowAsync'
};
// --------------------------------------------------------
// Type: IWebAuthenticationCoreManagerInterop
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IWebAuthenticationCoreManagerInterop = *opaque{
    // TODO: Method 'RequestTokenForWindowAsync'
    // TODO: Method 'RequestTokenWithWebAccountForWindowAsync'
};
// --------------------------------------------------------
// Type: PFN_PDF_CREATE_RENDERER
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFN_PDF_CREATE_RENDERER = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PDF_RENDER_PARAMS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PDF_RENDER_PARAMS = extern struct {
    SourceRect: D2D_RECT_F,
    DestinationWidth: u32,
    DestinationHeight: u32,
    BackgroundColor: DXGI_RGBA,
    IgnoreHighContrast: u8,
};
// --------------------------------------------------------
// Type: IPdfRendererNative
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IPdfRendererNative = *opaque{
    // TODO: Method 'RenderPageToSurface'
    // TODO: Method 'RenderPageToDeviceContext'
};
// --------------------------------------------------------
// Type: IDisplayDeviceInterop
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IDisplayDeviceInterop = *opaque{
    // TODO: Method 'CreateSharedHandle'
    // TODO: Method 'OpenSharedHandle'
};
// --------------------------------------------------------
// Type: IDisplayPathInterop
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IDisplayPathInterop = *opaque{
    // TODO: Method 'CreateSourcePresentationHandle'
    // TODO: Method 'GetSourceId'
};
// --------------------------------------------------------
// Type: PINSPECT_HSTRING_CALLBACK
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PINSPECT_HSTRING_CALLBACK = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PINSPECT_HSTRING_CALLBACK2
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PINSPECT_HSTRING_CALLBACK2 = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: IGraphicsCaptureItemInterop
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IGraphicsCaptureItemInterop = *opaque{
    // TODO: Method 'CreateForWindow'
    // TODO: Method 'CreateForMonitor'
};
// --------------------------------------------------------
// Type: IDirect3DDxgiInterfaceAccess
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IDirect3DDxgiInterfaceAccess = *opaque{
    // TODO: Method 'GetInterface'
};
// --------------------------------------------------------
// Type: ISoftwareBitmapNative
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ISoftwareBitmapNative = *opaque{
    // TODO: Method 'GetData'
};
// --------------------------------------------------------
// Type: ISoftwareBitmapNativeFactory
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ISoftwareBitmapNativeFactory = *opaque{
    // TODO: Method 'CreateFromWICBitmap'
    // TODO: Method 'CreateFromMF2DBuffer2'
};
// --------------------------------------------------------
// Type: IAudioFrameNative
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IAudioFrameNative = *opaque{
    // TODO: Method 'GetData'
};
// --------------------------------------------------------
// Type: IVideoFrameNative
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IVideoFrameNative = *opaque{
    // TODO: Method 'GetData'
    // TODO: Method 'GetDevice'
};
// --------------------------------------------------------
// Type: IAudioFrameNativeFactory
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IAudioFrameNativeFactory = *opaque{
    // TODO: Method 'CreateFromMFSample'
};
// --------------------------------------------------------
// Type: IVideoFrameNativeFactory
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IVideoFrameNativeFactory = *opaque{
    // TODO: Method 'CreateFromMFSample'
};
// --------------------------------------------------------
// Type: ISurfaceImageSourceNative
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ISurfaceImageSourceNative = *opaque{
    // TODO: Method 'SetDevice'
    // TODO: Method 'BeginDraw'
    // TODO: Method 'EndDraw'
};
// --------------------------------------------------------
// Type: IVirtualSurfaceUpdatesCallbackNative
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IVirtualSurfaceUpdatesCallbackNative = *opaque{
    // TODO: Method 'UpdatesNeeded'
};
// --------------------------------------------------------
// Type: IVirtualSurfaceImageSourceNative
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IVirtualSurfaceImageSourceNative = *opaque{
    // TODO: Method 'Invalidate'
    // TODO: Method 'GetUpdateRectCount'
    // TODO: Method 'GetUpdateRects'
    // TODO: Method 'GetVisibleBounds'
    // TODO: Method 'RegisterForUpdatesNeeded'
    // TODO: Method 'Resize'
};
// --------------------------------------------------------
// Type: ISwapChainBackgroundPanelNative
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ISwapChainBackgroundPanelNative = *opaque{
    // TODO: Method 'SetSwapChain'
};
// --------------------------------------------------------
// Type: ISurfaceImageSourceManagerNative
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ISurfaceImageSourceManagerNative = *opaque{
    // TODO: Method 'FlushAllSurfacesWithDevice'
};
// --------------------------------------------------------
// Type: ISurfaceImageSourceNativeWithD2D
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ISurfaceImageSourceNativeWithD2D = *opaque{
    // TODO: Method 'SetDevice'
    // TODO: Method 'BeginDraw'
    // TODO: Method 'EndDraw'
    // TODO: Method 'SuspendDraw'
    // TODO: Method 'ResumeDraw'
};
// --------------------------------------------------------
// Type: ISwapChainPanelNative
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ISwapChainPanelNative = *opaque{
    // TODO: Method 'SetSwapChain'
};
// --------------------------------------------------------
// Type: ISwapChainPanelNative2
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ISwapChainPanelNative2 = *opaque{
    // TODO: Method 'SetSwapChainHandle'
};
// --------------------------------------------------------
// Type: GRAPHICS_EFFECT_PROPERTY_MAPPING
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const GRAPHICS_EFFECT_PROPERTY_MAPPING = *opaque{
};
// --------------------------------------------------------
// Type: IGraphicsEffectD2D1Interop
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IGraphicsEffectD2D1Interop = *opaque{
    // TODO: Method 'GetEffectId'
    // TODO: Method 'GetNamedPropertyMapping'
    // TODO: Method 'GetPropertyCount'
    // TODO: Method 'GetProperty'
    // TODO: Method 'GetSource'
    // TODO: Method 'GetSourceCount'
};
// --------------------------------------------------------
// Type: IGeometrySource2DInterop
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IGeometrySource2DInterop = *opaque{
    // TODO: Method 'GetGeometry'
    // TODO: Method 'TryGetGeometryUsingFactory'
};
// --------------------------------------------------------
// Type: ICompositionDrawingSurfaceInterop
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ICompositionDrawingSurfaceInterop = *opaque{
    // TODO: Method 'BeginDraw'
    // TODO: Method 'EndDraw'
    // TODO: Method 'Resize'
    // TODO: Method 'Scroll'
    // TODO: Method 'ResumeDraw'
    // TODO: Method 'SuspendDraw'
};
// --------------------------------------------------------
// Type: ICompositionDrawingSurfaceInterop2
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ICompositionDrawingSurfaceInterop2 = *opaque{
    // TODO: Method 'CopySurface'
};
// --------------------------------------------------------
// Type: ICompositionGraphicsDeviceInterop
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ICompositionGraphicsDeviceInterop = *opaque{
    // TODO: Method 'GetRenderingDevice'
    // TODO: Method 'SetRenderingDevice'
};
// --------------------------------------------------------
// Type: ICompositorInterop
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ICompositorInterop = *opaque{
    // TODO: Method 'CreateCompositionSurfaceForHandle'
    // TODO: Method 'CreateCompositionSurfaceForSwapChain'
    // TODO: Method 'CreateGraphicsDevice'
};
// --------------------------------------------------------
// Type: ISwapChainInterop
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ISwapChainInterop = *opaque{
    // TODO: Method 'SetSwapChain'
};
// --------------------------------------------------------
// Type: IVisualInteractionSourceInterop
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IVisualInteractionSourceInterop = *opaque{
    // TODO: Method 'TryRedirectForManipulation'
};
// --------------------------------------------------------
// Type: ICompositionCapabilitiesInteropFactory
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ICompositionCapabilitiesInteropFactory = *opaque{
    // TODO: Method 'GetForWindow'
};
// --------------------------------------------------------
// Type: ICompositorDesktopInterop
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ICompositorDesktopInterop = *opaque{
    // TODO: Method 'CreateDesktopWindowTarget'
    // TODO: Method 'EnsureOnThread'
};
// --------------------------------------------------------
// Type: IDesktopWindowTargetInterop
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IDesktopWindowTargetInterop = *opaque{
    // TODO: Method 'get_Hwnd'
};
// --------------------------------------------------------
// Type: IDesktopWindowContentBridgeInterop
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IDesktopWindowContentBridgeInterop = *opaque{
    // TODO: Method 'Initialize'
    // TODO: Method 'get_Hwnd'
    // TODO: Method 'get_AppliedScaleFactor'
};
// --------------------------------------------------------
// Type: NotifyCollectionChangedEventArgs
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const NotifyCollectionChangedEventArgs = opaque {
};
// --------------------------------------------------------
// Type: NotifyCollectionChangedAction
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const NotifyCollectionChangedAction = *opaque{
};
// --------------------------------------------------------
// Type: TypeKind
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const TypeKind = *opaque{
};
// --------------------------------------------------------
// Type: TypeName
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TypeName = extern struct {
    Name: ?*opaque{},
    Kind: TypeKind,
};
// --------------------------------------------------------
// Type: IBindableVectorChangedEventHandler
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IBindableVectorChangedEventHandler = *opaque{
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: INotifyCollectionChangedEventHandler
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const INotifyCollectionChangedEventHandler = *opaque{
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: IBindableIterable
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IBindableIterable = *opaque{
    // TODO: Method 'First'
};
// --------------------------------------------------------
// Type: IBindableIterator
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IBindableIterator = *opaque{
    // TODO: Method 'get_Current'
    // TODO: Method 'get_HasCurrent'
    // TODO: Method 'MoveNext'
};
// --------------------------------------------------------
// Type: IBindableObservableVector
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IBindableObservableVector = *opaque{
    // TODO: Method 'add_VectorChanged'
    // TODO: Method 'remove_VectorChanged'
};
// --------------------------------------------------------
// Type: IBindableVector
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IBindableVector = *opaque{
    // TODO: Method 'GetAt'
    // TODO: Method 'get_Size'
    // TODO: Method 'GetView'
    // TODO: Method 'IndexOf'
    // TODO: Method 'SetAt'
    // TODO: Method 'InsertAt'
    // TODO: Method 'RemoveAt'
    // TODO: Method 'Append'
    // TODO: Method 'RemoveAtEnd'
    // TODO: Method 'Clear'
};
// --------------------------------------------------------
// Type: IBindableVectorView
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IBindableVectorView = *opaque{
    // TODO: Method 'GetAt'
    // TODO: Method 'get_Size'
    // TODO: Method 'IndexOf'
};
// --------------------------------------------------------
// Type: INotifyCollectionChanged
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const INotifyCollectionChanged = *opaque{
    // TODO: Method 'add_CollectionChanged'
    // TODO: Method 'remove_CollectionChanged'
};
// --------------------------------------------------------
// Type: INotifyCollectionChangedEventArgs
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const INotifyCollectionChangedEventArgs = *opaque{
    // TODO: Method 'get_Action'
    // TODO: Method 'get_NewItems'
    // TODO: Method 'get_OldItems'
    // TODO: Method 'get_NewStartingIndex'
    // TODO: Method 'get_OldStartingIndex'
};
// --------------------------------------------------------
// Type: INotifyCollectionChangedEventArgsFactory
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const INotifyCollectionChangedEventArgsFactory = *opaque{
    // TODO: Method 'CreateInstanceWithAllParameters'
};
// --------------------------------------------------------
// Type: IRestrictedErrorInfo
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IRestrictedErrorInfo = *opaque{
    // TODO: Method 'GetErrorDetails'
    // TODO: Method 'GetReference'
};
// --------------------------------------------------------
// Type: ILanguageExceptionErrorInfo
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ILanguageExceptionErrorInfo = *opaque{
    // TODO: Method 'GetLanguageException'
};
// --------------------------------------------------------
// Type: ILanguageExceptionTransform
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ILanguageExceptionTransform = *opaque{
    // TODO: Method 'GetTransformedRestrictedErrorInfo'
};
// --------------------------------------------------------
// Type: ILanguageExceptionStackBackTrace
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ILanguageExceptionStackBackTrace = *opaque{
    // TODO: Method 'GetStackBackTrace'
};
// --------------------------------------------------------
// Type: ILanguageExceptionErrorInfo2
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ILanguageExceptionErrorInfo2 = *opaque{
    // TODO: Method 'GetPreviousLanguageExceptionErrorInfo'
    // TODO: Method 'CapturePropagationContext'
    // TODO: Method 'GetPropagationContextHead'
};
// --------------------------------------------------------
// Type: RO_INIT_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const RO_INIT_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: __AnonymousRecord_roapi_L45_C9
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const __AnonymousRecord_roapi_L45_C9 = opaque {
};
// --------------------------------------------------------
// Type: APARTMENT_SHUTDOWN_REGISTRATION_COOKIE__
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const APARTMENT_SHUTDOWN_REGISTRATION_COOKIE__ = extern struct {
    unused: i32,
};
// --------------------------------------------------------
// Type: IBufferByteAccess
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IBufferByteAccess = *opaque{
    // TODO: Method 'Buffer'
};
// --------------------------------------------------------
// Type: RO_ERROR_REPORTING_FLAGS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const RO_ERROR_REPORTING_FLAGS = *opaque{
};
// --------------------------------------------------------
// Type: PINSPECT_MEMORY_CALLBACK
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PINSPECT_MEMORY_CALLBACK = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: ROPARAMIIDHANDLE__
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const ROPARAMIIDHANDLE__ = extern struct {
    unused: i32,
};
// --------------------------------------------------------
// Type: IRoSimpleMetaDataBuilder
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IRoSimpleMetaDataBuilder = *opaque{
    // TODO: Method 'SetWinRtInterface'
    // TODO: Method 'SetDelegate'
    // TODO: Method 'SetInterfaceGroupSimpleDefault'
    // TODO: Method 'SetInterfaceGroupParameterizedDefault'
    // TODO: Method 'SetRuntimeClassSimpleDefault'
    // TODO: Method 'SetRuntimeClassParameterizedDefault'
    // TODO: Method 'SetStruct'
    // TODO: Method 'SetEnum'
    // TODO: Method 'SetParameterizedInterface'
    // TODO: Method 'SetParameterizedDelegate'
};
// --------------------------------------------------------
// Type: IRoMetaDataLocator
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IRoMetaDataLocator = *opaque{
    // TODO: Method 'Locate'
};
// --------------------------------------------------------
// Type: BSOS_OPTIONS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const BSOS_OPTIONS = *opaque{
};

//
// functions
//

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn CoDecodeProxy(
    dwClientPid: u32,
    ui64ProxyAddress: u64,
    pServerInformation: ?*ServerInformation,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn RoGetAgileReference(
    options: AgileReferenceOptions,
    riid: ?*Guid,
    pUnk: IUnknown,
    ppAgileReference: ?*IAgileReference,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-core-winrt-string-l1-1-0" fn HSTRING_UserSize(
    param0: ?*u32,
    param1: u32,
    param2: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-core-winrt-string-l1-1-0" fn HSTRING_UserMarshal(
    param0: ?*u32,
    param1: ?*u8,
    param2: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) ?*u8;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-core-winrt-string-l1-1-0" fn HSTRING_UserUnmarshal(
    param0: ?*u32,
    param1: ?*u8,
    param2: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) ?*u8;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-core-winrt-string-l1-1-0" fn HSTRING_UserFree(
    param0: ?*u32,
    param1: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-core-winrt-string-l1-1-0" fn HSTRING_UserSize64(
    param0: ?*u32,
    param1: u32,
    param2: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-core-winrt-string-l1-1-0" fn HSTRING_UserMarshal64(
    param0: ?*u32,
    param1: ?*u8,
    param2: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) ?*u8;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-core-winrt-string-l1-1-0" fn HSTRING_UserUnmarshal64(
    param0: ?*u32,
    param1: ?*u8,
    param2: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) ?*u8;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-core-winrt-string-l1-1-0" fn HSTRING_UserFree64(
    param0: ?*u32,
    param1: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "Windows" fn PdfCreateRenderer(
    pDevice: IDXGIDevice,
    ppRenderer: ?*IPdfRendererNative,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-core-winrt-string-l1-1-0" fn WindowsCreateString(
    sourceString: ?*u16,
    length: u32,
    string: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-core-winrt-string-l1-1-0" fn WindowsCreateStringReference(
    sourceString: ?*u16,
    length: u32,
    hstringHeader: ?*HSTRING_HEADER,
    string: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-core-winrt-string-l1-1-0" fn WindowsDeleteString(
    string: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-core-winrt-string-l1-1-0" fn WindowsDuplicateString(
    string: ?*opaque{},
    newString: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-core-winrt-string-l1-1-0" fn WindowsGetStringLen(
    string: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-core-winrt-string-l1-1-0" fn WindowsGetStringRawBuffer(
    string: ?*opaque{},
    length: ?*u32,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-core-winrt-string-l1-1-0" fn WindowsIsStringEmpty(
    string: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-core-winrt-string-l1-1-0" fn WindowsStringHasEmbeddedNull(
    string: ?*opaque{},
    hasEmbedNull: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-core-winrt-string-l1-1-0" fn WindowsCompareStringOrdinal(
    string1: ?*opaque{},
    string2: ?*opaque{},
    result: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-core-winrt-string-l1-1-0" fn WindowsSubstring(
    string: ?*opaque{},
    startIndex: u32,
    newString: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-core-winrt-string-l1-1-0" fn WindowsSubstringWithSpecifiedLength(
    string: ?*opaque{},
    startIndex: u32,
    length: u32,
    newString: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-core-winrt-string-l1-1-0" fn WindowsConcatString(
    string1: ?*opaque{},
    string2: ?*opaque{},
    newString: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-core-winrt-string-l1-1-0" fn WindowsReplaceString(
    string: ?*opaque{},
    stringReplaced: ?*opaque{},
    stringReplaceWith: ?*opaque{},
    newString: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-core-winrt-string-l1-1-0" fn WindowsTrimStringStart(
    string: ?*opaque{},
    trimString: ?*opaque{},
    newString: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-core-winrt-string-l1-1-0" fn WindowsTrimStringEnd(
    string: ?*opaque{},
    trimString: ?*opaque{},
    newString: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-core-winrt-string-l1-1-0" fn WindowsPreallocateStringBuffer(
    length: u32,
    charBuffer: ?*?*u16,
    bufferHandle: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-core-winrt-string-l1-1-0" fn WindowsPromoteStringBuffer(
    bufferHandle: ?*opaque{},
    string: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-core-winrt-string-l1-1-0" fn WindowsDeleteStringBuffer(
    bufferHandle: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-core-winrt-string-l1-1-0" fn WindowsInspectString(
    targetHString: ?*opaque{},
    machine: u16,
    callback: PINSPECT_HSTRING_CALLBACK,
    context: ?*opaque{},
    length: ?*u32,
    targetStringAddress: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-core-winrt-string-l1-1-1" fn WindowsInspectString2(
    targetHString: u64,
    machine: u16,
    callback: PINSPECT_HSTRING_CALLBACK2,
    context: ?*opaque{},
    length: ?*u32,
    targetStringAddress: ?*u64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "d3d11" fn CreateDirect3D11DeviceFromDXGIDevice(
    dxgiDevice: IDXGIDevice,
    graphicsDevice: ?*IInspectable,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "d3d11" fn CreateDirect3D11SurfaceFromDXGISurface(
    dgxiSurface: IDXGISurface,
    graphicsSurface: ?*IInspectable,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-core-winrt-l1-1-0" fn RoInitialize(
    initType: RO_INIT_TYPE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-core-winrt-l1-1-0" fn RoUninitialize(
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-core-winrt-l1-1-0" fn RoActivateInstance(
    activatableClassId: ?*opaque{},
    instance: ?*IInspectable,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-core-winrt-l1-1-0" fn RoRegisterActivationFactories(
    activatableClassIds: ?*?*opaque{},
    activationFactoryCallbacks: ?*?*opaque{},
    count: u32,
    cookie: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-core-winrt-l1-1-0" fn RoRevokeActivationFactories(
    cookie: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-core-winrt-l1-1-0" fn RoGetActivationFactory(
    activatableClassId: ?*opaque{},
    iid: ?*Guid,
    factory: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-core-winrt-l1-1-0" fn RoRegisterForApartmentShutdown(
    callbackObject: IApartmentShutdown,
    apartmentIdentifier: ?*u64,
    regCookie: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-core-winrt-l1-1-0" fn RoUnregisterForApartmentShutdown(
    regCookie: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-core-winrt-l1-1-0" fn RoGetApartmentIdentifier(
    apartmentIdentifier: ?*u64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-core-winrt-robuffer-l1-1-0" fn RoGetBufferMarshaler(
    bufferMarshaler: ?*IMarshal,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-core-winrt-error-l1-1-0" fn RoGetErrorReportingFlags(
    pflags: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-core-winrt-error-l1-1-0" fn RoSetErrorReportingFlags(
    flags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-core-winrt-error-l1-1-0" fn RoResolveRestrictedErrorInfoReference(
    reference: ?*u16,
    ppRestrictedErrorInfo: ?*IRestrictedErrorInfo,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-core-winrt-error-l1-1-0" fn SetRestrictedErrorInfo(
    pRestrictedErrorInfo: IRestrictedErrorInfo,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-core-winrt-error-l1-1-0" fn GetRestrictedErrorInfo(
    ppRestrictedErrorInfo: ?*IRestrictedErrorInfo,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-core-winrt-error-l1-1-0" fn RoOriginateErrorW(
    @"error": HRESULT,
    cchMax: u32,
    message: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-core-winrt-error-l1-1-0" fn RoOriginateError(
    @"error": HRESULT,
    message: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-core-winrt-error-l1-1-0" fn RoTransformErrorW(
    oldError: HRESULT,
    newError: HRESULT,
    cchMax: u32,
    message: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-core-winrt-error-l1-1-0" fn RoTransformError(
    oldError: HRESULT,
    newError: HRESULT,
    message: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-core-winrt-error-l1-1-0" fn RoCaptureErrorContext(
    hr: HRESULT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-core-winrt-error-l1-1-0" fn RoFailFastWithErrorContext(
    hrError: HRESULT,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-core-winrt-error-l1-1-1" fn RoOriginateLanguageException(
    @"error": HRESULT,
    message: ?*opaque{},
    languageException: IUnknown,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-core-winrt-error-l1-1-1" fn RoClearError(
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-core-winrt-error-l1-1-1" fn RoReportUnhandledError(
    pRestrictedErrorInfo: IRestrictedErrorInfo,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-core-winrt-error-l1-1-1" fn RoInspectThreadErrorInfo(
    targetTebAddress: ?*opaque{},
    machine: u16,
    readMemoryCallback: PINSPECT_MEMORY_CALLBACK,
    context: ?*opaque{},
    targetErrorInfoAddress: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-core-winrt-error-l1-1-1" fn RoInspectCapturedStackBackTrace(
    targetErrorInfoAddress: ?*opaque{},
    machine: u16,
    readMemoryCallback: PINSPECT_MEMORY_CALLBACK,
    context: ?*opaque{},
    frameCount: ?*u32,
    targetBackTraceAddress: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-core-winrt-error-l1-1-1" fn RoGetMatchingRestrictedErrorInfo(
    hrIn: HRESULT,
    ppRestrictedErrorInfo: ?*IRestrictedErrorInfo,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-core-winrt-error-l1-1-1" fn RoReportFailedDelegate(
    punkDelegate: IUnknown,
    pRestrictedErrorInfo: IRestrictedErrorInfo,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-core-winrt-error-l1-1-1" fn IsErrorPropagationEnabled(
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "RoMetadata" fn MetaDataGetDispenser(
    rclsid: ?*Guid,
    riid: ?*Guid,
    ppv: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-core-winrt-roparameterizediid-l1-1-0" fn RoGetParameterizedTypeInstanceIID(
    nameElementCount: u32,
    nameElements: ?*?*u16,
    metaDataLocator: IRoMetaDataLocator,
    iid: ?*Guid,
    pExtra: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-core-winrt-roparameterizediid-l1-1-0" fn RoFreeParameterizedTypeExtra(
    extra: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-core-winrt-roparameterizediid-l1-1-0" fn RoParameterizedTypeExtraGetTypeSignature(
    extra: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) ?*i8;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-core-winrt-registration-l1-1-0" fn RoGetServerActivatableClasses(
    serverName: ?*opaque{},
    activatableClassIds: ?*?*?*opaque{},
    count: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-shcore-stream-winrt-l1-1-0" fn CreateRandomAccessStreamOnFile(
    filePath: ?*u16,
    accessMode: u32,
    riid: ?*Guid,
    ppv: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-shcore-stream-winrt-l1-1-0" fn CreateRandomAccessStreamOverStream(
    stream: IStream,
    options: BSOS_OPTIONS,
    riid: ?*Guid,
    ppv: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-shcore-stream-winrt-l1-1-0" fn CreateStreamOverRandomAccessStream(
    randomAccessStream: IUnknown,
    riid: ?*Guid,
    ppv: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

//
// Unicode Symbol Aliases
//
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {
    },
    .wide => struct {
    },
    else => if (@import("builtin").is_test) struct {
    } else struct {
    },
};

//
// type imports
//
const Guid = @import("../zig.zig").Guid;
const D2D_RECT_F = @import("direct2d.zig").D2D_RECT_F;
const DXGI_RGBA = @import("dxgi.zig").DXGI_RGBA;
const HRESULT = @import("com.zig").HRESULT;
const IUnknown = @import("com.zig").IUnknown;
const IDXGIDevice = @import("dxgi.zig").IDXGIDevice;
const BOOL = @import("systemservices.zig").BOOL;
const IDXGISurface = @import("dxgi.zig").IDXGISurface;
const IMarshal = @import("com.zig").IMarshal;
const IStream = @import("structuredstorage.zig").IStream;

test "" {
    const constant_export_count = 12;
    const type_export_count = 96;
    const func_count = 70;
    const unicode_alias_count = 0;
    const type_import_count = 10;
    @setEvalBranchQuota(0
        + constant_export_count
        + type_export_count
        + func_count
        + unicode_alias_count
        + type_import_count
        + 2 // TODO: why do I need these extra 2?
    );
    @import("std").testing.refAllDecls(@This());
}
