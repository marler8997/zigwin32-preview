//! NOTE: this source file is autogenerated, DO NOT MODIFY

//
// constants
//
pub const POSITIVE_INFINITY = @import("std").math.inf(f32);
pub const NEGATIVE_INFINITY = -@import("std").math.inf(f32);
pub const NaN = @import("std").math.nan(f32);

//
// types
//
// --------------------------------------------------------
// Type: TOUCHINPUT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TOUCHINPUT = extern struct {
    x: i32,
    y: i32,
    hSource: HANDLE,
    dwID: u32,
    dwFlags: u32,
    dwMask: u32,
    dwTime: u32,
    dwExtraInfo: ?*opaque{},
    cxContact: u32,
    cyContact: u32,
};
// --------------------------------------------------------
// Type: GESTUREINFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const GESTUREINFO = extern struct {
    cbSize: u32,
    dwFlags: u32,
    dwID: u32,
    hwndTarget: HWND,
    ptsLocation: POINTS,
    dwInstanceID: u32,
    dwSequenceID: u32,
    ullArguments: u64,
    cbExtraArgs: u32,
};
// --------------------------------------------------------
// Type: GESTURENOTIFYSTRUCT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const GESTURENOTIFYSTRUCT = extern struct {
    cbSize: u32,
    dwFlags: u32,
    hwndTarget: HWND,
    ptsLocation: POINTS,
    dwInstanceID: u32,
};
// --------------------------------------------------------
// Type: GESTURECONFIG
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const GESTURECONFIG = extern struct {
    dwID: u32,
    dwWant: u32,
    dwBlock: u32,
};
// --------------------------------------------------------
// Type: InertiaProcessor
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const InertiaProcessor = opaque {
};
// --------------------------------------------------------
// Type: ManipulationProcessor
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const ManipulationProcessor = opaque {
};
// --------------------------------------------------------
// Type: MANIPULATION_PROCESSOR_MANIPULATIONS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const MANIPULATION_PROCESSOR_MANIPULATIONS = *opaque{
};
// --------------------------------------------------------
// Type: _IManipulationEvents
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const _IManipulationEvents = *opaque{
    // TODO: Method 'ManipulationStarted'
    // TODO: Method 'ManipulationDelta'
    // TODO: Method 'ManipulationCompleted'
};
// --------------------------------------------------------
// Type: IInertiaProcessor
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IInertiaProcessor = *opaque{
    // TODO: Method 'get_InitialOriginX'
    // TODO: Method 'put_InitialOriginX'
    // TODO: Method 'get_InitialOriginY'
    // TODO: Method 'put_InitialOriginY'
    // TODO: Method 'get_InitialVelocityX'
    // TODO: Method 'put_InitialVelocityX'
    // TODO: Method 'get_InitialVelocityY'
    // TODO: Method 'put_InitialVelocityY'
    // TODO: Method 'get_InitialAngularVelocity'
    // TODO: Method 'put_InitialAngularVelocity'
    // TODO: Method 'get_InitialExpansionVelocity'
    // TODO: Method 'put_InitialExpansionVelocity'
    // TODO: Method 'get_InitialRadius'
    // TODO: Method 'put_InitialRadius'
    // TODO: Method 'get_BoundaryLeft'
    // TODO: Method 'put_BoundaryLeft'
    // TODO: Method 'get_BoundaryTop'
    // TODO: Method 'put_BoundaryTop'
    // TODO: Method 'get_BoundaryRight'
    // TODO: Method 'put_BoundaryRight'
    // TODO: Method 'get_BoundaryBottom'
    // TODO: Method 'put_BoundaryBottom'
    // TODO: Method 'get_ElasticMarginLeft'
    // TODO: Method 'put_ElasticMarginLeft'
    // TODO: Method 'get_ElasticMarginTop'
    // TODO: Method 'put_ElasticMarginTop'
    // TODO: Method 'get_ElasticMarginRight'
    // TODO: Method 'put_ElasticMarginRight'
    // TODO: Method 'get_ElasticMarginBottom'
    // TODO: Method 'put_ElasticMarginBottom'
    // TODO: Method 'get_DesiredDisplacement'
    // TODO: Method 'put_DesiredDisplacement'
    // TODO: Method 'get_DesiredRotation'
    // TODO: Method 'put_DesiredRotation'
    // TODO: Method 'get_DesiredExpansion'
    // TODO: Method 'put_DesiredExpansion'
    // TODO: Method 'get_DesiredDeceleration'
    // TODO: Method 'put_DesiredDeceleration'
    // TODO: Method 'get_DesiredAngularDeceleration'
    // TODO: Method 'put_DesiredAngularDeceleration'
    // TODO: Method 'get_DesiredExpansionDeceleration'
    // TODO: Method 'put_DesiredExpansionDeceleration'
    // TODO: Method 'get_InitialTimestamp'
    // TODO: Method 'put_InitialTimestamp'
    // TODO: Method 'Reset'
    // TODO: Method 'Process'
    // TODO: Method 'ProcessTime'
    // TODO: Method 'Complete'
    // TODO: Method 'CompleteTime'
};
// --------------------------------------------------------
// Type: IManipulationProcessor
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IManipulationProcessor = *opaque{
    // TODO: Method 'get_SupportedManipulations'
    // TODO: Method 'put_SupportedManipulations'
    // TODO: Method 'get_PivotPointX'
    // TODO: Method 'put_PivotPointX'
    // TODO: Method 'get_PivotPointY'
    // TODO: Method 'put_PivotPointY'
    // TODO: Method 'get_PivotRadius'
    // TODO: Method 'put_PivotRadius'
    // TODO: Method 'CompleteManipulation'
    // TODO: Method 'ProcessDown'
    // TODO: Method 'ProcessMove'
    // TODO: Method 'ProcessUp'
    // TODO: Method 'ProcessDownWithTime'
    // TODO: Method 'ProcessMoveWithTime'
    // TODO: Method 'ProcessUpWithTime'
    // TODO: Method 'GetVelocityX'
    // TODO: Method 'GetVelocityY'
    // TODO: Method 'GetExpansionVelocity'
    // TODO: Method 'GetAngularVelocity'
    // TODO: Method 'get_MinimumScaleRotateRadius'
    // TODO: Method 'put_MinimumScaleRotateRadius'
};

//
// functions
//

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn GetTouchInputInfo(
    hTouchInput: ?*opaque{},
    cInputs: u32,
    pInputs: ?*TOUCHINPUT,
    cbSize: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn CloseTouchInputHandle(
    hTouchInput: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn RegisterTouchWindow(
    hwnd: HWND,
    ulFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn UnregisterTouchWindow(
    hwnd: HWND,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn IsTouchWindow(
    hwnd: HWND,
    pulFlags: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn GetGestureInfo(
    hGestureInfo: ?*opaque{},
    pGestureInfo: ?*GESTUREINFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn GetGestureExtraArgs(
    hGestureInfo: ?*opaque{},
    cbExtraArgs: u32,
    pExtraArgs: ?*u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn CloseGestureInfoHandle(
    hGestureInfo: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn SetGestureConfig(
    hwnd: HWND,
    dwReserved: u32,
    cIDs: u32,
    pGestureConfig: ?*GESTURECONFIG,
    cbSize: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn GetGestureConfig(
    hwnd: HWND,
    dwReserved: u32,
    dwFlags: u32,
    pcIDs: ?*u32,
    pGestureConfig: ?*GESTURECONFIG,
    cbSize: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

//
// Unicode Symbol Aliases
//
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {
    },
    .wide => struct {
    },
    else => if (@import("builtin").is_test) struct {
    } else struct {
    },
};

//
// type imports
//
const HANDLE = @import("systemservices.zig").HANDLE;
const HWND = @import("windowsandmessaging.zig").HWND;
const POINTS = @import("displaydevices.zig").POINTS;
const BOOL = @import("systemservices.zig").BOOL;

test "" {
    const constant_export_count = 3;
    const type_export_count = 10;
    const func_count = 10;
    const unicode_alias_count = 0;
    const type_import_count = 4;
    @setEvalBranchQuota(0
        + constant_export_count
        + type_export_count
        + func_count
        + unicode_alias_count
        + type_import_count
        + 2 // TODO: why do I need these extra 2?
    );
    @import("std").testing.refAllDecls(@This());
}
