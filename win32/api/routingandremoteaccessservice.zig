//! NOTE: this source file is autogenerated, DO NOT MODIFY

//
// constants
//

//
// types
//
// --------------------------------------------------------
// Type: RASAPIVERSION
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const RASAPIVERSION = *opaque{
};
// --------------------------------------------------------
// Type: RASIPADDR
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const RASIPADDR = extern struct {
    a: u8,
    b: u8,
    c: u8,
    d: u8,
};
// --------------------------------------------------------
// Type: tagRASTUNNELENDPOINT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const tagRASTUNNELENDPOINT = extern struct {
    dwType: u32,
    Anonymous: _Anonymous_e__Union,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: HRASCONN__
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HRASCONN__ = extern struct {
    unused: i32,
};
// --------------------------------------------------------
// Type: tagRASCONNW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const tagRASCONNW = extern struct {
    dwSize: u32,
    hrasconn: ?*HRASCONN__,
    szEntryName: ?[*]u16,
    szDeviceType: ?[*]u16,
    szDeviceName: ?[*]u16,
    szPhonebook: ?[*]u16,
    dwSubEntry: u32,
    guidEntry: Guid,
    dwFlags: u32,
    luid: LUID,
    guidCorrelationId: Guid,
};
// --------------------------------------------------------
// Type: tagRASCONNA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const tagRASCONNA = extern struct {
    dwSize: u32,
    hrasconn: ?*HRASCONN__,
    szEntryName: ?[*]i8,
    szDeviceType: ?[*]i8,
    szDeviceName: ?[*]i8,
    szPhonebook: ?[*]i8,
    dwSubEntry: u32,
    guidEntry: Guid,
    dwFlags: u32,
    luid: LUID,
    guidCorrelationId: Guid,
};
// --------------------------------------------------------
// Type: tagRASCONNSTATE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const tagRASCONNSTATE = *opaque{
};
// --------------------------------------------------------
// Type: tagRASCONNSUBSTATE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const tagRASCONNSUBSTATE = *opaque{
};
// --------------------------------------------------------
// Type: tagRASCONNSTATUSW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const tagRASCONNSTATUSW = extern struct {
    dwSize: u32,
    rasconnstate: tagRASCONNSTATE,
    dwError: u32,
    szDeviceType: ?[*]u16,
    szDeviceName: ?[*]u16,
    szPhoneNumber: ?[*]u16,
    localEndPoint: tagRASTUNNELENDPOINT,
    remoteEndPoint: tagRASTUNNELENDPOINT,
    rasconnsubstate: tagRASCONNSUBSTATE,
};
// --------------------------------------------------------
// Type: tagRASCONNSTATUSA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const tagRASCONNSTATUSA = extern struct {
    dwSize: u32,
    rasconnstate: tagRASCONNSTATE,
    dwError: u32,
    szDeviceType: ?[*]i8,
    szDeviceName: ?[*]i8,
    szPhoneNumber: ?[*]i8,
    localEndPoint: tagRASTUNNELENDPOINT,
    remoteEndPoint: tagRASTUNNELENDPOINT,
    rasconnsubstate: tagRASCONNSUBSTATE,
};
// --------------------------------------------------------
// Type: tagRASDIALPARAMSW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const tagRASDIALPARAMSW = extern struct {
    dwSize: u32,
    szEntryName: ?[*]u16,
    szPhoneNumber: ?[*]u16,
    szCallbackNumber: ?[*]u16,
    szUserName: ?[*]u16,
    szPassword: ?[*]u16,
    szDomain: ?[*]u16,
    dwSubEntry: u32,
    dwCallbackId: ?*opaque{},
    dwIfIndex: u32,
    szEncPassword: ?*u16,
};
// --------------------------------------------------------
// Type: tagRASDIALPARAMSA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const tagRASDIALPARAMSA = extern struct {
    dwSize: u32,
    szEntryName: ?[*]i8,
    szPhoneNumber: ?[*]i8,
    szCallbackNumber: ?[*]i8,
    szUserName: ?[*]i8,
    szPassword: ?[*]i8,
    szDomain: ?[*]i8,
    dwSubEntry: u32,
    dwCallbackId: ?*opaque{},
    dwIfIndex: u32,
    szEncPassword: ?*i8,
};
// --------------------------------------------------------
// Type: tagRASEAPINFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const tagRASEAPINFO = extern struct {
    dwSizeofEapInfo: u32,
    pbEapInfo: ?*u8,
};
// --------------------------------------------------------
// Type: RASDEVSPECIFICINFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const RASDEVSPECIFICINFO = extern struct {
    dwSize: u32,
    pbDevSpecificInfo: ?*u8,
};
// --------------------------------------------------------
// Type: tagRASDIALEXTENSIONS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const tagRASDIALEXTENSIONS = extern struct {
    dwSize: u32,
    dwfOptions: u32,
    hwndParent: HWND,
    reserved: ?*opaque{},
    reserved1: ?*opaque{},
    RasEapInfo: tagRASEAPINFO,
    fSkipPppAuth: BOOL,
    RasDevSpecificInfo: RASDEVSPECIFICINFO,
};
// --------------------------------------------------------
// Type: tagRASENTRYNAMEW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const tagRASENTRYNAMEW = extern struct {
    dwSize: u32,
    szEntryName: ?[*]u16,
    dwFlags: u32,
    szPhonebookPath: ?[*]u16,
};
// --------------------------------------------------------
// Type: tagRASENTRYNAMEA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const tagRASENTRYNAMEA = extern struct {
    dwSize: u32,
    szEntryName: ?[*]i8,
    dwFlags: u32,
    szPhonebookPath: ?[*]i8,
};
// --------------------------------------------------------
// Type: tagRASPROJECTION
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const tagRASPROJECTION = *opaque{
};
// --------------------------------------------------------
// Type: tagRASAMBW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const tagRASAMBW = extern struct {
    dwSize: u32,
    dwError: u32,
    szNetBiosError: ?[*]u16,
    bLana: u8,
};
// --------------------------------------------------------
// Type: tagRASAMBA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const tagRASAMBA = extern struct {
    dwSize: u32,
    dwError: u32,
    szNetBiosError: ?[*]i8,
    bLana: u8,
};
// --------------------------------------------------------
// Type: tagRASPPPNBFW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const tagRASPPPNBFW = extern struct {
    dwSize: u32,
    dwError: u32,
    dwNetBiosError: u32,
    szNetBiosError: ?[*]u16,
    szWorkstationName: ?[*]u16,
    bLana: u8,
};
// --------------------------------------------------------
// Type: tagRASPPPNBFA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const tagRASPPPNBFA = extern struct {
    dwSize: u32,
    dwError: u32,
    dwNetBiosError: u32,
    szNetBiosError: ?[*]i8,
    szWorkstationName: ?[*]i8,
    bLana: u8,
};
// --------------------------------------------------------
// Type: tagRASIPXW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const tagRASIPXW = extern struct {
    dwSize: u32,
    dwError: u32,
    szIpxAddress: ?[*]u16,
};
// --------------------------------------------------------
// Type: tagRASPPPIPXA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const tagRASPPPIPXA = extern struct {
    dwSize: u32,
    dwError: u32,
    szIpxAddress: ?[*]i8,
};
// --------------------------------------------------------
// Type: tagRASPPPIPW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const tagRASPPPIPW = extern struct {
    dwSize: u32,
    dwError: u32,
    szIpAddress: ?[*]u16,
    szServerIpAddress: ?[*]u16,
    dwOptions: u32,
    dwServerOptions: u32,
};
// --------------------------------------------------------
// Type: tagRASPPPIPA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const tagRASPPPIPA = extern struct {
    dwSize: u32,
    dwError: u32,
    szIpAddress: ?[*]i8,
    szServerIpAddress: ?[*]i8,
    dwOptions: u32,
    dwServerOptions: u32,
};
// --------------------------------------------------------
// Type: tagRASPPPIPV6
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const tagRASPPPIPV6 = extern struct {
    dwSize: u32,
    dwError: u32,
    bLocalInterfaceIdentifier: ?[*]u8,
    bPeerInterfaceIdentifier: ?[*]u8,
    bLocalCompressionProtocol: ?[*]u8,
    bPeerCompressionProtocol: ?[*]u8,
};
// --------------------------------------------------------
// Type: tagRASPPPLCPW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const tagRASPPPLCPW = extern struct {
    dwSize: u32,
    fBundled: BOOL,
    dwError: u32,
    dwAuthenticationProtocol: u32,
    dwAuthenticationData: u32,
    dwEapTypeId: u32,
    dwServerAuthenticationProtocol: u32,
    dwServerAuthenticationData: u32,
    dwServerEapTypeId: u32,
    fMultilink: BOOL,
    dwTerminateReason: u32,
    dwServerTerminateReason: u32,
    szReplyMessage: ?[*]u16,
    dwOptions: u32,
    dwServerOptions: u32,
};
// --------------------------------------------------------
// Type: tagRASPPPLCPA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const tagRASPPPLCPA = extern struct {
    dwSize: u32,
    fBundled: BOOL,
    dwError: u32,
    dwAuthenticationProtocol: u32,
    dwAuthenticationData: u32,
    dwEapTypeId: u32,
    dwServerAuthenticationProtocol: u32,
    dwServerAuthenticationData: u32,
    dwServerEapTypeId: u32,
    fMultilink: BOOL,
    dwTerminateReason: u32,
    dwServerTerminateReason: u32,
    szReplyMessage: ?[*]i8,
    dwOptions: u32,
    dwServerOptions: u32,
};
// --------------------------------------------------------
// Type: tagRASPPPCCP
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const tagRASPPPCCP = extern struct {
    dwSize: u32,
    dwError: u32,
    dwCompressionAlgorithm: u32,
    dwOptions: u32,
    dwServerCompressionAlgorithm: u32,
    dwServerOptions: u32,
};
// --------------------------------------------------------
// Type: RASPPP_PROJECTION_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const RASPPP_PROJECTION_INFO = extern struct {
    dwIPv4NegotiationError: u32,
    ipv4Address: in_addr,
    ipv4ServerAddress: in_addr,
    dwIPv4Options: u32,
    dwIPv4ServerOptions: u32,
    dwIPv6NegotiationError: u32,
    bInterfaceIdentifier: ?[*]u8,
    bServerInterfaceIdentifier: ?[*]u8,
    fBundled: BOOL,
    fMultilink: BOOL,
    dwAuthenticationProtocol: u32,
    dwAuthenticationData: u32,
    dwServerAuthenticationProtocol: u32,
    dwServerAuthenticationData: u32,
    dwEapTypeId: u32,
    dwServerEapTypeId: u32,
    dwLcpOptions: u32,
    dwLcpServerOptions: u32,
    dwCcpError: u32,
    dwCcpCompressionAlgorithm: u32,
    dwCcpServerCompressionAlgorithm: u32,
    dwCcpOptions: u32,
    dwCcpServerOptions: u32,
};
// --------------------------------------------------------
// Type: RASIKEV2_PROJECTION_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const RASIKEV2_PROJECTION_INFO = extern struct {
    dwIPv4NegotiationError: u32,
    ipv4Address: in_addr,
    ipv4ServerAddress: in_addr,
    dwIPv6NegotiationError: u32,
    ipv6Address: in6_addr,
    ipv6ServerAddress: in6_addr,
    dwPrefixLength: u32,
    dwAuthenticationProtocol: u32,
    dwEapTypeId: u32,
    dwFlags: u32,
    dwEncryptionMethod: u32,
    numIPv4ServerAddresses: u32,
    ipv4ServerAddresses: ?*in_addr,
    numIPv6ServerAddresses: u32,
    ipv6ServerAddresses: ?*in6_addr,
};
// --------------------------------------------------------
// Type: RASPROJECTION_INFO_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const RASPROJECTION_INFO_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: IKEV2_ID_PAYLOAD_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const IKEV2_ID_PAYLOAD_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: RAS_PROJECTION_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const RAS_PROJECTION_INFO = extern struct {
    version: RASAPIVERSION,
    type: RASPROJECTION_INFO_TYPE,
    Anonymous: _Anonymous_e__Union,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: RASDIALFUNC
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const RASDIALFUNC = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: RASDIALFUNC1
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const RASDIALFUNC1 = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: RASDIALFUNC2
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const RASDIALFUNC2 = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: tagRASDEVINFOW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const tagRASDEVINFOW = extern struct {
    dwSize: u32,
    szDeviceType: ?[*]u16,
    szDeviceName: ?[*]u16,
};
// --------------------------------------------------------
// Type: tagRASDEVINFOA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const tagRASDEVINFOA = extern struct {
    dwSize: u32,
    szDeviceType: ?[*]i8,
    szDeviceName: ?[*]i8,
};
// --------------------------------------------------------
// Type: RASCTRYINFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const RASCTRYINFO = extern struct {
    dwSize: u32,
    dwCountryID: u32,
    dwNextCountryID: u32,
    dwCountryCode: u32,
    dwCountryNameOffset: u32,
};
// --------------------------------------------------------
// Type: tagRASENTRYA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const tagRASENTRYA = extern struct {
    dwSize: u32,
    dwfOptions: u32,
    dwCountryID: u32,
    dwCountryCode: u32,
    szAreaCode: ?[*]i8,
    szLocalPhoneNumber: ?[*]i8,
    dwAlternateOffset: u32,
    ipaddr: RASIPADDR,
    ipaddrDns: RASIPADDR,
    ipaddrDnsAlt: RASIPADDR,
    ipaddrWins: RASIPADDR,
    ipaddrWinsAlt: RASIPADDR,
    dwFrameSize: u32,
    dwfNetProtocols: u32,
    dwFramingProtocol: u32,
    szScript: ?[*]i8,
    szAutodialDll: ?[*]i8,
    szAutodialFunc: ?[*]i8,
    szDeviceType: ?[*]i8,
    szDeviceName: ?[*]i8,
    szX25PadType: ?[*]i8,
    szX25Address: ?[*]i8,
    szX25Facilities: ?[*]i8,
    szX25UserData: ?[*]i8,
    dwChannels: u32,
    dwReserved1: u32,
    dwReserved2: u32,
    dwSubEntries: u32,
    dwDialMode: u32,
    dwDialExtraPercent: u32,
    dwDialExtraSampleSeconds: u32,
    dwHangUpExtraPercent: u32,
    dwHangUpExtraSampleSeconds: u32,
    dwIdleDisconnectSeconds: u32,
    dwType: u32,
    dwEncryptionType: u32,
    dwCustomAuthKey: u32,
    guidId: Guid,
    szCustomDialDll: ?[*]i8,
    dwVpnStrategy: u32,
    dwfOptions2: u32,
    dwfOptions3: u32,
    szDnsSuffix: ?[*]i8,
    dwTcpWindowSize: u32,
    szPrerequisitePbk: ?[*]i8,
    szPrerequisiteEntry: ?[*]i8,
    dwRedialCount: u32,
    dwRedialPause: u32,
    ipv6addrDns: in6_addr,
    ipv6addrDnsAlt: in6_addr,
    dwIPv4InterfaceMetric: u32,
    dwIPv6InterfaceMetric: u32,
    ipv6addr: in6_addr,
    dwIPv6PrefixLength: u32,
    dwNetworkOutageTime: u32,
    szIDi: ?[*]i8,
    szIDr: ?[*]i8,
    fIsImsConfig: BOOL,
    IdiType: IKEV2_ID_PAYLOAD_TYPE,
    IdrType: IKEV2_ID_PAYLOAD_TYPE,
    fDisableIKEv2Fragmentation: BOOL,
};
// --------------------------------------------------------
// Type: tagRASENTRYW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const tagRASENTRYW = extern struct {
    dwSize: u32,
    dwfOptions: u32,
    dwCountryID: u32,
    dwCountryCode: u32,
    szAreaCode: ?[*]u16,
    szLocalPhoneNumber: ?[*]u16,
    dwAlternateOffset: u32,
    ipaddr: RASIPADDR,
    ipaddrDns: RASIPADDR,
    ipaddrDnsAlt: RASIPADDR,
    ipaddrWins: RASIPADDR,
    ipaddrWinsAlt: RASIPADDR,
    dwFrameSize: u32,
    dwfNetProtocols: u32,
    dwFramingProtocol: u32,
    szScript: ?[*]u16,
    szAutodialDll: ?[*]u16,
    szAutodialFunc: ?[*]u16,
    szDeviceType: ?[*]u16,
    szDeviceName: ?[*]u16,
    szX25PadType: ?[*]u16,
    szX25Address: ?[*]u16,
    szX25Facilities: ?[*]u16,
    szX25UserData: ?[*]u16,
    dwChannels: u32,
    dwReserved1: u32,
    dwReserved2: u32,
    dwSubEntries: u32,
    dwDialMode: u32,
    dwDialExtraPercent: u32,
    dwDialExtraSampleSeconds: u32,
    dwHangUpExtraPercent: u32,
    dwHangUpExtraSampleSeconds: u32,
    dwIdleDisconnectSeconds: u32,
    dwType: u32,
    dwEncryptionType: u32,
    dwCustomAuthKey: u32,
    guidId: Guid,
    szCustomDialDll: ?[*]u16,
    dwVpnStrategy: u32,
    dwfOptions2: u32,
    dwfOptions3: u32,
    szDnsSuffix: ?[*]u16,
    dwTcpWindowSize: u32,
    szPrerequisitePbk: ?[*]u16,
    szPrerequisiteEntry: ?[*]u16,
    dwRedialCount: u32,
    dwRedialPause: u32,
    ipv6addrDns: in6_addr,
    ipv6addrDnsAlt: in6_addr,
    dwIPv4InterfaceMetric: u32,
    dwIPv6InterfaceMetric: u32,
    ipv6addr: in6_addr,
    dwIPv6PrefixLength: u32,
    dwNetworkOutageTime: u32,
    szIDi: ?[*]u16,
    szIDr: ?[*]u16,
    fIsImsConfig: BOOL,
    IdiType: IKEV2_ID_PAYLOAD_TYPE,
    IdrType: IKEV2_ID_PAYLOAD_TYPE,
    fDisableIKEv2Fragmentation: BOOL,
};
// --------------------------------------------------------
// Type: ORASADFUNC
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const ORASADFUNC = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: tagRASADPARAMS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const tagRASADPARAMS = extern struct {
    dwSize: u32,
    hwndOwner: HWND,
    dwFlags: u32,
    xDlg: i32,
    yDlg: i32,
};
// --------------------------------------------------------
// Type: RASADFUNCA
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const RASADFUNCA = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: RASADFUNCW
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const RASADFUNCW = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: tagRASSUBENTRYA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const tagRASSUBENTRYA = extern struct {
    dwSize: u32,
    dwfFlags: u32,
    szDeviceType: ?[*]i8,
    szDeviceName: ?[*]i8,
    szLocalPhoneNumber: ?[*]i8,
    dwAlternateOffset: u32,
};
// --------------------------------------------------------
// Type: tagRASSUBENTRYW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const tagRASSUBENTRYW = extern struct {
    dwSize: u32,
    dwfFlags: u32,
    szDeviceType: ?[*]u16,
    szDeviceName: ?[*]u16,
    szLocalPhoneNumber: ?[*]u16,
    dwAlternateOffset: u32,
};
// --------------------------------------------------------
// Type: tagRASCREDENTIALSA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const tagRASCREDENTIALSA = extern struct {
    dwSize: u32,
    dwMask: u32,
    szUserName: ?[*]i8,
    szPassword: ?[*]i8,
    szDomain: ?[*]i8,
};
// --------------------------------------------------------
// Type: tagRASCREDENTIALSW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const tagRASCREDENTIALSW = extern struct {
    dwSize: u32,
    dwMask: u32,
    szUserName: ?[*]u16,
    szPassword: ?[*]u16,
    szDomain: ?[*]u16,
};
// --------------------------------------------------------
// Type: tagRASAUTODIALENTRYA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const tagRASAUTODIALENTRYA = extern struct {
    dwSize: u32,
    dwFlags: u32,
    dwDialingLocation: u32,
    szEntry: ?[*]i8,
};
// --------------------------------------------------------
// Type: tagRASAUTODIALENTRYW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const tagRASAUTODIALENTRYW = extern struct {
    dwSize: u32,
    dwFlags: u32,
    dwDialingLocation: u32,
    szEntry: ?[*]u16,
};
// --------------------------------------------------------
// Type: tagRASEAPUSERIDENTITYA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const tagRASEAPUSERIDENTITYA = extern struct {
    szUserName: ?[*]i8,
    dwSizeofEapInfo: u32,
    pbEapInfo: ?[*]u8,
};
// --------------------------------------------------------
// Type: tagRASEAPUSERIDENTITYW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const tagRASEAPUSERIDENTITYW = extern struct {
    szUserName: ?[*]u16,
    dwSizeofEapInfo: u32,
    pbEapInfo: ?[*]u8,
};
// --------------------------------------------------------
// Type: PFNRASGETBUFFER
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFNRASGETBUFFER = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PFNRASFREEBUFFER
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFNRASFREEBUFFER = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PFNRASSENDBUFFER
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFNRASSENDBUFFER = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PFNRASRECEIVEBUFFER
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFNRASRECEIVEBUFFER = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PFNRASRETRIEVEBUFFER
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFNRASRETRIEVEBUFFER = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: RasCustomScriptExecuteFn
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const RasCustomScriptExecuteFn = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: tagRASCOMMSETTINGS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const tagRASCOMMSETTINGS = extern struct {
    dwSize: u32,
    bParity: u8,
    bStop: u8,
    bByteSize: u8,
    bAlign: u8,
};
// --------------------------------------------------------
// Type: PFNRASSETCOMMSETTINGS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFNRASSETCOMMSETTINGS = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: tagRASCUSTOMSCRIPTEXTENSIONS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const tagRASCUSTOMSCRIPTEXTENSIONS = extern struct {
    dwSize: u32,
    pfnRasSetCommSettings: PFNRASSETCOMMSETTINGS,
};
// --------------------------------------------------------
// Type: RAS_STATS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const RAS_STATS = extern struct {
    dwSize: u32,
    dwBytesXmited: u32,
    dwBytesRcved: u32,
    dwFramesXmited: u32,
    dwFramesRcved: u32,
    dwCrcErr: u32,
    dwTimeoutErr: u32,
    dwAlignmentErr: u32,
    dwHardwareOverrunErr: u32,
    dwFramingErr: u32,
    dwBufferOverrunErr: u32,
    dwCompressionRatioIn: u32,
    dwCompressionRatioOut: u32,
    dwBps: u32,
    dwConnectDuration: u32,
};
// --------------------------------------------------------
// Type: RasCustomHangUpFn
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const RasCustomHangUpFn = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: RasCustomDialFn
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const RasCustomDialFn = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: RasCustomDeleteEntryNotifyFn
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const RasCustomDeleteEntryNotifyFn = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: tagRASUPDATECONN
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const tagRASUPDATECONN = extern struct {
    version: RASAPIVERSION,
    dwSize: u32,
    dwFlags: u32,
    dwIfIndex: u32,
    localEndPoint: tagRASTUNNELENDPOINT,
    remoteEndPoint: tagRASTUNNELENDPOINT,
};
// --------------------------------------------------------
// Type: RASPBDLGFUNCW
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const RASPBDLGFUNCW = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: RASPBDLGFUNCA
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const RASPBDLGFUNCA = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: tagRASNOUSERW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const tagRASNOUSERW = extern struct {
    dwSize: u32,
    dwFlags: u32,
    dwTimeoutMs: u32,
    szUserName: ?[*]u16,
    szPassword: ?[*]u16,
    szDomain: ?[*]u16,
};
// --------------------------------------------------------
// Type: tagRASNOUSERA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const tagRASNOUSERA = extern struct {
    dwSize: u32,
    dwFlags: u32,
    dwTimeoutMs: u32,
    szUserName: ?[*]i8,
    szPassword: ?[*]i8,
    szDomain: ?[*]i8,
};
// --------------------------------------------------------
// Type: tagRASPBDLGW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const tagRASPBDLGW = extern struct {
    dwSize: u32,
    hwndOwner: HWND,
    dwFlags: u32,
    xDlg: i32,
    yDlg: i32,
    dwCallbackId: ?*opaque{},
    pCallback: RASPBDLGFUNCW,
    dwError: u32,
    reserved: ?*opaque{},
    reserved2: ?*opaque{},
};
// --------------------------------------------------------
// Type: tagRASPBDLGA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const tagRASPBDLGA = extern struct {
    dwSize: u32,
    hwndOwner: HWND,
    dwFlags: u32,
    xDlg: i32,
    yDlg: i32,
    dwCallbackId: ?*opaque{},
    pCallback: RASPBDLGFUNCA,
    dwError: u32,
    reserved: ?*opaque{},
    reserved2: ?*opaque{},
};
// --------------------------------------------------------
// Type: tagRASENTRYDLGW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const tagRASENTRYDLGW = extern struct {
    dwSize: u32,
    hwndOwner: HWND,
    dwFlags: u32,
    xDlg: i32,
    yDlg: i32,
    szEntry: ?[*]u16,
    dwError: u32,
    reserved: ?*opaque{},
    reserved2: ?*opaque{},
};
// --------------------------------------------------------
// Type: tagRASENTRYDLGA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const tagRASENTRYDLGA = extern struct {
    dwSize: u32,
    hwndOwner: HWND,
    dwFlags: u32,
    xDlg: i32,
    yDlg: i32,
    szEntry: ?[*]i8,
    dwError: u32,
    reserved: ?*opaque{},
    reserved2: ?*opaque{},
};
// --------------------------------------------------------
// Type: tagRASDIALDLG
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const tagRASDIALDLG = extern struct {
    dwSize: u32,
    hwndOwner: HWND,
    dwFlags: u32,
    xDlg: i32,
    yDlg: i32,
    dwSubEntry: u32,
    dwError: u32,
    reserved: ?*opaque{},
    reserved2: ?*opaque{},
};
// --------------------------------------------------------
// Type: RasCustomDialDlgFn
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const RasCustomDialDlgFn = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: RasCustomEntryDlgFn
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const RasCustomEntryDlgFn = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: ROUTER_INTERFACE_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const ROUTER_INTERFACE_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: ROUTER_CONNECTION_STATE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const ROUTER_CONNECTION_STATE = *opaque{
};
// --------------------------------------------------------
// Type: MPR_INTERFACE_0
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const MPR_INTERFACE_0 = extern struct {
    wszInterfaceName: ?[*]u16,
    hInterface: HANDLE,
    fEnabled: BOOL,
    dwIfType: ROUTER_INTERFACE_TYPE,
    dwConnectionState: ROUTER_CONNECTION_STATE,
    fUnReachabilityReasons: u32,
    dwLastError: u32,
};
// --------------------------------------------------------
// Type: MPR_IPINIP_INTERFACE_0
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const MPR_IPINIP_INTERFACE_0 = extern struct {
    wszFriendlyName: ?[*]u16,
    Guid: Guid,
};
// --------------------------------------------------------
// Type: MPR_INTERFACE_1
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const MPR_INTERFACE_1 = extern struct {
    wszInterfaceName: ?[*]u16,
    hInterface: HANDLE,
    fEnabled: BOOL,
    dwIfType: ROUTER_INTERFACE_TYPE,
    dwConnectionState: ROUTER_CONNECTION_STATE,
    fUnReachabilityReasons: u32,
    dwLastError: u32,
    lpwsDialoutHoursRestriction: ?*u16,
};
// --------------------------------------------------------
// Type: MPR_INTERFACE_2
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const MPR_INTERFACE_2 = extern struct {
    wszInterfaceName: ?[*]u16,
    hInterface: HANDLE,
    fEnabled: BOOL,
    dwIfType: ROUTER_INTERFACE_TYPE,
    dwConnectionState: ROUTER_CONNECTION_STATE,
    fUnReachabilityReasons: u32,
    dwLastError: u32,
    dwfOptions: u32,
    szLocalPhoneNumber: ?[*]u16,
    szAlternates: ?*u16,
    ipaddr: u32,
    ipaddrDns: u32,
    ipaddrDnsAlt: u32,
    ipaddrWins: u32,
    ipaddrWinsAlt: u32,
    dwfNetProtocols: u32,
    szDeviceType: ?[*]u16,
    szDeviceName: ?[*]u16,
    szX25PadType: ?[*]u16,
    szX25Address: ?[*]u16,
    szX25Facilities: ?[*]u16,
    szX25UserData: ?[*]u16,
    dwChannels: u32,
    dwSubEntries: u32,
    dwDialMode: u32,
    dwDialExtraPercent: u32,
    dwDialExtraSampleSeconds: u32,
    dwHangUpExtraPercent: u32,
    dwHangUpExtraSampleSeconds: u32,
    dwIdleDisconnectSeconds: u32,
    dwType: u32,
    dwEncryptionType: u32,
    dwCustomAuthKey: u32,
    dwCustomAuthDataSize: u32,
    lpbCustomAuthData: ?*u8,
    guidId: Guid,
    dwVpnStrategy: u32,
};
// --------------------------------------------------------
// Type: MPR_INTERFACE_3
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const MPR_INTERFACE_3 = extern struct {
    wszInterfaceName: ?[*]u16,
    hInterface: HANDLE,
    fEnabled: BOOL,
    dwIfType: ROUTER_INTERFACE_TYPE,
    dwConnectionState: ROUTER_CONNECTION_STATE,
    fUnReachabilityReasons: u32,
    dwLastError: u32,
    dwfOptions: u32,
    szLocalPhoneNumber: ?[*]u16,
    szAlternates: ?*u16,
    ipaddr: u32,
    ipaddrDns: u32,
    ipaddrDnsAlt: u32,
    ipaddrWins: u32,
    ipaddrWinsAlt: u32,
    dwfNetProtocols: u32,
    szDeviceType: ?[*]u16,
    szDeviceName: ?[*]u16,
    szX25PadType: ?[*]u16,
    szX25Address: ?[*]u16,
    szX25Facilities: ?[*]u16,
    szX25UserData: ?[*]u16,
    dwChannels: u32,
    dwSubEntries: u32,
    dwDialMode: u32,
    dwDialExtraPercent: u32,
    dwDialExtraSampleSeconds: u32,
    dwHangUpExtraPercent: u32,
    dwHangUpExtraSampleSeconds: u32,
    dwIdleDisconnectSeconds: u32,
    dwType: u32,
    dwEncryptionType: u32,
    dwCustomAuthKey: u32,
    dwCustomAuthDataSize: u32,
    lpbCustomAuthData: ?*u8,
    guidId: Guid,
    dwVpnStrategy: u32,
    AddressCount: u32,
    ipv6addrDns: in6_addr,
    ipv6addrDnsAlt: in6_addr,
    ipv6addr: ?*in6_addr,
};
// --------------------------------------------------------
// Type: MPR_DEVICE_0
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const MPR_DEVICE_0 = extern struct {
    szDeviceType: ?[*]u16,
    szDeviceName: ?[*]u16,
};
// --------------------------------------------------------
// Type: MPR_DEVICE_1
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const MPR_DEVICE_1 = extern struct {
    szDeviceType: ?[*]u16,
    szDeviceName: ?[*]u16,
    szLocalPhoneNumber: ?[*]u16,
    szAlternates: ?*u16,
};
// --------------------------------------------------------
// Type: MPR_CREDENTIALSEX_0
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const MPR_CREDENTIALSEX_0 = extern struct {
    dwSize: u32,
    lpbCredentialsInfo: ?*u8,
};
// --------------------------------------------------------
// Type: MPR_CREDENTIALSEX_1
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const MPR_CREDENTIALSEX_1 = extern struct {
    dwSize: u32,
    lpbCredentialsInfo: ?*u8,
};
// --------------------------------------------------------
// Type: MPR_TRANSPORT_0
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const MPR_TRANSPORT_0 = extern struct {
    dwTransportId: u32,
    hTransport: HANDLE,
    wszTransportName: ?[*]u16,
};
// --------------------------------------------------------
// Type: MPR_IFTRANSPORT_0
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const MPR_IFTRANSPORT_0 = extern struct {
    dwTransportId: u32,
    hIfTransport: HANDLE,
    wszIfTransportName: ?[*]u16,
};
// --------------------------------------------------------
// Type: MPR_SERVER_0
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const MPR_SERVER_0 = extern struct {
    fLanOnlyMode: BOOL,
    dwUpTime: u32,
    dwTotalPorts: u32,
    dwPortsInUse: u32,
};
// --------------------------------------------------------
// Type: MPR_SERVER_1
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const MPR_SERVER_1 = extern struct {
    dwNumPptpPorts: u32,
    dwPptpPortFlags: u32,
    dwNumL2tpPorts: u32,
    dwL2tpPortFlags: u32,
};
// --------------------------------------------------------
// Type: MPR_SERVER_2
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const MPR_SERVER_2 = extern struct {
    dwNumPptpPorts: u32,
    dwPptpPortFlags: u32,
    dwNumL2tpPorts: u32,
    dwL2tpPortFlags: u32,
    dwNumSstpPorts: u32,
    dwSstpPortFlags: u32,
};
// --------------------------------------------------------
// Type: RAS_PORT_CONDITION
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const RAS_PORT_CONDITION = *opaque{
};
// --------------------------------------------------------
// Type: RAS_HARDWARE_CONDITION
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const RAS_HARDWARE_CONDITION = *opaque{
};
// --------------------------------------------------------
// Type: RAS_PORT_0
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const RAS_PORT_0 = extern struct {
    hPort: HANDLE,
    hConnection: HANDLE,
    dwPortCondition: RAS_PORT_CONDITION,
    dwTotalNumberOfCalls: u32,
    dwConnectDuration: u32,
    wszPortName: ?[*]u16,
    wszMediaName: ?[*]u16,
    wszDeviceName: ?[*]u16,
    wszDeviceType: ?[*]u16,
};
// --------------------------------------------------------
// Type: RAS_PORT_1
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const RAS_PORT_1 = extern struct {
    hPort: HANDLE,
    hConnection: HANDLE,
    dwHardwareCondition: RAS_HARDWARE_CONDITION,
    dwLineSpeed: u32,
    dwBytesXmited: u32,
    dwBytesRcved: u32,
    dwFramesXmited: u32,
    dwFramesRcved: u32,
    dwCrcErr: u32,
    dwTimeoutErr: u32,
    dwAlignmentErr: u32,
    dwHardwareOverrunErr: u32,
    dwFramingErr: u32,
    dwBufferOverrunErr: u32,
    dwCompressionRatioIn: u32,
    dwCompressionRatioOut: u32,
};
// --------------------------------------------------------
// Type: RAS_PORT_2
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const RAS_PORT_2 = extern struct {
    hPort: HANDLE,
    hConnection: HANDLE,
    dwConn_State: u32,
    wszPortName: ?[*]u16,
    wszMediaName: ?[*]u16,
    wszDeviceName: ?[*]u16,
    wszDeviceType: ?[*]u16,
    dwHardwareCondition: RAS_HARDWARE_CONDITION,
    dwLineSpeed: u32,
    dwCrcErr: u32,
    dwSerialOverRunErrs: u32,
    dwTimeoutErr: u32,
    dwAlignmentErr: u32,
    dwHardwareOverrunErr: u32,
    dwFramingErr: u32,
    dwBufferOverrunErr: u32,
    dwCompressionRatioIn: u32,
    dwCompressionRatioOut: u32,
    dwTotalErrors: u32,
    ullBytesXmited: u64,
    ullBytesRcved: u64,
    ullFramesXmited: u64,
    ullFramesRcved: u64,
    ullBytesTxUncompressed: u64,
    ullBytesTxCompressed: u64,
    ullBytesRcvUncompressed: u64,
    ullBytesRcvCompressed: u64,
};
// --------------------------------------------------------
// Type: PPP_NBFCP_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PPP_NBFCP_INFO = extern struct {
    dwError: u32,
    wszWksta: ?[*]u16,
};
// --------------------------------------------------------
// Type: PPP_IPCP_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PPP_IPCP_INFO = extern struct {
    dwError: u32,
    wszAddress: ?[*]u16,
    wszRemoteAddress: ?[*]u16,
};
// --------------------------------------------------------
// Type: PPP_IPCP_INFO2
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PPP_IPCP_INFO2 = extern struct {
    dwError: u32,
    wszAddress: ?[*]u16,
    wszRemoteAddress: ?[*]u16,
    dwOptions: u32,
    dwRemoteOptions: u32,
};
// --------------------------------------------------------
// Type: PPP_IPXCP_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PPP_IPXCP_INFO = extern struct {
    dwError: u32,
    wszAddress: ?[*]u16,
};
// --------------------------------------------------------
// Type: PPP_ATCP_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PPP_ATCP_INFO = extern struct {
    dwError: u32,
    wszAddress: ?[*]u16,
};
// --------------------------------------------------------
// Type: PPP_IPV6_CP_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PPP_IPV6_CP_INFO = extern struct {
    dwVersion: u32,
    dwSize: u32,
    dwError: u32,
    bInterfaceIdentifier: ?[*]u8,
    bRemoteInterfaceIdentifier: ?[*]u8,
    dwOptions: u32,
    dwRemoteOptions: u32,
    bPrefix: ?[*]u8,
    dwPrefixLength: u32,
};
// --------------------------------------------------------
// Type: PPP_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PPP_INFO = extern struct {
    nbf: PPP_NBFCP_INFO,
    ip: PPP_IPCP_INFO,
    ipx: PPP_IPXCP_INFO,
    at: PPP_ATCP_INFO,
};
// --------------------------------------------------------
// Type: PPP_CCP_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PPP_CCP_INFO = extern struct {
    dwError: u32,
    dwCompressionAlgorithm: u32,
    dwOptions: u32,
    dwRemoteCompressionAlgorithm: u32,
    dwRemoteOptions: u32,
};
// --------------------------------------------------------
// Type: PPP_LCP_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PPP_LCP_INFO = extern struct {
    dwError: u32,
    dwAuthenticationProtocol: u32,
    dwAuthenticationData: u32,
    dwRemoteAuthenticationProtocol: u32,
    dwRemoteAuthenticationData: u32,
    dwTerminateReason: u32,
    dwRemoteTerminateReason: u32,
    dwOptions: u32,
    dwRemoteOptions: u32,
    dwEapTypeId: u32,
    dwRemoteEapTypeId: u32,
};
// --------------------------------------------------------
// Type: PPP_INFO_2
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PPP_INFO_2 = extern struct {
    nbf: PPP_NBFCP_INFO,
    ip: PPP_IPCP_INFO2,
    ipx: PPP_IPXCP_INFO,
    at: PPP_ATCP_INFO,
    ccp: PPP_CCP_INFO,
    lcp: PPP_LCP_INFO,
};
// --------------------------------------------------------
// Type: PPP_INFO_3
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PPP_INFO_3 = extern struct {
    nbf: PPP_NBFCP_INFO,
    ip: PPP_IPCP_INFO2,
    ipv6: PPP_IPV6_CP_INFO,
    ccp: PPP_CCP_INFO,
    lcp: PPP_LCP_INFO,
};
// --------------------------------------------------------
// Type: RAS_CONNECTION_0
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const RAS_CONNECTION_0 = extern struct {
    hConnection: HANDLE,
    hInterface: HANDLE,
    dwConnectDuration: u32,
    dwInterfaceType: ROUTER_INTERFACE_TYPE,
    dwConnectionFlags: u32,
    wszInterfaceName: ?[*]u16,
    wszUserName: ?[*]u16,
    wszLogonDomain: ?[*]u16,
    wszRemoteComputer: ?[*]u16,
};
// --------------------------------------------------------
// Type: RAS_CONNECTION_1
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const RAS_CONNECTION_1 = extern struct {
    hConnection: HANDLE,
    hInterface: HANDLE,
    PppInfo: PPP_INFO,
    dwBytesXmited: u32,
    dwBytesRcved: u32,
    dwFramesXmited: u32,
    dwFramesRcved: u32,
    dwCrcErr: u32,
    dwTimeoutErr: u32,
    dwAlignmentErr: u32,
    dwHardwareOverrunErr: u32,
    dwFramingErr: u32,
    dwBufferOverrunErr: u32,
    dwCompressionRatioIn: u32,
    dwCompressionRatioOut: u32,
};
// --------------------------------------------------------
// Type: RAS_CONNECTION_2
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const RAS_CONNECTION_2 = extern struct {
    hConnection: HANDLE,
    wszUserName: ?[*]u16,
    dwInterfaceType: ROUTER_INTERFACE_TYPE,
    guid: Guid,
    PppInfo2: PPP_INFO_2,
};
// --------------------------------------------------------
// Type: RAS_QUARANTINE_STATE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const RAS_QUARANTINE_STATE = *opaque{
};
// --------------------------------------------------------
// Type: RAS_CONNECTION_3
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const RAS_CONNECTION_3 = extern struct {
    dwVersion: u32,
    dwSize: u32,
    hConnection: HANDLE,
    wszUserName: ?[*]u16,
    dwInterfaceType: ROUTER_INTERFACE_TYPE,
    guid: Guid,
    PppInfo3: PPP_INFO_3,
    rasQuarState: RAS_QUARANTINE_STATE,
    timer: FILETIME,
};
// --------------------------------------------------------
// Type: RAS_USER_0
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const RAS_USER_0 = extern struct {
    bfPrivilege: u8,
    wszPhoneNumber: ?[*]u16,
};
// --------------------------------------------------------
// Type: RAS_USER_1
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const RAS_USER_1 = extern struct {
    bfPrivilege: u8,
    wszPhoneNumber: ?[*]u16,
    bfPrivilege2: u8,
};
// --------------------------------------------------------
// Type: MPR_FILTER_0
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const MPR_FILTER_0 = extern struct {
    fEnable: BOOL,
};
// --------------------------------------------------------
// Type: MPRAPI_OBJECT_HEADER
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const MPRAPI_OBJECT_HEADER = extern struct {
    revision: u8,
    type: u8,
    size: u16,
};
// --------------------------------------------------------
// Type: MPRAPI_OBJECT_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const MPRAPI_OBJECT_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: PPP_PROJECTION_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PPP_PROJECTION_INFO = extern struct {
    dwIPv4NegotiationError: u32,
    wszAddress: ?[*]u16,
    wszRemoteAddress: ?[*]u16,
    dwIPv4Options: u32,
    dwIPv4RemoteOptions: u32,
    IPv4SubInterfaceIndex: u64,
    dwIPv6NegotiationError: u32,
    bInterfaceIdentifier: ?[*]u8,
    bRemoteInterfaceIdentifier: ?[*]u8,
    bPrefix: ?[*]u8,
    dwPrefixLength: u32,
    IPv6SubInterfaceIndex: u64,
    dwLcpError: u32,
    dwAuthenticationProtocol: u32,
    dwAuthenticationData: u32,
    dwRemoteAuthenticationProtocol: u32,
    dwRemoteAuthenticationData: u32,
    dwLcpTerminateReason: u32,
    dwLcpRemoteTerminateReason: u32,
    dwLcpOptions: u32,
    dwLcpRemoteOptions: u32,
    dwEapTypeId: u32,
    dwRemoteEapTypeId: u32,
    dwCcpError: u32,
    dwCompressionAlgorithm: u32,
    dwCcpOptions: u32,
    dwRemoteCompressionAlgorithm: u32,
    dwCcpRemoteOptions: u32,
};
// --------------------------------------------------------
// Type: PPP_PROJECTION_INFO2
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PPP_PROJECTION_INFO2 = extern struct {
    dwIPv4NegotiationError: u32,
    wszAddress: ?[*]u16,
    wszRemoteAddress: ?[*]u16,
    dwIPv4Options: u32,
    dwIPv4RemoteOptions: u32,
    IPv4SubInterfaceIndex: u64,
    dwIPv6NegotiationError: u32,
    bInterfaceIdentifier: ?[*]u8,
    bRemoteInterfaceIdentifier: ?[*]u8,
    bPrefix: ?[*]u8,
    dwPrefixLength: u32,
    IPv6SubInterfaceIndex: u64,
    dwLcpError: u32,
    dwAuthenticationProtocol: u32,
    dwAuthenticationData: u32,
    dwRemoteAuthenticationProtocol: u32,
    dwRemoteAuthenticationData: u32,
    dwLcpTerminateReason: u32,
    dwLcpRemoteTerminateReason: u32,
    dwLcpOptions: u32,
    dwLcpRemoteOptions: u32,
    dwEapTypeId: u32,
    dwEmbeddedEAPTypeId: u32,
    dwRemoteEapTypeId: u32,
    dwCcpError: u32,
    dwCompressionAlgorithm: u32,
    dwCcpOptions: u32,
    dwRemoteCompressionAlgorithm: u32,
    dwCcpRemoteOptions: u32,
};
// --------------------------------------------------------
// Type: IKEV2_PROJECTION_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const IKEV2_PROJECTION_INFO = extern struct {
    dwIPv4NegotiationError: u32,
    wszAddress: ?[*]u16,
    wszRemoteAddress: ?[*]u16,
    IPv4SubInterfaceIndex: u64,
    dwIPv6NegotiationError: u32,
    bInterfaceIdentifier: ?[*]u8,
    bRemoteInterfaceIdentifier: ?[*]u8,
    bPrefix: ?[*]u8,
    dwPrefixLength: u32,
    IPv6SubInterfaceIndex: u64,
    dwOptions: u32,
    dwAuthenticationProtocol: u32,
    dwEapTypeId: u32,
    dwCompressionAlgorithm: u32,
    dwEncryptionMethod: u32,
};
// --------------------------------------------------------
// Type: IKEV2_PROJECTION_INFO2
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const IKEV2_PROJECTION_INFO2 = extern struct {
    dwIPv4NegotiationError: u32,
    wszAddress: ?[*]u16,
    wszRemoteAddress: ?[*]u16,
    IPv4SubInterfaceIndex: u64,
    dwIPv6NegotiationError: u32,
    bInterfaceIdentifier: ?[*]u8,
    bRemoteInterfaceIdentifier: ?[*]u8,
    bPrefix: ?[*]u8,
    dwPrefixLength: u32,
    IPv6SubInterfaceIndex: u64,
    dwOptions: u32,
    dwAuthenticationProtocol: u32,
    dwEapTypeId: u32,
    dwEmbeddedEAPTypeId: u32,
    dwCompressionAlgorithm: u32,
    dwEncryptionMethod: u32,
};
// --------------------------------------------------------
// Type: PROJECTION_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PROJECTION_INFO = extern struct {
    projectionInfoType: u8,
    Anonymous: _Anonymous_e__Union,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: PROJECTION_INFO2
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PROJECTION_INFO2 = extern struct {
    projectionInfoType: u8,
    Anonymous: _Anonymous_e__Union,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: RAS_CONNECTION_EX
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const RAS_CONNECTION_EX = extern struct {
    Header: MPRAPI_OBJECT_HEADER,
    dwConnectDuration: u32,
    dwInterfaceType: ROUTER_INTERFACE_TYPE,
    dwConnectionFlags: u32,
    wszInterfaceName: ?[*]u16,
    wszUserName: ?[*]u16,
    wszLogonDomain: ?[*]u16,
    wszRemoteComputer: ?[*]u16,
    guid: Guid,
    rasQuarState: RAS_QUARANTINE_STATE,
    probationTime: FILETIME,
    dwBytesXmited: u32,
    dwBytesRcved: u32,
    dwFramesXmited: u32,
    dwFramesRcved: u32,
    dwCrcErr: u32,
    dwTimeoutErr: u32,
    dwAlignmentErr: u32,
    dwHardwareOverrunErr: u32,
    dwFramingErr: u32,
    dwBufferOverrunErr: u32,
    dwCompressionRatioIn: u32,
    dwCompressionRatioOut: u32,
    dwNumSwitchOvers: u32,
    wszRemoteEndpointAddress: ?[*]u16,
    wszLocalEndpointAddress: ?[*]u16,
    ProjectionInfo: PROJECTION_INFO,
    hConnection: HANDLE,
    hInterface: HANDLE,
};
// --------------------------------------------------------
// Type: RAS_CONNECTION_4
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const RAS_CONNECTION_4 = extern struct {
    dwConnectDuration: u32,
    dwInterfaceType: ROUTER_INTERFACE_TYPE,
    dwConnectionFlags: u32,
    wszInterfaceName: ?[*]u16,
    wszUserName: ?[*]u16,
    wszLogonDomain: ?[*]u16,
    wszRemoteComputer: ?[*]u16,
    guid: Guid,
    rasQuarState: RAS_QUARANTINE_STATE,
    probationTime: FILETIME,
    connectionStartTime: FILETIME,
    ullBytesXmited: u64,
    ullBytesRcved: u64,
    dwFramesXmited: u32,
    dwFramesRcved: u32,
    dwCrcErr: u32,
    dwTimeoutErr: u32,
    dwAlignmentErr: u32,
    dwHardwareOverrunErr: u32,
    dwFramingErr: u32,
    dwBufferOverrunErr: u32,
    dwCompressionRatioIn: u32,
    dwCompressionRatioOut: u32,
    dwNumSwitchOvers: u32,
    wszRemoteEndpointAddress: ?[*]u16,
    wszLocalEndpointAddress: ?[*]u16,
    ProjectionInfo: PROJECTION_INFO2,
    hConnection: HANDLE,
    hInterface: HANDLE,
    dwDeviceType: u32,
};
// --------------------------------------------------------
// Type: ROUTER_CUSTOM_IKEv2_POLICY0
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const ROUTER_CUSTOM_IKEv2_POLICY0 = extern struct {
    dwIntegrityMethod: u32,
    dwEncryptionMethod: u32,
    dwCipherTransformConstant: u32,
    dwAuthTransformConstant: u32,
    dwPfsGroup: u32,
    dwDhGroup: u32,
};
// --------------------------------------------------------
// Type: ROUTER_IKEv2_IF_CUSTOM_CONFIG0
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const ROUTER_IKEv2_IF_CUSTOM_CONFIG0 = extern struct {
    dwSaLifeTime: u32,
    dwSaDataSize: u32,
    certificateName: CRYPTOAPI_BLOB,
    customPolicy: ?*ROUTER_CUSTOM_IKEv2_POLICY0,
};
// --------------------------------------------------------
// Type: MPR_IF_CUSTOMINFOEX0
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const MPR_IF_CUSTOMINFOEX0 = extern struct {
    Header: MPRAPI_OBJECT_HEADER,
    dwFlags: u32,
    customIkev2Config: ROUTER_IKEv2_IF_CUSTOM_CONFIG0,
};
// --------------------------------------------------------
// Type: MPR_CERT_EKU
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const MPR_CERT_EKU = extern struct {
    dwSize: u32,
    IsEKUOID: BOOL,
    pwszEKU: ?*u16,
};
// --------------------------------------------------------
// Type: VPN_TS_IP_ADDRESS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VPN_TS_IP_ADDRESS = extern struct {
    Type: u16,
    Anonymous: _Anonymous_e__Union,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: MPR_VPN_TS_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const MPR_VPN_TS_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: _MPR_VPN_SELECTOR
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const _MPR_VPN_SELECTOR = extern struct {
    type: MPR_VPN_TS_TYPE,
    protocolId: u8,
    portStart: u16,
    portEnd: u16,
    tsPayloadId: u16,
    addrStart: VPN_TS_IP_ADDRESS,
    addrEnd: VPN_TS_IP_ADDRESS,
};
// --------------------------------------------------------
// Type: MPR_VPN_TRAFFIC_SELECTORS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const MPR_VPN_TRAFFIC_SELECTORS = extern struct {
    numTsi: u32,
    numTsr: u32,
    tsI: ?*_MPR_VPN_SELECTOR,
    tsR: ?*_MPR_VPN_SELECTOR,
};
// --------------------------------------------------------
// Type: ROUTER_IKEv2_IF_CUSTOM_CONFIG2
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const ROUTER_IKEv2_IF_CUSTOM_CONFIG2 = extern struct {
    dwSaLifeTime: u32,
    dwSaDataSize: u32,
    certificateName: CRYPTOAPI_BLOB,
    customPolicy: ?*ROUTER_CUSTOM_IKEv2_POLICY0,
    certificateHash: CRYPTOAPI_BLOB,
    dwMmSaLifeTime: u32,
    vpnTrafficSelectors: MPR_VPN_TRAFFIC_SELECTORS,
};
// --------------------------------------------------------
// Type: MPR_IF_CUSTOMINFOEX2
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const MPR_IF_CUSTOMINFOEX2 = extern struct {
    Header: MPRAPI_OBJECT_HEADER,
    dwFlags: u32,
    customIkev2Config: ROUTER_IKEv2_IF_CUSTOM_CONFIG2,
};
// --------------------------------------------------------
// Type: IKEV2_TUNNEL_CONFIG_PARAMS4
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const IKEV2_TUNNEL_CONFIG_PARAMS4 = extern struct {
    dwIdleTimeout: u32,
    dwNetworkBlackoutTime: u32,
    dwSaLifeTime: u32,
    dwSaDataSizeForRenegotiation: u32,
    dwConfigOptions: u32,
    dwTotalCertificates: u32,
    certificateNames: ?*CRYPTOAPI_BLOB,
    machineCertificateName: CRYPTOAPI_BLOB,
    dwEncryptionType: u32,
    customPolicy: ?*ROUTER_CUSTOM_IKEv2_POLICY0,
    dwTotalEkus: u32,
    certificateEKUs: ?*MPR_CERT_EKU,
    machineCertificateHash: CRYPTOAPI_BLOB,
    dwMmSaLifeTime: u32,
};
// --------------------------------------------------------
// Type: ROUTER_IKEv2_IF_CUSTOM_CONFIG1
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const ROUTER_IKEv2_IF_CUSTOM_CONFIG1 = extern struct {
    dwSaLifeTime: u32,
    dwSaDataSize: u32,
    certificateName: CRYPTOAPI_BLOB,
    customPolicy: ?*ROUTER_CUSTOM_IKEv2_POLICY0,
    certificateHash: CRYPTOAPI_BLOB,
};
// --------------------------------------------------------
// Type: MPR_IF_CUSTOMINFOEX1
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const MPR_IF_CUSTOMINFOEX1 = extern struct {
    Header: MPRAPI_OBJECT_HEADER,
    dwFlags: u32,
    customIkev2Config: ROUTER_IKEv2_IF_CUSTOM_CONFIG1,
};
// --------------------------------------------------------
// Type: IKEV2_TUNNEL_CONFIG_PARAMS3
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const IKEV2_TUNNEL_CONFIG_PARAMS3 = extern struct {
    dwIdleTimeout: u32,
    dwNetworkBlackoutTime: u32,
    dwSaLifeTime: u32,
    dwSaDataSizeForRenegotiation: u32,
    dwConfigOptions: u32,
    dwTotalCertificates: u32,
    certificateNames: ?*CRYPTOAPI_BLOB,
    machineCertificateName: CRYPTOAPI_BLOB,
    dwEncryptionType: u32,
    customPolicy: ?*ROUTER_CUSTOM_IKEv2_POLICY0,
    dwTotalEkus: u32,
    certificateEKUs: ?*MPR_CERT_EKU,
    machineCertificateHash: CRYPTOAPI_BLOB,
};
// --------------------------------------------------------
// Type: IKEV2_TUNNEL_CONFIG_PARAMS2
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const IKEV2_TUNNEL_CONFIG_PARAMS2 = extern struct {
    dwIdleTimeout: u32,
    dwNetworkBlackoutTime: u32,
    dwSaLifeTime: u32,
    dwSaDataSizeForRenegotiation: u32,
    dwConfigOptions: u32,
    dwTotalCertificates: u32,
    certificateNames: ?*CRYPTOAPI_BLOB,
    machineCertificateName: CRYPTOAPI_BLOB,
    dwEncryptionType: u32,
    customPolicy: ?*ROUTER_CUSTOM_IKEv2_POLICY0,
};
// --------------------------------------------------------
// Type: L2TP_TUNNEL_CONFIG_PARAMS2
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const L2TP_TUNNEL_CONFIG_PARAMS2 = extern struct {
    dwIdleTimeout: u32,
    dwEncryptionType: u32,
    dwSaLifeTime: u32,
    dwSaDataSizeForRenegotiation: u32,
    customPolicy: ?*ROUTER_CUSTOM_IKEv2_POLICY0,
    dwMmSaLifeTime: u32,
};
// --------------------------------------------------------
// Type: L2TP_TUNNEL_CONFIG_PARAMS1
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const L2TP_TUNNEL_CONFIG_PARAMS1 = extern struct {
    dwIdleTimeout: u32,
    dwEncryptionType: u32,
    dwSaLifeTime: u32,
    dwSaDataSizeForRenegotiation: u32,
    customPolicy: ?*ROUTER_CUSTOM_IKEv2_POLICY0,
};
// --------------------------------------------------------
// Type: IKEV2_CONFIG_PARAMS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const IKEV2_CONFIG_PARAMS = extern struct {
    dwNumPorts: u32,
    dwPortFlags: u32,
    dwTunnelConfigParamFlags: u32,
    TunnelConfigParams: IKEV2_TUNNEL_CONFIG_PARAMS4,
};
// --------------------------------------------------------
// Type: PPTP_CONFIG_PARAMS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PPTP_CONFIG_PARAMS = extern struct {
    dwNumPorts: u32,
    dwPortFlags: u32,
};
// --------------------------------------------------------
// Type: L2TP_CONFIG_PARAMS1
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const L2TP_CONFIG_PARAMS1 = extern struct {
    dwNumPorts: u32,
    dwPortFlags: u32,
    dwTunnelConfigParamFlags: u32,
    TunnelConfigParams: L2TP_TUNNEL_CONFIG_PARAMS2,
};
// --------------------------------------------------------
// Type: GRE_CONFIG_PARAMS0
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const GRE_CONFIG_PARAMS0 = extern struct {
    dwNumPorts: u32,
    dwPortFlags: u32,
};
// --------------------------------------------------------
// Type: L2TP_CONFIG_PARAMS0
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const L2TP_CONFIG_PARAMS0 = extern struct {
    dwNumPorts: u32,
    dwPortFlags: u32,
};
// --------------------------------------------------------
// Type: SSTP_CERT_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SSTP_CERT_INFO = extern struct {
    isDefault: BOOL,
    certBlob: CRYPTOAPI_BLOB,
};
// --------------------------------------------------------
// Type: SSTP_CONFIG_PARAMS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SSTP_CONFIG_PARAMS = extern struct {
    dwNumPorts: u32,
    dwPortFlags: u32,
    isUseHttps: BOOL,
    certAlgorithm: u32,
    sstpCertDetails: SSTP_CERT_INFO,
};
// --------------------------------------------------------
// Type: MPRAPI_TUNNEL_CONFIG_PARAMS0
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const MPRAPI_TUNNEL_CONFIG_PARAMS0 = extern struct {
    IkeConfigParams: IKEV2_CONFIG_PARAMS,
    PptpConfigParams: PPTP_CONFIG_PARAMS,
    L2tpConfigParams: L2TP_CONFIG_PARAMS1,
    SstpConfigParams: SSTP_CONFIG_PARAMS,
};
// --------------------------------------------------------
// Type: MPRAPI_TUNNEL_CONFIG_PARAMS1
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const MPRAPI_TUNNEL_CONFIG_PARAMS1 = extern struct {
    IkeConfigParams: IKEV2_CONFIG_PARAMS,
    PptpConfigParams: PPTP_CONFIG_PARAMS,
    L2tpConfigParams: L2TP_CONFIG_PARAMS1,
    SstpConfigParams: SSTP_CONFIG_PARAMS,
    GREConfigParams: GRE_CONFIG_PARAMS0,
};
// --------------------------------------------------------
// Type: MPR_SERVER_EX0
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const MPR_SERVER_EX0 = extern struct {
    Header: MPRAPI_OBJECT_HEADER,
    fLanOnlyMode: u32,
    dwUpTime: u32,
    dwTotalPorts: u32,
    dwPortsInUse: u32,
    Reserved: u32,
    ConfigParams: MPRAPI_TUNNEL_CONFIG_PARAMS0,
};
// --------------------------------------------------------
// Type: MPR_SERVER_EX1
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const MPR_SERVER_EX1 = extern struct {
    Header: MPRAPI_OBJECT_HEADER,
    fLanOnlyMode: u32,
    dwUpTime: u32,
    dwTotalPorts: u32,
    dwPortsInUse: u32,
    Reserved: u32,
    ConfigParams: MPRAPI_TUNNEL_CONFIG_PARAMS1,
};
// --------------------------------------------------------
// Type: MPR_SERVER_SET_CONFIG_EX0
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const MPR_SERVER_SET_CONFIG_EX0 = extern struct {
    Header: MPRAPI_OBJECT_HEADER,
    setConfigForProtocols: u32,
    ConfigParams: MPRAPI_TUNNEL_CONFIG_PARAMS0,
};
// --------------------------------------------------------
// Type: MPR_SERVER_SET_CONFIG_EX1
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const MPR_SERVER_SET_CONFIG_EX1 = extern struct {
    Header: MPRAPI_OBJECT_HEADER,
    setConfigForProtocols: u32,
    ConfigParams: MPRAPI_TUNNEL_CONFIG_PARAMS1,
};
// --------------------------------------------------------
// Type: AUTH_VALIDATION_EX
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const AUTH_VALIDATION_EX = extern struct {
    Header: MPRAPI_OBJECT_HEADER,
    hRasConnection: HANDLE,
    wszUserName: ?[*]u16,
    wszLogonDomain: ?[*]u16,
    AuthInfoSize: u32,
    AuthInfo: ?[*]u8,
};
// --------------------------------------------------------
// Type: RAS_UPDATE_CONNECTION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const RAS_UPDATE_CONNECTION = extern struct {
    Header: MPRAPI_OBJECT_HEADER,
    dwIfIndex: u32,
    wszLocalEndpointAddress: ?[*]u16,
    wszRemoteEndpointAddress: ?[*]u16,
};
// --------------------------------------------------------
// Type: PMPRADMINGETIPADDRESSFORUSER
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PMPRADMINGETIPADDRESSFORUSER = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PMPRADMINRELEASEIPADRESS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PMPRADMINRELEASEIPADRESS = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PMPRADMINGETIPV6ADDRESSFORUSER
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PMPRADMINGETIPV6ADDRESSFORUSER = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PMPRADMINRELEASEIPV6ADDRESSFORUSER
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PMPRADMINRELEASEIPV6ADDRESSFORUSER = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PMPRADMINACCEPTNEWCONNECTION
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PMPRADMINACCEPTNEWCONNECTION = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PMPRADMINACCEPTNEWCONNECTION2
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PMPRADMINACCEPTNEWCONNECTION2 = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PMPRADMINACCEPTNEWCONNECTION3
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PMPRADMINACCEPTNEWCONNECTION3 = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PMPRADMINACCEPTNEWLINK
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PMPRADMINACCEPTNEWLINK = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PMPRADMINCONNECTIONHANGUPNOTIFICATION
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PMPRADMINCONNECTIONHANGUPNOTIFICATION = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PMPRADMINCONNECTIONHANGUPNOTIFICATION2
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PMPRADMINCONNECTIONHANGUPNOTIFICATION2 = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PMPRADMINCONNECTIONHANGUPNOTIFICATION3
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PMPRADMINCONNECTIONHANGUPNOTIFICATION3 = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PMPRADMINLINKHANGUPNOTIFICATION
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PMPRADMINLINKHANGUPNOTIFICATION = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PMPRADMINTERMINATEDLL
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PMPRADMINTERMINATEDLL = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PMPRADMINACCEPTREAUTHENTICATION
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PMPRADMINACCEPTREAUTHENTICATION = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PMPRADMINACCEPTNEWCONNECTIONEX
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PMPRADMINACCEPTNEWCONNECTIONEX = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PMPRADMINACCEPTREAUTHENTICATIONEX
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PMPRADMINACCEPTREAUTHENTICATIONEX = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PMPRADMINACCEPTTUNNELENDPOINTCHANGEEX
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PMPRADMINACCEPTTUNNELENDPOINTCHANGEEX = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PMPRADMINCONNECTIONHANGUPNOTIFICATIONEX
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PMPRADMINCONNECTIONHANGUPNOTIFICATIONEX = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PMPRADMINRASVALIDATEPREAUTHENTICATEDCONNECTIONEX
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PMPRADMINRASVALIDATEPREAUTHENTICATEDCONNECTIONEX = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: MPRAPI_ADMIN_DLL_CALLBACKS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const MPRAPI_ADMIN_DLL_CALLBACKS = extern struct {
    revision: u8,
    lpfnMprAdminGetIpAddressForUser: PMPRADMINGETIPADDRESSFORUSER,
    lpfnMprAdminReleaseIpAddress: PMPRADMINRELEASEIPADRESS,
    lpfnMprAdminGetIpv6AddressForUser: PMPRADMINGETIPV6ADDRESSFORUSER,
    lpfnMprAdminReleaseIpV6AddressForUser: PMPRADMINRELEASEIPV6ADDRESSFORUSER,
    lpfnRasAdminAcceptNewLink: PMPRADMINACCEPTNEWLINK,
    lpfnRasAdminLinkHangupNotification: PMPRADMINLINKHANGUPNOTIFICATION,
    lpfnRasAdminTerminateDll: PMPRADMINTERMINATEDLL,
    lpfnRasAdminAcceptNewConnectionEx: PMPRADMINACCEPTNEWCONNECTIONEX,
    lpfnRasAdminAcceptEndpointChangeEx: PMPRADMINACCEPTTUNNELENDPOINTCHANGEEX,
    lpfnRasAdminAcceptReauthenticationEx: PMPRADMINACCEPTREAUTHENTICATIONEX,
    lpfnRasAdminConnectionHangupNotificationEx: PMPRADMINCONNECTIONHANGUPNOTIFICATIONEX,
    lpfnRASValidatePreAuthenticatedConnectionEx: PMPRADMINRASVALIDATEPREAUTHENTICATEDCONNECTIONEX,
};
// --------------------------------------------------------
// Type: SECURITY_MESSAGE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SECURITY_MESSAGE = extern struct {
    dwMsgId: u32,
    hPort: ?*opaque{},
    dwError: u32,
    UserName: ?[*]i8,
    Domain: ?[*]i8,
};
// --------------------------------------------------------
// Type: RAS_SECURITY_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const RAS_SECURITY_INFO = extern struct {
    LastError: u32,
    BytesReceived: u32,
    DeviceName: ?[*]i8,
};
// --------------------------------------------------------
// Type: RASSECURITYPROC
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const RASSECURITYPROC = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: MGM_IF_ENTRY
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const MGM_IF_ENTRY = extern struct {
    dwIfIndex: u32,
    dwIfNextHopAddr: u32,
    bIGMP: BOOL,
    bIsEnabled: BOOL,
};
// --------------------------------------------------------
// Type: PMGM_RPF_CALLBACK
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PMGM_RPF_CALLBACK = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PMGM_CREATION_ALERT_CALLBACK
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PMGM_CREATION_ALERT_CALLBACK = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PMGM_PRUNE_ALERT_CALLBACK
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PMGM_PRUNE_ALERT_CALLBACK = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PMGM_JOIN_ALERT_CALLBACK
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PMGM_JOIN_ALERT_CALLBACK = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PMGM_WRONG_IF_CALLBACK
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PMGM_WRONG_IF_CALLBACK = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PMGM_LOCAL_JOIN_CALLBACK
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PMGM_LOCAL_JOIN_CALLBACK = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PMGM_LOCAL_LEAVE_CALLBACK
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PMGM_LOCAL_LEAVE_CALLBACK = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PMGM_DISABLE_IGMP_CALLBACK
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PMGM_DISABLE_IGMP_CALLBACK = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PMGM_ENABLE_IGMP_CALLBACK
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PMGM_ENABLE_IGMP_CALLBACK = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: ROUTING_PROTOCOL_CONFIG
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const ROUTING_PROTOCOL_CONFIG = extern struct {
    dwCallbackFlags: u32,
    pfnRpfCallback: PMGM_RPF_CALLBACK,
    pfnCreationAlertCallback: PMGM_CREATION_ALERT_CALLBACK,
    pfnPruneAlertCallback: PMGM_PRUNE_ALERT_CALLBACK,
    pfnJoinAlertCallback: PMGM_JOIN_ALERT_CALLBACK,
    pfnWrongIfCallback: PMGM_WRONG_IF_CALLBACK,
    pfnLocalJoinCallback: PMGM_LOCAL_JOIN_CALLBACK,
    pfnLocalLeaveCallback: PMGM_LOCAL_LEAVE_CALLBACK,
    pfnDisableIgmpCallback: PMGM_DISABLE_IGMP_CALLBACK,
    pfnEnableIgmpCallback: PMGM_ENABLE_IGMP_CALLBACK,
};
// --------------------------------------------------------
// Type: MGM_ENUM_TYPES
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const MGM_ENUM_TYPES = *opaque{
};
// --------------------------------------------------------
// Type: SOURCE_GROUP_ENTRY
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SOURCE_GROUP_ENTRY = extern struct {
    dwSourceAddr: u32,
    dwSourceMask: u32,
    dwGroupAddr: u32,
    dwGroupMask: u32,
};
// --------------------------------------------------------
// Type: RTM_REGN_PROFILE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const RTM_REGN_PROFILE = extern struct {
    MaxNextHopsInRoute: u32,
    MaxHandlesInEnum: u32,
    ViewsSupported: u32,
    NumberOfViews: u32,
};
// --------------------------------------------------------
// Type: RTM_NET_ADDRESS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const RTM_NET_ADDRESS = extern struct {
    AddressFamily: u16,
    NumBits: u16,
    AddrBits: ?[*]u8,
};
// --------------------------------------------------------
// Type: RTM_PREF_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const RTM_PREF_INFO = extern struct {
    Metric: u32,
    Preference: u32,
};
// --------------------------------------------------------
// Type: RTM_NEXTHOP_LIST
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const RTM_NEXTHOP_LIST = extern struct {
    NumNextHops: u16,
    NextHops: ?[*]?*opaque{},
};
// --------------------------------------------------------
// Type: RTM_DEST_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const RTM_DEST_INFO = extern struct {
    DestHandle: ?*opaque{},
    DestAddress: RTM_NET_ADDRESS,
    LastChanged: FILETIME,
    BelongsToViews: u32,
    NumberOfViews: u32,
    ViewInfo: ?[*]_Anonymous_e__Struct,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Struct
    // TypeLayoutAttr: sequential
    // TODO: I think this is a struct, but not sure at this point, assuming it is for now
    pub const _Anonymous_e__Struct = extern struct {
        ViewId: i32,
        NumRoutes: u32,
        Route: ?*opaque{},
        Owner: ?*opaque{},
        DestFlags: u32,
        HoldRoute: ?*opaque{},
    };
};
// --------------------------------------------------------
// Type: RTM_ROUTE_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const RTM_ROUTE_INFO = extern struct {
    DestHandle: ?*opaque{},
    RouteOwner: ?*opaque{},
    Neighbour: ?*opaque{},
    State: u8,
    Flags1: u8,
    Flags: u16,
    PrefInfo: RTM_PREF_INFO,
    BelongsToViews: u32,
    EntitySpecificInfo: ?*opaque{},
    NextHopsList: RTM_NEXTHOP_LIST,
};
// --------------------------------------------------------
// Type: RTM_NEXTHOP_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const RTM_NEXTHOP_INFO = extern struct {
    NextHopAddress: RTM_NET_ADDRESS,
    NextHopOwner: ?*opaque{},
    InterfaceIndex: u32,
    State: u16,
    Flags: u16,
    EntitySpecificInfo: ?*opaque{},
    RemoteNextHop: ?*opaque{},
};
// --------------------------------------------------------
// Type: RTM_ENTITY_ID
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const RTM_ENTITY_ID = extern struct {
    Anonymous: _Anonymous_e__Union,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
        // --------------------------------------------------------
        // Type: _Anonymous_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _Anonymous_e__Struct = extern struct {
            EntityProtocolId: u32,
            EntityInstanceId: u32,
        };
    };
};
// --------------------------------------------------------
// Type: RTM_ENTITY_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const RTM_ENTITY_INFO = extern struct {
    RtmInstanceId: u16,
    AddressFamily: u16,
    EntityId: RTM_ENTITY_ID,
};
// --------------------------------------------------------
// Type: RTM_EVENT_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const RTM_EVENT_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: _EVENT_CALLBACK
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const _EVENT_CALLBACK = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: RTM_EVENT_CALLBACK
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const RTM_EVENT_CALLBACK = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PRTM_EVENT_CALLBACK
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PRTM_EVENT_CALLBACK = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: RTM_ENTITY_METHOD_INPUT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const RTM_ENTITY_METHOD_INPUT = extern struct {
    MethodType: u32,
    InputSize: u32,
    InputData: ?[*]u8,
};
// --------------------------------------------------------
// Type: RTM_ENTITY_METHOD_OUTPUT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const RTM_ENTITY_METHOD_OUTPUT = extern struct {
    MethodType: u32,
    MethodStatus: u32,
    OutputSize: u32,
    OutputData: ?[*]u8,
};
// --------------------------------------------------------
// Type: _ENTITY_METHOD
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const _ENTITY_METHOD = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: RTM_ENTITY_EXPORT_METHOD
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const RTM_ENTITY_EXPORT_METHOD = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PRTM_ENTITY_EXPORT_METHOD
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PRTM_ENTITY_EXPORT_METHOD = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: RTM_ENTITY_EXPORT_METHODS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const RTM_ENTITY_EXPORT_METHODS = extern struct {
    NumMethods: u32,
    Methods: ?[*]?*opaque{},
};

//
// functions
//

// set_last_errror=False (can and should we use this?)
pub extern "RASAPI32" fn RasDialA(
    param0: ?*tagRASDIALEXTENSIONS,
    param1: ?*i8,
    param2: ?*tagRASDIALPARAMSA,
    param3: u32,
    param4: ?*opaque{},
    param5: ?*?*HRASCONN__,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "RASAPI32" fn RasDialW(
    param0: ?*tagRASDIALEXTENSIONS,
    param1: ?*u16,
    param2: ?*tagRASDIALPARAMSW,
    param3: u32,
    param4: ?*opaque{},
    param5: ?*?*HRASCONN__,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "RASAPI32" fn RasEnumConnectionsA(
    param0: ?*tagRASCONNA,
    param1: ?*u32,
    param2: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "RASAPI32" fn RasEnumConnectionsW(
    param0: ?*tagRASCONNW,
    param1: ?*u32,
    param2: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "RASAPI32" fn RasEnumEntriesA(
    param0: ?*i8,
    param1: ?*i8,
    param2: ?*tagRASENTRYNAMEA,
    param3: ?*u32,
    param4: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "RASAPI32" fn RasEnumEntriesW(
    param0: ?*u16,
    param1: ?*u16,
    param2: ?*tagRASENTRYNAMEW,
    param3: ?*u32,
    param4: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "RASAPI32" fn RasGetConnectStatusA(
    param0: ?*HRASCONN__,
    param1: ?*tagRASCONNSTATUSA,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "RASAPI32" fn RasGetConnectStatusW(
    param0: ?*HRASCONN__,
    param1: ?*tagRASCONNSTATUSW,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "RASAPI32" fn RasGetErrorStringA(
    ResourceId: u32,
    lpszString: ?*i8,
    InBufSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "RASAPI32" fn RasGetErrorStringW(
    ResourceId: u32,
    lpszString: ?*u16,
    InBufSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "RASAPI32" fn RasHangUpA(
    param0: ?*HRASCONN__,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "RASAPI32" fn RasHangUpW(
    param0: ?*HRASCONN__,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "RASAPI32" fn RasGetProjectionInfoA(
    param0: ?*HRASCONN__,
    param1: tagRASPROJECTION,
    param2: ?*opaque{},
    param3: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "RASAPI32" fn RasGetProjectionInfoW(
    param0: ?*HRASCONN__,
    param1: tagRASPROJECTION,
    param2: ?*opaque{},
    param3: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "RASAPI32" fn RasCreatePhonebookEntryA(
    param0: HWND,
    param1: ?*i8,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "RASAPI32" fn RasCreatePhonebookEntryW(
    param0: HWND,
    param1: ?*u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "RASAPI32" fn RasEditPhonebookEntryA(
    param0: HWND,
    param1: ?*i8,
    param2: ?*i8,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "RASAPI32" fn RasEditPhonebookEntryW(
    param0: HWND,
    param1: ?*u16,
    param2: ?*u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "RASAPI32" fn RasSetEntryDialParamsA(
    param0: ?*i8,
    param1: ?*tagRASDIALPARAMSA,
    param2: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "RASAPI32" fn RasSetEntryDialParamsW(
    param0: ?*u16,
    param1: ?*tagRASDIALPARAMSW,
    param2: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "RASAPI32" fn RasGetEntryDialParamsA(
    param0: ?*i8,
    param1: ?*tagRASDIALPARAMSA,
    param2: ?*i32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "RASAPI32" fn RasGetEntryDialParamsW(
    param0: ?*u16,
    param1: ?*tagRASDIALPARAMSW,
    param2: ?*i32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "RASAPI32" fn RasEnumDevicesA(
    param0: ?*tagRASDEVINFOA,
    param1: ?*u32,
    param2: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "RASAPI32" fn RasEnumDevicesW(
    param0: ?*tagRASDEVINFOW,
    param1: ?*u32,
    param2: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "RASAPI32" fn RasGetCountryInfoA(
    param0: ?*RASCTRYINFO,
    param1: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "RASAPI32" fn RasGetCountryInfoW(
    param0: ?*RASCTRYINFO,
    param1: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "RASAPI32" fn RasGetEntryPropertiesA(
    param0: ?*i8,
    param1: ?*i8,
    param2: ?*tagRASENTRYA,
    param3: ?*u32,
    param4: ?*u8,
    param5: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "RASAPI32" fn RasGetEntryPropertiesW(
    param0: ?*u16,
    param1: ?*u16,
    param2: ?*tagRASENTRYW,
    param3: ?*u32,
    param4: ?*u8,
    param5: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "RASAPI32" fn RasSetEntryPropertiesA(
    param0: ?*i8,
    param1: ?*i8,
    param2: ?*tagRASENTRYA,
    param3: u32,
    param4: ?*u8,
    param5: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "RASAPI32" fn RasSetEntryPropertiesW(
    param0: ?*u16,
    param1: ?*u16,
    param2: ?*tagRASENTRYW,
    param3: u32,
    param4: ?*u8,
    param5: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "RASAPI32" fn RasRenameEntryA(
    param0: ?*i8,
    param1: ?*i8,
    param2: ?*i8,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "RASAPI32" fn RasRenameEntryW(
    param0: ?*u16,
    param1: ?*u16,
    param2: ?*u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "RASAPI32" fn RasDeleteEntryA(
    param0: ?*i8,
    param1: ?*i8,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "RASAPI32" fn RasDeleteEntryW(
    param0: ?*u16,
    param1: ?*u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "RASAPI32" fn RasValidateEntryNameA(
    param0: ?*i8,
    param1: ?*i8,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "RASAPI32" fn RasValidateEntryNameW(
    param0: ?*u16,
    param1: ?*u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "RASAPI32" fn RasConnectionNotificationA(
    param0: ?*HRASCONN__,
    param1: HANDLE,
    param2: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "RASAPI32" fn RasConnectionNotificationW(
    param0: ?*HRASCONN__,
    param1: HANDLE,
    param2: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "RASAPI32" fn RasGetSubEntryHandleA(
    param0: ?*HRASCONN__,
    param1: u32,
    param2: ?*?*HRASCONN__,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "RASAPI32" fn RasGetSubEntryHandleW(
    param0: ?*HRASCONN__,
    param1: u32,
    param2: ?*?*HRASCONN__,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "RASAPI32" fn RasGetCredentialsA(
    param0: ?*i8,
    param1: ?*i8,
    param2: ?*tagRASCREDENTIALSA,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "RASAPI32" fn RasGetCredentialsW(
    param0: ?*u16,
    param1: ?*u16,
    param2: ?*tagRASCREDENTIALSW,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "RASAPI32" fn RasSetCredentialsA(
    param0: ?*i8,
    param1: ?*i8,
    param2: ?*tagRASCREDENTIALSA,
    param3: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "RASAPI32" fn RasSetCredentialsW(
    param0: ?*u16,
    param1: ?*u16,
    param2: ?*tagRASCREDENTIALSW,
    param3: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "RASAPI32" fn RasGetSubEntryPropertiesA(
    param0: ?*i8,
    param1: ?*i8,
    param2: u32,
    param3: ?*tagRASSUBENTRYA,
    param4: ?*u32,
    param5: ?*u8,
    param6: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "RASAPI32" fn RasGetSubEntryPropertiesW(
    param0: ?*u16,
    param1: ?*u16,
    param2: u32,
    param3: ?*tagRASSUBENTRYW,
    param4: ?*u32,
    param5: ?*u8,
    param6: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "RASAPI32" fn RasSetSubEntryPropertiesA(
    param0: ?*i8,
    param1: ?*i8,
    param2: u32,
    param3: ?*tagRASSUBENTRYA,
    param4: u32,
    param5: ?*u8,
    param6: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "RASAPI32" fn RasSetSubEntryPropertiesW(
    param0: ?*u16,
    param1: ?*u16,
    param2: u32,
    param3: ?*tagRASSUBENTRYW,
    param4: u32,
    param5: ?*u8,
    param6: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "RASAPI32" fn RasGetAutodialAddressA(
    param0: ?*i8,
    param1: ?*u32,
    param2: ?*tagRASAUTODIALENTRYA,
    param3: ?*u32,
    param4: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "RASAPI32" fn RasGetAutodialAddressW(
    param0: ?*u16,
    param1: ?*u32,
    param2: ?*tagRASAUTODIALENTRYW,
    param3: ?*u32,
    param4: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "RASAPI32" fn RasSetAutodialAddressA(
    param0: ?*i8,
    param1: u32,
    param2: ?*tagRASAUTODIALENTRYA,
    param3: u32,
    param4: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "RASAPI32" fn RasSetAutodialAddressW(
    param0: ?*u16,
    param1: u32,
    param2: ?*tagRASAUTODIALENTRYW,
    param3: u32,
    param4: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "RASAPI32" fn RasEnumAutodialAddressesA(
    lppRasAutodialAddresses: ?*?*i8,
    lpdwcbRasAutodialAddresses: ?*u32,
    lpdwcRasAutodialAddresses: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "RASAPI32" fn RasEnumAutodialAddressesW(
    lppRasAutodialAddresses: ?*?*u16,
    lpdwcbRasAutodialAddresses: ?*u32,
    lpdwcRasAutodialAddresses: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "RASAPI32" fn RasGetAutodialEnableA(
    param0: u32,
    param1: ?*i32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "RASAPI32" fn RasGetAutodialEnableW(
    param0: u32,
    param1: ?*i32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "RASAPI32" fn RasSetAutodialEnableA(
    param0: u32,
    param1: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "RASAPI32" fn RasSetAutodialEnableW(
    param0: u32,
    param1: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "RASAPI32" fn RasGetAutodialParamA(
    param0: u32,
    param1: ?*opaque{},
    param2: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "RASAPI32" fn RasGetAutodialParamW(
    param0: u32,
    param1: ?*opaque{},
    param2: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "RASAPI32" fn RasSetAutodialParamA(
    param0: u32,
    param1: ?*opaque{},
    param2: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "RASAPI32" fn RasSetAutodialParamW(
    param0: u32,
    param1: ?*opaque{},
    param2: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "RASAPI32" fn RasGetPCscf(
    lpszPCscf: ?*u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "RASAPI32" fn RasInvokeEapUI(
    param0: ?*HRASCONN__,
    param1: u32,
    param2: ?*tagRASDIALEXTENSIONS,
    param3: HWND,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "RASAPI32" fn RasGetLinkStatistics(
    hRasConn: ?*HRASCONN__,
    dwSubEntry: u32,
    lpStatistics: ?*RAS_STATS,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "RASAPI32" fn RasGetConnectionStatistics(
    hRasConn: ?*HRASCONN__,
    lpStatistics: ?*RAS_STATS,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "RASAPI32" fn RasClearLinkStatistics(
    hRasConn: ?*HRASCONN__,
    dwSubEntry: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "RASAPI32" fn RasClearConnectionStatistics(
    hRasConn: ?*HRASCONN__,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "RASAPI32" fn RasGetEapUserDataA(
    hToken: HANDLE,
    pszPhonebook: ?*i8,
    pszEntry: ?*i8,
    pbEapData: ?*u8,
    pdwSizeofEapData: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "RASAPI32" fn RasGetEapUserDataW(
    hToken: HANDLE,
    pszPhonebook: ?*u16,
    pszEntry: ?*u16,
    pbEapData: ?*u8,
    pdwSizeofEapData: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "RASAPI32" fn RasSetEapUserDataA(
    hToken: HANDLE,
    pszPhonebook: ?*i8,
    pszEntry: ?*i8,
    pbEapData: ?*u8,
    dwSizeofEapData: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "RASAPI32" fn RasSetEapUserDataW(
    hToken: HANDLE,
    pszPhonebook: ?*u16,
    pszEntry: ?*u16,
    pbEapData: ?*u8,
    dwSizeofEapData: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "RASAPI32" fn RasGetCustomAuthDataA(
    pszPhonebook: ?*i8,
    pszEntry: ?*i8,
    pbCustomAuthData: ?*u8,
    pdwSizeofCustomAuthData: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "RASAPI32" fn RasGetCustomAuthDataW(
    pszPhonebook: ?*u16,
    pszEntry: ?*u16,
    pbCustomAuthData: ?*u8,
    pdwSizeofCustomAuthData: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "RASAPI32" fn RasSetCustomAuthDataA(
    pszPhonebook: ?*i8,
    pszEntry: ?*i8,
    pbCustomAuthData: ?*u8,
    dwSizeofCustomAuthData: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "RASAPI32" fn RasSetCustomAuthDataW(
    pszPhonebook: ?*u16,
    pszEntry: ?*u16,
    pbCustomAuthData: ?*u8,
    dwSizeofCustomAuthData: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "RASAPI32" fn RasGetEapUserIdentityW(
    pszPhonebook: ?*u16,
    pszEntry: ?*u16,
    dwFlags: u32,
    hwnd: HWND,
    ppRasEapUserIdentity: ?*?*tagRASEAPUSERIDENTITYW,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "RASAPI32" fn RasGetEapUserIdentityA(
    pszPhonebook: ?*i8,
    pszEntry: ?*i8,
    dwFlags: u32,
    hwnd: HWND,
    ppRasEapUserIdentity: ?*?*tagRASEAPUSERIDENTITYA,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "RASAPI32" fn RasFreeEapUserIdentityW(
    pRasEapUserIdentity: ?*tagRASEAPUSERIDENTITYW,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "RASAPI32" fn RasFreeEapUserIdentityA(
    pRasEapUserIdentity: ?*tagRASEAPUSERIDENTITYA,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "RASAPI32" fn RasDeleteSubEntryA(
    pszPhonebook: ?*i8,
    pszEntry: ?*i8,
    dwSubentryId: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "RASAPI32" fn RasDeleteSubEntryW(
    pszPhonebook: ?*u16,
    pszEntry: ?*u16,
    dwSubEntryId: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "RASAPI32" fn RasUpdateConnection(
    hrasconn: ?*HRASCONN__,
    lprasupdateconn: ?*tagRASUPDATECONN,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "RASAPI32" fn RasGetProjectionInfoEx(
    hrasconn: ?*HRASCONN__,
    pRasProjection: ?*RAS_PROJECTION_INFO,
    lpdwSize: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "RASDLG" fn RasPhonebookDlgA(
    lpszPhonebook: ?*i8,
    lpszEntry: ?*i8,
    lpInfo: ?*tagRASPBDLGA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "RASDLG" fn RasPhonebookDlgW(
    lpszPhonebook: ?*u16,
    lpszEntry: ?*u16,
    lpInfo: ?*tagRASPBDLGW,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "RASDLG" fn RasEntryDlgA(
    lpszPhonebook: ?*i8,
    lpszEntry: ?*i8,
    lpInfo: ?*tagRASENTRYDLGA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "RASDLG" fn RasEntryDlgW(
    lpszPhonebook: ?*u16,
    lpszEntry: ?*u16,
    lpInfo: ?*tagRASENTRYDLGW,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "RASDLG" fn RasDialDlgA(
    lpszPhonebook: ?*i8,
    lpszEntry: ?*i8,
    lpszPhoneNumber: ?*i8,
    lpInfo: ?*tagRASDIALDLG,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "RASDLG" fn RasDialDlgW(
    lpszPhonebook: ?*u16,
    lpszEntry: ?*u16,
    lpszPhoneNumber: ?*u16,
    lpInfo: ?*tagRASDIALDLG,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "MPRAPI" fn MprAdminConnectionEnumEx(
    hRasServer: ?*opaque{},
    pObjectHeader: ?*MPRAPI_OBJECT_HEADER,
    dwPreferedMaxLen: u32,
    lpdwEntriesRead: ?*u32,
    lpdwTotalEntries: ?*u32,
    ppRasConn: ?*?*RAS_CONNECTION_EX,
    lpdwResumeHandle: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MPRAPI" fn MprAdminConnectionGetInfoEx(
    hRasServer: ?*opaque{},
    hRasConnection: HANDLE,
    pRasConnection: ?*RAS_CONNECTION_EX,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MPRAPI" fn MprAdminServerGetInfoEx(
    hMprServer: ?*opaque{},
    pServerInfo: ?*MPR_SERVER_EX1,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MPRAPI" fn MprAdminServerSetInfoEx(
    hMprServer: ?*opaque{},
    pServerInfo: ?*MPR_SERVER_SET_CONFIG_EX1,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MPRAPI" fn MprConfigServerGetInfoEx(
    hMprConfig: HANDLE,
    pServerInfo: ?*MPR_SERVER_EX1,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MPRAPI" fn MprConfigServerSetInfoEx(
    hMprConfig: HANDLE,
    pSetServerConfig: ?*MPR_SERVER_SET_CONFIG_EX1,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MPRAPI" fn MprAdminUpdateConnection(
    hRasServer: ?*opaque{},
    hRasConnection: HANDLE,
    pRasUpdateConnection: ?*RAS_UPDATE_CONNECTION,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MPRAPI" fn MprAdminIsServiceInitialized(
    lpwsServerName: ?*u16,
    fIsServiceInitialized: ?*i32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MPRAPI" fn MprAdminInterfaceSetCustomInfoEx(
    hMprServer: ?*opaque{},
    hInterface: HANDLE,
    pCustomInfo: ?*MPR_IF_CUSTOMINFOEX2,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MPRAPI" fn MprAdminInterfaceGetCustomInfoEx(
    hMprServer: ?*opaque{},
    hInterface: HANDLE,
    pCustomInfo: ?*MPR_IF_CUSTOMINFOEX2,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MPRAPI" fn MprConfigInterfaceGetCustomInfoEx(
    hMprConfig: HANDLE,
    hRouterInterface: HANDLE,
    pCustomInfo: ?*MPR_IF_CUSTOMINFOEX2,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MPRAPI" fn MprConfigInterfaceSetCustomInfoEx(
    hMprConfig: HANDLE,
    hRouterInterface: HANDLE,
    pCustomInfo: ?*MPR_IF_CUSTOMINFOEX2,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MPRAPI" fn MprAdminConnectionEnum(
    hRasServer: ?*opaque{},
    dwLevel: u32,
    lplpbBuffer: ?*?*u8,
    dwPrefMaxLen: u32,
    lpdwEntriesRead: ?*u32,
    lpdwTotalEntries: ?*u32,
    lpdwResumeHandle: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MPRAPI" fn MprAdminPortEnum(
    hRasServer: ?*opaque{},
    dwLevel: u32,
    hRasConnection: HANDLE,
    lplpbBuffer: ?*?*u8,
    dwPrefMaxLen: u32,
    lpdwEntriesRead: ?*u32,
    lpdwTotalEntries: ?*u32,
    lpdwResumeHandle: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MPRAPI" fn MprAdminConnectionGetInfo(
    hRasServer: ?*opaque{},
    dwLevel: u32,
    hRasConnection: HANDLE,
    lplpbBuffer: ?*?*u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MPRAPI" fn MprAdminPortGetInfo(
    hRasServer: ?*opaque{},
    dwLevel: u32,
    hPort: HANDLE,
    lplpbBuffer: ?*?*u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MPRAPI" fn MprAdminConnectionClearStats(
    hRasServer: ?*opaque{},
    hRasConnection: HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MPRAPI" fn MprAdminPortClearStats(
    hRasServer: ?*opaque{},
    hPort: HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MPRAPI" fn MprAdminPortReset(
    hRasServer: ?*opaque{},
    hPort: HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MPRAPI" fn MprAdminPortDisconnect(
    hRasServer: ?*opaque{},
    hPort: HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MPRAPI" fn MprAdminConnectionRemoveQuarantine(
    hRasServer: HANDLE,
    hRasConnection: HANDLE,
    fIsIpAddress: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MPRAPI" fn MprAdminUserGetInfo(
    lpszServer: ?*u16,
    lpszUser: ?*u16,
    dwLevel: u32,
    lpbBuffer: ?*u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MPRAPI" fn MprAdminUserSetInfo(
    lpszServer: ?*u16,
    lpszUser: ?*u16,
    dwLevel: u32,
    lpbBuffer: ?*u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MPRAPI" fn MprAdminSendUserMessage(
    hMprServer: ?*opaque{},
    hConnection: HANDLE,
    lpwszMessage: ?*u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MPRAPI" fn MprAdminGetPDCServer(
    lpszDomain: ?*u16,
    lpszServer: ?*u16,
    lpszPDCServer: ?*u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MPRAPI" fn MprAdminIsServiceRunning(
    lpwsServerName: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "MPRAPI" fn MprAdminServerConnect(
    lpwsServerName: ?*u16,
    phMprServer: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MPRAPI" fn MprAdminServerDisconnect(
    hMprServer: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "MPRAPI" fn MprAdminServerGetCredentials(
    hMprServer: ?*opaque{},
    dwLevel: u32,
    lplpbBuffer: ?*?*u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MPRAPI" fn MprAdminServerSetCredentials(
    hMprServer: ?*opaque{},
    dwLevel: u32,
    lpbBuffer: ?*u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MPRAPI" fn MprAdminBufferFree(
    pBuffer: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MPRAPI" fn MprAdminGetErrorString(
    dwError: u32,
    lplpwsErrorString: ?*?*u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MPRAPI" fn MprAdminServerGetInfo(
    hMprServer: ?*opaque{},
    dwLevel: u32,
    lplpbBuffer: ?*?*u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MPRAPI" fn MprAdminServerSetInfo(
    hMprServer: ?*opaque{},
    dwLevel: u32,
    lpbBuffer: ?*u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MPRAPI" fn MprAdminEstablishDomainRasServer(
    pszDomain: ?*u16,
    pszMachine: ?*u16,
    bEnable: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MPRAPI" fn MprAdminIsDomainRasServer(
    pszDomain: ?*u16,
    pszMachine: ?*u16,
    pbIsRasServer: ?*i32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MPRAPI" fn MprAdminTransportCreate(
    hMprServer: ?*opaque{},
    dwTransportId: u32,
    lpwsTransportName: ?*u16,
    pGlobalInfo: ?*u8,
    dwGlobalInfoSize: u32,
    pClientInterfaceInfo: ?*u8,
    dwClientInterfaceInfoSize: u32,
    lpwsDLLPath: ?*u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MPRAPI" fn MprAdminTransportSetInfo(
    hMprServer: ?*opaque{},
    dwTransportId: u32,
    pGlobalInfo: ?*u8,
    dwGlobalInfoSize: u32,
    pClientInterfaceInfo: ?*u8,
    dwClientInterfaceInfoSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MPRAPI" fn MprAdminTransportGetInfo(
    hMprServer: ?*opaque{},
    dwTransportId: u32,
    ppGlobalInfo: ?*?*u8,
    lpdwGlobalInfoSize: ?*u32,
    ppClientInterfaceInfo: ?*?*u8,
    lpdwClientInterfaceInfoSize: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MPRAPI" fn MprAdminDeviceEnum(
    hMprServer: ?*opaque{},
    dwLevel: u32,
    lplpbBuffer: ?*?*u8,
    lpdwTotalEntries: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MPRAPI" fn MprAdminInterfaceGetHandle(
    hMprServer: ?*opaque{},
    lpwsInterfaceName: ?*u16,
    phInterface: ?*HANDLE,
    fIncludeClientInterfaces: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MPRAPI" fn MprAdminInterfaceCreate(
    hMprServer: ?*opaque{},
    dwLevel: u32,
    lpbBuffer: ?*u8,
    phInterface: ?*HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MPRAPI" fn MprAdminInterfaceGetInfo(
    hMprServer: ?*opaque{},
    hInterface: HANDLE,
    dwLevel: u32,
    lplpbBuffer: ?*?*u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MPRAPI" fn MprAdminInterfaceSetInfo(
    hMprServer: ?*opaque{},
    hInterface: HANDLE,
    dwLevel: u32,
    lpbBuffer: ?*u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MPRAPI" fn MprAdminInterfaceDelete(
    hMprServer: ?*opaque{},
    hInterface: HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MPRAPI" fn MprAdminInterfaceDeviceGetInfo(
    hMprServer: ?*opaque{},
    hInterface: HANDLE,
    dwIndex: u32,
    dwLevel: u32,
    lplpBuffer: ?*?*u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MPRAPI" fn MprAdminInterfaceDeviceSetInfo(
    hMprServer: ?*opaque{},
    hInterface: HANDLE,
    dwIndex: u32,
    dwLevel: u32,
    lpbBuffer: ?*u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MPRAPI" fn MprAdminInterfaceTransportRemove(
    hMprServer: ?*opaque{},
    hInterface: HANDLE,
    dwTransportId: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MPRAPI" fn MprAdminInterfaceTransportAdd(
    hMprServer: ?*opaque{},
    hInterface: HANDLE,
    dwTransportId: u32,
    pInterfaceInfo: ?*u8,
    dwInterfaceInfoSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MPRAPI" fn MprAdminInterfaceTransportGetInfo(
    hMprServer: ?*opaque{},
    hInterface: HANDLE,
    dwTransportId: u32,
    ppInterfaceInfo: ?*?*u8,
    lpdwInterfaceInfoSize: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MPRAPI" fn MprAdminInterfaceTransportSetInfo(
    hMprServer: ?*opaque{},
    hInterface: HANDLE,
    dwTransportId: u32,
    pInterfaceInfo: ?*u8,
    dwInterfaceInfoSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MPRAPI" fn MprAdminInterfaceEnum(
    hMprServer: ?*opaque{},
    dwLevel: u32,
    lplpbBuffer: ?*?*u8,
    dwPrefMaxLen: u32,
    lpdwEntriesRead: ?*u32,
    lpdwTotalEntries: ?*u32,
    lpdwResumeHandle: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MPRAPI" fn MprAdminInterfaceSetCredentials(
    lpwsServer: ?*u16,
    lpwsInterfaceName: ?*u16,
    lpwsUserName: ?*u16,
    lpwsDomainName: ?*u16,
    lpwsPassword: ?*u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MPRAPI" fn MprAdminInterfaceGetCredentials(
    lpwsServer: ?*u16,
    lpwsInterfaceName: ?*u16,
    lpwsUserName: ?*u16,
    lpwsPassword: ?*u16,
    lpwsDomainName: ?*u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MPRAPI" fn MprAdminInterfaceSetCredentialsEx(
    hMprServer: ?*opaque{},
    hInterface: HANDLE,
    dwLevel: u32,
    lpbBuffer: ?*u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MPRAPI" fn MprAdminInterfaceGetCredentialsEx(
    hMprServer: ?*opaque{},
    hInterface: HANDLE,
    dwLevel: u32,
    lplpbBuffer: ?*?*u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MPRAPI" fn MprAdminInterfaceConnect(
    hMprServer: ?*opaque{},
    hInterface: HANDLE,
    hEvent: HANDLE,
    fSynchronous: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MPRAPI" fn MprAdminInterfaceDisconnect(
    hMprServer: ?*opaque{},
    hInterface: HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MPRAPI" fn MprAdminInterfaceUpdateRoutes(
    hMprServer: ?*opaque{},
    hInterface: HANDLE,
    dwProtocolId: u32,
    hEvent: HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MPRAPI" fn MprAdminInterfaceQueryUpdateResult(
    hMprServer: ?*opaque{},
    hInterface: HANDLE,
    dwProtocolId: u32,
    lpdwUpdateResult: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MPRAPI" fn MprAdminInterfaceUpdatePhonebookInfo(
    hMprServer: ?*opaque{},
    hInterface: HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MPRAPI" fn MprAdminRegisterConnectionNotification(
    hMprServer: ?*opaque{},
    hEventNotification: HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MPRAPI" fn MprAdminDeregisterConnectionNotification(
    hMprServer: ?*opaque{},
    hEventNotification: HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MPRAPI" fn MprAdminMIBServerConnect(
    lpwsServerName: ?*u16,
    phMibServer: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MPRAPI" fn MprAdminMIBServerDisconnect(
    hMibServer: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "MPRAPI" fn MprAdminMIBEntryCreate(
    hMibServer: ?*opaque{},
    dwPid: u32,
    dwRoutingPid: u32,
    lpEntry: ?*opaque{},
    dwEntrySize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MPRAPI" fn MprAdminMIBEntryDelete(
    hMibServer: ?*opaque{},
    dwProtocolId: u32,
    dwRoutingPid: u32,
    lpEntry: ?*opaque{},
    dwEntrySize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MPRAPI" fn MprAdminMIBEntrySet(
    hMibServer: ?*opaque{},
    dwProtocolId: u32,
    dwRoutingPid: u32,
    lpEntry: ?*opaque{},
    dwEntrySize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MPRAPI" fn MprAdminMIBEntryGet(
    hMibServer: ?*opaque{},
    dwProtocolId: u32,
    dwRoutingPid: u32,
    lpInEntry: ?*opaque{},
    dwInEntrySize: u32,
    lplpOutEntry: ?*?*opaque{},
    lpOutEntrySize: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MPRAPI" fn MprAdminMIBEntryGetFirst(
    hMibServer: ?*opaque{},
    dwProtocolId: u32,
    dwRoutingPid: u32,
    lpInEntry: ?*opaque{},
    dwInEntrySize: u32,
    lplpOutEntry: ?*?*opaque{},
    lpOutEntrySize: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MPRAPI" fn MprAdminMIBEntryGetNext(
    hMibServer: ?*opaque{},
    dwProtocolId: u32,
    dwRoutingPid: u32,
    lpInEntry: ?*opaque{},
    dwInEntrySize: u32,
    lplpOutEntry: ?*?*opaque{},
    lpOutEntrySize: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MPRAPI" fn MprAdminMIBBufferFree(
    pBuffer: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MPRAPI" fn MprConfigServerInstall(
    dwLevel: u32,
    pBuffer: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MPRAPI" fn MprConfigServerConnect(
    lpwsServerName: ?*u16,
    phMprConfig: ?*HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MPRAPI" fn MprConfigServerDisconnect(
    hMprConfig: HANDLE,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "MPRAPI" fn MprConfigServerRefresh(
    hMprConfig: HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MPRAPI" fn MprConfigBufferFree(
    pBuffer: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MPRAPI" fn MprConfigServerGetInfo(
    hMprConfig: HANDLE,
    dwLevel: u32,
    lplpbBuffer: ?*?*u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MPRAPI" fn MprConfigServerSetInfo(
    hMprServer: ?*opaque{},
    dwLevel: u32,
    lpbBuffer: ?*u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MPRAPI" fn MprConfigServerBackup(
    hMprConfig: HANDLE,
    lpwsPath: ?*u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MPRAPI" fn MprConfigServerRestore(
    hMprConfig: HANDLE,
    lpwsPath: ?*u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MPRAPI" fn MprConfigTransportCreate(
    hMprConfig: HANDLE,
    dwTransportId: u32,
    lpwsTransportName: ?*u16,
    pGlobalInfo: ?*u8,
    dwGlobalInfoSize: u32,
    pClientInterfaceInfo: ?*u8,
    dwClientInterfaceInfoSize: u32,
    lpwsDLLPath: ?*u16,
    phRouterTransport: ?*HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MPRAPI" fn MprConfigTransportDelete(
    hMprConfig: HANDLE,
    hRouterTransport: HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MPRAPI" fn MprConfigTransportGetHandle(
    hMprConfig: HANDLE,
    dwTransportId: u32,
    phRouterTransport: ?*HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MPRAPI" fn MprConfigTransportSetInfo(
    hMprConfig: HANDLE,
    hRouterTransport: HANDLE,
    pGlobalInfo: ?*u8,
    dwGlobalInfoSize: u32,
    pClientInterfaceInfo: ?*u8,
    dwClientInterfaceInfoSize: u32,
    lpwsDLLPath: ?*u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MPRAPI" fn MprConfigTransportGetInfo(
    hMprConfig: HANDLE,
    hRouterTransport: HANDLE,
    ppGlobalInfo: ?*?*u8,
    lpdwGlobalInfoSize: ?*u32,
    ppClientInterfaceInfo: ?*?*u8,
    lpdwClientInterfaceInfoSize: ?*u32,
    lplpwsDLLPath: ?*?*u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MPRAPI" fn MprConfigTransportEnum(
    hMprConfig: HANDLE,
    dwLevel: u32,
    lplpBuffer: ?*?*u8,
    dwPrefMaxLen: u32,
    lpdwEntriesRead: ?*u32,
    lpdwTotalEntries: ?*u32,
    lpdwResumeHandle: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MPRAPI" fn MprConfigInterfaceCreate(
    hMprConfig: HANDLE,
    dwLevel: u32,
    lpbBuffer: ?*u8,
    phRouterInterface: ?*HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MPRAPI" fn MprConfigInterfaceDelete(
    hMprConfig: HANDLE,
    hRouterInterface: HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MPRAPI" fn MprConfigInterfaceGetHandle(
    hMprConfig: HANDLE,
    lpwsInterfaceName: ?*u16,
    phRouterInterface: ?*HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MPRAPI" fn MprConfigInterfaceGetInfo(
    hMprConfig: HANDLE,
    hRouterInterface: HANDLE,
    dwLevel: u32,
    lplpBuffer: ?*?*u8,
    lpdwBufferSize: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MPRAPI" fn MprConfigInterfaceSetInfo(
    hMprConfig: HANDLE,
    hRouterInterface: HANDLE,
    dwLevel: u32,
    lpbBuffer: ?*u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MPRAPI" fn MprConfigInterfaceEnum(
    hMprConfig: HANDLE,
    dwLevel: u32,
    lplpBuffer: ?*?*u8,
    dwPrefMaxLen: u32,
    lpdwEntriesRead: ?*u32,
    lpdwTotalEntries: ?*u32,
    lpdwResumeHandle: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MPRAPI" fn MprConfigInterfaceTransportAdd(
    hMprConfig: HANDLE,
    hRouterInterface: HANDLE,
    dwTransportId: u32,
    lpwsTransportName: ?*u16,
    pInterfaceInfo: ?*u8,
    dwInterfaceInfoSize: u32,
    phRouterIfTransport: ?*HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MPRAPI" fn MprConfigInterfaceTransportRemove(
    hMprConfig: HANDLE,
    hRouterInterface: HANDLE,
    hRouterIfTransport: HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MPRAPI" fn MprConfigInterfaceTransportGetHandle(
    hMprConfig: HANDLE,
    hRouterInterface: HANDLE,
    dwTransportId: u32,
    phRouterIfTransport: ?*HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MPRAPI" fn MprConfigInterfaceTransportGetInfo(
    hMprConfig: HANDLE,
    hRouterInterface: HANDLE,
    hRouterIfTransport: HANDLE,
    ppInterfaceInfo: ?*?*u8,
    lpdwInterfaceInfoSize: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MPRAPI" fn MprConfigInterfaceTransportSetInfo(
    hMprConfig: HANDLE,
    hRouterInterface: HANDLE,
    hRouterIfTransport: HANDLE,
    pInterfaceInfo: ?*u8,
    dwInterfaceInfoSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MPRAPI" fn MprConfigInterfaceTransportEnum(
    hMprConfig: HANDLE,
    hRouterInterface: HANDLE,
    dwLevel: u32,
    lplpBuffer: ?*?*u8,
    dwPrefMaxLen: u32,
    lpdwEntriesRead: ?*u32,
    lpdwTotalEntries: ?*u32,
    lpdwResumeHandle: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MPRAPI" fn MprConfigGetFriendlyName(
    hMprConfig: HANDLE,
    pszGuidName: ?*u16,
    pszBuffer: ?*u16,
    dwBufferSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MPRAPI" fn MprConfigGetGuidName(
    hMprConfig: HANDLE,
    pszFriendlyName: ?*u16,
    pszBuffer: ?*u16,
    dwBufferSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MPRAPI" fn MprConfigFilterGetInfo(
    hMprConfig: HANDLE,
    dwLevel: u32,
    dwTransportId: u32,
    lpBuffer: ?*u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MPRAPI" fn MprConfigFilterSetInfo(
    hMprConfig: HANDLE,
    dwLevel: u32,
    dwTransportId: u32,
    lpBuffer: ?*u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MPRAPI" fn MprInfoCreate(
    dwVersion: u32,
    lplpNewHeader: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MPRAPI" fn MprInfoDelete(
    lpHeader: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MPRAPI" fn MprInfoRemoveAll(
    lpHeader: ?*opaque{},
    lplpNewHeader: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MPRAPI" fn MprInfoDuplicate(
    lpHeader: ?*opaque{},
    lplpNewHeader: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MPRAPI" fn MprInfoBlockAdd(
    lpHeader: ?*opaque{},
    dwInfoType: u32,
    dwItemSize: u32,
    dwItemCount: u32,
    lpItemData: ?*u8,
    lplpNewHeader: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MPRAPI" fn MprInfoBlockRemove(
    lpHeader: ?*opaque{},
    dwInfoType: u32,
    lplpNewHeader: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MPRAPI" fn MprInfoBlockSet(
    lpHeader: ?*opaque{},
    dwInfoType: u32,
    dwItemSize: u32,
    dwItemCount: u32,
    lpItemData: ?*u8,
    lplpNewHeader: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MPRAPI" fn MprInfoBlockFind(
    lpHeader: ?*opaque{},
    dwInfoType: u32,
    lpdwItemSize: ?*u32,
    lpdwItemCount: ?*u32,
    lplpItemData: ?*?*u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MPRAPI" fn MprInfoBlockQuerySize(
    lpHeader: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "rtm" fn MgmRegisterMProtocol(
    prpiInfo: ?*ROUTING_PROTOCOL_CONFIG,
    dwProtocolId: u32,
    dwComponentId: u32,
    phProtocol: ?*HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "rtm" fn MgmDeRegisterMProtocol(
    hProtocol: HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "rtm" fn MgmTakeInterfaceOwnership(
    hProtocol: HANDLE,
    dwIfIndex: u32,
    dwIfNextHopAddr: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "rtm" fn MgmReleaseInterfaceOwnership(
    hProtocol: HANDLE,
    dwIfIndex: u32,
    dwIfNextHopAddr: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "rtm" fn MgmGetProtocolOnInterface(
    dwIfIndex: u32,
    dwIfNextHopAddr: u32,
    pdwIfProtocolId: ?*u32,
    pdwIfComponentId: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "rtm" fn MgmAddGroupMembershipEntry(
    hProtocol: HANDLE,
    dwSourceAddr: u32,
    dwSourceMask: u32,
    dwGroupAddr: u32,
    dwGroupMask: u32,
    dwIfIndex: u32,
    dwIfNextHopIPAddr: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "rtm" fn MgmDeleteGroupMembershipEntry(
    hProtocol: HANDLE,
    dwSourceAddr: u32,
    dwSourceMask: u32,
    dwGroupAddr: u32,
    dwGroupMask: u32,
    dwIfIndex: u32,
    dwIfNextHopIPAddr: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "rtm" fn MgmGetMfe(
    pimm: ?*MIB_IPMCAST_MFE,
    pdwBufferSize: ?*u32,
    pbBuffer: ?*u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "rtm" fn MgmGetFirstMfe(
    pdwBufferSize: ?*u32,
    pbBuffer: ?*u8,
    pdwNumEntries: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "rtm" fn MgmGetNextMfe(
    pimmStart: ?*MIB_IPMCAST_MFE,
    pdwBufferSize: ?*u32,
    pbBuffer: ?*u8,
    pdwNumEntries: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "rtm" fn MgmGetMfeStats(
    pimm: ?*MIB_IPMCAST_MFE,
    pdwBufferSize: ?*u32,
    pbBuffer: ?*u8,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "rtm" fn MgmGetFirstMfeStats(
    pdwBufferSize: ?*u32,
    pbBuffer: ?*u8,
    pdwNumEntries: ?*u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "rtm" fn MgmGetNextMfeStats(
    pimmStart: ?*MIB_IPMCAST_MFE,
    pdwBufferSize: ?*u32,
    pbBuffer: ?*u8,
    pdwNumEntries: ?*u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "rtm" fn MgmGroupEnumerationStart(
    hProtocol: HANDLE,
    metEnumType: MGM_ENUM_TYPES,
    phEnumHandle: ?*HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "rtm" fn MgmGroupEnumerationGetNext(
    hEnum: HANDLE,
    pdwBufferSize: ?*u32,
    pbBuffer: ?*u8,
    pdwNumEntries: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "rtm" fn MgmGroupEnumerationEnd(
    hEnum: HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "rtm" fn RtmConvertNetAddressToIpv6AddressAndLength(
    pNetAddress: ?*RTM_NET_ADDRESS,
    pAddress: ?*in6_addr,
    pLength: ?*u32,
    dwAddressSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "rtm" fn RtmConvertIpv6AddressAndLengthToNetAddress(
    pNetAddress: ?*RTM_NET_ADDRESS,
    Address: in6_addr,
    dwLength: u32,
    dwAddressSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "rtm" fn RtmRegisterEntity(
    RtmEntityInfo: ?*RTM_ENTITY_INFO,
    ExportMethods: ?*RTM_ENTITY_EXPORT_METHODS,
    EventCallback: RTM_EVENT_CALLBACK,
    ReserveOpaquePointer: BOOL,
    RtmRegProfile: ?*RTM_REGN_PROFILE,
    RtmRegHandle: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "rtm" fn RtmDeregisterEntity(
    RtmRegHandle: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "rtm" fn RtmGetRegisteredEntities(
    RtmRegHandle: ?*opaque{},
    NumEntities: ?*u32,
    EntityHandles: ?*?*opaque{},
    EntityInfos: ?*RTM_ENTITY_INFO,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "rtm" fn RtmReleaseEntities(
    RtmRegHandle: ?*opaque{},
    NumEntities: u32,
    EntityHandles: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "rtm" fn RtmLockDestination(
    RtmRegHandle: ?*opaque{},
    DestHandle: ?*opaque{},
    Exclusive: BOOL,
    LockDest: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "rtm" fn RtmGetOpaqueInformationPointer(
    RtmRegHandle: ?*opaque{},
    DestHandle: ?*opaque{},
    OpaqueInfoPointer: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "rtm" fn RtmGetEntityMethods(
    RtmRegHandle: ?*opaque{},
    EntityHandle: ?*opaque{},
    NumMethods: ?*u32,
    ExptMethods: PRTM_ENTITY_EXPORT_METHOD,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "rtm" fn RtmInvokeMethod(
    RtmRegHandle: ?*opaque{},
    EntityHandle: ?*opaque{},
    Input: ?*RTM_ENTITY_METHOD_INPUT,
    OutputSize: ?*u32,
    Output: ?*RTM_ENTITY_METHOD_OUTPUT,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "rtm" fn RtmBlockMethods(
    RtmRegHandle: ?*opaque{},
    TargetHandle: HANDLE,
    TargetType: u8,
    BlockingFlag: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "rtm" fn RtmGetEntityInfo(
    RtmRegHandle: ?*opaque{},
    EntityHandle: ?*opaque{},
    EntityInfo: ?*RTM_ENTITY_INFO,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "rtm" fn RtmGetDestInfo(
    RtmRegHandle: ?*opaque{},
    DestHandle: ?*opaque{},
    ProtocolId: u32,
    TargetViews: u32,
    DestInfo: ?*RTM_DEST_INFO,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "rtm" fn RtmGetRouteInfo(
    RtmRegHandle: ?*opaque{},
    RouteHandle: ?*opaque{},
    RouteInfo: ?*RTM_ROUTE_INFO,
    DestAddress: ?*RTM_NET_ADDRESS,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "rtm" fn RtmGetNextHopInfo(
    RtmRegHandle: ?*opaque{},
    NextHopHandle: ?*opaque{},
    NextHopInfo: ?*RTM_NEXTHOP_INFO,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "rtm" fn RtmReleaseEntityInfo(
    RtmRegHandle: ?*opaque{},
    EntityInfo: ?*RTM_ENTITY_INFO,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "rtm" fn RtmReleaseDestInfo(
    RtmRegHandle: ?*opaque{},
    DestInfo: ?*RTM_DEST_INFO,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "rtm" fn RtmReleaseRouteInfo(
    RtmRegHandle: ?*opaque{},
    RouteInfo: ?*RTM_ROUTE_INFO,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "rtm" fn RtmReleaseNextHopInfo(
    RtmRegHandle: ?*opaque{},
    NextHopInfo: ?*RTM_NEXTHOP_INFO,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "rtm" fn RtmAddRouteToDest(
    RtmRegHandle: ?*opaque{},
    RouteHandle: ?*?*opaque{},
    DestAddress: ?*RTM_NET_ADDRESS,
    RouteInfo: ?*RTM_ROUTE_INFO,
    TimeToLive: u32,
    RouteListHandle: ?*opaque{},
    NotifyType: u32,
    NotifyHandle: ?*opaque{},
    ChangeFlags: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "rtm" fn RtmDeleteRouteToDest(
    RtmRegHandle: ?*opaque{},
    RouteHandle: ?*opaque{},
    ChangeFlags: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "rtm" fn RtmHoldDestination(
    RtmRegHandle: ?*opaque{},
    DestHandle: ?*opaque{},
    TargetViews: u32,
    HoldTime: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "rtm" fn RtmGetRoutePointer(
    RtmRegHandle: ?*opaque{},
    RouteHandle: ?*opaque{},
    RoutePointer: ?*?*RTM_ROUTE_INFO,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "rtm" fn RtmLockRoute(
    RtmRegHandle: ?*opaque{},
    RouteHandle: ?*opaque{},
    Exclusive: BOOL,
    LockRoute: BOOL,
    RoutePointer: ?*?*RTM_ROUTE_INFO,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "rtm" fn RtmUpdateAndUnlockRoute(
    RtmRegHandle: ?*opaque{},
    RouteHandle: ?*opaque{},
    TimeToLive: u32,
    RouteListHandle: ?*opaque{},
    NotifyType: u32,
    NotifyHandle: ?*opaque{},
    ChangeFlags: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "rtm" fn RtmGetExactMatchDestination(
    RtmRegHandle: ?*opaque{},
    DestAddress: ?*RTM_NET_ADDRESS,
    ProtocolId: u32,
    TargetViews: u32,
    DestInfo: ?*RTM_DEST_INFO,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "rtm" fn RtmGetMostSpecificDestination(
    RtmRegHandle: ?*opaque{},
    DestAddress: ?*RTM_NET_ADDRESS,
    ProtocolId: u32,
    TargetViews: u32,
    DestInfo: ?*RTM_DEST_INFO,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "rtm" fn RtmGetLessSpecificDestination(
    RtmRegHandle: ?*opaque{},
    DestHandle: ?*opaque{},
    ProtocolId: u32,
    TargetViews: u32,
    DestInfo: ?*RTM_DEST_INFO,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "rtm" fn RtmGetExactMatchRoute(
    RtmRegHandle: ?*opaque{},
    DestAddress: ?*RTM_NET_ADDRESS,
    MatchingFlags: u32,
    RouteInfo: ?*RTM_ROUTE_INFO,
    InterfaceIndex: u32,
    TargetViews: u32,
    RouteHandle: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "rtm" fn RtmIsBestRoute(
    RtmRegHandle: ?*opaque{},
    RouteHandle: ?*opaque{},
    BestInViews: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "rtm" fn RtmAddNextHop(
    RtmRegHandle: ?*opaque{},
    NextHopInfo: ?*RTM_NEXTHOP_INFO,
    NextHopHandle: ?*?*opaque{},
    ChangeFlags: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "rtm" fn RtmFindNextHop(
    RtmRegHandle: ?*opaque{},
    NextHopInfo: ?*RTM_NEXTHOP_INFO,
    NextHopHandle: ?*?*opaque{},
    NextHopPointer: ?*?*RTM_NEXTHOP_INFO,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "rtm" fn RtmDeleteNextHop(
    RtmRegHandle: ?*opaque{},
    NextHopHandle: ?*opaque{},
    NextHopInfo: ?*RTM_NEXTHOP_INFO,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "rtm" fn RtmGetNextHopPointer(
    RtmRegHandle: ?*opaque{},
    NextHopHandle: ?*opaque{},
    NextHopPointer: ?*?*RTM_NEXTHOP_INFO,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "rtm" fn RtmLockNextHop(
    RtmRegHandle: ?*opaque{},
    NextHopHandle: ?*opaque{},
    Exclusive: BOOL,
    LockNextHop: BOOL,
    NextHopPointer: ?*?*RTM_NEXTHOP_INFO,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "rtm" fn RtmCreateDestEnum(
    RtmRegHandle: ?*opaque{},
    TargetViews: u32,
    EnumFlags: u32,
    NetAddress: ?*RTM_NET_ADDRESS,
    ProtocolId: u32,
    RtmEnumHandle: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "rtm" fn RtmGetEnumDests(
    RtmRegHandle: ?*opaque{},
    EnumHandle: ?*opaque{},
    NumDests: ?*u32,
    DestInfos: ?*RTM_DEST_INFO,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "rtm" fn RtmReleaseDests(
    RtmRegHandle: ?*opaque{},
    NumDests: u32,
    DestInfos: ?*RTM_DEST_INFO,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "rtm" fn RtmCreateRouteEnum(
    RtmRegHandle: ?*opaque{},
    DestHandle: ?*opaque{},
    TargetViews: u32,
    EnumFlags: u32,
    StartDest: ?*RTM_NET_ADDRESS,
    MatchingFlags: u32,
    CriteriaRoute: ?*RTM_ROUTE_INFO,
    CriteriaInterface: u32,
    RtmEnumHandle: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "rtm" fn RtmGetEnumRoutes(
    RtmRegHandle: ?*opaque{},
    EnumHandle: ?*opaque{},
    NumRoutes: ?*u32,
    RouteHandles: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "rtm" fn RtmReleaseRoutes(
    RtmRegHandle: ?*opaque{},
    NumRoutes: u32,
    RouteHandles: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "rtm" fn RtmCreateNextHopEnum(
    RtmRegHandle: ?*opaque{},
    EnumFlags: u32,
    NetAddress: ?*RTM_NET_ADDRESS,
    RtmEnumHandle: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "rtm" fn RtmGetEnumNextHops(
    RtmRegHandle: ?*opaque{},
    EnumHandle: ?*opaque{},
    NumNextHops: ?*u32,
    NextHopHandles: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "rtm" fn RtmReleaseNextHops(
    RtmRegHandle: ?*opaque{},
    NumNextHops: u32,
    NextHopHandles: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "rtm" fn RtmDeleteEnumHandle(
    RtmRegHandle: ?*opaque{},
    EnumHandle: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "rtm" fn RtmRegisterForChangeNotification(
    RtmRegHandle: ?*opaque{},
    TargetViews: u32,
    NotifyFlags: u32,
    NotifyContext: ?*opaque{},
    NotifyHandle: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "rtm" fn RtmGetChangedDests(
    RtmRegHandle: ?*opaque{},
    NotifyHandle: ?*opaque{},
    NumDests: ?*u32,
    ChangedDests: ?*RTM_DEST_INFO,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "rtm" fn RtmReleaseChangedDests(
    RtmRegHandle: ?*opaque{},
    NotifyHandle: ?*opaque{},
    NumDests: u32,
    ChangedDests: ?*RTM_DEST_INFO,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "rtm" fn RtmIgnoreChangedDests(
    RtmRegHandle: ?*opaque{},
    NotifyHandle: ?*opaque{},
    NumDests: u32,
    ChangedDests: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "rtm" fn RtmGetChangeStatus(
    RtmRegHandle: ?*opaque{},
    NotifyHandle: ?*opaque{},
    DestHandle: ?*opaque{},
    ChangeStatus: ?*i32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "rtm" fn RtmMarkDestForChangeNotification(
    RtmRegHandle: ?*opaque{},
    NotifyHandle: ?*opaque{},
    DestHandle: ?*opaque{},
    MarkDest: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "rtm" fn RtmIsMarkedForChangeNotification(
    RtmRegHandle: ?*opaque{},
    NotifyHandle: ?*opaque{},
    DestHandle: ?*opaque{},
    DestMarked: ?*i32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "rtm" fn RtmDeregisterFromChangeNotification(
    RtmRegHandle: ?*opaque{},
    NotifyHandle: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "rtm" fn RtmCreateRouteList(
    RtmRegHandle: ?*opaque{},
    RouteListHandle: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "rtm" fn RtmInsertInRouteList(
    RtmRegHandle: ?*opaque{},
    RouteListHandle: ?*opaque{},
    NumRoutes: u32,
    RouteHandles: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "rtm" fn RtmCreateRouteListEnum(
    RtmRegHandle: ?*opaque{},
    RouteListHandle: ?*opaque{},
    RtmEnumHandle: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "rtm" fn RtmGetListEnumRoutes(
    RtmRegHandle: ?*opaque{},
    EnumHandle: ?*opaque{},
    NumRoutes: ?*u32,
    RouteHandles: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "rtm" fn RtmDeleteRouteList(
    RtmRegHandle: ?*opaque{},
    RouteListHandle: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "rtm" fn RtmReferenceHandles(
    RtmRegHandle: ?*opaque{},
    NumHandles: u32,
    RtmHandles: ?*HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

//
// Unicode Symbol Aliases
//
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {
        pub const tagRASCONN = tagRASCONNA;
        pub const tagRASCONNSTATUS = tagRASCONNSTATUSA;
        pub const tagRASDIALPARAMS = tagRASDIALPARAMSA;
        pub const tagRASENTRYNAME = tagRASENTRYNAMEA;
        pub const tagRASAMB = tagRASAMBA;
        pub const tagRASPPPNBF = tagRASPPPNBFA;
        pub const tagRASPPPIP = tagRASPPPIPA;
        pub const tagRASPPPLCP = tagRASPPPLCPA;
        pub const tagRASDEVINFO = tagRASDEVINFOA;
        pub const tagRASENTRY = tagRASENTRYA;
        pub const RASADFUNC = RASADFUNCA;
        pub const tagRASSUBENTRY = tagRASSUBENTRYA;
        pub const tagRASCREDENTIALS = tagRASCREDENTIALSA;
        pub const tagRASAUTODIALENTRY = tagRASAUTODIALENTRYA;
        pub const tagRASEAPUSERIDENTITY = tagRASEAPUSERIDENTITYA;
        pub const RASPBDLGFUNC = RASPBDLGFUNCA;
        pub const tagRASNOUSER = tagRASNOUSERA;
        pub const tagRASPBDLG = tagRASPBDLGA;
        pub const tagRASENTRYDLG = tagRASENTRYDLGA;
        pub const RasDial = RasDialA;
        pub const RasEnumConnections = RasEnumConnectionsA;
        pub const RasEnumEntries = RasEnumEntriesA;
        pub const RasGetConnectStatus = RasGetConnectStatusA;
        pub const RasGetErrorString = RasGetErrorStringA;
        pub const RasHangUp = RasHangUpA;
        pub const RasGetProjectionInfo = RasGetProjectionInfoA;
        pub const RasCreatePhonebookEntry = RasCreatePhonebookEntryA;
        pub const RasEditPhonebookEntry = RasEditPhonebookEntryA;
        pub const RasSetEntryDialParams = RasSetEntryDialParamsA;
        pub const RasGetEntryDialParams = RasGetEntryDialParamsA;
        pub const RasEnumDevices = RasEnumDevicesA;
        pub const RasGetCountryInfo = RasGetCountryInfoA;
        pub const RasGetEntryProperties = RasGetEntryPropertiesA;
        pub const RasSetEntryProperties = RasSetEntryPropertiesA;
        pub const RasRenameEntry = RasRenameEntryA;
        pub const RasDeleteEntry = RasDeleteEntryA;
        pub const RasValidateEntryName = RasValidateEntryNameA;
        pub const RasConnectionNotification = RasConnectionNotificationA;
        pub const RasGetSubEntryHandle = RasGetSubEntryHandleA;
        pub const RasGetCredentials = RasGetCredentialsA;
        pub const RasSetCredentials = RasSetCredentialsA;
        pub const RasGetSubEntryProperties = RasGetSubEntryPropertiesA;
        pub const RasSetSubEntryProperties = RasSetSubEntryPropertiesA;
        pub const RasGetAutodialAddress = RasGetAutodialAddressA;
        pub const RasSetAutodialAddress = RasSetAutodialAddressA;
        pub const RasEnumAutodialAddresses = RasEnumAutodialAddressesA;
        pub const RasGetAutodialEnable = RasGetAutodialEnableA;
        pub const RasSetAutodialEnable = RasSetAutodialEnableA;
        pub const RasGetAutodialParam = RasGetAutodialParamA;
        pub const RasSetAutodialParam = RasSetAutodialParamA;
        pub const RasGetEapUserData = RasGetEapUserDataA;
        pub const RasSetEapUserData = RasSetEapUserDataA;
        pub const RasGetCustomAuthData = RasGetCustomAuthDataA;
        pub const RasSetCustomAuthData = RasSetCustomAuthDataA;
        pub const RasGetEapUserIdentity = RasGetEapUserIdentityA;
        pub const RasFreeEapUserIdentity = RasFreeEapUserIdentityA;
        pub const RasDeleteSubEntry = RasDeleteSubEntryA;
        pub const RasPhonebookDlg = RasPhonebookDlgA;
        pub const RasEntryDlg = RasEntryDlgA;
        pub const RasDialDlg = RasDialDlgA;
    },
    .wide => struct {
        pub const tagRASCONN = tagRASCONNW;
        pub const tagRASCONNSTATUS = tagRASCONNSTATUSW;
        pub const tagRASDIALPARAMS = tagRASDIALPARAMSW;
        pub const tagRASENTRYNAME = tagRASENTRYNAMEW;
        pub const tagRASAMB = tagRASAMBW;
        pub const tagRASPPPNBF = tagRASPPPNBFW;
        pub const tagRASPPPIP = tagRASPPPIPW;
        pub const tagRASPPPLCP = tagRASPPPLCPW;
        pub const tagRASDEVINFO = tagRASDEVINFOW;
        pub const tagRASENTRY = tagRASENTRYW;
        pub const RASADFUNC = RASADFUNCW;
        pub const tagRASSUBENTRY = tagRASSUBENTRYW;
        pub const tagRASCREDENTIALS = tagRASCREDENTIALSW;
        pub const tagRASAUTODIALENTRY = tagRASAUTODIALENTRYW;
        pub const tagRASEAPUSERIDENTITY = tagRASEAPUSERIDENTITYW;
        pub const RASPBDLGFUNC = RASPBDLGFUNCW;
        pub const tagRASNOUSER = tagRASNOUSERW;
        pub const tagRASPBDLG = tagRASPBDLGW;
        pub const tagRASENTRYDLG = tagRASENTRYDLGW;
        pub const RasDial = RasDialW;
        pub const RasEnumConnections = RasEnumConnectionsW;
        pub const RasEnumEntries = RasEnumEntriesW;
        pub const RasGetConnectStatus = RasGetConnectStatusW;
        pub const RasGetErrorString = RasGetErrorStringW;
        pub const RasHangUp = RasHangUpW;
        pub const RasGetProjectionInfo = RasGetProjectionInfoW;
        pub const RasCreatePhonebookEntry = RasCreatePhonebookEntryW;
        pub const RasEditPhonebookEntry = RasEditPhonebookEntryW;
        pub const RasSetEntryDialParams = RasSetEntryDialParamsW;
        pub const RasGetEntryDialParams = RasGetEntryDialParamsW;
        pub const RasEnumDevices = RasEnumDevicesW;
        pub const RasGetCountryInfo = RasGetCountryInfoW;
        pub const RasGetEntryProperties = RasGetEntryPropertiesW;
        pub const RasSetEntryProperties = RasSetEntryPropertiesW;
        pub const RasRenameEntry = RasRenameEntryW;
        pub const RasDeleteEntry = RasDeleteEntryW;
        pub const RasValidateEntryName = RasValidateEntryNameW;
        pub const RasConnectionNotification = RasConnectionNotificationW;
        pub const RasGetSubEntryHandle = RasGetSubEntryHandleW;
        pub const RasGetCredentials = RasGetCredentialsW;
        pub const RasSetCredentials = RasSetCredentialsW;
        pub const RasGetSubEntryProperties = RasGetSubEntryPropertiesW;
        pub const RasSetSubEntryProperties = RasSetSubEntryPropertiesW;
        pub const RasGetAutodialAddress = RasGetAutodialAddressW;
        pub const RasSetAutodialAddress = RasSetAutodialAddressW;
        pub const RasEnumAutodialAddresses = RasEnumAutodialAddressesW;
        pub const RasGetAutodialEnable = RasGetAutodialEnableW;
        pub const RasSetAutodialEnable = RasSetAutodialEnableW;
        pub const RasGetAutodialParam = RasGetAutodialParamW;
        pub const RasSetAutodialParam = RasSetAutodialParamW;
        pub const RasGetEapUserData = RasGetEapUserDataW;
        pub const RasSetEapUserData = RasSetEapUserDataW;
        pub const RasGetCustomAuthData = RasGetCustomAuthDataW;
        pub const RasSetCustomAuthData = RasSetCustomAuthDataW;
        pub const RasGetEapUserIdentity = RasGetEapUserIdentityW;
        pub const RasFreeEapUserIdentity = RasFreeEapUserIdentityW;
        pub const RasDeleteSubEntry = RasDeleteSubEntryW;
        pub const RasPhonebookDlg = RasPhonebookDlgW;
        pub const RasEntryDlg = RasEntryDlgW;
        pub const RasDialDlg = RasDialDlgW;
    },
    else => if (@import("builtin").is_test) struct {
        pub const tagRASCONN = *opaque{};
        pub const tagRASCONNSTATUS = *opaque{};
        pub const tagRASDIALPARAMS = *opaque{};
        pub const tagRASENTRYNAME = *opaque{};
        pub const tagRASAMB = *opaque{};
        pub const tagRASPPPNBF = *opaque{};
        pub const tagRASPPPIP = *opaque{};
        pub const tagRASPPPLCP = *opaque{};
        pub const tagRASDEVINFO = *opaque{};
        pub const tagRASENTRY = *opaque{};
        pub const RASADFUNC = *opaque{};
        pub const tagRASSUBENTRY = *opaque{};
        pub const tagRASCREDENTIALS = *opaque{};
        pub const tagRASAUTODIALENTRY = *opaque{};
        pub const tagRASEAPUSERIDENTITY = *opaque{};
        pub const RASPBDLGFUNC = *opaque{};
        pub const tagRASNOUSER = *opaque{};
        pub const tagRASPBDLG = *opaque{};
        pub const tagRASENTRYDLG = *opaque{};
        pub const RasDial = *opaque{};
        pub const RasEnumConnections = *opaque{};
        pub const RasEnumEntries = *opaque{};
        pub const RasGetConnectStatus = *opaque{};
        pub const RasGetErrorString = *opaque{};
        pub const RasHangUp = *opaque{};
        pub const RasGetProjectionInfo = *opaque{};
        pub const RasCreatePhonebookEntry = *opaque{};
        pub const RasEditPhonebookEntry = *opaque{};
        pub const RasSetEntryDialParams = *opaque{};
        pub const RasGetEntryDialParams = *opaque{};
        pub const RasEnumDevices = *opaque{};
        pub const RasGetCountryInfo = *opaque{};
        pub const RasGetEntryProperties = *opaque{};
        pub const RasSetEntryProperties = *opaque{};
        pub const RasRenameEntry = *opaque{};
        pub const RasDeleteEntry = *opaque{};
        pub const RasValidateEntryName = *opaque{};
        pub const RasConnectionNotification = *opaque{};
        pub const RasGetSubEntryHandle = *opaque{};
        pub const RasGetCredentials = *opaque{};
        pub const RasSetCredentials = *opaque{};
        pub const RasGetSubEntryProperties = *opaque{};
        pub const RasSetSubEntryProperties = *opaque{};
        pub const RasGetAutodialAddress = *opaque{};
        pub const RasSetAutodialAddress = *opaque{};
        pub const RasEnumAutodialAddresses = *opaque{};
        pub const RasGetAutodialEnable = *opaque{};
        pub const RasSetAutodialEnable = *opaque{};
        pub const RasGetAutodialParam = *opaque{};
        pub const RasSetAutodialParam = *opaque{};
        pub const RasGetEapUserData = *opaque{};
        pub const RasSetEapUserData = *opaque{};
        pub const RasGetCustomAuthData = *opaque{};
        pub const RasSetCustomAuthData = *opaque{};
        pub const RasGetEapUserIdentity = *opaque{};
        pub const RasFreeEapUserIdentity = *opaque{};
        pub const RasDeleteSubEntry = *opaque{};
        pub const RasPhonebookDlg = *opaque{};
        pub const RasEntryDlg = *opaque{};
        pub const RasDialDlg = *opaque{};
    } else struct {
        pub const tagRASCONN = @compileError("'tagRASCONN' requires that UNICODE be set to true or false in the root module");
        pub const tagRASCONNSTATUS = @compileError("'tagRASCONNSTATUS' requires that UNICODE be set to true or false in the root module");
        pub const tagRASDIALPARAMS = @compileError("'tagRASDIALPARAMS' requires that UNICODE be set to true or false in the root module");
        pub const tagRASENTRYNAME = @compileError("'tagRASENTRYNAME' requires that UNICODE be set to true or false in the root module");
        pub const tagRASAMB = @compileError("'tagRASAMB' requires that UNICODE be set to true or false in the root module");
        pub const tagRASPPPNBF = @compileError("'tagRASPPPNBF' requires that UNICODE be set to true or false in the root module");
        pub const tagRASPPPIP = @compileError("'tagRASPPPIP' requires that UNICODE be set to true or false in the root module");
        pub const tagRASPPPLCP = @compileError("'tagRASPPPLCP' requires that UNICODE be set to true or false in the root module");
        pub const tagRASDEVINFO = @compileError("'tagRASDEVINFO' requires that UNICODE be set to true or false in the root module");
        pub const tagRASENTRY = @compileError("'tagRASENTRY' requires that UNICODE be set to true or false in the root module");
        pub const RASADFUNC = @compileError("'RASADFUNC' requires that UNICODE be set to true or false in the root module");
        pub const tagRASSUBENTRY = @compileError("'tagRASSUBENTRY' requires that UNICODE be set to true or false in the root module");
        pub const tagRASCREDENTIALS = @compileError("'tagRASCREDENTIALS' requires that UNICODE be set to true or false in the root module");
        pub const tagRASAUTODIALENTRY = @compileError("'tagRASAUTODIALENTRY' requires that UNICODE be set to true or false in the root module");
        pub const tagRASEAPUSERIDENTITY = @compileError("'tagRASEAPUSERIDENTITY' requires that UNICODE be set to true or false in the root module");
        pub const RASPBDLGFUNC = @compileError("'RASPBDLGFUNC' requires that UNICODE be set to true or false in the root module");
        pub const tagRASNOUSER = @compileError("'tagRASNOUSER' requires that UNICODE be set to true or false in the root module");
        pub const tagRASPBDLG = @compileError("'tagRASPBDLG' requires that UNICODE be set to true or false in the root module");
        pub const tagRASENTRYDLG = @compileError("'tagRASENTRYDLG' requires that UNICODE be set to true or false in the root module");
        pub const RasDial = @compileError("'RasDial' requires that UNICODE be set to true or false in the root module");
        pub const RasEnumConnections = @compileError("'RasEnumConnections' requires that UNICODE be set to true or false in the root module");
        pub const RasEnumEntries = @compileError("'RasEnumEntries' requires that UNICODE be set to true or false in the root module");
        pub const RasGetConnectStatus = @compileError("'RasGetConnectStatus' requires that UNICODE be set to true or false in the root module");
        pub const RasGetErrorString = @compileError("'RasGetErrorString' requires that UNICODE be set to true or false in the root module");
        pub const RasHangUp = @compileError("'RasHangUp' requires that UNICODE be set to true or false in the root module");
        pub const RasGetProjectionInfo = @compileError("'RasGetProjectionInfo' requires that UNICODE be set to true or false in the root module");
        pub const RasCreatePhonebookEntry = @compileError("'RasCreatePhonebookEntry' requires that UNICODE be set to true or false in the root module");
        pub const RasEditPhonebookEntry = @compileError("'RasEditPhonebookEntry' requires that UNICODE be set to true or false in the root module");
        pub const RasSetEntryDialParams = @compileError("'RasSetEntryDialParams' requires that UNICODE be set to true or false in the root module");
        pub const RasGetEntryDialParams = @compileError("'RasGetEntryDialParams' requires that UNICODE be set to true or false in the root module");
        pub const RasEnumDevices = @compileError("'RasEnumDevices' requires that UNICODE be set to true or false in the root module");
        pub const RasGetCountryInfo = @compileError("'RasGetCountryInfo' requires that UNICODE be set to true or false in the root module");
        pub const RasGetEntryProperties = @compileError("'RasGetEntryProperties' requires that UNICODE be set to true or false in the root module");
        pub const RasSetEntryProperties = @compileError("'RasSetEntryProperties' requires that UNICODE be set to true or false in the root module");
        pub const RasRenameEntry = @compileError("'RasRenameEntry' requires that UNICODE be set to true or false in the root module");
        pub const RasDeleteEntry = @compileError("'RasDeleteEntry' requires that UNICODE be set to true or false in the root module");
        pub const RasValidateEntryName = @compileError("'RasValidateEntryName' requires that UNICODE be set to true or false in the root module");
        pub const RasConnectionNotification = @compileError("'RasConnectionNotification' requires that UNICODE be set to true or false in the root module");
        pub const RasGetSubEntryHandle = @compileError("'RasGetSubEntryHandle' requires that UNICODE be set to true or false in the root module");
        pub const RasGetCredentials = @compileError("'RasGetCredentials' requires that UNICODE be set to true or false in the root module");
        pub const RasSetCredentials = @compileError("'RasSetCredentials' requires that UNICODE be set to true or false in the root module");
        pub const RasGetSubEntryProperties = @compileError("'RasGetSubEntryProperties' requires that UNICODE be set to true or false in the root module");
        pub const RasSetSubEntryProperties = @compileError("'RasSetSubEntryProperties' requires that UNICODE be set to true or false in the root module");
        pub const RasGetAutodialAddress = @compileError("'RasGetAutodialAddress' requires that UNICODE be set to true or false in the root module");
        pub const RasSetAutodialAddress = @compileError("'RasSetAutodialAddress' requires that UNICODE be set to true or false in the root module");
        pub const RasEnumAutodialAddresses = @compileError("'RasEnumAutodialAddresses' requires that UNICODE be set to true or false in the root module");
        pub const RasGetAutodialEnable = @compileError("'RasGetAutodialEnable' requires that UNICODE be set to true or false in the root module");
        pub const RasSetAutodialEnable = @compileError("'RasSetAutodialEnable' requires that UNICODE be set to true or false in the root module");
        pub const RasGetAutodialParam = @compileError("'RasGetAutodialParam' requires that UNICODE be set to true or false in the root module");
        pub const RasSetAutodialParam = @compileError("'RasSetAutodialParam' requires that UNICODE be set to true or false in the root module");
        pub const RasGetEapUserData = @compileError("'RasGetEapUserData' requires that UNICODE be set to true or false in the root module");
        pub const RasSetEapUserData = @compileError("'RasSetEapUserData' requires that UNICODE be set to true or false in the root module");
        pub const RasGetCustomAuthData = @compileError("'RasGetCustomAuthData' requires that UNICODE be set to true or false in the root module");
        pub const RasSetCustomAuthData = @compileError("'RasSetCustomAuthData' requires that UNICODE be set to true or false in the root module");
        pub const RasGetEapUserIdentity = @compileError("'RasGetEapUserIdentity' requires that UNICODE be set to true or false in the root module");
        pub const RasFreeEapUserIdentity = @compileError("'RasFreeEapUserIdentity' requires that UNICODE be set to true or false in the root module");
        pub const RasDeleteSubEntry = @compileError("'RasDeleteSubEntry' requires that UNICODE be set to true or false in the root module");
        pub const RasPhonebookDlg = @compileError("'RasPhonebookDlg' requires that UNICODE be set to true or false in the root module");
        pub const RasEntryDlg = @compileError("'RasEntryDlg' requires that UNICODE be set to true or false in the root module");
        pub const RasDialDlg = @compileError("'RasDialDlg' requires that UNICODE be set to true or false in the root module");
    },
};

//
// type imports
//
const Guid = @import("../zig.zig").Guid;
const LUID = @import("kernel.zig").LUID;
const HWND = @import("windowsandmessaging.zig").HWND;
const BOOL = @import("systemservices.zig").BOOL;
const in_addr = @import("winsock.zig").in_addr;
const in6_addr = @import("winsock.zig").in6_addr;
const HANDLE = @import("systemservices.zig").HANDLE;
const FILETIME = @import("windowsprogramming.zig").FILETIME;
const CRYPTOAPI_BLOB = @import("security.zig").CRYPTOAPI_BLOB;
const MIB_IPMCAST_MFE = @import("mib.zig").MIB_IPMCAST_MFE;

test "" {
    const constant_export_count = 0;
    const type_export_count = 217;
    const func_count = 277;
    const unicode_alias_count = 60;
    const type_import_count = 10;
    @setEvalBranchQuota(0
        + constant_export_count
        + type_export_count
        + func_count
        + unicode_alias_count
        + type_import_count
        + 2 // TODO: why do I need these extra 2?
    );
    @import("std").testing.refAllDecls(@This());
}
