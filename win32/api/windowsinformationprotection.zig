//! NOTE: this source file is autogenerated, DO NOT MODIFY

//
// constants
//

//
// types
//
// --------------------------------------------------------
// Type: IProtectionPolicyManagerInterop
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IProtectionPolicyManagerInterop = *opaque{
    // TODO: Method 'RequestAccessForWindowAsync'
    // TODO: Method 'GetForWindow'
};
// --------------------------------------------------------
// Type: IProtectionPolicyManagerInterop2
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IProtectionPolicyManagerInterop2 = *opaque{
    // TODO: Method 'RequestAccessForAppWithWindowAsync'
    // TODO: Method 'RequestAccessWithAuditingInfoForWindowAsync'
    // TODO: Method 'RequestAccessWithMessageForWindowAsync'
    // TODO: Method 'RequestAccessForAppWithAuditingInfoForWindowAsync'
    // TODO: Method 'RequestAccessForAppWithMessageForWindowAsync'
};
// --------------------------------------------------------
// Type: IProtectionPolicyManagerInterop3
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IProtectionPolicyManagerInterop3 = *opaque{
    // TODO: Method 'RequestAccessWithBehaviorForWindowAsync'
    // TODO: Method 'RequestAccessForAppWithBehaviorForWindowAsync'
    // TODO: Method 'RequestAccessToFilesForAppForWindowAsync'
    // TODO: Method 'RequestAccessToFilesForAppWithMessageAndBehaviorForWindowAsync'
    // TODO: Method 'RequestAccessToFilesForProcessForWindowAsync'
    // TODO: Method 'RequestAccessToFilesForProcessWithMessageAndBehaviorForWindowAsync'
};
// --------------------------------------------------------
// Type: HTHREAD_NETWORK_CONTEXT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HTHREAD_NETWORK_CONTEXT = extern struct {
    ThreadId: u32,
    ThreadContext: HANDLE,
};
// --------------------------------------------------------
// Type: ENTERPRISE_DATA_POLICIES
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const ENTERPRISE_DATA_POLICIES = *opaque{
};
// --------------------------------------------------------
// Type: FILE_UNPROTECT_OPTIONS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const FILE_UNPROTECT_OPTIONS = extern struct {
    audit: bool,
};

//
// functions
//

// set_last_errror=False (can and should we use this?)
pub extern "srpapi" fn SrpCreateThreadNetworkContext(
    enterpriseId: ?*u16,
    threadNetworkContext: ?*HTHREAD_NETWORK_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "srpapi" fn SrpCloseThreadNetworkContext(
    threadNetworkContext: ?*HTHREAD_NETWORK_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "srpapi" fn SrpSetTokenEnterpriseId(
    tokenHandle: HANDLE,
    enterpriseId: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "srpapi" fn SrpGetEnterpriseIds(
    tokenHandle: HANDLE,
    numberOfBytes: ?*u32,
    enterpriseIds: ?*?*u16,
    enterpriseIdCount: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "srpapi" fn SrpEnablePermissiveModeFileEncryption(
    enterpriseId: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "srpapi" fn SrpDisablePermissiveModeFileEncryption(
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "srpapi" fn SrpGetEnterprisePolicy(
    tokenHandle: HANDLE,
    policyFlags: ?*ENTERPRISE_DATA_POLICIES,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "srpapi" fn SrpIsTokenService(
    TokenHandle: HANDLE,
    IsTokenService: ?*u8,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "srpapi" fn SrpDoesPolicyAllowAppExecution(
    packageId: ?*PACKAGE_ID,
    isAllowed: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "efswrt" fn ProtectFileToEnterpriseIdentity(
    fileOrFolderPath: ?*u16,
    identity: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "efswrt" fn UnprotectFile(
    fileOrFolderPath: ?*u16,
    options: ?*FILE_UNPROTECT_OPTIONS,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

//
// Unicode Symbol Aliases
//
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {
    },
    .wide => struct {
    },
    else => if (@import("builtin").is_test) struct {
    } else struct {
    },
};

//
// type imports
//
const HANDLE = @import("systemservices.zig").HANDLE;
const HRESULT = @import("com.zig").HRESULT;
const NTSTATUS = @import("systemservices.zig").NTSTATUS;
const PACKAGE_ID = @import("appxpackaging.zig").PACKAGE_ID;

test "" {
    const constant_export_count = 0;
    const type_export_count = 6;
    const func_count = 11;
    const unicode_alias_count = 0;
    const type_import_count = 4;
    @setEvalBranchQuota(0
        + constant_export_count
        + type_export_count
        + func_count
        + unicode_alias_count
        + type_import_count
        + 2 // TODO: why do I need these extra 2?
    );
    @import("std").testing.refAllDecls(@This());
}
