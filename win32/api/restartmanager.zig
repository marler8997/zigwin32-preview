//! NOTE: this source file is autogenerated, DO NOT MODIFY

//
// constants
//

//
// types
//
// --------------------------------------------------------
// Type: RM_APP_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const RM_APP_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: RM_SHUTDOWN_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const RM_SHUTDOWN_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: RM_APP_STATUS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const RM_APP_STATUS = *opaque{
};
// --------------------------------------------------------
// Type: RM_REBOOT_REASON
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const RM_REBOOT_REASON = *opaque{
};
// --------------------------------------------------------
// Type: RM_UNIQUE_PROCESS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const RM_UNIQUE_PROCESS = extern struct {
    dwProcessId: u32,
    ProcessStartTime: FILETIME,
};
// --------------------------------------------------------
// Type: RM_PROCESS_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const RM_PROCESS_INFO = extern struct {
    Process: RM_UNIQUE_PROCESS,
    strAppName: ?[*]u16,
    strServiceShortName: ?[*]u16,
    ApplicationType: RM_APP_TYPE,
    AppStatus: u32,
    TSSessionId: u32,
    bRestartable: BOOL,
};
// --------------------------------------------------------
// Type: RM_FILTER_TRIGGER
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const RM_FILTER_TRIGGER = *opaque{
};
// --------------------------------------------------------
// Type: RM_FILTER_ACTION
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const RM_FILTER_ACTION = *opaque{
};
// --------------------------------------------------------
// Type: RM_FILTER_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const RM_FILTER_INFO = extern struct {
    FilterAction: RM_FILTER_ACTION,
    FilterTrigger: RM_FILTER_TRIGGER,
    cbNextOffset: u32,
    Anonymous: _Anonymous_e__Union,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: RM_WRITE_STATUS_CALLBACK
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const RM_WRITE_STATUS_CALLBACK = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};

//
// functions
//

// set_last_errror=False (can and should we use this?)
pub extern "rstrtmgr" fn RmStartSession(
    pSessionHandle: ?*u32,
    dwSessionFlags: u32,
    strSessionKey: ?*u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "RstrtMgr" fn RmJoinSession(
    pSessionHandle: ?*u32,
    strSessionKey: ?*u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "rstrtmgr" fn RmEndSession(
    dwSessionHandle: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "rstrtmgr" fn RmRegisterResources(
    dwSessionHandle: u32,
    nFiles: u32,
    rgsFileNames: ?*?*u16,
    nApplications: u32,
    rgApplications: ?*RM_UNIQUE_PROCESS,
    nServices: u32,
    rgsServiceNames: ?*?*u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "rstrtmgr" fn RmGetList(
    dwSessionHandle: u32,
    pnProcInfoNeeded: ?*u32,
    pnProcInfo: ?*u32,
    rgAffectedApps: ?*RM_PROCESS_INFO,
    lpdwRebootReasons: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "rstrtmgr" fn RmShutdown(
    dwSessionHandle: u32,
    lActionFlags: u32,
    fnStatus: RM_WRITE_STATUS_CALLBACK,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "rstrtmgr" fn RmRestart(
    dwSessionHandle: u32,
    dwRestartFlags: u32,
    fnStatus: RM_WRITE_STATUS_CALLBACK,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "RstrtMgr" fn RmCancelCurrentTask(
    dwSessionHandle: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "RstrtMgr" fn RmAddFilter(
    dwSessionHandle: u32,
    strModuleName: ?*u16,
    pProcess: ?*RM_UNIQUE_PROCESS,
    strServiceShortName: ?*u16,
    FilterAction: RM_FILTER_ACTION,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "RstrtMgr" fn RmRemoveFilter(
    dwSessionHandle: u32,
    strModuleName: ?*u16,
    pProcess: ?*RM_UNIQUE_PROCESS,
    strServiceShortName: ?*u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "RstrtMgr" fn RmGetFilterList(
    dwSessionHandle: u32,
    pbFilterBuf: ?*u8,
    cbFilterBuf: u32,
    cbFilterBufNeeded: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

//
// Unicode Symbol Aliases
//
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {
    },
    .wide => struct {
    },
    else => if (@import("builtin").is_test) struct {
    } else struct {
    },
};

//
// type imports
//
const FILETIME = @import("windowsprogramming.zig").FILETIME;
const BOOL = @import("systemservices.zig").BOOL;

test "" {
    const constant_export_count = 0;
    const type_export_count = 10;
    const func_count = 11;
    const unicode_alias_count = 0;
    const type_import_count = 2;
    @setEvalBranchQuota(0
        + constant_export_count
        + type_export_count
        + func_count
        + unicode_alias_count
        + type_import_count
        + 2 // TODO: why do I need these extra 2?
    );
    @import("std").testing.refAllDecls(@This());
}
