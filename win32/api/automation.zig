//! NOTE: this source file is autogenerated, DO NOT MODIFY

//
// constants
//

//
// types
//
// --------------------------------------------------------
// Type: SAFEARRAYBOUND
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SAFEARRAYBOUND = extern struct {
    cElements: u32,
    lLbound: i32,
};
// --------------------------------------------------------
// Type: _wireSAFEARR_BSTR
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const _wireSAFEARR_BSTR = extern struct {
    Size: u32,
    aBstr: ?*?*FLAGGED_WORD_BLOB,
};
// --------------------------------------------------------
// Type: _wireSAFEARR_UNKNOWN
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const _wireSAFEARR_UNKNOWN = extern struct {
    Size: u32,
    apUnknown: ?*IUnknown,
};
// --------------------------------------------------------
// Type: _wireSAFEARR_DISPATCH
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const _wireSAFEARR_DISPATCH = extern struct {
    Size: u32,
    apDispatch: ?*IDispatch,
};
// --------------------------------------------------------
// Type: _wireSAFEARR_VARIANT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const _wireSAFEARR_VARIANT = extern struct {
    Size: u32,
    aVariant: ?*?*_wireVARIANT,
};
// --------------------------------------------------------
// Type: _wireSAFEARR_BRECORD
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const _wireSAFEARR_BRECORD = extern struct {
    Size: u32,
    aRecord: ?*?*_wireBRECORD,
};
// --------------------------------------------------------
// Type: _wireSAFEARR_HAVEIID
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const _wireSAFEARR_HAVEIID = extern struct {
    Size: u32,
    apUnknown: ?*IUnknown,
    iid: Guid,
};
// --------------------------------------------------------
// Type: SF_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const SF_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: _wireSAFEARRAY_UNION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const _wireSAFEARRAY_UNION = extern struct {
    sfType: u32,
    u: _u_e__Struct,
    // --------------------------------------------------------
    // Type: _u_e__Struct
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _u_e__Struct = *opaque{
    };
};
// --------------------------------------------------------
// Type: _wireSAFEARRAY
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const _wireSAFEARRAY = extern struct {
    cDims: u16,
    fFeatures: u16,
    cbElements: u32,
    cLocks: u32,
    uArrayStructs: _wireSAFEARRAY_UNION,
    rgsabound: ?[*]SAFEARRAYBOUND,
};
// --------------------------------------------------------
// Type: SAFEARRAY
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SAFEARRAY = extern struct {
    cDims: u16,
    fFeatures: u16,
    cbElements: u32,
    cLocks: u32,
    pvData: ?*opaque{},
    rgsabound: ?[*]SAFEARRAYBOUND,
};
// --------------------------------------------------------
// Type: VARIANT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VARIANT = extern struct {
    Anonymous: _Anonymous_e__Union,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
        // --------------------------------------------------------
        // Type: _Anonymous_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _Anonymous_e__Struct = extern struct {
            vt: u16,
            wReserved1: u16,
            wReserved2: u16,
            wReserved3: u16,
            Anonymous: _Anonymous_e__Union,
            // --------------------------------------------------------
            // Type: _Anonymous_e__Union
            // TypeLayoutAttr: explicit
            // not generating the actual code for this type because it has an explicit layout
            pub const _Anonymous_e__Union = *opaque{
                // --------------------------------------------------------
                // Type: _Anonymous_e__Struct
                // TypeLayoutAttr: sequential
                // TODO: I think this is a struct, but not sure at this point, assuming it is for now
                pub const _Anonymous_e__Struct = extern struct {
                    pvRecord: ?*opaque{},
                    pRecInfo: IRecordInfo,
                };
            };
        };
    };
};
// --------------------------------------------------------
// Type: _wireBRECORD
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const _wireBRECORD = extern struct {
    fFlags: u32,
    clSize: u32,
    pRecInfo: IRecordInfo,
    pRecord: ?*u8,
};
// --------------------------------------------------------
// Type: _wireVARIANT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const _wireVARIANT = extern struct {
    clSize: u32,
    rpcReserved: u32,
    vt: u16,
    wReserved1: u16,
    wReserved2: u16,
    wReserved3: u16,
    Anonymous: _Anonymous_e__Union,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: TYPEKIND
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const TYPEKIND = *opaque{
};
// --------------------------------------------------------
// Type: TYPEDESC
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TYPEDESC = extern struct {
    Anonymous: _Anonymous_e__Union,
    vt: u16,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: ARRAYDESC
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const ARRAYDESC = extern struct {
    tdescElem: TYPEDESC,
    cDims: u16,
    rgbounds: ?[*]SAFEARRAYBOUND,
};
// --------------------------------------------------------
// Type: PARAMDESCEX
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PARAMDESCEX = extern struct {
    cBytes: u32,
    varDefaultValue: VARIANT,
};
// --------------------------------------------------------
// Type: PARAMDESC
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PARAMDESC = extern struct {
    pparamdescex: ?*PARAMDESCEX,
    wParamFlags: u16,
};
// --------------------------------------------------------
// Type: IDLDESC
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const IDLDESC = extern struct {
    dwReserved: ?*opaque{},
    wIDLFlags: u16,
};
// --------------------------------------------------------
// Type: ELEMDESC
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const ELEMDESC = extern struct {
    tdesc: TYPEDESC,
    Anonymous: _Anonymous_e__Union,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: TYPEATTR
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TYPEATTR = extern struct {
    guid: Guid,
    lcid: u32,
    dwReserved: u32,
    memidConstructor: i32,
    memidDestructor: i32,
    lpstrSchema: ?*u16,
    cbSizeInstance: u32,
    typekind: TYPEKIND,
    cFuncs: u16,
    cVars: u16,
    cImplTypes: u16,
    cbSizeVft: u16,
    cbAlignment: u16,
    wTypeFlags: u16,
    wMajorVerNum: u16,
    wMinorVerNum: u16,
    tdescAlias: TYPEDESC,
    idldescType: IDLDESC,
};
// --------------------------------------------------------
// Type: DISPPARAMS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DISPPARAMS = extern struct {
    rgvarg: ?*VARIANT,
    rgdispidNamedArgs: ?*i32,
    cArgs: u32,
    cNamedArgs: u32,
};
// --------------------------------------------------------
// Type: EXCEPINFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const EXCEPINFO = extern struct {
    wCode: u16,
    wReserved: u16,
    bstrSource: BSTR,
    bstrDescription: BSTR,
    bstrHelpFile: BSTR,
    dwHelpContext: u32,
    pvReserved: ?*opaque{},
    pfnDeferredFillIn: ?*?*?*?*?*?*?*?*?*?*HRESULT,
    scode: i32,
};
// --------------------------------------------------------
// Type: CALLCONV
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const CALLCONV = *opaque{
};
// --------------------------------------------------------
// Type: FUNCKIND
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const FUNCKIND = *opaque{
};
// --------------------------------------------------------
// Type: INVOKEKIND
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const INVOKEKIND = *opaque{
};
// --------------------------------------------------------
// Type: FUNCDESC
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const FUNCDESC = extern struct {
    memid: i32,
    lprgscode: ?*i32,
    lprgelemdescParam: ?*ELEMDESC,
    funckind: FUNCKIND,
    invkind: INVOKEKIND,
    @"callconv": CALLCONV,
    cParams: i16,
    cParamsOpt: i16,
    oVft: i16,
    cScodes: i16,
    elemdescFunc: ELEMDESC,
    wFuncFlags: u16,
};
// --------------------------------------------------------
// Type: VARKIND
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const VARKIND = *opaque{
};
// --------------------------------------------------------
// Type: VARDESC
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VARDESC = extern struct {
    memid: i32,
    lpstrSchema: ?*u16,
    Anonymous: _Anonymous_e__Union,
    elemdescVar: ELEMDESC,
    wVarFlags: u16,
    varkind: VARKIND,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: TYPEFLAGS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const TYPEFLAGS = *opaque{
};
// --------------------------------------------------------
// Type: FUNCFLAGS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const FUNCFLAGS = *opaque{
};
// --------------------------------------------------------
// Type: VARFLAGS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const VARFLAGS = *opaque{
};
// --------------------------------------------------------
// Type: CLEANLOCALSTORAGE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CLEANLOCALSTORAGE = extern struct {
    pInterface: IUnknown,
    pStorage: ?*opaque{},
    flags: u32,
};
// --------------------------------------------------------
// Type: CUSTDATAITEM
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CUSTDATAITEM = extern struct {
    guid: Guid,
    varValue: VARIANT,
};
// --------------------------------------------------------
// Type: CUSTDATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CUSTDATA = extern struct {
    cCustData: u32,
    prgCustData: ?*CUSTDATAITEM,
};
// --------------------------------------------------------
// Type: ICreateTypeInfo
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ICreateTypeInfo = *opaque{
    // TODO: Method 'SetGuid'
    // TODO: Method 'SetTypeFlags'
    // TODO: Method 'SetDocString'
    // TODO: Method 'SetHelpContext'
    // TODO: Method 'SetVersion'
    // TODO: Method 'AddRefTypeInfo'
    // TODO: Method 'AddFuncDesc'
    // TODO: Method 'AddImplType'
    // TODO: Method 'SetImplTypeFlags'
    // TODO: Method 'SetAlignment'
    // TODO: Method 'SetSchema'
    // TODO: Method 'AddVarDesc'
    // TODO: Method 'SetFuncAndParamNames'
    // TODO: Method 'SetVarName'
    // TODO: Method 'SetTypeDescAlias'
    // TODO: Method 'DefineFuncAsDllEntry'
    // TODO: Method 'SetFuncDocString'
    // TODO: Method 'SetVarDocString'
    // TODO: Method 'SetFuncHelpContext'
    // TODO: Method 'SetVarHelpContext'
    // TODO: Method 'SetMops'
    // TODO: Method 'SetTypeIdldesc'
    // TODO: Method 'LayOut'
};
// --------------------------------------------------------
// Type: ICreateTypeInfo2
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ICreateTypeInfo2 = *opaque{
    // TODO: Method 'DeleteFuncDesc'
    // TODO: Method 'DeleteFuncDescByMemId'
    // TODO: Method 'DeleteVarDesc'
    // TODO: Method 'DeleteVarDescByMemId'
    // TODO: Method 'DeleteImplType'
    // TODO: Method 'SetCustData'
    // TODO: Method 'SetFuncCustData'
    // TODO: Method 'SetParamCustData'
    // TODO: Method 'SetVarCustData'
    // TODO: Method 'SetImplTypeCustData'
    // TODO: Method 'SetHelpStringContext'
    // TODO: Method 'SetFuncHelpStringContext'
    // TODO: Method 'SetVarHelpStringContext'
    // TODO: Method 'Invalidate'
    // TODO: Method 'SetName'
};
// --------------------------------------------------------
// Type: ICreateTypeLib
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ICreateTypeLib = *opaque{
    // TODO: Method 'CreateTypeInfo'
    // TODO: Method 'SetName'
    // TODO: Method 'SetVersion'
    // TODO: Method 'SetGuid'
    // TODO: Method 'SetDocString'
    // TODO: Method 'SetHelpFileName'
    // TODO: Method 'SetHelpContext'
    // TODO: Method 'SetLcid'
    // TODO: Method 'SetLibFlags'
    // TODO: Method 'SaveAllChanges'
};
// --------------------------------------------------------
// Type: ICreateTypeLib2
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ICreateTypeLib2 = *opaque{
    // TODO: Method 'DeleteTypeInfo'
    // TODO: Method 'SetCustData'
    // TODO: Method 'SetHelpStringContext'
    // TODO: Method 'SetHelpStringDll'
};
// --------------------------------------------------------
// Type: IDispatch
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IDispatch = *opaque{
    // TODO: Method 'GetTypeInfoCount'
    // TODO: Method 'GetTypeInfo'
    // TODO: Method 'GetIDsOfNames'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: IEnumVARIANT
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IEnumVARIANT = *opaque{
    // TODO: Method 'Next'
    // TODO: Method 'Skip'
    // TODO: Method 'Reset'
    // TODO: Method 'Clone'
};
// --------------------------------------------------------
// Type: DESCKIND
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const DESCKIND = *opaque{
};
// --------------------------------------------------------
// Type: BINDPTR
// TypeLayoutAttr: explicit
// not generating the actual code for this type because it has an explicit layout
pub const BINDPTR = *opaque{
};
// --------------------------------------------------------
// Type: ITypeComp
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ITypeComp = *opaque{
    // TODO: Method 'Bind'
    // TODO: Method 'BindType'
};
// --------------------------------------------------------
// Type: ITypeInfo
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ITypeInfo = *opaque{
    // TODO: Method 'GetTypeAttr'
    // TODO: Method 'GetTypeComp'
    // TODO: Method 'GetFuncDesc'
    // TODO: Method 'GetVarDesc'
    // TODO: Method 'GetNames'
    // TODO: Method 'GetRefTypeOfImplType'
    // TODO: Method 'GetImplTypeFlags'
    // TODO: Method 'GetIDsOfNames'
    // TODO: Method 'Invoke'
    // TODO: Method 'GetDocumentation'
    // TODO: Method 'GetDllEntry'
    // TODO: Method 'GetRefTypeInfo'
    // TODO: Method 'AddressOfMember'
    // TODO: Method 'CreateInstance'
    // TODO: Method 'GetMops'
    // TODO: Method 'GetContainingTypeLib'
    // TODO: Method 'ReleaseTypeAttr'
    // TODO: Method 'ReleaseFuncDesc'
    // TODO: Method 'ReleaseVarDesc'
};
// --------------------------------------------------------
// Type: ITypeInfo2
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ITypeInfo2 = *opaque{
    // TODO: Method 'GetTypeKind'
    // TODO: Method 'GetTypeFlags'
    // TODO: Method 'GetFuncIndexOfMemId'
    // TODO: Method 'GetVarIndexOfMemId'
    // TODO: Method 'GetCustData'
    // TODO: Method 'GetFuncCustData'
    // TODO: Method 'GetParamCustData'
    // TODO: Method 'GetVarCustData'
    // TODO: Method 'GetImplTypeCustData'
    // TODO: Method 'GetDocumentation2'
    // TODO: Method 'GetAllCustData'
    // TODO: Method 'GetAllFuncCustData'
    // TODO: Method 'GetAllParamCustData'
    // TODO: Method 'GetAllVarCustData'
    // TODO: Method 'GetAllImplTypeCustData'
};
// --------------------------------------------------------
// Type: SYSKIND
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const SYSKIND = *opaque{
};
// --------------------------------------------------------
// Type: LIBFLAGS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const LIBFLAGS = *opaque{
};
// --------------------------------------------------------
// Type: TLIBATTR
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TLIBATTR = extern struct {
    guid: Guid,
    lcid: u32,
    syskind: SYSKIND,
    wMajorVerNum: u16,
    wMinorVerNum: u16,
    wLibFlags: u16,
};
// --------------------------------------------------------
// Type: ITypeLib
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ITypeLib = *opaque{
    // TODO: Method 'GetTypeInfoCount'
    // TODO: Method 'GetTypeInfo'
    // TODO: Method 'GetTypeInfoType'
    // TODO: Method 'GetTypeInfoOfGuid'
    // TODO: Method 'GetLibAttr'
    // TODO: Method 'GetTypeComp'
    // TODO: Method 'GetDocumentation'
    // TODO: Method 'IsName'
    // TODO: Method 'FindName'
    // TODO: Method 'ReleaseTLibAttr'
};
// --------------------------------------------------------
// Type: ITypeLib2
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ITypeLib2 = *opaque{
    // TODO: Method 'GetCustData'
    // TODO: Method 'GetLibStatistics'
    // TODO: Method 'GetDocumentation2'
    // TODO: Method 'GetAllCustData'
};
// --------------------------------------------------------
// Type: CHANGEKIND
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const CHANGEKIND = *opaque{
};
// --------------------------------------------------------
// Type: ITypeChangeEvents
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ITypeChangeEvents = *opaque{
    // TODO: Method 'RequestTypeChange'
    // TODO: Method 'AfterTypeChange'
};
// --------------------------------------------------------
// Type: IErrorInfo
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IErrorInfo = *opaque{
    // TODO: Method 'GetGUID'
    // TODO: Method 'GetSource'
    // TODO: Method 'GetDescription'
    // TODO: Method 'GetHelpFile'
    // TODO: Method 'GetHelpContext'
};
// --------------------------------------------------------
// Type: ICreateErrorInfo
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ICreateErrorInfo = *opaque{
    // TODO: Method 'SetGUID'
    // TODO: Method 'SetSource'
    // TODO: Method 'SetDescription'
    // TODO: Method 'SetHelpFile'
    // TODO: Method 'SetHelpContext'
};
// --------------------------------------------------------
// Type: ISupportErrorInfo
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ISupportErrorInfo = *opaque{
    // TODO: Method 'InterfaceSupportsErrorInfo'
};
// --------------------------------------------------------
// Type: ITypeFactory
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ITypeFactory = *opaque{
    // TODO: Method 'CreateFromTypeInfo'
};
// --------------------------------------------------------
// Type: ITypeMarshal
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ITypeMarshal = *opaque{
    // TODO: Method 'Size'
    // TODO: Method 'Marshal'
    // TODO: Method 'Unmarshal'
    // TODO: Method 'Free'
};
// --------------------------------------------------------
// Type: IRecordInfo
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IRecordInfo = *opaque{
    // TODO: Method 'RecordInit'
    // TODO: Method 'RecordClear'
    // TODO: Method 'RecordCopy'
    // TODO: Method 'GetGuid'
    // TODO: Method 'GetName'
    // TODO: Method 'GetSize'
    // TODO: Method 'GetTypeInfo'
    // TODO: Method 'GetField'
    // TODO: Method 'GetFieldNoCopy'
    // TODO: Method 'PutField'
    // TODO: Method 'PutFieldNoCopy'
    // TODO: Method 'GetFieldNames'
    // TODO: Method 'IsMatchingType'
    // TODO: Method 'RecordCreate'
    // TODO: Method 'RecordCreateCopy'
    // TODO: Method 'RecordDestroy'
};
// --------------------------------------------------------
// Type: IErrorLog
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IErrorLog = *opaque{
    // TODO: Method 'AddError'
};
// --------------------------------------------------------
// Type: IPropertyBag
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IPropertyBag = *opaque{
    // TODO: Method 'Read'
    // TODO: Method 'Write'
};
// --------------------------------------------------------
// Type: ITypeLibRegistrationReader
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ITypeLibRegistrationReader = *opaque{
    // TODO: Method 'EnumTypeLibRegistrations'
};
// --------------------------------------------------------
// Type: ITypeLibRegistration
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ITypeLibRegistration = *opaque{
    // TODO: Method 'GetGuid'
    // TODO: Method 'GetVersion'
    // TODO: Method 'GetLcid'
    // TODO: Method 'GetWin32Path'
    // TODO: Method 'GetWin64Path'
    // TODO: Method 'GetDisplayName'
    // TODO: Method 'GetFlags'
    // TODO: Method 'GetHelpDir'
};
// --------------------------------------------------------
// Type: NUMPARSE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NUMPARSE = extern struct {
    cDig: i32,
    dwInFlags: u32,
    dwOutFlags: u32,
    cchUsed: i32,
    nBaseShift: i32,
    nPwr10: i32,
};
// --------------------------------------------------------
// Type: UDATE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const UDATE = extern struct {
    st: SYSTEMTIME,
    wDayOfYear: u16,
};
// --------------------------------------------------------
// Type: REGKIND
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const REGKIND = *opaque{
};
// --------------------------------------------------------
// Type: PARAMDATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PARAMDATA = extern struct {
    szName: ?*u16,
    vt: u16,
};
// --------------------------------------------------------
// Type: METHODDATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const METHODDATA = extern struct {
    szName: ?*u16,
    ppdata: ?*PARAMDATA,
    dispid: i32,
    iMeth: u32,
    cc: CALLCONV,
    cArgs: u32,
    wFlags: u16,
    vtReturn: u16,
};
// --------------------------------------------------------
// Type: INTERFACEDATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const INTERFACEDATA = extern struct {
    pmethdata: ?*METHODDATA,
    cMembers: u32,
};
// --------------------------------------------------------
// Type: WiaDevMgr
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const WiaDevMgr = opaque {
};
// --------------------------------------------------------
// Type: WiaLog
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const WiaLog = opaque {
};
// --------------------------------------------------------
// Type: WIA_RAW_HEADER
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const WIA_RAW_HEADER = extern struct {
    Tag: u32,
    Version: u32,
    HeaderSize: u32,
    XRes: u32,
    YRes: u32,
    XExtent: u32,
    YExtent: u32,
    BytesPerLine: u32,
    BitsPerPixel: u32,
    ChannelsPerPixel: u32,
    DataType: u32,
    BitsPerChannel: ?[*]u8,
    Compression: u32,
    PhotometricInterp: u32,
    LineOrder: u32,
    RawDataOffset: u32,
    RawDataSize: u32,
    PaletteOffset: u32,
    PaletteSize: u32,
};
// --------------------------------------------------------
// Type: WIA_BARCODE_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const WIA_BARCODE_INFO = extern struct {
    Size: u32,
    Type: u32,
    Page: u32,
    Confidence: u32,
    XOffset: u32,
    YOffset: u32,
    Rotation: u32,
    Length: u32,
    Text: ?[*]u16,
};
// --------------------------------------------------------
// Type: WIA_BARCODES
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const WIA_BARCODES = extern struct {
    Tag: u32,
    Version: u32,
    Size: u32,
    Count: u32,
    Barcodes: ?[*]WIA_BARCODE_INFO,
};
// --------------------------------------------------------
// Type: WIA_PATCH_CODE_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const WIA_PATCH_CODE_INFO = extern struct {
    Type: u32,
};
// --------------------------------------------------------
// Type: WIA_PATCH_CODES
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const WIA_PATCH_CODES = extern struct {
    Tag: u32,
    Version: u32,
    Size: u32,
    Count: u32,
    PatchCodes: ?[*]WIA_PATCH_CODE_INFO,
};
// --------------------------------------------------------
// Type: WIA_MICR_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const WIA_MICR_INFO = extern struct {
    Size: u32,
    Page: u32,
    Length: u32,
    Text: ?[*]u16,
};
// --------------------------------------------------------
// Type: WIA_MICR
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const WIA_MICR = extern struct {
    Tag: u32,
    Version: u32,
    Size: u32,
    Placeholder: u16,
    Reserved: u16,
    Count: u32,
    Micr: ?[*]WIA_MICR_INFO,
};
// --------------------------------------------------------
// Type: IDispatchEx
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IDispatchEx = *opaque{
    // TODO: Method 'GetDispID'
    // TODO: Method 'InvokeEx'
    // TODO: Method 'DeleteMemberByName'
    // TODO: Method 'DeleteMemberByDispID'
    // TODO: Method 'GetMemberProperties'
    // TODO: Method 'GetMemberName'
    // TODO: Method 'GetNextDispID'
    // TODO: Method 'GetNameSpaceParent'
};
// --------------------------------------------------------
// Type: IDispError
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IDispError = *opaque{
    // TODO: Method 'QueryErrorInfo'
    // TODO: Method 'GetNext'
    // TODO: Method 'GetHresult'
    // TODO: Method 'GetSource'
    // TODO: Method 'GetHelpInfo'
    // TODO: Method 'GetDescription'
};
// --------------------------------------------------------
// Type: IVariantChangeType
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IVariantChangeType = *opaque{
    // TODO: Method 'ChangeType'
};
// --------------------------------------------------------
// Type: IObjectIdentity
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IObjectIdentity = *opaque{
    // TODO: Method 'IsEqualObject'
};
// --------------------------------------------------------
// Type: ICanHandleException
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ICanHandleException = *opaque{
    // TODO: Method 'CanHandleException'
};
// --------------------------------------------------------
// Type: IProvideRuntimeContext
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IProvideRuntimeContext = *opaque{
    // TODO: Method 'GetCurrentSourceContext'
};
// --------------------------------------------------------
// Type: BSTR
// TypeLayoutAttr: sequential
// RAIIFree 'SysFreeString' (TODO: can we use this information?)
pub const BSTR = ?*opaque{};
// --------------------------------------------------------
// Type: VARENUM
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const VARENUM = *opaque{
};

//
// functions
//

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn BSTR_UserSize(
    param0: ?*u32,
    param1: u32,
    param2: ?*BSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn BSTR_UserMarshal(
    param0: ?*u32,
    param1: ?*u8,
    param2: ?*BSTR,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn BSTR_UserUnmarshal(
    param0: ?*u32,
    param1: ?*u8,
    param2: ?*BSTR,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn BSTR_UserFree(
    param0: ?*u32,
    param1: ?*BSTR,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn BSTR_UserSize64(
    param0: ?*u32,
    param1: u32,
    param2: ?*BSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn BSTR_UserMarshal64(
    param0: ?*u32,
    param1: ?*u8,
    param2: ?*BSTR,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn BSTR_UserUnmarshal64(
    param0: ?*u32,
    param1: ?*u8,
    param2: ?*BSTR,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn BSTR_UserFree64(
    param0: ?*u32,
    param1: ?*BSTR,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn HWND_UserSize(
    param0: ?*u32,
    param1: u32,
    param2: ?*HWND,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn HWND_UserMarshal(
    param0: ?*u32,
    param1: ?*u8,
    param2: ?*HWND,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn HWND_UserUnmarshal(
    param0: ?*u32,
    param1: ?*u8,
    param2: ?*HWND,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn HWND_UserFree(
    param0: ?*u32,
    param1: ?*HWND,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn HWND_UserSize64(
    param0: ?*u32,
    param1: u32,
    param2: ?*HWND,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn HWND_UserMarshal64(
    param0: ?*u32,
    param1: ?*u8,
    param2: ?*HWND,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn HWND_UserUnmarshal64(
    param0: ?*u32,
    param1: ?*u8,
    param2: ?*HWND,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn HWND_UserFree64(
    param0: ?*u32,
    param1: ?*HWND,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VARIANT_UserSize(
    param0: ?*u32,
    param1: u32,
    param2: ?*VARIANT,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VARIANT_UserMarshal(
    param0: ?*u32,
    param1: ?*u8,
    param2: ?*VARIANT,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VARIANT_UserUnmarshal(
    param0: ?*u32,
    param1: ?*u8,
    param2: ?*VARIANT,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VARIANT_UserFree(
    param0: ?*u32,
    param1: ?*VARIANT,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VARIANT_UserSize64(
    param0: ?*u32,
    param1: u32,
    param2: ?*VARIANT,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VARIANT_UserMarshal64(
    param0: ?*u32,
    param1: ?*u8,
    param2: ?*VARIANT,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VARIANT_UserUnmarshal64(
    param0: ?*u32,
    param1: ?*u8,
    param2: ?*VARIANT,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VARIANT_UserFree64(
    param0: ?*u32,
    param1: ?*VARIANT,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn LPSAFEARRAY_UserSize(
    param0: ?*u32,
    param1: u32,
    param2: ?*?*SAFEARRAY,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn LPSAFEARRAY_UserMarshal(
    param0: ?*u32,
    param1: ?*u8,
    param2: ?*?*SAFEARRAY,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn LPSAFEARRAY_UserUnmarshal(
    param0: ?*u32,
    param1: ?*u8,
    param2: ?*?*SAFEARRAY,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn LPSAFEARRAY_UserFree(
    param0: ?*u32,
    param1: ?*?*SAFEARRAY,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn LPSAFEARRAY_UserSize64(
    param0: ?*u32,
    param1: u32,
    param2: ?*?*SAFEARRAY,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn LPSAFEARRAY_UserMarshal64(
    param0: ?*u32,
    param1: ?*u8,
    param2: ?*?*SAFEARRAY,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn LPSAFEARRAY_UserUnmarshal64(
    param0: ?*u32,
    param1: ?*u8,
    param2: ?*?*SAFEARRAY,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn LPSAFEARRAY_UserFree64(
    param0: ?*u32,
    param1: ?*?*SAFEARRAY,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn STGMEDIUM_UserSize(
    param0: ?*u32,
    param1: u32,
    param2: ?*STGMEDIUM,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn STGMEDIUM_UserMarshal(
    param0: ?*u32,
    param1: ?*u8,
    param2: ?*STGMEDIUM,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn STGMEDIUM_UserUnmarshal(
    param0: ?*u32,
    param1: ?*u8,
    param2: ?*STGMEDIUM,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn STGMEDIUM_UserFree(
    param0: ?*u32,
    param1: ?*STGMEDIUM,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn STGMEDIUM_UserSize64(
    param0: ?*u32,
    param1: u32,
    param2: ?*STGMEDIUM,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn STGMEDIUM_UserMarshal64(
    param0: ?*u32,
    param1: ?*u8,
    param2: ?*STGMEDIUM,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn STGMEDIUM_UserUnmarshal64(
    param0: ?*u32,
    param1: ?*u8,
    param2: ?*STGMEDIUM,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn STGMEDIUM_UserFree64(
    param0: ?*u32,
    param1: ?*STGMEDIUM,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn OleLoadPictureFile(
    varFileName: VARIANT,
    lplpdispPicture: ?*IDispatch,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn OleLoadPictureFileEx(
    varFileName: VARIANT,
    xSizeDesired: u32,
    ySizeDesired: u32,
    dwFlags: u32,
    lplpdispPicture: ?*IDispatch,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn OleSavePictureFile(
    lpdispPicture: IDispatch,
    bstrFileName: BSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn SysAllocString(
    psz: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BSTR;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn SysReAllocString(
    pbstr: ?*BSTR,
    psz: ?*u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn SysAllocStringLen(
    strIn: ?*u16,
    ui: u32,
) callconv(@import("std").os.windows.WINAPI) BSTR;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn SysReAllocStringLen(
    pbstr: ?*BSTR,
    psz: ?*u16,
    len: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn SysAddRefString(
    bstrString: BSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn SysReleaseString(
    bstrString: BSTR,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn SysFreeString(
    bstrString: BSTR,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn SysStringLen(
    pbstr: BSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn SysStringByteLen(
    bstr: BSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn SysAllocStringByteLen(
    psz: ?*i8,
    len: u32,
) callconv(@import("std").os.windows.WINAPI) BSTR;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn DosDateTimeToVariantTime(
    wDosDate: u16,
    wDosTime: u16,
    pvtime: ?*f64,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VariantTimeToDosDateTime(
    vtime: f64,
    pwDosDate: ?*u16,
    pwDosTime: ?*u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn SystemTimeToVariantTime(
    lpSystemTime: ?*SYSTEMTIME,
    pvtime: ?*f64,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VariantTimeToSystemTime(
    vtime: f64,
    lpSystemTime: ?*SYSTEMTIME,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn SafeArrayAllocDescriptor(
    cDims: u32,
    ppsaOut: ?*?*SAFEARRAY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn SafeArrayAllocDescriptorEx(
    vt: u16,
    cDims: u32,
    ppsaOut: ?*?*SAFEARRAY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn SafeArrayAllocData(
    psa: ?*SAFEARRAY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn SafeArrayCreate(
    vt: u16,
    cDims: u32,
    rgsabound: ?*SAFEARRAYBOUND,
) callconv(@import("std").os.windows.WINAPI) ?*SAFEARRAY;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn SafeArrayCreateEx(
    vt: u16,
    cDims: u32,
    rgsabound: ?*SAFEARRAYBOUND,
    pvExtra: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) ?*SAFEARRAY;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn SafeArrayCopyData(
    psaSource: ?*SAFEARRAY,
    psaTarget: ?*SAFEARRAY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn SafeArrayReleaseDescriptor(
    psa: ?*SAFEARRAY,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn SafeArrayDestroyDescriptor(
    psa: ?*SAFEARRAY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn SafeArrayReleaseData(
    pData: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn SafeArrayDestroyData(
    psa: ?*SAFEARRAY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn SafeArrayAddRef(
    psa: ?*SAFEARRAY,
    ppDataToRelease: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn SafeArrayDestroy(
    psa: ?*SAFEARRAY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn SafeArrayRedim(
    psa: ?*SAFEARRAY,
    psaboundNew: ?*SAFEARRAYBOUND,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn SafeArrayGetDim(
    psa: ?*SAFEARRAY,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn SafeArrayGetElemsize(
    psa: ?*SAFEARRAY,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn SafeArrayGetUBound(
    psa: ?*SAFEARRAY,
    nDim: u32,
    plUbound: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn SafeArrayGetLBound(
    psa: ?*SAFEARRAY,
    nDim: u32,
    plLbound: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn SafeArrayLock(
    psa: ?*SAFEARRAY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn SafeArrayUnlock(
    psa: ?*SAFEARRAY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn SafeArrayAccessData(
    psa: ?*SAFEARRAY,
    ppvData: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn SafeArrayUnaccessData(
    psa: ?*SAFEARRAY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn SafeArrayGetElement(
    psa: ?*SAFEARRAY,
    rgIndices: ?*i32,
    pv: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn SafeArrayPutElement(
    psa: ?*SAFEARRAY,
    rgIndices: ?*i32,
    pv: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn SafeArrayCopy(
    psa: ?*SAFEARRAY,
    ppsaOut: ?*?*SAFEARRAY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn SafeArrayPtrOfIndex(
    psa: ?*SAFEARRAY,
    rgIndices: ?*i32,
    ppvData: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn SafeArraySetRecordInfo(
    psa: ?*SAFEARRAY,
    prinfo: IRecordInfo,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn SafeArrayGetRecordInfo(
    psa: ?*SAFEARRAY,
    prinfo: ?*IRecordInfo,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn SafeArraySetIID(
    psa: ?*SAFEARRAY,
    guid: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn SafeArrayGetIID(
    psa: ?*SAFEARRAY,
    pguid: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn SafeArrayGetVartype(
    psa: ?*SAFEARRAY,
    pvt: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn SafeArrayCreateVector(
    vt: u16,
    lLbound: i32,
    cElements: u32,
) callconv(@import("std").os.windows.WINAPI) ?*SAFEARRAY;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn SafeArrayCreateVectorEx(
    vt: u16,
    lLbound: i32,
    cElements: u32,
    pvExtra: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) ?*SAFEARRAY;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VariantInit(
    pvarg: ?*VARIANT,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VariantClear(
    pvarg: ?*VARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VariantCopy(
    pvargDest: ?*VARIANT,
    pvargSrc: ?*VARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VariantCopyInd(
    pvarDest: ?*VARIANT,
    pvargSrc: ?*VARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VariantChangeType(
    pvargDest: ?*VARIANT,
    pvarSrc: ?*VARIANT,
    wFlags: u16,
    vt: u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VariantChangeTypeEx(
    pvargDest: ?*VARIANT,
    pvarSrc: ?*VARIANT,
    lcid: u32,
    wFlags: u16,
    vt: u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VectorFromBstr(
    bstr: BSTR,
    ppsa: ?*?*SAFEARRAY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn BstrFromVector(
    psa: ?*SAFEARRAY,
    pbstr: ?*BSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarUI1FromI2(
    sIn: i16,
    pbOut: ?*u8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarUI1FromI4(
    lIn: i32,
    pbOut: ?*u8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarUI1FromI8(
    i64In: i64,
    pbOut: ?*u8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarUI1FromR4(
    fltIn: f32,
    pbOut: ?*u8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarUI1FromR8(
    dblIn: f64,
    pbOut: ?*u8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarUI1FromCy(
    cyIn: CY,
    pbOut: ?*u8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarUI1FromDate(
    dateIn: f64,
    pbOut: ?*u8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarUI1FromStr(
    strIn: ?*u16,
    lcid: u32,
    dwFlags: u32,
    pbOut: ?*u8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarUI1FromDisp(
    pdispIn: IDispatch,
    lcid: u32,
    pbOut: ?*u8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarUI1FromBool(
    boolIn: i16,
    pbOut: ?*u8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarUI1FromI1(
    cIn: i8,
    pbOut: ?*u8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarUI1FromUI2(
    uiIn: u16,
    pbOut: ?*u8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarUI1FromUI4(
    ulIn: u32,
    pbOut: ?*u8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarUI1FromUI8(
    ui64In: u64,
    pbOut: ?*u8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarUI1FromDec(
    pdecIn: ?*DECIMAL,
    pbOut: ?*u8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarI2FromUI1(
    bIn: u8,
    psOut: ?*i16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarI2FromI4(
    lIn: i32,
    psOut: ?*i16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarI2FromI8(
    i64In: i64,
    psOut: ?*i16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarI2FromR4(
    fltIn: f32,
    psOut: ?*i16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarI2FromR8(
    dblIn: f64,
    psOut: ?*i16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarI2FromCy(
    cyIn: CY,
    psOut: ?*i16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarI2FromDate(
    dateIn: f64,
    psOut: ?*i16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarI2FromStr(
    strIn: ?*u16,
    lcid: u32,
    dwFlags: u32,
    psOut: ?*i16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarI2FromDisp(
    pdispIn: IDispatch,
    lcid: u32,
    psOut: ?*i16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarI2FromBool(
    boolIn: i16,
    psOut: ?*i16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarI2FromI1(
    cIn: i8,
    psOut: ?*i16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarI2FromUI2(
    uiIn: u16,
    psOut: ?*i16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarI2FromUI4(
    ulIn: u32,
    psOut: ?*i16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarI2FromUI8(
    ui64In: u64,
    psOut: ?*i16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarI2FromDec(
    pdecIn: ?*DECIMAL,
    psOut: ?*i16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarI4FromUI1(
    bIn: u8,
    plOut: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarI4FromI2(
    sIn: i16,
    plOut: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarI4FromI8(
    i64In: i64,
    plOut: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarI4FromR4(
    fltIn: f32,
    plOut: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarI4FromR8(
    dblIn: f64,
    plOut: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarI4FromCy(
    cyIn: CY,
    plOut: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarI4FromDate(
    dateIn: f64,
    plOut: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarI4FromStr(
    strIn: ?*u16,
    lcid: u32,
    dwFlags: u32,
    plOut: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarI4FromDisp(
    pdispIn: IDispatch,
    lcid: u32,
    plOut: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarI4FromBool(
    boolIn: i16,
    plOut: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarI4FromI1(
    cIn: i8,
    plOut: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarI4FromUI2(
    uiIn: u16,
    plOut: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarI4FromUI4(
    ulIn: u32,
    plOut: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarI4FromUI8(
    ui64In: u64,
    plOut: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarI4FromDec(
    pdecIn: ?*DECIMAL,
    plOut: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarI8FromUI1(
    bIn: u8,
    pi64Out: ?*i64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarI8FromI2(
    sIn: i16,
    pi64Out: ?*i64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarI8FromR4(
    fltIn: f32,
    pi64Out: ?*i64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarI8FromR8(
    dblIn: f64,
    pi64Out: ?*i64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarI8FromCy(
    cyIn: CY,
    pi64Out: ?*i64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarI8FromDate(
    dateIn: f64,
    pi64Out: ?*i64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarI8FromStr(
    strIn: ?*u16,
    lcid: u32,
    dwFlags: u32,
    pi64Out: ?*i64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarI8FromDisp(
    pdispIn: IDispatch,
    lcid: u32,
    pi64Out: ?*i64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarI8FromBool(
    boolIn: i16,
    pi64Out: ?*i64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarI8FromI1(
    cIn: i8,
    pi64Out: ?*i64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarI8FromUI2(
    uiIn: u16,
    pi64Out: ?*i64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarI8FromUI4(
    ulIn: u32,
    pi64Out: ?*i64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarI8FromUI8(
    ui64In: u64,
    pi64Out: ?*i64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarI8FromDec(
    pdecIn: ?*DECIMAL,
    pi64Out: ?*i64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarR4FromUI1(
    bIn: u8,
    pfltOut: ?*f32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarR4FromI2(
    sIn: i16,
    pfltOut: ?*f32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarR4FromI4(
    lIn: i32,
    pfltOut: ?*f32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarR4FromI8(
    i64In: i64,
    pfltOut: ?*f32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarR4FromR8(
    dblIn: f64,
    pfltOut: ?*f32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarR4FromCy(
    cyIn: CY,
    pfltOut: ?*f32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarR4FromDate(
    dateIn: f64,
    pfltOut: ?*f32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarR4FromStr(
    strIn: ?*u16,
    lcid: u32,
    dwFlags: u32,
    pfltOut: ?*f32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarR4FromDisp(
    pdispIn: IDispatch,
    lcid: u32,
    pfltOut: ?*f32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarR4FromBool(
    boolIn: i16,
    pfltOut: ?*f32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarR4FromI1(
    cIn: i8,
    pfltOut: ?*f32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarR4FromUI2(
    uiIn: u16,
    pfltOut: ?*f32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarR4FromUI4(
    ulIn: u32,
    pfltOut: ?*f32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarR4FromUI8(
    ui64In: u64,
    pfltOut: ?*f32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarR4FromDec(
    pdecIn: ?*DECIMAL,
    pfltOut: ?*f32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarR8FromUI1(
    bIn: u8,
    pdblOut: ?*f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarR8FromI2(
    sIn: i16,
    pdblOut: ?*f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarR8FromI4(
    lIn: i32,
    pdblOut: ?*f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarR8FromI8(
    i64In: i64,
    pdblOut: ?*f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarR8FromR4(
    fltIn: f32,
    pdblOut: ?*f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarR8FromCy(
    cyIn: CY,
    pdblOut: ?*f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarR8FromDate(
    dateIn: f64,
    pdblOut: ?*f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarR8FromStr(
    strIn: ?*u16,
    lcid: u32,
    dwFlags: u32,
    pdblOut: ?*f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarR8FromDisp(
    pdispIn: IDispatch,
    lcid: u32,
    pdblOut: ?*f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarR8FromBool(
    boolIn: i16,
    pdblOut: ?*f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarR8FromI1(
    cIn: i8,
    pdblOut: ?*f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarR8FromUI2(
    uiIn: u16,
    pdblOut: ?*f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarR8FromUI4(
    ulIn: u32,
    pdblOut: ?*f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarR8FromUI8(
    ui64In: u64,
    pdblOut: ?*f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarR8FromDec(
    pdecIn: ?*DECIMAL,
    pdblOut: ?*f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarDateFromUI1(
    bIn: u8,
    pdateOut: ?*f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarDateFromI2(
    sIn: i16,
    pdateOut: ?*f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarDateFromI4(
    lIn: i32,
    pdateOut: ?*f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarDateFromI8(
    i64In: i64,
    pdateOut: ?*f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarDateFromR4(
    fltIn: f32,
    pdateOut: ?*f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarDateFromR8(
    dblIn: f64,
    pdateOut: ?*f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarDateFromCy(
    cyIn: CY,
    pdateOut: ?*f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarDateFromStr(
    strIn: ?*u16,
    lcid: u32,
    dwFlags: u32,
    pdateOut: ?*f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarDateFromDisp(
    pdispIn: IDispatch,
    lcid: u32,
    pdateOut: ?*f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarDateFromBool(
    boolIn: i16,
    pdateOut: ?*f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarDateFromI1(
    cIn: i8,
    pdateOut: ?*f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarDateFromUI2(
    uiIn: u16,
    pdateOut: ?*f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarDateFromUI4(
    ulIn: u32,
    pdateOut: ?*f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarDateFromUI8(
    ui64In: u64,
    pdateOut: ?*f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarDateFromDec(
    pdecIn: ?*DECIMAL,
    pdateOut: ?*f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarCyFromUI1(
    bIn: u8,
    pcyOut: ?*CY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarCyFromI2(
    sIn: i16,
    pcyOut: ?*CY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarCyFromI4(
    lIn: i32,
    pcyOut: ?*CY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarCyFromI8(
    i64In: i64,
    pcyOut: ?*CY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarCyFromR4(
    fltIn: f32,
    pcyOut: ?*CY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarCyFromR8(
    dblIn: f64,
    pcyOut: ?*CY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarCyFromDate(
    dateIn: f64,
    pcyOut: ?*CY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarCyFromStr(
    strIn: ?*u16,
    lcid: u32,
    dwFlags: u32,
    pcyOut: ?*CY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarCyFromDisp(
    pdispIn: IDispatch,
    lcid: u32,
    pcyOut: ?*CY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarCyFromBool(
    boolIn: i16,
    pcyOut: ?*CY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarCyFromI1(
    cIn: i8,
    pcyOut: ?*CY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarCyFromUI2(
    uiIn: u16,
    pcyOut: ?*CY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarCyFromUI4(
    ulIn: u32,
    pcyOut: ?*CY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarCyFromUI8(
    ui64In: u64,
    pcyOut: ?*CY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarCyFromDec(
    pdecIn: ?*DECIMAL,
    pcyOut: ?*CY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarBstrFromUI1(
    bVal: u8,
    lcid: u32,
    dwFlags: u32,
    pbstrOut: ?*BSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarBstrFromI2(
    iVal: i16,
    lcid: u32,
    dwFlags: u32,
    pbstrOut: ?*BSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarBstrFromI4(
    lIn: i32,
    lcid: u32,
    dwFlags: u32,
    pbstrOut: ?*BSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarBstrFromI8(
    i64In: i64,
    lcid: u32,
    dwFlags: u32,
    pbstrOut: ?*BSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarBstrFromR4(
    fltIn: f32,
    lcid: u32,
    dwFlags: u32,
    pbstrOut: ?*BSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarBstrFromR8(
    dblIn: f64,
    lcid: u32,
    dwFlags: u32,
    pbstrOut: ?*BSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarBstrFromCy(
    cyIn: CY,
    lcid: u32,
    dwFlags: u32,
    pbstrOut: ?*BSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarBstrFromDate(
    dateIn: f64,
    lcid: u32,
    dwFlags: u32,
    pbstrOut: ?*BSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarBstrFromDisp(
    pdispIn: IDispatch,
    lcid: u32,
    dwFlags: u32,
    pbstrOut: ?*BSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarBstrFromBool(
    boolIn: i16,
    lcid: u32,
    dwFlags: u32,
    pbstrOut: ?*BSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarBstrFromI1(
    cIn: i8,
    lcid: u32,
    dwFlags: u32,
    pbstrOut: ?*BSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarBstrFromUI2(
    uiIn: u16,
    lcid: u32,
    dwFlags: u32,
    pbstrOut: ?*BSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarBstrFromUI4(
    ulIn: u32,
    lcid: u32,
    dwFlags: u32,
    pbstrOut: ?*BSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarBstrFromUI8(
    ui64In: u64,
    lcid: u32,
    dwFlags: u32,
    pbstrOut: ?*BSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarBstrFromDec(
    pdecIn: ?*DECIMAL,
    lcid: u32,
    dwFlags: u32,
    pbstrOut: ?*BSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarBoolFromUI1(
    bIn: u8,
    pboolOut: ?*i16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarBoolFromI2(
    sIn: i16,
    pboolOut: ?*i16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarBoolFromI4(
    lIn: i32,
    pboolOut: ?*i16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarBoolFromI8(
    i64In: i64,
    pboolOut: ?*i16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarBoolFromR4(
    fltIn: f32,
    pboolOut: ?*i16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarBoolFromR8(
    dblIn: f64,
    pboolOut: ?*i16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarBoolFromDate(
    dateIn: f64,
    pboolOut: ?*i16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarBoolFromCy(
    cyIn: CY,
    pboolOut: ?*i16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarBoolFromStr(
    strIn: ?*u16,
    lcid: u32,
    dwFlags: u32,
    pboolOut: ?*i16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarBoolFromDisp(
    pdispIn: IDispatch,
    lcid: u32,
    pboolOut: ?*i16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarBoolFromI1(
    cIn: i8,
    pboolOut: ?*i16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarBoolFromUI2(
    uiIn: u16,
    pboolOut: ?*i16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarBoolFromUI4(
    ulIn: u32,
    pboolOut: ?*i16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarBoolFromUI8(
    i64In: u64,
    pboolOut: ?*i16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarBoolFromDec(
    pdecIn: ?*DECIMAL,
    pboolOut: ?*i16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarI1FromUI1(
    bIn: u8,
    pcOut: ?*i8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarI1FromI2(
    uiIn: i16,
    pcOut: ?*i8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarI1FromI4(
    lIn: i32,
    pcOut: ?*i8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarI1FromI8(
    i64In: i64,
    pcOut: ?*i8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarI1FromR4(
    fltIn: f32,
    pcOut: ?*i8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarI1FromR8(
    dblIn: f64,
    pcOut: ?*i8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarI1FromDate(
    dateIn: f64,
    pcOut: ?*i8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarI1FromCy(
    cyIn: CY,
    pcOut: ?*i8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarI1FromStr(
    strIn: ?*u16,
    lcid: u32,
    dwFlags: u32,
    pcOut: ?*i8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarI1FromDisp(
    pdispIn: IDispatch,
    lcid: u32,
    pcOut: ?*i8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarI1FromBool(
    boolIn: i16,
    pcOut: ?*i8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarI1FromUI2(
    uiIn: u16,
    pcOut: ?*i8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarI1FromUI4(
    ulIn: u32,
    pcOut: ?*i8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarI1FromUI8(
    i64In: u64,
    pcOut: ?*i8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarI1FromDec(
    pdecIn: ?*DECIMAL,
    pcOut: ?*i8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarUI2FromUI1(
    bIn: u8,
    puiOut: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarUI2FromI2(
    uiIn: i16,
    puiOut: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarUI2FromI4(
    lIn: i32,
    puiOut: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarUI2FromI8(
    i64In: i64,
    puiOut: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarUI2FromR4(
    fltIn: f32,
    puiOut: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarUI2FromR8(
    dblIn: f64,
    puiOut: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarUI2FromDate(
    dateIn: f64,
    puiOut: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarUI2FromCy(
    cyIn: CY,
    puiOut: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarUI2FromStr(
    strIn: ?*u16,
    lcid: u32,
    dwFlags: u32,
    puiOut: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarUI2FromDisp(
    pdispIn: IDispatch,
    lcid: u32,
    puiOut: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarUI2FromBool(
    boolIn: i16,
    puiOut: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarUI2FromI1(
    cIn: i8,
    puiOut: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarUI2FromUI4(
    ulIn: u32,
    puiOut: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarUI2FromUI8(
    i64In: u64,
    puiOut: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarUI2FromDec(
    pdecIn: ?*DECIMAL,
    puiOut: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarUI4FromUI1(
    bIn: u8,
    pulOut: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarUI4FromI2(
    uiIn: i16,
    pulOut: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarUI4FromI4(
    lIn: i32,
    pulOut: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarUI4FromI8(
    i64In: i64,
    plOut: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarUI4FromR4(
    fltIn: f32,
    pulOut: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarUI4FromR8(
    dblIn: f64,
    pulOut: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarUI4FromDate(
    dateIn: f64,
    pulOut: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarUI4FromCy(
    cyIn: CY,
    pulOut: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarUI4FromStr(
    strIn: ?*u16,
    lcid: u32,
    dwFlags: u32,
    pulOut: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarUI4FromDisp(
    pdispIn: IDispatch,
    lcid: u32,
    pulOut: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarUI4FromBool(
    boolIn: i16,
    pulOut: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarUI4FromI1(
    cIn: i8,
    pulOut: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarUI4FromUI2(
    uiIn: u16,
    pulOut: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarUI4FromUI8(
    ui64In: u64,
    plOut: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarUI4FromDec(
    pdecIn: ?*DECIMAL,
    pulOut: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarUI8FromUI1(
    bIn: u8,
    pi64Out: ?*u64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarUI8FromI2(
    sIn: i16,
    pi64Out: ?*u64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarUI8FromI8(
    ui64In: i64,
    pi64Out: ?*u64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarUI8FromR4(
    fltIn: f32,
    pi64Out: ?*u64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarUI8FromR8(
    dblIn: f64,
    pi64Out: ?*u64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarUI8FromCy(
    cyIn: CY,
    pi64Out: ?*u64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarUI8FromDate(
    dateIn: f64,
    pi64Out: ?*u64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarUI8FromStr(
    strIn: ?*u16,
    lcid: u32,
    dwFlags: u32,
    pi64Out: ?*u64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarUI8FromDisp(
    pdispIn: IDispatch,
    lcid: u32,
    pi64Out: ?*u64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarUI8FromBool(
    boolIn: i16,
    pi64Out: ?*u64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarUI8FromI1(
    cIn: i8,
    pi64Out: ?*u64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarUI8FromUI2(
    uiIn: u16,
    pi64Out: ?*u64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarUI8FromUI4(
    ulIn: u32,
    pi64Out: ?*u64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarUI8FromDec(
    pdecIn: ?*DECIMAL,
    pi64Out: ?*u64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarDecFromUI1(
    bIn: u8,
    pdecOut: ?*DECIMAL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarDecFromI2(
    uiIn: i16,
    pdecOut: ?*DECIMAL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarDecFromI4(
    lIn: i32,
    pdecOut: ?*DECIMAL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarDecFromI8(
    i64In: i64,
    pdecOut: ?*DECIMAL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarDecFromR4(
    fltIn: f32,
    pdecOut: ?*DECIMAL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarDecFromR8(
    dblIn: f64,
    pdecOut: ?*DECIMAL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarDecFromDate(
    dateIn: f64,
    pdecOut: ?*DECIMAL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarDecFromCy(
    cyIn: CY,
    pdecOut: ?*DECIMAL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarDecFromStr(
    strIn: ?*u16,
    lcid: u32,
    dwFlags: u32,
    pdecOut: ?*DECIMAL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarDecFromDisp(
    pdispIn: IDispatch,
    lcid: u32,
    pdecOut: ?*DECIMAL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarDecFromBool(
    boolIn: i16,
    pdecOut: ?*DECIMAL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarDecFromI1(
    cIn: i8,
    pdecOut: ?*DECIMAL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarDecFromUI2(
    uiIn: u16,
    pdecOut: ?*DECIMAL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarDecFromUI4(
    ulIn: u32,
    pdecOut: ?*DECIMAL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarDecFromUI8(
    ui64In: u64,
    pdecOut: ?*DECIMAL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarParseNumFromStr(
    strIn: ?*u16,
    lcid: u32,
    dwFlags: u32,
    pnumprs: ?*NUMPARSE,
    rgbDig: ?*u8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarNumFromParseNum(
    pnumprs: ?*NUMPARSE,
    rgbDig: ?*u8,
    dwVtBits: u32,
    pvar: ?*VARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarAdd(
    pvarLeft: ?*VARIANT,
    pvarRight: ?*VARIANT,
    pvarResult: ?*VARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarAnd(
    pvarLeft: ?*VARIANT,
    pvarRight: ?*VARIANT,
    pvarResult: ?*VARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarCat(
    pvarLeft: ?*VARIANT,
    pvarRight: ?*VARIANT,
    pvarResult: ?*VARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarDiv(
    pvarLeft: ?*VARIANT,
    pvarRight: ?*VARIANT,
    pvarResult: ?*VARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarEqv(
    pvarLeft: ?*VARIANT,
    pvarRight: ?*VARIANT,
    pvarResult: ?*VARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarIdiv(
    pvarLeft: ?*VARIANT,
    pvarRight: ?*VARIANT,
    pvarResult: ?*VARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarImp(
    pvarLeft: ?*VARIANT,
    pvarRight: ?*VARIANT,
    pvarResult: ?*VARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarMod(
    pvarLeft: ?*VARIANT,
    pvarRight: ?*VARIANT,
    pvarResult: ?*VARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarMul(
    pvarLeft: ?*VARIANT,
    pvarRight: ?*VARIANT,
    pvarResult: ?*VARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarOr(
    pvarLeft: ?*VARIANT,
    pvarRight: ?*VARIANT,
    pvarResult: ?*VARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarPow(
    pvarLeft: ?*VARIANT,
    pvarRight: ?*VARIANT,
    pvarResult: ?*VARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarSub(
    pvarLeft: ?*VARIANT,
    pvarRight: ?*VARIANT,
    pvarResult: ?*VARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarXor(
    pvarLeft: ?*VARIANT,
    pvarRight: ?*VARIANT,
    pvarResult: ?*VARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarAbs(
    pvarIn: ?*VARIANT,
    pvarResult: ?*VARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarFix(
    pvarIn: ?*VARIANT,
    pvarResult: ?*VARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarInt(
    pvarIn: ?*VARIANT,
    pvarResult: ?*VARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarNeg(
    pvarIn: ?*VARIANT,
    pvarResult: ?*VARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarNot(
    pvarIn: ?*VARIANT,
    pvarResult: ?*VARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarRound(
    pvarIn: ?*VARIANT,
    cDecimals: i32,
    pvarResult: ?*VARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarCmp(
    pvarLeft: ?*VARIANT,
    pvarRight: ?*VARIANT,
    lcid: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarDecAdd(
    pdecLeft: ?*DECIMAL,
    pdecRight: ?*DECIMAL,
    pdecResult: ?*DECIMAL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarDecDiv(
    pdecLeft: ?*DECIMAL,
    pdecRight: ?*DECIMAL,
    pdecResult: ?*DECIMAL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarDecMul(
    pdecLeft: ?*DECIMAL,
    pdecRight: ?*DECIMAL,
    pdecResult: ?*DECIMAL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarDecSub(
    pdecLeft: ?*DECIMAL,
    pdecRight: ?*DECIMAL,
    pdecResult: ?*DECIMAL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarDecAbs(
    pdecIn: ?*DECIMAL,
    pdecResult: ?*DECIMAL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarDecFix(
    pdecIn: ?*DECIMAL,
    pdecResult: ?*DECIMAL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarDecInt(
    pdecIn: ?*DECIMAL,
    pdecResult: ?*DECIMAL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarDecNeg(
    pdecIn: ?*DECIMAL,
    pdecResult: ?*DECIMAL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarDecRound(
    pdecIn: ?*DECIMAL,
    cDecimals: i32,
    pdecResult: ?*DECIMAL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarDecCmp(
    pdecLeft: ?*DECIMAL,
    pdecRight: ?*DECIMAL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarDecCmpR8(
    pdecLeft: ?*DECIMAL,
    dblRight: f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarCyAdd(
    cyLeft: CY,
    cyRight: CY,
    pcyResult: ?*CY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarCyMul(
    cyLeft: CY,
    cyRight: CY,
    pcyResult: ?*CY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarCyMulI4(
    cyLeft: CY,
    lRight: i32,
    pcyResult: ?*CY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarCyMulI8(
    cyLeft: CY,
    lRight: i64,
    pcyResult: ?*CY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarCySub(
    cyLeft: CY,
    cyRight: CY,
    pcyResult: ?*CY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarCyAbs(
    cyIn: CY,
    pcyResult: ?*CY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarCyFix(
    cyIn: CY,
    pcyResult: ?*CY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarCyInt(
    cyIn: CY,
    pcyResult: ?*CY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarCyNeg(
    cyIn: CY,
    pcyResult: ?*CY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarCyRound(
    cyIn: CY,
    cDecimals: i32,
    pcyResult: ?*CY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarCyCmp(
    cyLeft: CY,
    cyRight: CY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarCyCmpR8(
    cyLeft: CY,
    dblRight: f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarBstrCat(
    bstrLeft: BSTR,
    bstrRight: BSTR,
    pbstrResult: ?*?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarBstrCmp(
    bstrLeft: BSTR,
    bstrRight: BSTR,
    lcid: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarR8Pow(
    dblLeft: f64,
    dblRight: f64,
    pdblResult: ?*f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarR4CmpR8(
    fltLeft: f32,
    dblRight: f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarR8Round(
    dblIn: f64,
    cDecimals: i32,
    pdblResult: ?*f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarDateFromUdate(
    pudateIn: ?*UDATE,
    dwFlags: u32,
    pdateOut: ?*f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarDateFromUdateEx(
    pudateIn: ?*UDATE,
    lcid: u32,
    dwFlags: u32,
    pdateOut: ?*f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarUdateFromDate(
    dateIn: f64,
    dwFlags: u32,
    pudateOut: ?*UDATE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn GetAltMonthNames(
    lcid: u32,
    prgp: ?*?*?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarFormat(
    pvarIn: ?*VARIANT,
    pstrFormat: ?*u16,
    iFirstDay: i32,
    iFirstWeek: i32,
    dwFlags: u32,
    pbstrOut: ?*BSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarFormatDateTime(
    pvarIn: ?*VARIANT,
    iNamedFormat: i32,
    dwFlags: u32,
    pbstrOut: ?*BSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarFormatNumber(
    pvarIn: ?*VARIANT,
    iNumDig: i32,
    iIncLead: i32,
    iUseParens: i32,
    iGroup: i32,
    dwFlags: u32,
    pbstrOut: ?*BSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarFormatPercent(
    pvarIn: ?*VARIANT,
    iNumDig: i32,
    iIncLead: i32,
    iUseParens: i32,
    iGroup: i32,
    dwFlags: u32,
    pbstrOut: ?*BSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarFormatCurrency(
    pvarIn: ?*VARIANT,
    iNumDig: i32,
    iIncLead: i32,
    iUseParens: i32,
    iGroup: i32,
    dwFlags: u32,
    pbstrOut: ?*BSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarWeekdayName(
    iWeekday: i32,
    fAbbrev: i32,
    iFirstDay: i32,
    dwFlags: u32,
    pbstrOut: ?*BSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarMonthName(
    iMonth: i32,
    fAbbrev: i32,
    dwFlags: u32,
    pbstrOut: ?*BSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarFormatFromTokens(
    pvarIn: ?*VARIANT,
    pstrFormat: ?*u16,
    pbTokCur: ?*u8,
    dwFlags: u32,
    pbstrOut: ?*BSTR,
    lcid: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn VarTokenizeFormatString(
    pstrFormat: ?*u16,
    rgbTok: ?*u8,
    cbTok: i32,
    iFirstDay: i32,
    iFirstWeek: i32,
    lcid: u32,
    pcbActual: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn LHashValOfNameSysA(
    syskind: SYSKIND,
    lcid: u32,
    szName: ?*i8,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn LHashValOfNameSys(
    syskind: SYSKIND,
    lcid: u32,
    szName: ?*u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn LoadTypeLib(
    szFile: ?*u16,
    pptlib: ?*ITypeLib,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn LoadTypeLibEx(
    szFile: ?*u16,
    regkind: REGKIND,
    pptlib: ?*ITypeLib,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn LoadRegTypeLib(
    rguid: ?*Guid,
    wVerMajor: u16,
    wVerMinor: u16,
    lcid: u32,
    pptlib: ?*ITypeLib,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn QueryPathOfRegTypeLib(
    guid: ?*Guid,
    wMaj: u16,
    wMin: u16,
    lcid: u32,
    lpbstrPathName: ?*?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn RegisterTypeLib(
    ptlib: ITypeLib,
    szFullPath: ?*u16,
    szHelpDir: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn UnRegisterTypeLib(
    libID: ?*Guid,
    wVerMajor: u16,
    wVerMinor: u16,
    lcid: u32,
    syskind: SYSKIND,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn RegisterTypeLibForUser(
    ptlib: ITypeLib,
    szFullPath: ?*u16,
    szHelpDir: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn UnRegisterTypeLibForUser(
    libID: ?*Guid,
    wMajorVerNum: u16,
    wMinorVerNum: u16,
    lcid: u32,
    syskind: SYSKIND,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn CreateTypeLib(
    syskind: SYSKIND,
    szFile: ?*u16,
    ppctlib: ?*ICreateTypeLib,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn CreateTypeLib2(
    syskind: SYSKIND,
    szFile: ?*u16,
    ppctlib: ?*ICreateTypeLib2,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn DispGetParam(
    pdispparams: ?*DISPPARAMS,
    position: u32,
    vtTarg: u16,
    pvarResult: ?*VARIANT,
    puArgErr: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn DispGetIDsOfNames(
    ptinfo: ITypeInfo,
    rgszNames: ?*?*u16,
    cNames: u32,
    rgdispid: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn DispInvoke(
    _this: ?*opaque{},
    ptinfo: ITypeInfo,
    dispidMember: i32,
    wFlags: u16,
    pparams: ?*DISPPARAMS,
    pvarResult: ?*VARIANT,
    pexcepinfo: ?*EXCEPINFO,
    puArgErr: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn CreateDispTypeInfo(
    pidata: ?*INTERFACEDATA,
    lcid: u32,
    pptinfo: ?*ITypeInfo,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn CreateStdDispatch(
    punkOuter: IUnknown,
    pvThis: ?*opaque{},
    ptinfo: ITypeInfo,
    ppunkStdDisp: ?*IUnknown,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn DispCallFunc(
    pvInstance: ?*opaque{},
    oVft: ?*opaque{},
    cc: CALLCONV,
    vtReturn: u16,
    cActuals: u32,
    prgvt: ?*u16,
    prgpvarg: ?*?*VARIANT,
    pvargResult: ?*VARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn RegisterActiveObject(
    punk: IUnknown,
    rclsid: ?*Guid,
    dwFlags: u32,
    pdwRegister: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn RevokeActiveObject(
    dwRegister: u32,
    pvReserved: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn GetActiveObject(
    rclsid: ?*Guid,
    pvReserved: ?*opaque{},
    ppunk: ?*IUnknown,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn SetErrorInfo(
    dwReserved: u32,
    perrinfo: IErrorInfo,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn GetErrorInfo(
    dwReserved: u32,
    pperrinfo: ?*IErrorInfo,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn CreateErrorInfo(
    pperrinfo: ?*ICreateErrorInfo,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn GetRecordInfoFromTypeInfo(
    pTypeInfo: ITypeInfo,
    ppRecInfo: ?*IRecordInfo,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn GetRecordInfoFromGuids(
    rGuidTypeLib: ?*Guid,
    uVerMajor: u32,
    uVerMinor: u32,
    lcid: u32,
    rGuidTypeInfo: ?*Guid,
    ppRecInfo: ?*IRecordInfo,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn OaBuildVersion(
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn ClearCustData(
    pCustData: ?*CUSTDATA,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn OaEnablePerUserTLibRegistration(
) callconv(@import("std").os.windows.WINAPI) void;

//
// Unicode Symbol Aliases
//
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {
    },
    .wide => struct {
    },
    else => if (@import("builtin").is_test) struct {
    } else struct {
    },
};

//
// type imports
//
const Guid = @import("../zig.zig").Guid;
const FLAGGED_WORD_BLOB = @import("com.zig").FLAGGED_WORD_BLOB;
const IUnknown = @import("com.zig").IUnknown;
const HRESULT = @import("com.zig").HRESULT;
const SYSTEMTIME = @import("windowsprogramming.zig").SYSTEMTIME;
const HWND = @import("windowsandmessaging.zig").HWND;
const STGMEDIUM = @import("com.zig").STGMEDIUM;
const CY = @import("systemservices.zig").CY;
const DECIMAL = @import("systemservices.zig").DECIMAL;

test "" {
    const constant_export_count = 0;
    const type_export_count = 87;
    const func_count = 412;
    const unicode_alias_count = 0;
    const type_import_count = 9;
    @setEvalBranchQuota(0
        + constant_export_count
        + type_export_count
        + func_count
        + unicode_alias_count
        + type_import_count
        + 2 // TODO: why do I need these extra 2?
    );
    @import("std").testing.refAllDecls(@This());
}
