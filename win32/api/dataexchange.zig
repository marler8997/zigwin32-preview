//! NOTE: this source file is autogenerated, DO NOT MODIFY

//
// constants
//

//
// types
//
// --------------------------------------------------------
// Type: COPYDATASTRUCT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const COPYDATASTRUCT = extern struct {
    dwData: ?*opaque{},
    cbData: u32,
    lpData: ?*opaque{},
};
// --------------------------------------------------------
// Type: METAFILEPICT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const METAFILEPICT = extern struct {
    mm: i32,
    xExt: i32,
    yExt: i32,
    hMF: ?*opaque{},
};
// --------------------------------------------------------
// Type: DDEACK
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DDEACK = extern struct {
    _bitfield: u16,
};
// --------------------------------------------------------
// Type: DDEADVISE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DDEADVISE = extern struct {
    _bitfield: u16,
    cfFormat: i16,
};
// --------------------------------------------------------
// Type: DDEDATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DDEDATA = extern struct {
    _bitfield: u16,
    cfFormat: i16,
    Value: ?[*]u8,
};
// --------------------------------------------------------
// Type: DDEPOKE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DDEPOKE = extern struct {
    _bitfield: u16,
    cfFormat: i16,
    Value: ?[*]u8,
};
// --------------------------------------------------------
// Type: DDELN
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DDELN = extern struct {
    _bitfield: u16,
    cfFormat: i16,
};
// --------------------------------------------------------
// Type: DDEUP
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DDEUP = extern struct {
    _bitfield: u16,
    cfFormat: i16,
    rgb: ?[*]u8,
};
// --------------------------------------------------------
// Type: HCONVLIST__
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HCONVLIST__ = extern struct {
    unused: i32,
};
// --------------------------------------------------------
// Type: HCONV__
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HCONV__ = extern struct {
    unused: i32,
};
// --------------------------------------------------------
// Type: HSZ__
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HSZ__ = extern struct {
    unused: i32,
};
// --------------------------------------------------------
// Type: HDDEDATA__
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HDDEDATA__ = extern struct {
    unused: i32,
};
// --------------------------------------------------------
// Type: HSZPAIR
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HSZPAIR = extern struct {
    hszSvc: ?*opaque{},
    hszTopic: ?*opaque{},
};
// --------------------------------------------------------
// Type: CONVCONTEXT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CONVCONTEXT = extern struct {
    cb: u32,
    wFlags: u32,
    wCountryID: u32,
    iCodePage: i32,
    dwLangID: u32,
    dwSecurity: u32,
    qos: SECURITY_QUALITY_OF_SERVICE,
};
// --------------------------------------------------------
// Type: CONVINFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CONVINFO = extern struct {
    cb: u32,
    hUser: ?*opaque{},
    hConvPartner: ?*opaque{},
    hszSvcPartner: ?*opaque{},
    hszServiceReq: ?*opaque{},
    hszTopic: ?*opaque{},
    hszItem: ?*opaque{},
    wFmt: u32,
    wType: u32,
    wStatus: u32,
    wConvst: u32,
    wLastError: u32,
    hConvList: ?*opaque{},
    ConvCtxt: CONVCONTEXT,
    hwnd: HWND,
    hwndPartner: HWND,
};
// --------------------------------------------------------
// Type: FNCALLBACK
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const FNCALLBACK = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PFNCALLBACK
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFNCALLBACK = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: DDEML_MSG_HOOK_DATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DDEML_MSG_HOOK_DATA = extern struct {
    uiLo: ?*opaque{},
    uiHi: ?*opaque{},
    cbData: u32,
    Data: ?[*]u32,
};
// --------------------------------------------------------
// Type: MONMSGSTRUCT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const MONMSGSTRUCT = extern struct {
    cb: u32,
    hwndTo: HWND,
    dwTime: u32,
    hTask: HANDLE,
    wMsg: u32,
    wParam: WPARAM,
    lParam: LPARAM,
    dmhd: DDEML_MSG_HOOK_DATA,
};
// --------------------------------------------------------
// Type: MONCBSTRUCT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const MONCBSTRUCT = extern struct {
    cb: u32,
    dwTime: u32,
    hTask: HANDLE,
    dwRet: u32,
    wType: u32,
    wFmt: u32,
    hConv: ?*opaque{},
    hsz1: ?*opaque{},
    hsz2: ?*opaque{},
    hData: ?*opaque{},
    dwData1: ?*opaque{},
    dwData2: ?*opaque{},
    cc: CONVCONTEXT,
    cbData: u32,
    Data: ?[*]u32,
};
// --------------------------------------------------------
// Type: MONHSZSTRUCTA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const MONHSZSTRUCTA = extern struct {
    cb: u32,
    fsAction: BOOL,
    dwTime: u32,
    hsz: ?*opaque{},
    hTask: HANDLE,
    str: ?[*]i8,
};
// --------------------------------------------------------
// Type: MONHSZSTRUCTW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const MONHSZSTRUCTW = extern struct {
    cb: u32,
    fsAction: BOOL,
    dwTime: u32,
    hsz: ?*opaque{},
    hTask: HANDLE,
    str: ?[*]u16,
};
// --------------------------------------------------------
// Type: MONERRSTRUCT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const MONERRSTRUCT = extern struct {
    cb: u32,
    wLastError: u32,
    dwTime: u32,
    hTask: HANDLE,
};
// --------------------------------------------------------
// Type: MONLINKSTRUCT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const MONLINKSTRUCT = extern struct {
    cb: u32,
    dwTime: u32,
    hTask: HANDLE,
    fEstablished: BOOL,
    fNoData: BOOL,
    hszSvc: ?*opaque{},
    hszTopic: ?*opaque{},
    hszItem: ?*opaque{},
    wFmt: u32,
    fServer: BOOL,
    hConvServer: ?*opaque{},
    hConvClient: ?*opaque{},
};
// --------------------------------------------------------
// Type: MONCONVSTRUCT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const MONCONVSTRUCT = extern struct {
    cb: u32,
    fConnect: BOOL,
    dwTime: u32,
    hTask: HANDLE,
    hszSvc: ?*opaque{},
    hszTopic: ?*opaque{},
    hConvClient: ?*opaque{},
    hConvServer: ?*opaque{},
};

//
// functions
//

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn OpenClipboard(
    hWndNewOwner: HWND,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn CloseClipboard(
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn GetClipboardSequenceNumber(
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn GetClipboardOwner(
) callconv(@import("std").os.windows.WINAPI) HWND;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn SetClipboardViewer(
    hWndNewViewer: HWND,
) callconv(@import("std").os.windows.WINAPI) HWND;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn GetClipboardViewer(
) callconv(@import("std").os.windows.WINAPI) HWND;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn ChangeClipboardChain(
    hWndRemove: HWND,
    hWndNewNext: HWND,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn SetClipboardData(
    uFormat: u32,
    hMem: HANDLE,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn GetClipboardData(
    uFormat: u32,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn RegisterClipboardFormatA(
    lpszFormat: ?*i8,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn RegisterClipboardFormatW(
    lpszFormat: ?*u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn CountClipboardFormats(
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn EnumClipboardFormats(
    format: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn GetClipboardFormatNameA(
    format: u32,
    lpszFormatName: ?*i8,
    cchMaxCount: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn GetClipboardFormatNameW(
    format: u32,
    lpszFormatName: ?*u16,
    cchMaxCount: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn EmptyClipboard(
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn IsClipboardFormatAvailable(
    format: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn GetPriorityClipboardFormat(
    paFormatPriorityList: ?*u32,
    cFormats: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn GetOpenClipboardWindow(
) callconv(@import("std").os.windows.WINAPI) HWND;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn AddClipboardFormatListener(
    hwnd: HWND,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn RemoveClipboardFormatListener(
    hwnd: HWND,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn GetUpdatedClipboardFormats(
    lpuiFormats: ?*u32,
    cFormats: u32,
    pcFormatsOut: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn DdeSetQualityOfService(
    hwndClient: HWND,
    pqosNew: ?*SECURITY_QUALITY_OF_SERVICE,
    pqosPrev: ?*SECURITY_QUALITY_OF_SERVICE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn ImpersonateDdeClientWindow(
    hWndClient: HWND,
    hWndServer: HWND,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn PackDDElParam(
    msg: u32,
    uiLo: ?*opaque{},
    uiHi: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) LPARAM;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn UnpackDDElParam(
    msg: u32,
    lParam: LPARAM,
    puiLo: ?*u32,
    puiHi: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn FreeDDElParam(
    msg: u32,
    lParam: LPARAM,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn ReuseDDElParam(
    lParam: LPARAM,
    msgIn: u32,
    msgOut: u32,
    uiLo: ?*opaque{},
    uiHi: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) LPARAM;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn DdeInitializeA(
    pidInst: ?*u32,
    pfnCallback: PFNCALLBACK,
    afCmd: u32,
    ulRes: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn DdeInitializeW(
    pidInst: ?*u32,
    pfnCallback: PFNCALLBACK,
    afCmd: u32,
    ulRes: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn DdeUninitialize(
    idInst: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn DdeConnectList(
    idInst: u32,
    hszService: ?*opaque{},
    hszTopic: ?*opaque{},
    hConvList: ?*opaque{},
    pCC: ?*CONVCONTEXT,
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn DdeQueryNextServer(
    hConvList: ?*opaque{},
    hConvPrev: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn DdeDisconnectList(
    hConvList: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn DdeConnect(
    idInst: u32,
    hszService: ?*opaque{},
    hszTopic: ?*opaque{},
    pCC: ?*CONVCONTEXT,
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn DdeDisconnect(
    hConv: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn DdeReconnect(
    hConv: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn DdeQueryConvInfo(
    hConv: ?*opaque{},
    idTransaction: u32,
    pConvInfo: ?*CONVINFO,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn DdeSetUserHandle(
    hConv: ?*opaque{},
    id: u32,
    hUser: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn DdeAbandonTransaction(
    idInst: u32,
    hConv: ?*opaque{},
    idTransaction: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn DdePostAdvise(
    idInst: u32,
    hszTopic: ?*opaque{},
    hszItem: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn DdeEnableCallback(
    idInst: u32,
    hConv: ?*opaque{},
    wCmd: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn DdeImpersonateClient(
    hConv: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn DdeNameService(
    idInst: u32,
    hsz1: ?*opaque{},
    hsz2: ?*opaque{},
    afCmd: u32,
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn DdeClientTransaction(
    pData: ?*u8,
    cbData: u32,
    hConv: ?*opaque{},
    hszItem: ?*opaque{},
    wFmt: u32,
    wType: u32,
    dwTimeout: u32,
    pdwResult: ?*u32,
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn DdeCreateDataHandle(
    idInst: u32,
    pSrc: ?*u8,
    cb: u32,
    cbOff: u32,
    hszItem: ?*opaque{},
    wFmt: u32,
    afCmd: u32,
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn DdeAddData(
    hData: ?*opaque{},
    pSrc: ?*u8,
    cb: u32,
    cbOff: u32,
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn DdeGetData(
    hData: ?*opaque{},
    pDst: ?*u8,
    cbMax: u32,
    cbOff: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn DdeAccessData(
    hData: ?*opaque{},
    pcbDataSize: ?*u32,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn DdeUnaccessData(
    hData: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn DdeFreeDataHandle(
    hData: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn DdeGetLastError(
    idInst: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn DdeCreateStringHandleA(
    idInst: u32,
    psz: ?*i8,
    iCodePage: i32,
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn DdeCreateStringHandleW(
    idInst: u32,
    psz: ?*u16,
    iCodePage: i32,
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn DdeQueryStringA(
    idInst: u32,
    hsz: ?*opaque{},
    psz: ?*i8,
    cchMax: u32,
    iCodePage: i32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn DdeQueryStringW(
    idInst: u32,
    hsz: ?*opaque{},
    psz: ?*u16,
    cchMax: u32,
    iCodePage: i32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn DdeFreeStringHandle(
    idInst: u32,
    hsz: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn DdeKeepStringHandle(
    idInst: u32,
    hsz: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn DdeCmpStringHandles(
    hsz1: ?*opaque{},
    hsz2: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GlobalDeleteAtom(
    nAtom: u16,
) callconv(@import("std").os.windows.WINAPI) u16;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn InitAtomTable(
    nSize: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn DeleteAtom(
    nAtom: u16,
) callconv(@import("std").os.windows.WINAPI) u16;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GlobalAddAtomA(
    lpString: ?*i8,
) callconv(@import("std").os.windows.WINAPI) u16;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GlobalAddAtomW(
    lpString: ?*u16,
) callconv(@import("std").os.windows.WINAPI) u16;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GlobalAddAtomExA(
    lpString: ?*i8,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) u16;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GlobalAddAtomExW(
    lpString: ?*u16,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) u16;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GlobalFindAtomA(
    lpString: ?*i8,
) callconv(@import("std").os.windows.WINAPI) u16;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GlobalFindAtomW(
    lpString: ?*u16,
) callconv(@import("std").os.windows.WINAPI) u16;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GlobalGetAtomNameA(
    nAtom: u16,
    lpBuffer: ?*i8,
    nSize: i32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GlobalGetAtomNameW(
    nAtom: u16,
    lpBuffer: ?*u16,
    nSize: i32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn AddAtomA(
    lpString: ?*i8,
) callconv(@import("std").os.windows.WINAPI) u16;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn AddAtomW(
    lpString: ?*u16,
) callconv(@import("std").os.windows.WINAPI) u16;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn FindAtomA(
    lpString: ?*i8,
) callconv(@import("std").os.windows.WINAPI) u16;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn FindAtomW(
    lpString: ?*u16,
) callconv(@import("std").os.windows.WINAPI) u16;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetAtomNameA(
    nAtom: u16,
    lpBuffer: ?*i8,
    nSize: i32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetAtomNameW(
    nAtom: u16,
    lpBuffer: ?*u16,
    nSize: i32,
) callconv(@import("std").os.windows.WINAPI) u32;

//
// Unicode Symbol Aliases
//
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {
        pub const MONHSZSTRUCT = MONHSZSTRUCTA;
        pub const RegisterClipboardFormat = RegisterClipboardFormatA;
        pub const GetClipboardFormatName = GetClipboardFormatNameA;
        pub const DdeInitialize = DdeInitializeA;
        pub const DdeCreateStringHandle = DdeCreateStringHandleA;
        pub const DdeQueryString = DdeQueryStringA;
        pub const GlobalAddAtom = GlobalAddAtomA;
        pub const GlobalAddAtomEx = GlobalAddAtomExA;
        pub const GlobalFindAtom = GlobalFindAtomA;
        pub const GlobalGetAtomName = GlobalGetAtomNameA;
        pub const AddAtom = AddAtomA;
        pub const FindAtom = FindAtomA;
        pub const GetAtomName = GetAtomNameA;
    },
    .wide => struct {
        pub const MONHSZSTRUCT = MONHSZSTRUCTW;
        pub const RegisterClipboardFormat = RegisterClipboardFormatW;
        pub const GetClipboardFormatName = GetClipboardFormatNameW;
        pub const DdeInitialize = DdeInitializeW;
        pub const DdeCreateStringHandle = DdeCreateStringHandleW;
        pub const DdeQueryString = DdeQueryStringW;
        pub const GlobalAddAtom = GlobalAddAtomW;
        pub const GlobalAddAtomEx = GlobalAddAtomExW;
        pub const GlobalFindAtom = GlobalFindAtomW;
        pub const GlobalGetAtomName = GlobalGetAtomNameW;
        pub const AddAtom = AddAtomW;
        pub const FindAtom = FindAtomW;
        pub const GetAtomName = GetAtomNameW;
    },
    else => if (@import("builtin").is_test) struct {
        pub const MONHSZSTRUCT = *opaque{};
        pub const RegisterClipboardFormat = *opaque{};
        pub const GetClipboardFormatName = *opaque{};
        pub const DdeInitialize = *opaque{};
        pub const DdeCreateStringHandle = *opaque{};
        pub const DdeQueryString = *opaque{};
        pub const GlobalAddAtom = *opaque{};
        pub const GlobalAddAtomEx = *opaque{};
        pub const GlobalFindAtom = *opaque{};
        pub const GlobalGetAtomName = *opaque{};
        pub const AddAtom = *opaque{};
        pub const FindAtom = *opaque{};
        pub const GetAtomName = *opaque{};
    } else struct {
        pub const MONHSZSTRUCT = @compileError("'MONHSZSTRUCT' requires that UNICODE be set to true or false in the root module");
        pub const RegisterClipboardFormat = @compileError("'RegisterClipboardFormat' requires that UNICODE be set to true or false in the root module");
        pub const GetClipboardFormatName = @compileError("'GetClipboardFormatName' requires that UNICODE be set to true or false in the root module");
        pub const DdeInitialize = @compileError("'DdeInitialize' requires that UNICODE be set to true or false in the root module");
        pub const DdeCreateStringHandle = @compileError("'DdeCreateStringHandle' requires that UNICODE be set to true or false in the root module");
        pub const DdeQueryString = @compileError("'DdeQueryString' requires that UNICODE be set to true or false in the root module");
        pub const GlobalAddAtom = @compileError("'GlobalAddAtom' requires that UNICODE be set to true or false in the root module");
        pub const GlobalAddAtomEx = @compileError("'GlobalAddAtomEx' requires that UNICODE be set to true or false in the root module");
        pub const GlobalFindAtom = @compileError("'GlobalFindAtom' requires that UNICODE be set to true or false in the root module");
        pub const GlobalGetAtomName = @compileError("'GlobalGetAtomName' requires that UNICODE be set to true or false in the root module");
        pub const AddAtom = @compileError("'AddAtom' requires that UNICODE be set to true or false in the root module");
        pub const FindAtom = @compileError("'FindAtom' requires that UNICODE be set to true or false in the root module");
        pub const GetAtomName = @compileError("'GetAtomName' requires that UNICODE be set to true or false in the root module");
    },
};

//
// type imports
//
const SECURITY_QUALITY_OF_SERVICE = @import("security.zig").SECURITY_QUALITY_OF_SERVICE;
const HWND = @import("windowsandmessaging.zig").HWND;
const HANDLE = @import("systemservices.zig").HANDLE;
const WPARAM = @import("windowsandmessaging.zig").WPARAM;
const LPARAM = @import("windowsandmessaging.zig").LPARAM;
const BOOL = @import("systemservices.zig").BOOL;

test "" {
    const constant_export_count = 0;
    const type_export_count = 25;
    const func_count = 76;
    const unicode_alias_count = 13;
    const type_import_count = 6;
    @setEvalBranchQuota(0
        + constant_export_count
        + type_export_count
        + func_count
        + unicode_alias_count
        + type_import_count
        + 2 // TODO: why do I need these extra 2?
    );
    @import("std").testing.refAllDecls(@This());
}
