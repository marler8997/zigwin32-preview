//! NOTE: this source file is autogenerated, DO NOT MODIFY

//
// constants
//
pub const TRUE : i32 = 1;
pub const FALSE : i32 = 0;
pub const RT_CURSOR : u16 = 1;
pub const RT_BITMAP : u16 = 2;
pub const RT_ICON : u16 = 3;
pub const RT_MENU : u16 = 4;
pub const RT_DIALOG : u16 = 5;
pub const RT_STRING : u16 = 6;
pub const RT_FONTDIR : u16 = 7;
pub const RT_FONT : u16 = 8;
pub const RT_ACCELERATOR : u16 = 9;
pub const RT_RCDATA : u16 = 10;
pub const RT_MESSAGETABLE : u16 = 11;
pub const DIFFERENCE : i32 = 11;
pub const RT_GROUP_CURSOR : u16 = 12;
pub const RT_GROUP_ICON : u16 = 14;
pub const RT_VERSION : u16 = 16;
pub const RT_DLGINCLUDE : u16 = 17;
pub const RT_PLUGPLAY : u16 = 19;
pub const RT_VXD : u16 = 20;
pub const RT_ANICURSOR : u16 = 21;
pub const RT_ANIICON : u16 = 22;
pub const RT_HTML : u16 = 23;
pub const RT_MANIFEST : u16 = 24;
pub const CREATEPROCESS_MANIFEST_RESOURCE_ID : u16 = 1;
pub const ISOLATIONAWARE_MANIFEST_RESOURCE_ID : u16 = 2;
pub const ISOLATIONAWARE_NOSTATICIMPORT_MANIFEST_RESOURCE_ID : u16 = 3;
pub const ISOLATIONPOLICY_MANIFEST_RESOURCE_ID : u16 = 4;
pub const ISOLATIONPOLICY_BROWSER_MANIFEST_RESOURCE_ID : u16 = 5;
pub const MINIMUM_RESERVED_MANIFEST_RESOURCE_ID : u16 = 1;
pub const MAXIMUM_RESERVED_MANIFEST_RESOURCE_ID : u16 = 16;
pub const SETWALLPAPER_DEFAULT : i32 = -1;
pub const SB_HORZ : i32 = 0;
pub const SB_VERT : i32 = 1;
pub const SB_CTL : i32 = 2;
pub const SB_BOTH : i32 = 3;
pub const SB_LINEUP : i32 = 0;
pub const SB_LINELEFT : i32 = 0;
pub const SB_LINEDOWN : i32 = 1;
pub const SB_LINERIGHT : i32 = 1;
pub const SB_PAGEUP : i32 = 2;
pub const SB_PAGELEFT : i32 = 2;
pub const SB_PAGEDOWN : i32 = 3;
pub const SB_PAGERIGHT : i32 = 3;
pub const SB_THUMBPOSITION : i32 = 4;
pub const SB_THUMBTRACK : i32 = 5;
pub const SB_TOP : i32 = 6;
pub const SB_LEFT : i32 = 6;
pub const SB_BOTTOM : i32 = 7;
pub const SB_RIGHT : i32 = 7;
pub const SB_ENDSCROLL : i32 = 8;
pub const SW_HIDE : i32 = 0;
pub const SW_SHOWNORMAL : i32 = 1;
pub const SW_NORMAL : i32 = 1;
pub const SW_SHOWMINIMIZED : i32 = 2;
pub const SW_SHOWMAXIMIZED : i32 = 3;
pub const SW_MAXIMIZE : i32 = 3;
pub const SW_SHOWNOACTIVATE : i32 = 4;
pub const SW_SHOW : i32 = 5;
pub const SW_MINIMIZE : i32 = 6;
pub const SW_SHOWMINNOACTIVE : i32 = 7;
pub const SW_SHOWNA : i32 = 8;
pub const SW_RESTORE : i32 = 9;
pub const SW_SHOWDEFAULT : i32 = 10;
pub const SW_FORCEMINIMIZE : i32 = 11;
pub const SW_MAX : i32 = 11;
pub const HIDE_WINDOW : i32 = 0;
pub const SHOW_OPENWINDOW : i32 = 1;
pub const SHOW_ICONWINDOW : i32 = 2;
pub const SHOW_FULLSCREEN : i32 = 3;
pub const SHOW_OPENNOACTIVATE : i32 = 4;
pub const SW_PARENTCLOSING : i32 = 1;
pub const SW_OTHERZOOM : i32 = 2;
pub const SW_PARENTOPENING : i32 = 3;
pub const SW_OTHERUNZOOM : i32 = 4;
pub const AW_HOR_POSITIVE : i32 = 1;
pub const AW_HOR_NEGATIVE : i32 = 2;
pub const AW_VER_POSITIVE : i32 = 4;
pub const AW_VER_NEGATIVE : i32 = 8;
pub const AW_CENTER : i32 = 16;
pub const AW_HIDE : i32 = 65536;
pub const AW_ACTIVATE : i32 = 131072;
pub const AW_SLIDE : i32 = 262144;
pub const AW_BLEND : i32 = 524288;
pub const KF_EXTENDED : i32 = 256;
pub const KF_DLGMODE : i32 = 2048;
pub const KF_MENUMODE : i32 = 4096;
pub const KF_ALTDOWN : i32 = 8192;
pub const KF_REPEAT : i32 = 16384;
pub const KF_UP : i32 = 32768;
pub const VK_LBUTTON : i32 = 1;
pub const VK_RBUTTON : i32 = 2;
pub const VK_CANCEL : i32 = 3;
pub const VK_MBUTTON : i32 = 4;
pub const VK_XBUTTON1 : i32 = 5;
pub const VK_XBUTTON2 : i32 = 6;
pub const VK_BACK : i32 = 8;
pub const VK_TAB : i32 = 9;
pub const VK_CLEAR : i32 = 12;
pub const VK_RETURN : i32 = 13;
pub const VK_SHIFT : i32 = 16;
pub const VK_CONTROL : i32 = 17;
pub const VK_MENU : i32 = 18;
pub const VK_PAUSE : i32 = 19;
pub const VK_CAPITAL : i32 = 20;
pub const VK_KANA : i32 = 21;
pub const VK_HANGEUL : i32 = 21;
pub const VK_HANGUL : i32 = 21;
pub const VK_JUNJA : i32 = 23;
pub const VK_FINAL : i32 = 24;
pub const VK_HANJA : i32 = 25;
pub const VK_KANJI : i32 = 25;
pub const VK_ESCAPE : i32 = 27;
pub const VK_CONVERT : i32 = 28;
pub const VK_NONCONVERT : i32 = 29;
pub const VK_ACCEPT : i32 = 30;
pub const VK_MODECHANGE : i32 = 31;
pub const VK_SPACE : i32 = 32;
pub const VK_PRIOR : i32 = 33;
pub const VK_NEXT : i32 = 34;
pub const VK_END : i32 = 35;
pub const VK_HOME : i32 = 36;
pub const VK_LEFT : i32 = 37;
pub const VK_UP : i32 = 38;
pub const VK_RIGHT : i32 = 39;
pub const VK_DOWN : i32 = 40;
pub const VK_SELECT : i32 = 41;
pub const VK_PRINT : i32 = 42;
pub const VK_EXECUTE : i32 = 43;
pub const VK_SNAPSHOT : i32 = 44;
pub const VK_INSERT : i32 = 45;
pub const VK_DELETE : i32 = 46;
pub const VK_HELP : i32 = 47;
pub const VK_LWIN : i32 = 91;
pub const VK_RWIN : i32 = 92;
pub const VK_APPS : i32 = 93;
pub const VK_SLEEP : i32 = 95;
pub const VK_NUMPAD0 : i32 = 96;
pub const VK_NUMPAD1 : i32 = 97;
pub const VK_NUMPAD2 : i32 = 98;
pub const VK_NUMPAD3 : i32 = 99;
pub const VK_NUMPAD4 : i32 = 100;
pub const VK_NUMPAD5 : i32 = 101;
pub const VK_NUMPAD6 : i32 = 102;
pub const VK_NUMPAD7 : i32 = 103;
pub const VK_NUMPAD8 : i32 = 104;
pub const VK_NUMPAD9 : i32 = 105;
pub const VK_MULTIPLY : i32 = 106;
pub const VK_ADD : i32 = 107;
pub const VK_SEPARATOR : i32 = 108;
pub const VK_SUBTRACT : i32 = 109;
pub const VK_DECIMAL : i32 = 110;
pub const VK_DIVIDE : i32 = 111;
pub const VK_F1 : i32 = 112;
pub const VK_F2 : i32 = 113;
pub const VK_F3 : i32 = 114;
pub const VK_F4 : i32 = 115;
pub const VK_F5 : i32 = 116;
pub const VK_F6 : i32 = 117;
pub const VK_F7 : i32 = 118;
pub const VK_F8 : i32 = 119;
pub const VK_F9 : i32 = 120;
pub const VK_F10 : i32 = 121;
pub const VK_F11 : i32 = 122;
pub const VK_F12 : i32 = 123;
pub const VK_F13 : i32 = 124;
pub const VK_F14 : i32 = 125;
pub const VK_F15 : i32 = 126;
pub const VK_F16 : i32 = 127;
pub const VK_F17 : i32 = 128;
pub const VK_F18 : i32 = 129;
pub const VK_F19 : i32 = 130;
pub const VK_F20 : i32 = 131;
pub const VK_F21 : i32 = 132;
pub const VK_F22 : i32 = 133;
pub const VK_F23 : i32 = 134;
pub const VK_F24 : i32 = 135;
pub const VK_NAVIGATION_VIEW : i32 = 136;
pub const VK_NAVIGATION_MENU : i32 = 137;
pub const VK_NAVIGATION_UP : i32 = 138;
pub const VK_NAVIGATION_DOWN : i32 = 139;
pub const VK_NAVIGATION_LEFT : i32 = 140;
pub const VK_NAVIGATION_RIGHT : i32 = 141;
pub const VK_NAVIGATION_ACCEPT : i32 = 142;
pub const VK_NAVIGATION_CANCEL : i32 = 143;
pub const VK_NUMLOCK : i32 = 144;
pub const VK_SCROLL : i32 = 145;
pub const VK_OEM_NEC_EQUAL : i32 = 146;
pub const VK_OEM_FJ_JISHO : i32 = 146;
pub const VK_OEM_FJ_MASSHOU : i32 = 147;
pub const VK_OEM_FJ_TOUROKU : i32 = 148;
pub const VK_OEM_FJ_LOYA : i32 = 149;
pub const VK_OEM_FJ_ROYA : i32 = 150;
pub const VK_LSHIFT : i32 = 160;
pub const VK_RSHIFT : i32 = 161;
pub const VK_LCONTROL : i32 = 162;
pub const VK_RCONTROL : i32 = 163;
pub const VK_LMENU : i32 = 164;
pub const VK_RMENU : i32 = 165;
pub const VK_BROWSER_BACK : i32 = 166;
pub const VK_BROWSER_FORWARD : i32 = 167;
pub const VK_BROWSER_REFRESH : i32 = 168;
pub const VK_BROWSER_STOP : i32 = 169;
pub const VK_BROWSER_SEARCH : i32 = 170;
pub const VK_BROWSER_FAVORITES : i32 = 171;
pub const VK_BROWSER_HOME : i32 = 172;
pub const VK_VOLUME_MUTE : i32 = 173;
pub const VK_VOLUME_DOWN : i32 = 174;
pub const VK_VOLUME_UP : i32 = 175;
pub const VK_MEDIA_NEXT_TRACK : i32 = 176;
pub const VK_MEDIA_PREV_TRACK : i32 = 177;
pub const VK_MEDIA_STOP : i32 = 178;
pub const VK_MEDIA_PLAY_PAUSE : i32 = 179;
pub const VK_LAUNCH_MAIL : i32 = 180;
pub const VK_LAUNCH_MEDIA_SELECT : i32 = 181;
pub const VK_LAUNCH_APP1 : i32 = 182;
pub const VK_LAUNCH_APP2 : i32 = 183;
pub const VK_OEM_1 : i32 = 186;
pub const VK_OEM_PLUS : i32 = 187;
pub const VK_OEM_COMMA : i32 = 188;
pub const VK_OEM_MINUS : i32 = 189;
pub const VK_OEM_PERIOD : i32 = 190;
pub const VK_OEM_2 : i32 = 191;
pub const VK_OEM_3 : i32 = 192;
pub const VK_GAMEPAD_A : i32 = 195;
pub const VK_GAMEPAD_B : i32 = 196;
pub const VK_GAMEPAD_X : i32 = 197;
pub const VK_GAMEPAD_Y : i32 = 198;
pub const VK_GAMEPAD_RIGHT_SHOULDER : i32 = 199;
pub const VK_GAMEPAD_LEFT_SHOULDER : i32 = 200;
pub const VK_GAMEPAD_LEFT_TRIGGER : i32 = 201;
pub const VK_GAMEPAD_RIGHT_TRIGGER : i32 = 202;
pub const VK_GAMEPAD_DPAD_UP : i32 = 203;
pub const VK_GAMEPAD_DPAD_DOWN : i32 = 204;
pub const VK_GAMEPAD_DPAD_LEFT : i32 = 205;
pub const VK_GAMEPAD_DPAD_RIGHT : i32 = 206;
pub const VK_GAMEPAD_MENU : i32 = 207;
pub const VK_GAMEPAD_VIEW : i32 = 208;
pub const VK_GAMEPAD_LEFT_THUMBSTICK_BUTTON : i32 = 209;
pub const VK_GAMEPAD_RIGHT_THUMBSTICK_BUTTON : i32 = 210;
pub const VK_GAMEPAD_LEFT_THUMBSTICK_UP : i32 = 211;
pub const VK_GAMEPAD_LEFT_THUMBSTICK_DOWN : i32 = 212;
pub const VK_GAMEPAD_LEFT_THUMBSTICK_RIGHT : i32 = 213;
pub const VK_GAMEPAD_LEFT_THUMBSTICK_LEFT : i32 = 214;
pub const VK_GAMEPAD_RIGHT_THUMBSTICK_UP : i32 = 215;
pub const VK_GAMEPAD_RIGHT_THUMBSTICK_DOWN : i32 = 216;
pub const VK_GAMEPAD_RIGHT_THUMBSTICK_RIGHT : i32 = 217;
pub const VK_GAMEPAD_RIGHT_THUMBSTICK_LEFT : i32 = 218;
pub const VK_OEM_4 : i32 = 219;
pub const VK_OEM_5 : i32 = 220;
pub const VK_OEM_6 : i32 = 221;
pub const VK_OEM_7 : i32 = 222;
pub const VK_OEM_8 : i32 = 223;
pub const VK_OEM_AX : i32 = 225;
pub const VK_OEM_102 : i32 = 226;
pub const VK_ICO_HELP : i32 = 227;
pub const VK_ICO_00 : i32 = 228;
pub const VK_PROCESSKEY : i32 = 229;
pub const VK_ICO_CLEAR : i32 = 230;
pub const VK_PACKET : i32 = 231;
pub const VK_OEM_RESET : i32 = 233;
pub const VK_OEM_JUMP : i32 = 234;
pub const VK_OEM_PA1 : i32 = 235;
pub const VK_OEM_PA2 : i32 = 236;
pub const VK_OEM_PA3 : i32 = 237;
pub const VK_OEM_WSCTRL : i32 = 238;
pub const VK_OEM_CUSEL : i32 = 239;
pub const VK_OEM_ATTN : i32 = 240;
pub const VK_OEM_FINISH : i32 = 241;
pub const VK_OEM_COPY : i32 = 242;
pub const VK_OEM_AUTO : i32 = 243;
pub const VK_OEM_ENLW : i32 = 244;
pub const VK_OEM_BACKTAB : i32 = 245;
pub const VK_ATTN : i32 = 246;
pub const VK_CRSEL : i32 = 247;
pub const VK_EXSEL : i32 = 248;
pub const VK_EREOF : i32 = 249;
pub const VK_PLAY : i32 = 250;
pub const VK_ZOOM : i32 = 251;
pub const VK_NONAME : i32 = 252;
pub const VK_PA1 : i32 = 253;
pub const VK_OEM_CLEAR : i32 = 254;
pub const WH_MIN : i32 = -1;
pub const WH_MSGFILTER : i32 = -1;
pub const WH_JOURNALRECORD : i32 = 0;
pub const WH_JOURNALPLAYBACK : i32 = 1;
pub const WH_KEYBOARD : i32 = 2;
pub const WH_GETMESSAGE : i32 = 3;
pub const WH_CALLWNDPROC : i32 = 4;
pub const WH_CBT : i32 = 5;
pub const WH_SYSMSGFILTER : i32 = 6;
pub const WH_MOUSE : i32 = 7;
pub const WH_HARDWARE : i32 = 8;
pub const WH_DEBUG : i32 = 9;
pub const WH_SHELL : i32 = 10;
pub const WH_FOREGROUNDIDLE : i32 = 11;
pub const WH_CALLWNDPROCRET : i32 = 12;
pub const WH_KEYBOARD_LL : i32 = 13;
pub const WH_MOUSE_LL : i32 = 14;
pub const WH_MAX : i32 = 14;
pub const WH_MINHOOK : i32 = -1;
pub const WH_MAXHOOK : i32 = 14;
pub const HC_ACTION : i32 = 0;
pub const HC_GETNEXT : i32 = 1;
pub const HC_SKIP : i32 = 2;
pub const HC_NOREMOVE : i32 = 3;
pub const HC_NOREM : i32 = 3;
pub const HC_SYSMODALON : i32 = 4;
pub const HC_SYSMODALOFF : i32 = 5;
pub const HCBT_MOVESIZE : i32 = 0;
pub const HCBT_MINMAX : i32 = 1;
pub const HCBT_QS : i32 = 2;
pub const HCBT_CREATEWND : i32 = 3;
pub const HCBT_DESTROYWND : i32 = 4;
pub const HCBT_ACTIVATE : i32 = 5;
pub const HCBT_CLICKSKIPPED : i32 = 6;
pub const HCBT_KEYSKIPPED : i32 = 7;
pub const HCBT_SYSCOMMAND : i32 = 8;
pub const HCBT_SETFOCUS : i32 = 9;
pub const WTS_CONSOLE_CONNECT : i32 = 1;
pub const WTS_CONSOLE_DISCONNECT : i32 = 2;
pub const WTS_REMOTE_CONNECT : i32 = 3;
pub const WTS_REMOTE_DISCONNECT : i32 = 4;
pub const WTS_SESSION_LOGON : i32 = 5;
pub const WTS_SESSION_LOGOFF : i32 = 6;
pub const WTS_SESSION_LOCK : i32 = 7;
pub const WTS_SESSION_UNLOCK : i32 = 8;
pub const WTS_SESSION_REMOTE_CONTROL : i32 = 9;
pub const WTS_SESSION_CREATE : i32 = 10;
pub const WTS_SESSION_TERMINATE : i32 = 11;
pub const MSGF_DIALOGBOX : i32 = 0;
pub const MSGF_MESSAGEBOX : i32 = 1;
pub const MSGF_MENU : i32 = 2;
pub const MSGF_SCROLLBAR : i32 = 5;
pub const MSGF_NEXTWINDOW : i32 = 6;
pub const MSGF_MAX : i32 = 8;
pub const MSGF_USER : i32 = 4096;
pub const HSHELL_WINDOWCREATED : i32 = 1;
pub const HSHELL_WINDOWDESTROYED : i32 = 2;
pub const HSHELL_ACTIVATESHELLWINDOW : i32 = 3;
pub const HSHELL_WINDOWACTIVATED : i32 = 4;
pub const HSHELL_GETMINRECT : i32 = 5;
pub const HSHELL_REDRAW : i32 = 6;
pub const HSHELL_TASKMAN : i32 = 7;
pub const HSHELL_LANGUAGE : i32 = 8;
pub const HSHELL_SYSMENU : i32 = 9;
pub const HSHELL_ENDTASK : i32 = 10;
pub const HSHELL_ACCESSIBILITYSTATE : i32 = 11;
pub const HSHELL_APPCOMMAND : i32 = 12;
pub const HSHELL_WINDOWREPLACED : i32 = 13;
pub const HSHELL_WINDOWREPLACING : i32 = 14;
pub const HSHELL_MONITORCHANGED : i32 = 16;
pub const HSHELL_HIGHBIT : i32 = 32768;
pub const HSHELL_FLASH : i32 = 32774;
pub const HSHELL_RUDEAPPACTIVATED : i32 = 32772;
pub const APPCOMMAND_BROWSER_BACKWARD : i32 = 1;
pub const APPCOMMAND_BROWSER_FORWARD : i32 = 2;
pub const APPCOMMAND_BROWSER_REFRESH : i32 = 3;
pub const APPCOMMAND_BROWSER_STOP : i32 = 4;
pub const APPCOMMAND_BROWSER_SEARCH : i32 = 5;
pub const APPCOMMAND_BROWSER_FAVORITES : i32 = 6;
pub const APPCOMMAND_BROWSER_HOME : i32 = 7;
pub const APPCOMMAND_VOLUME_MUTE : i32 = 8;
pub const APPCOMMAND_VOLUME_DOWN : i32 = 9;
pub const APPCOMMAND_VOLUME_UP : i32 = 10;
pub const APPCOMMAND_MEDIA_NEXTTRACK : i32 = 11;
pub const APPCOMMAND_MEDIA_PREVIOUSTRACK : i32 = 12;
pub const APPCOMMAND_MEDIA_STOP : i32 = 13;
pub const APPCOMMAND_MEDIA_PLAY_PAUSE : i32 = 14;
pub const APPCOMMAND_LAUNCH_MAIL : i32 = 15;
pub const APPCOMMAND_LAUNCH_MEDIA_SELECT : i32 = 16;
pub const APPCOMMAND_LAUNCH_APP1 : i32 = 17;
pub const APPCOMMAND_LAUNCH_APP2 : i32 = 18;
pub const APPCOMMAND_BASS_DOWN : i32 = 19;
pub const APPCOMMAND_BASS_BOOST : i32 = 20;
pub const APPCOMMAND_BASS_UP : i32 = 21;
pub const APPCOMMAND_TREBLE_DOWN : i32 = 22;
pub const APPCOMMAND_TREBLE_UP : i32 = 23;
pub const APPCOMMAND_MICROPHONE_VOLUME_MUTE : i32 = 24;
pub const APPCOMMAND_MICROPHONE_VOLUME_DOWN : i32 = 25;
pub const APPCOMMAND_MICROPHONE_VOLUME_UP : i32 = 26;
pub const APPCOMMAND_HELP : i32 = 27;
pub const APPCOMMAND_FIND : i32 = 28;
pub const APPCOMMAND_NEW : i32 = 29;
pub const APPCOMMAND_OPEN : i32 = 30;
pub const APPCOMMAND_CLOSE : i32 = 31;
pub const APPCOMMAND_SAVE : i32 = 32;
pub const APPCOMMAND_PRINT : i32 = 33;
pub const APPCOMMAND_UNDO : i32 = 34;
pub const APPCOMMAND_REDO : i32 = 35;
pub const APPCOMMAND_COPY : i32 = 36;
pub const APPCOMMAND_CUT : i32 = 37;
pub const APPCOMMAND_PASTE : i32 = 38;
pub const APPCOMMAND_REPLY_TO_MAIL : i32 = 39;
pub const APPCOMMAND_FORWARD_MAIL : i32 = 40;
pub const APPCOMMAND_SEND_MAIL : i32 = 41;
pub const APPCOMMAND_SPELL_CHECK : i32 = 42;
pub const APPCOMMAND_DICTATE_OR_COMMAND_CONTROL_TOGGLE : i32 = 43;
pub const APPCOMMAND_MIC_ON_OFF_TOGGLE : i32 = 44;
pub const APPCOMMAND_CORRECTION_LIST : i32 = 45;
pub const APPCOMMAND_MEDIA_PLAY : i32 = 46;
pub const APPCOMMAND_MEDIA_PAUSE : i32 = 47;
pub const APPCOMMAND_MEDIA_RECORD : i32 = 48;
pub const APPCOMMAND_MEDIA_FAST_FORWARD : i32 = 49;
pub const APPCOMMAND_MEDIA_REWIND : i32 = 50;
pub const APPCOMMAND_MEDIA_CHANNEL_UP : i32 = 51;
pub const APPCOMMAND_MEDIA_CHANNEL_DOWN : i32 = 52;
pub const APPCOMMAND_DELETE : i32 = 53;
pub const APPCOMMAND_DWM_FLIP3D : i32 = 54;
pub const FAPPCOMMAND_MOUSE : i32 = 32768;
pub const FAPPCOMMAND_KEY : i32 = 0;
pub const FAPPCOMMAND_OEM : i32 = 4096;
pub const FAPPCOMMAND_MASK : i32 = 61440;
pub const LLKHF_EXTENDED : i32 = 1;
pub const LLKHF_INJECTED : i32 = 16;
pub const LLKHF_ALTDOWN : i32 = 32;
pub const LLKHF_UP : i32 = 128;
pub const LLKHF_LOWER_IL_INJECTED : i32 = 2;
pub const LLMHF_INJECTED : i32 = 1;
pub const LLMHF_LOWER_IL_INJECTED : i32 = 2;
pub const HKL_PREV : i32 = 0;
pub const HKL_NEXT : i32 = 1;
pub const KLF_ACTIVATE : i32 = 1;
pub const KLF_SUBSTITUTE_OK : i32 = 2;
pub const KLF_REORDER : i32 = 8;
pub const KLF_REPLACELANG : i32 = 16;
pub const KLF_NOTELLSHELL : i32 = 128;
pub const KLF_SETFORPROCESS : i32 = 256;
pub const KLF_SHIFTLOCK : i32 = 65536;
pub const KLF_RESET : i32 = 1073741824;
pub const INPUTLANGCHANGE_SYSCHARSET : i32 = 1;
pub const INPUTLANGCHANGE_FORWARD : i32 = 2;
pub const INPUTLANGCHANGE_BACKWARD : i32 = 4;
pub const KL_NAMELENGTH : i32 = 9;
pub const GMMP_USE_DISPLAY_POINTS : i32 = 1;
pub const GMMP_USE_HIGH_RESOLUTION_POINTS : i32 = 2;
pub const DESKTOP_READOBJECTS : i32 = 1;
pub const DESKTOP_CREATEWINDOW : i32 = 2;
pub const DESKTOP_CREATEMENU : i32 = 4;
pub const DESKTOP_HOOKCONTROL : i32 = 8;
pub const DESKTOP_JOURNALRECORD : i32 = 16;
pub const DESKTOP_JOURNALPLAYBACK : i32 = 32;
pub const DESKTOP_ENUMERATE : i32 = 64;
pub const DESKTOP_WRITEOBJECTS : i32 = 128;
pub const DESKTOP_SWITCHDESKTOP : i32 = 256;
pub const DF_ALLOWOTHERACCOUNTHOOK : i32 = 1;
pub const WINSTA_ENUMDESKTOPS : i32 = 1;
pub const WINSTA_READATTRIBUTES : i32 = 2;
pub const WINSTA_ACCESSCLIPBOARD : i32 = 4;
pub const WINSTA_CREATEDESKTOP : i32 = 8;
pub const WINSTA_WRITEATTRIBUTES : i32 = 16;
pub const WINSTA_ACCESSGLOBALATOMS : i32 = 32;
pub const WINSTA_EXITWINDOWS : i32 = 64;
pub const WINSTA_ENUMERATE : i32 = 256;
pub const WINSTA_READSCREEN : i32 = 512;
pub const WINSTA_ALL_ACCESS : i32 = 895;
pub const CWF_CREATE_ONLY : i32 = 1;
pub const WSF_VISIBLE : i32 = 1;
pub const UOI_FLAGS : i32 = 1;
pub const UOI_NAME : i32 = 2;
pub const UOI_TYPE : i32 = 3;
pub const UOI_USER_SID : i32 = 4;
pub const UOI_HEAPSIZE : i32 = 5;
pub const UOI_IO : i32 = 6;
pub const UOI_TIMERPROC_EXCEPTION_SUPPRESSION : i32 = 7;
pub const GWL_WNDPROC : i32 = -4;
pub const GWL_HINSTANCE : i32 = -6;
pub const GWL_HWNDPARENT : i32 = -8;
pub const GWL_STYLE : i32 = -16;
pub const GWL_EXSTYLE : i32 = -20;
pub const GWL_USERDATA : i32 = -21;
pub const GWL_ID : i32 = -12;
pub const GWLP_WNDPROC : i32 = -4;
pub const GWLP_HINSTANCE : i32 = -6;
pub const GWLP_HWNDPARENT : i32 = -8;
pub const GWLP_USERDATA : i32 = -21;
pub const GWLP_ID : i32 = -12;
pub const GCL_MENUNAME : i32 = -8;
pub const GCL_HBRBACKGROUND : i32 = -10;
pub const GCL_HCURSOR : i32 = -12;
pub const GCL_HICON : i32 = -14;
pub const GCL_HMODULE : i32 = -16;
pub const GCL_CBWNDEXTRA : i32 = -18;
pub const GCL_CBCLSEXTRA : i32 = -20;
pub const GCL_WNDPROC : i32 = -24;
pub const GCL_STYLE : i32 = -26;
pub const GCW_ATOM : i32 = -32;
pub const GCL_HICONSM : i32 = -34;
pub const GCLP_MENUNAME : i32 = -8;
pub const GCLP_HBRBACKGROUND : i32 = -10;
pub const GCLP_HCURSOR : i32 = -12;
pub const GCLP_HICON : i32 = -14;
pub const GCLP_HMODULE : i32 = -16;
pub const GCLP_WNDPROC : i32 = -24;
pub const GCLP_HICONSM : i32 = -34;
pub const WM_NULL : i32 = 0;
pub const WM_CREATE : i32 = 1;
pub const WM_DESTROY : i32 = 2;
pub const WM_MOVE : i32 = 3;
pub const WM_SIZE : i32 = 5;
pub const WM_ACTIVATE : i32 = 6;
pub const WA_INACTIVE : i32 = 0;
pub const WA_ACTIVE : i32 = 1;
pub const WA_CLICKACTIVE : i32 = 2;
pub const WM_SETFOCUS : i32 = 7;
pub const WM_KILLFOCUS : i32 = 8;
pub const WM_ENABLE : i32 = 10;
pub const WM_SETREDRAW : i32 = 11;
pub const WM_SETTEXT : i32 = 12;
pub const WM_GETTEXT : i32 = 13;
pub const WM_GETTEXTLENGTH : i32 = 14;
pub const WM_PAINT : i32 = 15;
pub const WM_CLOSE : i32 = 16;
pub const WM_QUERYENDSESSION : i32 = 17;
pub const WM_QUERYOPEN : i32 = 19;
pub const WM_ENDSESSION : i32 = 22;
pub const WM_QUIT : i32 = 18;
pub const WM_ERASEBKGND : i32 = 20;
pub const WM_SYSCOLORCHANGE : i32 = 21;
pub const WM_SHOWWINDOW : i32 = 24;
pub const WM_WININICHANGE : i32 = 26;
pub const WM_SETTINGCHANGE : i32 = 26;
pub const WM_DEVMODECHANGE : i32 = 27;
pub const WM_ACTIVATEAPP : i32 = 28;
pub const WM_FONTCHANGE : i32 = 29;
pub const WM_TIMECHANGE : i32 = 30;
pub const WM_CANCELMODE : i32 = 31;
pub const WM_SETCURSOR : i32 = 32;
pub const WM_MOUSEACTIVATE : i32 = 33;
pub const WM_CHILDACTIVATE : i32 = 34;
pub const WM_QUEUESYNC : i32 = 35;
pub const WM_GETMINMAXINFO : i32 = 36;
pub const WM_PAINTICON : i32 = 38;
pub const WM_ICONERASEBKGND : i32 = 39;
pub const WM_NEXTDLGCTL : i32 = 40;
pub const WM_SPOOLERSTATUS : i32 = 42;
pub const WM_DRAWITEM : i32 = 43;
pub const WM_MEASUREITEM : i32 = 44;
pub const WM_DELETEITEM : i32 = 45;
pub const WM_VKEYTOITEM : i32 = 46;
pub const WM_CHARTOITEM : i32 = 47;
pub const WM_SETFONT : i32 = 48;
pub const WM_GETFONT : i32 = 49;
pub const WM_SETHOTKEY : i32 = 50;
pub const WM_GETHOTKEY : i32 = 51;
pub const WM_QUERYDRAGICON : i32 = 55;
pub const WM_COMPAREITEM : i32 = 57;
pub const WM_GETOBJECT : i32 = 61;
pub const WM_COMPACTING : i32 = 65;
pub const WM_COMMNOTIFY : i32 = 68;
pub const WM_WINDOWPOSCHANGING : i32 = 70;
pub const WM_WINDOWPOSCHANGED : i32 = 71;
pub const WM_POWER : i32 = 72;
pub const PWR_OK : i32 = 1;
pub const PWR_FAIL : i32 = -1;
pub const PWR_SUSPENDREQUEST : i32 = 1;
pub const PWR_SUSPENDRESUME : i32 = 2;
pub const PWR_CRITICALRESUME : i32 = 3;
pub const WM_COPYDATA : i32 = 74;
pub const WM_CANCELJOURNAL : i32 = 75;
pub const WM_NOTIFY : i32 = 78;
pub const WM_INPUTLANGCHANGEREQUEST : i32 = 80;
pub const WM_INPUTLANGCHANGE : i32 = 81;
pub const WM_TCARD : i32 = 82;
pub const WM_HELP : i32 = 83;
pub const WM_USERCHANGED : i32 = 84;
pub const WM_NOTIFYFORMAT : i32 = 85;
pub const NFR_ANSI : i32 = 1;
pub const NFR_UNICODE : i32 = 2;
pub const NF_QUERY : i32 = 3;
pub const NF_REQUERY : i32 = 4;
pub const WM_CONTEXTMENU : i32 = 123;
pub const WM_STYLECHANGING : i32 = 124;
pub const WM_STYLECHANGED : i32 = 125;
pub const WM_DISPLAYCHANGE : i32 = 126;
pub const WM_GETICON : i32 = 127;
pub const WM_SETICON : i32 = 128;
pub const WM_NCCREATE : i32 = 129;
pub const WM_NCDESTROY : i32 = 130;
pub const WM_NCCALCSIZE : i32 = 131;
pub const WM_NCHITTEST : i32 = 132;
pub const WM_NCPAINT : i32 = 133;
pub const WM_NCACTIVATE : i32 = 134;
pub const WM_GETDLGCODE : i32 = 135;
pub const WM_SYNCPAINT : i32 = 136;
pub const WM_NCMOUSEMOVE : i32 = 160;
pub const WM_NCLBUTTONDOWN : i32 = 161;
pub const WM_NCLBUTTONUP : i32 = 162;
pub const WM_NCLBUTTONDBLCLK : i32 = 163;
pub const WM_NCRBUTTONDOWN : i32 = 164;
pub const WM_NCRBUTTONUP : i32 = 165;
pub const WM_NCRBUTTONDBLCLK : i32 = 166;
pub const WM_NCMBUTTONDOWN : i32 = 167;
pub const WM_NCMBUTTONUP : i32 = 168;
pub const WM_NCMBUTTONDBLCLK : i32 = 169;
pub const WM_NCXBUTTONDOWN : i32 = 171;
pub const WM_NCXBUTTONUP : i32 = 172;
pub const WM_NCXBUTTONDBLCLK : i32 = 173;
pub const WM_INPUT_DEVICE_CHANGE : i32 = 254;
pub const WM_INPUT : i32 = 255;
pub const WM_KEYFIRST : i32 = 256;
pub const WM_KEYDOWN : i32 = 256;
pub const WM_KEYUP : i32 = 257;
pub const WM_CHAR : i32 = 258;
pub const WM_DEADCHAR : i32 = 259;
pub const WM_SYSKEYDOWN : i32 = 260;
pub const WM_SYSKEYUP : i32 = 261;
pub const WM_SYSCHAR : i32 = 262;
pub const WM_SYSDEADCHAR : i32 = 263;
pub const WM_UNICHAR : i32 = 265;
pub const WM_KEYLAST : i32 = 265;
pub const UNICODE_NOCHAR : i32 = 65535;
pub const WM_IME_STARTCOMPOSITION : i32 = 269;
pub const WM_IME_ENDCOMPOSITION : i32 = 270;
pub const WM_IME_COMPOSITION : i32 = 271;
pub const WM_IME_KEYLAST : i32 = 271;
pub const WM_INITDIALOG : i32 = 272;
pub const WM_COMMAND : i32 = 273;
pub const WM_SYSCOMMAND : i32 = 274;
pub const WM_TIMER : i32 = 275;
pub const WM_HSCROLL : i32 = 276;
pub const WM_VSCROLL : i32 = 277;
pub const WM_INITMENU : i32 = 278;
pub const WM_INITMENUPOPUP : i32 = 279;
pub const WM_GESTURE : i32 = 281;
pub const WM_GESTURENOTIFY : i32 = 282;
pub const WM_MENUSELECT : i32 = 287;
pub const WM_MENUCHAR : i32 = 288;
pub const WM_ENTERIDLE : i32 = 289;
pub const WM_MENURBUTTONUP : i32 = 290;
pub const WM_MENUDRAG : i32 = 291;
pub const WM_MENUGETOBJECT : i32 = 292;
pub const WM_UNINITMENUPOPUP : i32 = 293;
pub const WM_MENUCOMMAND : i32 = 294;
pub const WM_CHANGEUISTATE : i32 = 295;
pub const WM_UPDATEUISTATE : i32 = 296;
pub const WM_QUERYUISTATE : i32 = 297;
pub const UIS_SET : i32 = 1;
pub const UIS_CLEAR : i32 = 2;
pub const UIS_INITIALIZE : i32 = 3;
pub const UISF_HIDEFOCUS : i32 = 1;
pub const UISF_HIDEACCEL : i32 = 2;
pub const UISF_ACTIVE : i32 = 4;
pub const WM_CTLCOLORMSGBOX : i32 = 306;
pub const WM_CTLCOLOREDIT : i32 = 307;
pub const WM_CTLCOLORLISTBOX : i32 = 308;
pub const WM_CTLCOLORBTN : i32 = 309;
pub const WM_CTLCOLORDLG : i32 = 310;
pub const WM_CTLCOLORSCROLLBAR : i32 = 311;
pub const WM_CTLCOLORSTATIC : i32 = 312;
pub const MN_GETHMENU : i32 = 481;
pub const WM_MOUSEFIRST : i32 = 512;
pub const WM_MOUSEMOVE : i32 = 512;
pub const WM_LBUTTONDOWN : i32 = 513;
pub const WM_LBUTTONUP : i32 = 514;
pub const WM_LBUTTONDBLCLK : i32 = 515;
pub const WM_RBUTTONDOWN : i32 = 516;
pub const WM_RBUTTONUP : i32 = 517;
pub const WM_RBUTTONDBLCLK : i32 = 518;
pub const WM_MBUTTONDOWN : i32 = 519;
pub const WM_MBUTTONUP : i32 = 520;
pub const WM_MBUTTONDBLCLK : i32 = 521;
pub const WM_MOUSEWHEEL : i32 = 522;
pub const WM_XBUTTONDOWN : i32 = 523;
pub const WM_XBUTTONUP : i32 = 524;
pub const WM_XBUTTONDBLCLK : i32 = 525;
pub const WM_MOUSEHWHEEL : i32 = 526;
pub const WM_MOUSELAST : i32 = 526;
pub const WHEEL_DELTA : i32 = 120;
pub const WHEEL_PAGESCROLL : u32 = 4294967295;
pub const XBUTTON1 : i32 = 1;
pub const XBUTTON2 : i32 = 2;
pub const WM_PARENTNOTIFY : i32 = 528;
pub const WM_ENTERMENULOOP : i32 = 529;
pub const WM_EXITMENULOOP : i32 = 530;
pub const WM_NEXTMENU : i32 = 531;
pub const WM_SIZING : i32 = 532;
pub const WM_CAPTURECHANGED : i32 = 533;
pub const WM_MOVING : i32 = 534;
pub const WM_POWERBROADCAST : i32 = 536;
pub const PBT_APMQUERYSUSPEND : i32 = 0;
pub const PBT_APMQUERYSTANDBY : i32 = 1;
pub const PBT_APMQUERYSUSPENDFAILED : i32 = 2;
pub const PBT_APMQUERYSTANDBYFAILED : i32 = 3;
pub const PBT_APMSUSPEND : i32 = 4;
pub const PBT_APMSTANDBY : i32 = 5;
pub const PBT_APMRESUMECRITICAL : i32 = 6;
pub const PBT_APMRESUMESUSPEND : i32 = 7;
pub const PBT_APMRESUMESTANDBY : i32 = 8;
pub const PBTF_APMRESUMEFROMFAILURE : i32 = 1;
pub const PBT_APMBATTERYLOW : i32 = 9;
pub const PBT_APMPOWERSTATUSCHANGE : i32 = 10;
pub const PBT_APMOEMEVENT : i32 = 11;
pub const PBT_APMRESUMEAUTOMATIC : i32 = 18;
pub const PBT_POWERSETTINGCHANGE : i32 = 32787;
pub const WM_DEVICECHANGE : i32 = 537;
pub const WM_MDICREATE : i32 = 544;
pub const WM_MDIDESTROY : i32 = 545;
pub const WM_MDIACTIVATE : i32 = 546;
pub const WM_MDIRESTORE : i32 = 547;
pub const WM_MDINEXT : i32 = 548;
pub const WM_MDIMAXIMIZE : i32 = 549;
pub const WM_MDITILE : i32 = 550;
pub const WM_MDICASCADE : i32 = 551;
pub const WM_MDIICONARRANGE : i32 = 552;
pub const WM_MDIGETACTIVE : i32 = 553;
pub const WM_MDISETMENU : i32 = 560;
pub const WM_ENTERSIZEMOVE : i32 = 561;
pub const WM_EXITSIZEMOVE : i32 = 562;
pub const WM_DROPFILES : i32 = 563;
pub const WM_MDIREFRESHMENU : i32 = 564;
pub const WM_POINTERDEVICECHANGE : i32 = 568;
pub const WM_POINTERDEVICEINRANGE : i32 = 569;
pub const WM_POINTERDEVICEOUTOFRANGE : i32 = 570;
pub const WM_TOUCH : i32 = 576;
pub const WM_NCPOINTERUPDATE : i32 = 577;
pub const WM_NCPOINTERDOWN : i32 = 578;
pub const WM_NCPOINTERUP : i32 = 579;
pub const WM_POINTERUPDATE : i32 = 581;
pub const WM_POINTERDOWN : i32 = 582;
pub const WM_POINTERUP : i32 = 583;
pub const WM_POINTERENTER : i32 = 585;
pub const WM_POINTERLEAVE : i32 = 586;
pub const WM_POINTERACTIVATE : i32 = 587;
pub const WM_POINTERCAPTURECHANGED : i32 = 588;
pub const WM_TOUCHHITTESTING : i32 = 589;
pub const WM_POINTERWHEEL : i32 = 590;
pub const WM_POINTERHWHEEL : i32 = 591;
pub const DM_POINTERHITTEST : i32 = 592;
pub const WM_POINTERROUTEDTO : i32 = 593;
pub const WM_POINTERROUTEDAWAY : i32 = 594;
pub const WM_POINTERROUTEDRELEASED : i32 = 595;
pub const WM_IME_SETCONTEXT : i32 = 641;
pub const WM_IME_NOTIFY : i32 = 642;
pub const WM_IME_CONTROL : i32 = 643;
pub const WM_IME_COMPOSITIONFULL : i32 = 644;
pub const WM_IME_SELECT : i32 = 645;
pub const WM_IME_CHAR : i32 = 646;
pub const WM_IME_REQUEST : i32 = 648;
pub const WM_IME_KEYDOWN : i32 = 656;
pub const WM_IME_KEYUP : i32 = 657;
pub const WM_MOUSEHOVER : i32 = 673;
pub const WM_MOUSELEAVE : i32 = 675;
pub const WM_NCMOUSEHOVER : i32 = 672;
pub const WM_NCMOUSELEAVE : i32 = 674;
pub const WM_WTSSESSION_CHANGE : i32 = 689;
pub const WM_TABLET_FIRST : i32 = 704;
pub const WM_TABLET_LAST : i32 = 735;
pub const WM_DPICHANGED : i32 = 736;
pub const WM_DPICHANGED_BEFOREPARENT : i32 = 738;
pub const WM_DPICHANGED_AFTERPARENT : i32 = 739;
pub const WM_GETDPISCALEDSIZE : i32 = 740;
pub const WM_CUT : i32 = 768;
pub const WM_COPY : i32 = 769;
pub const WM_PASTE : i32 = 770;
pub const WM_CLEAR : i32 = 771;
pub const WM_UNDO : i32 = 772;
pub const WM_RENDERFORMAT : i32 = 773;
pub const WM_RENDERALLFORMATS : i32 = 774;
pub const WM_DESTROYCLIPBOARD : i32 = 775;
pub const WM_DRAWCLIPBOARD : i32 = 776;
pub const WM_PAINTCLIPBOARD : i32 = 777;
pub const WM_VSCROLLCLIPBOARD : i32 = 778;
pub const WM_SIZECLIPBOARD : i32 = 779;
pub const WM_ASKCBFORMATNAME : i32 = 780;
pub const WM_CHANGECBCHAIN : i32 = 781;
pub const WM_HSCROLLCLIPBOARD : i32 = 782;
pub const WM_QUERYNEWPALETTE : i32 = 783;
pub const WM_PALETTEISCHANGING : i32 = 784;
pub const WM_PALETTECHANGED : i32 = 785;
pub const WM_HOTKEY : i32 = 786;
pub const WM_PRINT : i32 = 791;
pub const WM_PRINTCLIENT : i32 = 792;
pub const WM_APPCOMMAND : i32 = 793;
pub const WM_THEMECHANGED : i32 = 794;
pub const WM_CLIPBOARDUPDATE : i32 = 797;
pub const WM_DWMCOMPOSITIONCHANGED : i32 = 798;
pub const WM_DWMNCRENDERINGCHANGED : i32 = 799;
pub const WM_DWMCOLORIZATIONCOLORCHANGED : i32 = 800;
pub const WM_DWMWINDOWMAXIMIZEDCHANGE : i32 = 801;
pub const WM_DWMSENDICONICTHUMBNAIL : i32 = 803;
pub const WM_DWMSENDICONICLIVEPREVIEWBITMAP : i32 = 806;
pub const WM_GETTITLEBARINFOEX : i32 = 831;
pub const WM_HANDHELDFIRST : i32 = 856;
pub const WM_HANDHELDLAST : i32 = 863;
pub const WM_AFXFIRST : i32 = 864;
pub const WM_AFXLAST : i32 = 895;
pub const WM_PENWINFIRST : i32 = 896;
pub const WM_PENWINLAST : i32 = 911;
pub const WM_APP : i32 = 32768;
pub const WM_USER : i32 = 1024;
pub const WMSZ_LEFT : i32 = 1;
pub const WMSZ_RIGHT : i32 = 2;
pub const WMSZ_TOP : i32 = 3;
pub const WMSZ_TOPLEFT : i32 = 4;
pub const WMSZ_TOPRIGHT : i32 = 5;
pub const WMSZ_BOTTOM : i32 = 6;
pub const WMSZ_BOTTOMLEFT : i32 = 7;
pub const WMSZ_BOTTOMRIGHT : i32 = 8;
pub const HTERROR : i32 = -2;
pub const HTTRANSPARENT : i32 = -1;
pub const HTNOWHERE : i32 = 0;
pub const HTCLIENT : i32 = 1;
pub const HTCAPTION : i32 = 2;
pub const HTSYSMENU : i32 = 3;
pub const HTGROWBOX : i32 = 4;
pub const HTSIZE : i32 = 4;
pub const HTMENU : i32 = 5;
pub const HTHSCROLL : i32 = 6;
pub const HTVSCROLL : i32 = 7;
pub const HTMINBUTTON : i32 = 8;
pub const HTMAXBUTTON : i32 = 9;
pub const HTLEFT : i32 = 10;
pub const HTRIGHT : i32 = 11;
pub const HTTOP : i32 = 12;
pub const HTTOPLEFT : i32 = 13;
pub const HTTOPRIGHT : i32 = 14;
pub const HTBOTTOM : i32 = 15;
pub const HTBOTTOMLEFT : i32 = 16;
pub const HTBOTTOMRIGHT : i32 = 17;
pub const HTBORDER : i32 = 18;
pub const HTREDUCE : i32 = 8;
pub const HTZOOM : i32 = 9;
pub const HTSIZEFIRST : i32 = 10;
pub const HTSIZELAST : i32 = 17;
pub const HTOBJECT : i32 = 19;
pub const HTCLOSE : i32 = 20;
pub const HTHELP : i32 = 21;
pub const SMTO_NORMAL : i32 = 0;
pub const SMTO_BLOCK : i32 = 1;
pub const SMTO_ABORTIFHUNG : i32 = 2;
pub const SMTO_NOTIMEOUTIFNOTHUNG : i32 = 8;
pub const SMTO_ERRORONEXIT : i32 = 32;
pub const MA_ACTIVATE : i32 = 1;
pub const MA_ACTIVATEANDEAT : i32 = 2;
pub const MA_NOACTIVATE : i32 = 3;
pub const MA_NOACTIVATEANDEAT : i32 = 4;
pub const ICON_SMALL : i32 = 0;
pub const ICON_BIG : i32 = 1;
pub const ICON_SMALL2 : i32 = 2;
pub const SIZE_RESTORED : i32 = 0;
pub const SIZE_MINIMIZED : i32 = 1;
pub const SIZE_MAXIMIZED : i32 = 2;
pub const SIZE_MAXSHOW : i32 = 3;
pub const SIZE_MAXHIDE : i32 = 4;
pub const SIZENORMAL : i32 = 0;
pub const SIZEICONIC : i32 = 1;
pub const SIZEFULLSCREEN : i32 = 2;
pub const SIZEZOOMSHOW : i32 = 3;
pub const SIZEZOOMHIDE : i32 = 4;
pub const WVR_ALIGNTOP : i32 = 16;
pub const WVR_ALIGNLEFT : i32 = 32;
pub const WVR_ALIGNBOTTOM : i32 = 64;
pub const WVR_ALIGNRIGHT : i32 = 128;
pub const WVR_HREDRAW : i32 = 256;
pub const WVR_VREDRAW : i32 = 512;
pub const WVR_REDRAW : i32 = 768;
pub const WVR_VALIDRECTS : i32 = 1024;
pub const MK_LBUTTON : i32 = 1;
pub const MK_RBUTTON : i32 = 2;
pub const MK_SHIFT : i32 = 4;
pub const MK_CONTROL : i32 = 8;
pub const MK_MBUTTON : i32 = 16;
pub const MK_XBUTTON1 : i32 = 32;
pub const MK_XBUTTON2 : i32 = 64;
pub const TME_HOVER : u32 = 1;
pub const TME_LEAVE : u32 = 2;
pub const TME_NONCLIENT : u32 = 16;
pub const TME_QUERY : u32 = 1073741824;
pub const TME_CANCEL : u32 = 2147483648;
pub const HOVER_DEFAULT : u32 = 4294967295;
pub const WS_OVERLAPPED : u32 = 0;
pub const WS_POPUP : u32 = 2147483648;
pub const WS_CHILD : u32 = 1073741824;
pub const WS_MINIMIZE : u32 = 536870912;
pub const WS_VISIBLE : u32 = 268435456;
pub const WS_DISABLED : u32 = 134217728;
pub const WS_CLIPSIBLINGS : u32 = 67108864;
pub const WS_CLIPCHILDREN : u32 = 33554432;
pub const WS_MAXIMIZE : u32 = 16777216;
pub const WS_CAPTION : u32 = 12582912;
pub const WS_BORDER : u32 = 8388608;
pub const WS_DLGFRAME : u32 = 4194304;
pub const WS_VSCROLL : u32 = 2097152;
pub const WS_HSCROLL : u32 = 1048576;
pub const WS_SYSMENU : u32 = 524288;
pub const WS_THICKFRAME : u32 = 262144;
pub const WS_GROUP : u32 = 131072;
pub const WS_TABSTOP : u32 = 65536;
pub const WS_MINIMIZEBOX : u32 = 131072;
pub const WS_MAXIMIZEBOX : u32 = 65536;
pub const WS_TILED : u32 = 0;
pub const WS_ICONIC : u32 = 536870912;
pub const WS_SIZEBOX : u32 = 262144;
pub const WS_TILEDWINDOW : u32 = 13565952;
pub const WS_OVERLAPPEDWINDOW : u32 = 13565952;
pub const WS_POPUPWINDOW : u32 = 2156396544;
pub const WS_CHILDWINDOW : u32 = 1073741824;
pub const WS_EX_DLGMODALFRAME : i32 = 1;
pub const WS_EX_NOPARENTNOTIFY : i32 = 4;
pub const WS_EX_TOPMOST : i32 = 8;
pub const WS_EX_ACCEPTFILES : i32 = 16;
pub const WS_EX_TRANSPARENT : i32 = 32;
pub const WS_EX_MDICHILD : i32 = 64;
pub const WS_EX_TOOLWINDOW : i32 = 128;
pub const WS_EX_WINDOWEDGE : i32 = 256;
pub const WS_EX_CLIENTEDGE : i32 = 512;
pub const WS_EX_CONTEXTHELP : i32 = 1024;
pub const WS_EX_RIGHT : i32 = 4096;
pub const WS_EX_LEFT : i32 = 0;
pub const WS_EX_RTLREADING : i32 = 8192;
pub const WS_EX_LTRREADING : i32 = 0;
pub const WS_EX_LEFTSCROLLBAR : i32 = 16384;
pub const WS_EX_RIGHTSCROLLBAR : i32 = 0;
pub const WS_EX_CONTROLPARENT : i32 = 65536;
pub const WS_EX_STATICEDGE : i32 = 131072;
pub const WS_EX_APPWINDOW : i32 = 262144;
pub const WS_EX_OVERLAPPEDWINDOW : i32 = 768;
pub const WS_EX_PALETTEWINDOW : i32 = 392;
pub const WS_EX_NOINHERITLAYOUT : i32 = 1048576;
pub const WS_EX_NOREDIRECTIONBITMAP : i32 = 2097152;
pub const WS_EX_LAYOUTRTL : i32 = 4194304;
pub const WS_EX_COMPOSITED : i32 = 33554432;
pub const WS_EX_NOACTIVATE : i32 = 134217728;
pub const CS_VREDRAW : i32 = 1;
pub const CS_HREDRAW : i32 = 2;
pub const CS_DBLCLKS : i32 = 8;
pub const CS_OWNDC : i32 = 32;
pub const CS_CLASSDC : i32 = 64;
pub const CS_PARENTDC : i32 = 128;
pub const CS_NOCLOSE : i32 = 512;
pub const CS_SAVEBITS : i32 = 2048;
pub const CS_BYTEALIGNCLIENT : i32 = 4096;
pub const CS_BYTEALIGNWINDOW : i32 = 8192;
pub const CS_GLOBALCLASS : i32 = 16384;
pub const CS_IME : i32 = 65536;
pub const CS_DROPSHADOW : i32 = 131072;
pub const PRF_CHECKVISIBLE : i32 = 1;
pub const PRF_NONCLIENT : i32 = 2;
pub const PRF_CLIENT : i32 = 4;
pub const PRF_ERASEBKGND : i32 = 8;
pub const PRF_CHILDREN : i32 = 16;
pub const PRF_OWNED : i32 = 32;
pub const BDR_RAISEDOUTER : i32 = 1;
pub const BDR_SUNKENOUTER : i32 = 2;
pub const BDR_RAISEDINNER : i32 = 4;
pub const BDR_SUNKENINNER : i32 = 8;
pub const BDR_OUTER : i32 = 3;
pub const BDR_INNER : i32 = 12;
pub const BDR_RAISED : i32 = 5;
pub const BDR_SUNKEN : i32 = 10;
pub const EDGE_RAISED : i32 = 5;
pub const EDGE_SUNKEN : i32 = 10;
pub const EDGE_ETCHED : i32 = 6;
pub const EDGE_BUMP : i32 = 9;
pub const BF_LEFT : i32 = 1;
pub const BF_TOP : i32 = 2;
pub const BF_RIGHT : i32 = 4;
pub const BF_BOTTOM : i32 = 8;
pub const BF_TOPLEFT : i32 = 3;
pub const BF_TOPRIGHT : i32 = 6;
pub const BF_BOTTOMLEFT : i32 = 9;
pub const BF_BOTTOMRIGHT : i32 = 12;
pub const BF_RECT : i32 = 15;
pub const BF_DIAGONAL : i32 = 16;
pub const BF_DIAGONAL_ENDTOPRIGHT : i32 = 22;
pub const BF_DIAGONAL_ENDTOPLEFT : i32 = 19;
pub const BF_DIAGONAL_ENDBOTTOMLEFT : i32 = 25;
pub const BF_DIAGONAL_ENDBOTTOMRIGHT : i32 = 28;
pub const BF_MIDDLE : i32 = 2048;
pub const BF_SOFT : i32 = 4096;
pub const BF_ADJUST : i32 = 8192;
pub const BF_FLAT : i32 = 16384;
pub const BF_MONO : i32 = 32768;
pub const DFC_CAPTION : i32 = 1;
pub const DFC_MENU : i32 = 2;
pub const DFC_SCROLL : i32 = 3;
pub const DFC_BUTTON : i32 = 4;
pub const DFC_POPUPMENU : i32 = 5;
pub const DFCS_CAPTIONCLOSE : i32 = 0;
pub const DFCS_CAPTIONMIN : i32 = 1;
pub const DFCS_CAPTIONMAX : i32 = 2;
pub const DFCS_CAPTIONRESTORE : i32 = 3;
pub const DFCS_CAPTIONHELP : i32 = 4;
pub const DFCS_MENUARROW : i32 = 0;
pub const DFCS_MENUCHECK : i32 = 1;
pub const DFCS_MENUBULLET : i32 = 2;
pub const DFCS_MENUARROWRIGHT : i32 = 4;
pub const DFCS_SCROLLUP : i32 = 0;
pub const DFCS_SCROLLDOWN : i32 = 1;
pub const DFCS_SCROLLLEFT : i32 = 2;
pub const DFCS_SCROLLRIGHT : i32 = 3;
pub const DFCS_SCROLLCOMBOBOX : i32 = 5;
pub const DFCS_SCROLLSIZEGRIP : i32 = 8;
pub const DFCS_SCROLLSIZEGRIPRIGHT : i32 = 16;
pub const DFCS_BUTTONCHECK : i32 = 0;
pub const DFCS_BUTTONRADIOIMAGE : i32 = 1;
pub const DFCS_BUTTONRADIOMASK : i32 = 2;
pub const DFCS_BUTTONRADIO : i32 = 4;
pub const DFCS_BUTTON3STATE : i32 = 8;
pub const DFCS_BUTTONPUSH : i32 = 16;
pub const DFCS_INACTIVE : i32 = 256;
pub const DFCS_PUSHED : i32 = 512;
pub const DFCS_CHECKED : i32 = 1024;
pub const DFCS_TRANSPARENT : i32 = 2048;
pub const DFCS_HOT : i32 = 4096;
pub const DFCS_ADJUSTRECT : i32 = 8192;
pub const DFCS_FLAT : i32 = 16384;
pub const DFCS_MONO : i32 = 32768;
pub const DC_ACTIVE : i32 = 1;
pub const DC_SMALLCAP : i32 = 2;
pub const DC_ICON : i32 = 4;
pub const DC_TEXT : i32 = 8;
pub const DC_INBUTTON : i32 = 16;
pub const DC_GRADIENT : i32 = 32;
pub const DC_BUTTONS : i32 = 4096;
pub const IDANI_OPEN : i32 = 1;
pub const IDANI_CAPTION : i32 = 3;
pub const CF_TEXT : i32 = 1;
pub const CF_BITMAP : i32 = 2;
pub const CF_METAFILEPICT : i32 = 3;
pub const CF_SYLK : i32 = 4;
pub const CF_DIF : i32 = 5;
pub const CF_TIFF : i32 = 6;
pub const CF_OEMTEXT : i32 = 7;
pub const CF_DIB : i32 = 8;
pub const CF_PALETTE : i32 = 9;
pub const CF_PENDATA : i32 = 10;
pub const CF_RIFF : i32 = 11;
pub const CF_WAVE : i32 = 12;
pub const CF_UNICODETEXT : i32 = 13;
pub const CF_ENHMETAFILE : i32 = 14;
pub const CF_HDROP : i32 = 15;
pub const CF_LOCALE : i32 = 16;
pub const CF_DIBV5 : i32 = 17;
pub const CF_MAX : i32 = 18;
pub const CF_OWNERDISPLAY : i32 = 128;
pub const CF_DSPTEXT : i32 = 129;
pub const CF_DSPBITMAP : i32 = 130;
pub const CF_DSPMETAFILEPICT : i32 = 131;
pub const CF_DSPENHMETAFILE : i32 = 142;
pub const CF_PRIVATEFIRST : i32 = 512;
pub const CF_PRIVATELAST : i32 = 767;
pub const CF_GDIOBJFIRST : i32 = 768;
pub const CF_GDIOBJLAST : i32 = 1023;
pub const FVIRTKEY : i32 = 1;
pub const FNOINVERT : i32 = 2;
pub const FSHIFT : i32 = 4;
pub const FCONTROL : i32 = 8;
pub const FALT : i32 = 16;
pub const WPF_SETMINPOSITION : i32 = 1;
pub const WPF_RESTORETOMAXIMIZED : i32 = 2;
pub const WPF_ASYNCWINDOWPLACEMENT : i32 = 4;
pub const ODT_MENU : i32 = 1;
pub const ODT_LISTBOX : i32 = 2;
pub const ODT_COMBOBOX : i32 = 3;
pub const ODT_BUTTON : i32 = 4;
pub const ODT_STATIC : i32 = 5;
pub const ODA_DRAWENTIRE : i32 = 1;
pub const ODA_SELECT : i32 = 2;
pub const ODA_FOCUS : i32 = 4;
pub const ODS_SELECTED : i32 = 1;
pub const ODS_GRAYED : i32 = 2;
pub const ODS_DISABLED : i32 = 4;
pub const ODS_CHECKED : i32 = 8;
pub const ODS_FOCUS : i32 = 16;
pub const ODS_DEFAULT : i32 = 32;
pub const ODS_COMBOBOXEDIT : i32 = 4096;
pub const ODS_HOTLIGHT : i32 = 64;
pub const ODS_INACTIVE : i32 = 128;
pub const ODS_NOACCEL : i32 = 256;
pub const ODS_NOFOCUSRECT : i32 = 512;
pub const PM_NOREMOVE : i32 = 0;
pub const PM_REMOVE : i32 = 1;
pub const PM_NOYIELD : i32 = 2;
pub const PM_QS_INPUT : i32 = 470220800;
pub const PM_QS_POSTMESSAGE : i32 = 9961472;
pub const PM_QS_PAINT : i32 = 2097152;
pub const PM_QS_SENDMESSAGE : i32 = 4194304;
pub const MOD_ALT : i32 = 1;
pub const MOD_CONTROL : i32 = 2;
pub const MOD_SHIFT : i32 = 4;
pub const MOD_WIN : i32 = 8;
pub const MOD_NOREPEAT : i32 = 16384;
pub const IDHOT_SNAPWINDOW : i32 = -1;
pub const IDHOT_SNAPDESKTOP : i32 = -2;
pub const ENDSESSION_CLOSEAPP : u32 = 1;
pub const ENDSESSION_CRITICAL : u32 = 1073741824;
pub const ENDSESSION_LOGOFF : u32 = 2147483648;
pub const EWX_LOGOFF : i32 = 0;
pub const EWX_SHUTDOWN : i32 = 1;
pub const EWX_REBOOT : i32 = 2;
pub const EWX_FORCE : i32 = 4;
pub const EWX_POWEROFF : i32 = 8;
pub const EWX_FORCEIFHUNG : i32 = 16;
pub const EWX_QUICKRESOLVE : i32 = 32;
pub const EWX_RESTARTAPPS : i32 = 64;
pub const EWX_HYBRID_SHUTDOWN : i32 = 4194304;
pub const EWX_BOOTOPTIONS : i32 = 16777216;
pub const EWX_ARSO : i32 = 67108864;
pub const BSM_ALLCOMPONENTS : i32 = 0;
pub const BSM_VXDS : i32 = 1;
pub const BSM_NETDRIVER : i32 = 2;
pub const BSM_INSTALLABLEDRIVERS : i32 = 4;
pub const BSM_APPLICATIONS : i32 = 8;
pub const BSM_ALLDESKTOPS : i32 = 16;
pub const BSF_QUERY : i32 = 1;
pub const BSF_IGNORECURRENTTASK : i32 = 2;
pub const BSF_FLUSHDISK : i32 = 4;
pub const BSF_NOHANG : i32 = 8;
pub const BSF_POSTMESSAGE : i32 = 16;
pub const BSF_FORCEIFHUNG : i32 = 32;
pub const BSF_NOTIMEOUTIFNOTHUNG : i32 = 64;
pub const BSF_ALLOWSFW : i32 = 128;
pub const BSF_SENDNOTIFYMESSAGE : i32 = 256;
pub const BSF_RETURNHDESK : i32 = 512;
pub const BSF_LUID : i32 = 1024;
pub const BROADCAST_QUERY_DENY : i32 = 1112363332;
pub const DEVICE_NOTIFY_WINDOW_HANDLE : i32 = 0;
pub const DEVICE_NOTIFY_SERVICE_HANDLE : i32 = 1;
pub const DEVICE_NOTIFY_ALL_INTERFACE_CLASSES : i32 = 4;
pub const HWND_BROADCAST : i32 = 65535;
pub const HWND_MESSAGE : i32 = -3;
pub const ISMEX_NOSEND : i32 = 0;
pub const ISMEX_SEND : i32 = 1;
pub const ISMEX_NOTIFY : i32 = 2;
pub const ISMEX_CALLBACK : i32 = 4;
pub const ISMEX_REPLIED : i32 = 8;
pub const CW_USEDEFAULT : i32 = -2147483648;
pub const HWND_DESKTOP : i32 = 0;
pub const PW_CLIENTONLY : i32 = 1;
pub const PW_RENDERFULLCONTENT : i32 = 2;
pub const LWA_COLORKEY : i32 = 1;
pub const LWA_ALPHA : i32 = 2;
pub const ULW_COLORKEY : i32 = 1;
pub const ULW_ALPHA : i32 = 2;
pub const ULW_OPAQUE : i32 = 4;
pub const ULW_EX_NORESIZE : i32 = 8;
pub const FLASHW_STOP : i32 = 0;
pub const FLASHW_CAPTION : i32 = 1;
pub const FLASHW_TRAY : i32 = 2;
pub const FLASHW_ALL : i32 = 3;
pub const FLASHW_TIMER : i32 = 4;
pub const FLASHW_TIMERNOFG : i32 = 12;
pub const WDA_NONE : i32 = 0;
pub const WDA_MONITOR : i32 = 1;
pub const WDA_EXCLUDEFROMCAPTURE : i32 = 17;
pub const SWP_NOSIZE : i32 = 1;
pub const SWP_NOMOVE : i32 = 2;
pub const SWP_NOZORDER : i32 = 4;
pub const SWP_NOREDRAW : i32 = 8;
pub const SWP_NOACTIVATE : i32 = 16;
pub const SWP_FRAMECHANGED : i32 = 32;
pub const SWP_SHOWWINDOW : i32 = 64;
pub const SWP_HIDEWINDOW : i32 = 128;
pub const SWP_NOCOPYBITS : i32 = 256;
pub const SWP_NOOWNERZORDER : i32 = 512;
pub const SWP_NOSENDCHANGING : i32 = 1024;
pub const SWP_DRAWFRAME : i32 = 32;
pub const SWP_NOREPOSITION : i32 = 512;
pub const SWP_DEFERERASE : i32 = 8192;
pub const SWP_ASYNCWINDOWPOS : i32 = 16384;
pub const HWND_TOP : i32 = 0;
pub const HWND_BOTTOM : i32 = 1;
pub const HWND_TOPMOST : i32 = -1;
pub const HWND_NOTOPMOST : i32 = -2;
pub const DLGWINDOWEXTRA : i32 = 30;
pub const KEYEVENTF_EXTENDEDKEY : i32 = 1;
pub const KEYEVENTF_KEYUP : i32 = 2;
pub const KEYEVENTF_UNICODE : i32 = 4;
pub const KEYEVENTF_SCANCODE : i32 = 8;
pub const MOUSEEVENTF_MOVE : i32 = 1;
pub const MOUSEEVENTF_LEFTDOWN : i32 = 2;
pub const MOUSEEVENTF_LEFTUP : i32 = 4;
pub const MOUSEEVENTF_RIGHTDOWN : i32 = 8;
pub const MOUSEEVENTF_RIGHTUP : i32 = 16;
pub const MOUSEEVENTF_MIDDLEDOWN : i32 = 32;
pub const MOUSEEVENTF_MIDDLEUP : i32 = 64;
pub const MOUSEEVENTF_XDOWN : i32 = 128;
pub const MOUSEEVENTF_XUP : i32 = 256;
pub const MOUSEEVENTF_WHEEL : i32 = 2048;
pub const MOUSEEVENTF_HWHEEL : i32 = 4096;
pub const MOUSEEVENTF_MOVE_NOCOALESCE : i32 = 8192;
pub const MOUSEEVENTF_VIRTUALDESK : i32 = 16384;
pub const MOUSEEVENTF_ABSOLUTE : i32 = 32768;
pub const INPUT_MOUSE : i32 = 0;
pub const INPUT_KEYBOARD : i32 = 1;
pub const INPUT_HARDWARE : i32 = 2;
pub const TOUCHEVENTF_MOVE : i32 = 1;
pub const TOUCHEVENTF_DOWN : i32 = 2;
pub const TOUCHEVENTF_UP : i32 = 4;
pub const TOUCHEVENTF_INRANGE : i32 = 8;
pub const TOUCHEVENTF_PRIMARY : i32 = 16;
pub const TOUCHEVENTF_NOCOALESCE : i32 = 32;
pub const TOUCHEVENTF_PEN : i32 = 64;
pub const TOUCHEVENTF_PALM : i32 = 128;
pub const TOUCHINPUTMASKF_TIMEFROMSYSTEM : i32 = 1;
pub const TOUCHINPUTMASKF_EXTRAINFO : i32 = 2;
pub const TOUCHINPUTMASKF_CONTACTAREA : i32 = 4;
pub const TWF_FINETOUCH : i32 = 1;
pub const TWF_WANTPALM : i32 = 2;
pub const POINTER_FLAG_NONE : i32 = 0;
pub const POINTER_FLAG_NEW : i32 = 1;
pub const POINTER_FLAG_INRANGE : i32 = 2;
pub const POINTER_FLAG_INCONTACT : i32 = 4;
pub const POINTER_FLAG_FIRSTBUTTON : i32 = 16;
pub const POINTER_FLAG_SECONDBUTTON : i32 = 32;
pub const POINTER_FLAG_THIRDBUTTON : i32 = 64;
pub const POINTER_FLAG_FOURTHBUTTON : i32 = 128;
pub const POINTER_FLAG_FIFTHBUTTON : i32 = 256;
pub const POINTER_FLAG_PRIMARY : i32 = 8192;
pub const POINTER_FLAG_CONFIDENCE : i32 = 16384;
pub const POINTER_FLAG_CANCELED : i32 = 32768;
pub const POINTER_FLAG_DOWN : i32 = 65536;
pub const POINTER_FLAG_UPDATE : i32 = 131072;
pub const POINTER_FLAG_UP : i32 = 262144;
pub const POINTER_FLAG_WHEEL : i32 = 524288;
pub const POINTER_FLAG_HWHEEL : i32 = 1048576;
pub const POINTER_FLAG_CAPTURECHANGED : i32 = 2097152;
pub const POINTER_FLAG_HASTRANSFORM : i32 = 4194304;
pub const POINTER_MOD_SHIFT : i32 = 4;
pub const POINTER_MOD_CTRL : i32 = 8;
pub const TOUCH_FLAG_NONE : i32 = 0;
pub const TOUCH_MASK_NONE : i32 = 0;
pub const TOUCH_MASK_CONTACTAREA : i32 = 1;
pub const TOUCH_MASK_ORIENTATION : i32 = 2;
pub const TOUCH_MASK_PRESSURE : i32 = 4;
pub const PEN_FLAG_NONE : i32 = 0;
pub const PEN_FLAG_BARREL : i32 = 1;
pub const PEN_FLAG_INVERTED : i32 = 2;
pub const PEN_FLAG_ERASER : i32 = 4;
pub const PEN_MASK_NONE : i32 = 0;
pub const PEN_MASK_PRESSURE : i32 = 1;
pub const PEN_MASK_ROTATION : i32 = 2;
pub const PEN_MASK_TILT_X : i32 = 4;
pub const PEN_MASK_TILT_Y : i32 = 8;
pub const POINTER_MESSAGE_FLAG_NEW : i32 = 1;
pub const POINTER_MESSAGE_FLAG_INRANGE : i32 = 2;
pub const POINTER_MESSAGE_FLAG_INCONTACT : i32 = 4;
pub const POINTER_MESSAGE_FLAG_FIRSTBUTTON : i32 = 16;
pub const POINTER_MESSAGE_FLAG_SECONDBUTTON : i32 = 32;
pub const POINTER_MESSAGE_FLAG_THIRDBUTTON : i32 = 64;
pub const POINTER_MESSAGE_FLAG_FOURTHBUTTON : i32 = 128;
pub const POINTER_MESSAGE_FLAG_FIFTHBUTTON : i32 = 256;
pub const POINTER_MESSAGE_FLAG_PRIMARY : i32 = 8192;
pub const POINTER_MESSAGE_FLAG_CONFIDENCE : i32 = 16384;
pub const POINTER_MESSAGE_FLAG_CANCELED : i32 = 32768;
pub const PA_ACTIVATE : i32 = 1;
pub const PA_NOACTIVATE : i32 = 3;
pub const MAX_TOUCH_COUNT : i32 = 256;
pub const TOUCH_FEEDBACK_DEFAULT : i32 = 1;
pub const TOUCH_FEEDBACK_INDIRECT : i32 = 2;
pub const TOUCH_FEEDBACK_NONE : i32 = 3;
pub const TOUCH_HIT_TESTING_DEFAULT : i32 = 0;
pub const TOUCH_HIT_TESTING_CLIENT : i32 = 1;
pub const TOUCH_HIT_TESTING_NONE : i32 = 2;
pub const TOUCH_HIT_TESTING_PROXIMITY_CLOSEST : i32 = 0;
pub const TOUCH_HIT_TESTING_PROXIMITY_FARTHEST : i32 = 4095;
pub const GWFS_INCLUDE_ANCESTORS : i32 = 1;
pub const MAPVK_VK_TO_VSC : i32 = 0;
pub const MAPVK_VSC_TO_VK : i32 = 1;
pub const MAPVK_VK_TO_CHAR : i32 = 2;
pub const MAPVK_VSC_TO_VK_EX : i32 = 3;
pub const MAPVK_VK_TO_VSC_EX : i32 = 4;
pub const MWMO_WAITALL : i32 = 1;
pub const MWMO_ALERTABLE : i32 = 2;
pub const MWMO_INPUTAVAILABLE : i32 = 4;
pub const QS_KEY : i32 = 1;
pub const QS_MOUSEMOVE : i32 = 2;
pub const QS_MOUSEBUTTON : i32 = 4;
pub const QS_POSTMESSAGE : i32 = 8;
pub const QS_TIMER : i32 = 16;
pub const QS_PAINT : i32 = 32;
pub const QS_SENDMESSAGE : i32 = 64;
pub const QS_HOTKEY : i32 = 128;
pub const QS_ALLPOSTMESSAGE : i32 = 256;
pub const QS_RAWINPUT : i32 = 1024;
pub const QS_TOUCH : i32 = 2048;
pub const QS_POINTER : i32 = 4096;
pub const QS_MOUSE : i32 = 6;
pub const QS_INPUT : i32 = 7175;
pub const QS_ALLEVENTS : i32 = 7359;
pub const QS_ALLINPUT : i32 = 7423;
pub const USER_TIMER_MAXIMUM : i32 = 2147483647;
pub const USER_TIMER_MINIMUM : i32 = 10;
pub const TIMERV_DEFAULT_COALESCING : u32 = 0;
pub const TIMERV_NO_COALESCING : u32 = 4294967295;
pub const TIMERV_COALESCING_MIN : u32 = 1;
pub const TIMERV_COALESCING_MAX : u32 = 2147483637;
pub const SM_CXSCREEN : i32 = 0;
pub const SM_CYSCREEN : i32 = 1;
pub const SM_CXVSCROLL : i32 = 2;
pub const SM_CYHSCROLL : i32 = 3;
pub const SM_CYCAPTION : i32 = 4;
pub const SM_CXBORDER : i32 = 5;
pub const SM_CYBORDER : i32 = 6;
pub const SM_CXDLGFRAME : i32 = 7;
pub const SM_CYDLGFRAME : i32 = 8;
pub const SM_CYVTHUMB : i32 = 9;
pub const SM_CXHTHUMB : i32 = 10;
pub const SM_CXICON : i32 = 11;
pub const SM_CYICON : i32 = 12;
pub const SM_CXCURSOR : i32 = 13;
pub const SM_CYCURSOR : i32 = 14;
pub const SM_CYMENU : i32 = 15;
pub const SM_CXFULLSCREEN : i32 = 16;
pub const SM_CYFULLSCREEN : i32 = 17;
pub const SM_CYKANJIWINDOW : i32 = 18;
pub const SM_MOUSEPRESENT : i32 = 19;
pub const SM_CYVSCROLL : i32 = 20;
pub const SM_CXHSCROLL : i32 = 21;
pub const SM_DEBUG : i32 = 22;
pub const SM_SWAPBUTTON : i32 = 23;
pub const SM_RESERVED1 : i32 = 24;
pub const SM_RESERVED2 : i32 = 25;
pub const SM_RESERVED3 : i32 = 26;
pub const SM_RESERVED4 : i32 = 27;
pub const SM_CXMIN : i32 = 28;
pub const SM_CYMIN : i32 = 29;
pub const SM_CXSIZE : i32 = 30;
pub const SM_CYSIZE : i32 = 31;
pub const SM_CXFRAME : i32 = 32;
pub const SM_CYFRAME : i32 = 33;
pub const SM_CXMINTRACK : i32 = 34;
pub const SM_CYMINTRACK : i32 = 35;
pub const SM_CXDOUBLECLK : i32 = 36;
pub const SM_CYDOUBLECLK : i32 = 37;
pub const SM_CXICONSPACING : i32 = 38;
pub const SM_CYICONSPACING : i32 = 39;
pub const SM_MENUDROPALIGNMENT : i32 = 40;
pub const SM_PENWINDOWS : i32 = 41;
pub const SM_DBCSENABLED : i32 = 42;
pub const SM_CMOUSEBUTTONS : i32 = 43;
pub const SM_CXFIXEDFRAME : i32 = 7;
pub const SM_CYFIXEDFRAME : i32 = 8;
pub const SM_CXSIZEFRAME : i32 = 32;
pub const SM_CYSIZEFRAME : i32 = 33;
pub const SM_SECURE : i32 = 44;
pub const SM_CXEDGE : i32 = 45;
pub const SM_CYEDGE : i32 = 46;
pub const SM_CXMINSPACING : i32 = 47;
pub const SM_CYMINSPACING : i32 = 48;
pub const SM_CXSMICON : i32 = 49;
pub const SM_CYSMICON : i32 = 50;
pub const SM_CYSMCAPTION : i32 = 51;
pub const SM_CXSMSIZE : i32 = 52;
pub const SM_CYSMSIZE : i32 = 53;
pub const SM_CXMENUSIZE : i32 = 54;
pub const SM_CYMENUSIZE : i32 = 55;
pub const SM_ARRANGE : i32 = 56;
pub const SM_CXMINIMIZED : i32 = 57;
pub const SM_CYMINIMIZED : i32 = 58;
pub const SM_CXMAXTRACK : i32 = 59;
pub const SM_CYMAXTRACK : i32 = 60;
pub const SM_CXMAXIMIZED : i32 = 61;
pub const SM_CYMAXIMIZED : i32 = 62;
pub const SM_NETWORK : i32 = 63;
pub const SM_CLEANBOOT : i32 = 67;
pub const SM_CXDRAG : i32 = 68;
pub const SM_CYDRAG : i32 = 69;
pub const SM_SHOWSOUNDS : i32 = 70;
pub const SM_CXMENUCHECK : i32 = 71;
pub const SM_CYMENUCHECK : i32 = 72;
pub const SM_SLOWMACHINE : i32 = 73;
pub const SM_MIDEASTENABLED : i32 = 74;
pub const SM_MOUSEWHEELPRESENT : i32 = 75;
pub const SM_XVIRTUALSCREEN : i32 = 76;
pub const SM_YVIRTUALSCREEN : i32 = 77;
pub const SM_CXVIRTUALSCREEN : i32 = 78;
pub const SM_CYVIRTUALSCREEN : i32 = 79;
pub const SM_CMONITORS : i32 = 80;
pub const SM_SAMEDISPLAYFORMAT : i32 = 81;
pub const SM_IMMENABLED : i32 = 82;
pub const SM_CXFOCUSBORDER : i32 = 83;
pub const SM_CYFOCUSBORDER : i32 = 84;
pub const SM_TABLETPC : i32 = 86;
pub const SM_MEDIACENTER : i32 = 87;
pub const SM_STARTER : i32 = 88;
pub const SM_SERVERR2 : i32 = 89;
pub const SM_MOUSEHORIZONTALWHEELPRESENT : i32 = 91;
pub const SM_CXPADDEDBORDER : i32 = 92;
pub const SM_DIGITIZER : i32 = 94;
pub const SM_MAXIMUMTOUCHES : i32 = 95;
pub const SM_CMETRICS : i32 = 97;
pub const SM_REMOTESESSION : i32 = 4096;
pub const SM_SHUTTINGDOWN : i32 = 8192;
pub const SM_REMOTECONTROL : i32 = 8193;
pub const SM_CARETBLINKINGENABLED : i32 = 8194;
pub const SM_CONVERTIBLESLATEMODE : i32 = 8195;
pub const SM_SYSTEMDOCKED : i32 = 8196;
pub const PMB_ACTIVE : i32 = 1;
pub const MNC_IGNORE : i32 = 0;
pub const MNC_CLOSE : i32 = 1;
pub const MNC_EXECUTE : i32 = 2;
pub const MNC_SELECT : i32 = 3;
pub const MNS_NOCHECK : u32 = 2147483648;
pub const MNS_MODELESS : u32 = 1073741824;
pub const MNS_DRAGDROP : u32 = 536870912;
pub const MNS_AUTODISMISS : u32 = 268435456;
pub const MNS_NOTIFYBYPOS : u32 = 134217728;
pub const MNS_CHECKORBMP : u32 = 67108864;
pub const MIM_MAXHEIGHT : u32 = 1;
pub const MIM_BACKGROUND : u32 = 2;
pub const MIM_HELPID : u32 = 4;
pub const MIM_MENUDATA : u32 = 8;
pub const MIM_STYLE : u32 = 16;
pub const MIM_APPLYTOSUBMENUS : u32 = 2147483648;
pub const MND_CONTINUE : i32 = 0;
pub const MND_ENDMENU : i32 = 1;
pub const MNGOF_TOPGAP : i32 = 1;
pub const MNGOF_BOTTOMGAP : i32 = 2;
pub const MNGO_NOINTERFACE : i32 = 0;
pub const MNGO_NOERROR : i32 = 1;
pub const MIIM_STATE : i32 = 1;
pub const MIIM_ID : i32 = 2;
pub const MIIM_SUBMENU : i32 = 4;
pub const MIIM_CHECKMARKS : i32 = 8;
pub const MIIM_TYPE : i32 = 16;
pub const MIIM_DATA : i32 = 32;
pub const MIIM_STRING : i32 = 64;
pub const MIIM_BITMAP : i32 = 128;
pub const MIIM_FTYPE : i32 = 256;
pub const HBMMENU_CALLBACK : i32 = -1;
pub const HBMMENU_SYSTEM : i32 = 1;
pub const HBMMENU_MBAR_RESTORE : i32 = 2;
pub const HBMMENU_MBAR_MINIMIZE : i32 = 3;
pub const HBMMENU_MBAR_CLOSE : i32 = 5;
pub const HBMMENU_MBAR_CLOSE_D : i32 = 6;
pub const HBMMENU_MBAR_MINIMIZE_D : i32 = 7;
pub const HBMMENU_POPUP_CLOSE : i32 = 8;
pub const HBMMENU_POPUP_RESTORE : i32 = 9;
pub const HBMMENU_POPUP_MAXIMIZE : i32 = 10;
pub const HBMMENU_POPUP_MINIMIZE : i32 = 11;
pub const TPM_LEFTBUTTON : i32 = 0;
pub const TPM_RIGHTBUTTON : i32 = 2;
pub const TPM_LEFTALIGN : i32 = 0;
pub const TPM_CENTERALIGN : i32 = 4;
pub const TPM_RIGHTALIGN : i32 = 8;
pub const TPM_TOPALIGN : i32 = 0;
pub const TPM_VCENTERALIGN : i32 = 16;
pub const TPM_BOTTOMALIGN : i32 = 32;
pub const TPM_HORIZONTAL : i32 = 0;
pub const TPM_VERTICAL : i32 = 64;
pub const TPM_NONOTIFY : i32 = 128;
pub const TPM_RETURNCMD : i32 = 256;
pub const TPM_RECURSE : i32 = 1;
pub const TPM_HORPOSANIMATION : i32 = 1024;
pub const TPM_HORNEGANIMATION : i32 = 2048;
pub const TPM_VERPOSANIMATION : i32 = 4096;
pub const TPM_VERNEGANIMATION : i32 = 8192;
pub const TPM_NOANIMATION : i32 = 16384;
pub const TPM_LAYOUTRTL : i32 = 32768;
pub const TPM_WORKAREA : i32 = 65536;
pub const DOF_EXECUTABLE : i32 = 32769;
pub const DOF_DOCUMENT : i32 = 32770;
pub const DOF_DIRECTORY : i32 = 32771;
pub const DOF_MULTIPLE : i32 = 32772;
pub const DOF_PROGMAN : i32 = 1;
pub const DOF_SHELLDATA : i32 = 2;
pub const DO_DROPFILE : i32 = 1162627398;
pub const DO_PRINTFILE : i32 = 1414419024;
pub const DT_TOP : i32 = 0;
pub const DT_LEFT : i32 = 0;
pub const DT_CENTER : i32 = 1;
pub const DT_RIGHT : i32 = 2;
pub const DT_VCENTER : i32 = 4;
pub const DT_BOTTOM : i32 = 8;
pub const DT_WORDBREAK : i32 = 16;
pub const DT_SINGLELINE : i32 = 32;
pub const DT_EXPANDTABS : i32 = 64;
pub const DT_TABSTOP : i32 = 128;
pub const DT_NOCLIP : i32 = 256;
pub const DT_EXTERNALLEADING : i32 = 512;
pub const DT_CALCRECT : i32 = 1024;
pub const DT_NOPREFIX : i32 = 2048;
pub const DT_INTERNAL : i32 = 4096;
pub const DT_EDITCONTROL : i32 = 8192;
pub const DT_PATH_ELLIPSIS : i32 = 16384;
pub const DT_END_ELLIPSIS : i32 = 32768;
pub const DT_MODIFYSTRING : i32 = 65536;
pub const DT_RTLREADING : i32 = 131072;
pub const DT_WORD_ELLIPSIS : i32 = 262144;
pub const DT_NOFULLWIDTHCHARBREAK : i32 = 524288;
pub const DT_HIDEPREFIX : i32 = 1048576;
pub const DT_PREFIXONLY : i32 = 2097152;
pub const DST_COMPLEX : i32 = 0;
pub const DST_TEXT : i32 = 1;
pub const DST_PREFIXTEXT : i32 = 2;
pub const DST_ICON : i32 = 3;
pub const DST_BITMAP : i32 = 4;
pub const DSS_NORMAL : i32 = 0;
pub const DSS_UNION : i32 = 16;
pub const DSS_DISABLED : i32 = 32;
pub const DSS_MONO : i32 = 128;
pub const DSS_HIDEPREFIX : i32 = 512;
pub const DSS_PREFIXONLY : i32 = 1024;
pub const DSS_RIGHT : i32 = 32768;
pub const ASFW_ANY : u32 = 4294967295;
pub const LSFW_LOCK : i32 = 1;
pub const LSFW_UNLOCK : i32 = 2;
pub const DCX_WINDOW : i32 = 1;
pub const DCX_CACHE : i32 = 2;
pub const DCX_NORESETATTRS : i32 = 4;
pub const DCX_CLIPCHILDREN : i32 = 8;
pub const DCX_CLIPSIBLINGS : i32 = 16;
pub const DCX_PARENTCLIP : i32 = 32;
pub const DCX_EXCLUDERGN : i32 = 64;
pub const DCX_INTERSECTRGN : i32 = 128;
pub const DCX_EXCLUDEUPDATE : i32 = 256;
pub const DCX_INTERSECTUPDATE : i32 = 512;
pub const DCX_LOCKWINDOWUPDATE : i32 = 1024;
pub const DCX_VALIDATE : i32 = 2097152;
pub const RDW_INVALIDATE : i32 = 1;
pub const RDW_INTERNALPAINT : i32 = 2;
pub const RDW_ERASE : i32 = 4;
pub const RDW_VALIDATE : i32 = 8;
pub const RDW_NOINTERNALPAINT : i32 = 16;
pub const RDW_NOERASE : i32 = 32;
pub const RDW_NOCHILDREN : i32 = 64;
pub const RDW_ALLCHILDREN : i32 = 128;
pub const RDW_UPDATENOW : i32 = 256;
pub const RDW_ERASENOW : i32 = 512;
pub const RDW_FRAME : i32 = 1024;
pub const RDW_NOFRAME : i32 = 2048;
pub const SW_SCROLLCHILDREN : i32 = 1;
pub const SW_INVALIDATE : i32 = 2;
pub const SW_ERASE : i32 = 4;
pub const SW_SMOOTHSCROLL : i32 = 16;
pub const ESB_ENABLE_BOTH : i32 = 0;
pub const ESB_DISABLE_BOTH : i32 = 3;
pub const ESB_DISABLE_LEFT : i32 = 1;
pub const ESB_DISABLE_RIGHT : i32 = 2;
pub const ESB_DISABLE_UP : i32 = 1;
pub const ESB_DISABLE_DOWN : i32 = 2;
pub const ESB_DISABLE_LTUP : i32 = 1;
pub const ESB_DISABLE_RTDN : i32 = 2;
pub const HELPINFO_WINDOW : i32 = 1;
pub const HELPINFO_MENUITEM : i32 = 2;
pub const MB_OK : i32 = 0;
pub const MB_OKCANCEL : i32 = 1;
pub const MB_ABORTRETRYIGNORE : i32 = 2;
pub const MB_YESNOCANCEL : i32 = 3;
pub const MB_YESNO : i32 = 4;
pub const MB_RETRYCANCEL : i32 = 5;
pub const MB_CANCELTRYCONTINUE : i32 = 6;
pub const MB_ICONHAND : i32 = 16;
pub const MB_ICONQUESTION : i32 = 32;
pub const MB_ICONEXCLAMATION : i32 = 48;
pub const MB_ICONASTERISK : i32 = 64;
pub const MB_USERICON : i32 = 128;
pub const MB_ICONWARNING : i32 = 48;
pub const MB_ICONERROR : i32 = 16;
pub const MB_ICONINFORMATION : i32 = 64;
pub const MB_ICONSTOP : i32 = 16;
pub const MB_DEFBUTTON1 : i32 = 0;
pub const MB_DEFBUTTON2 : i32 = 256;
pub const MB_DEFBUTTON3 : i32 = 512;
pub const MB_DEFBUTTON4 : i32 = 768;
pub const MB_APPLMODAL : i32 = 0;
pub const MB_SYSTEMMODAL : i32 = 4096;
pub const MB_TASKMODAL : i32 = 8192;
pub const MB_HELP : i32 = 16384;
pub const MB_NOFOCUS : i32 = 32768;
pub const MB_SETFOREGROUND : i32 = 65536;
pub const MB_DEFAULT_DESKTOP_ONLY : i32 = 131072;
pub const MB_TOPMOST : i32 = 262144;
pub const MB_RIGHT : i32 = 524288;
pub const MB_RTLREADING : i32 = 1048576;
pub const MB_SERVICE_NOTIFICATION : i32 = 2097152;
pub const MB_SERVICE_NOTIFICATION_NT3X : i32 = 262144;
pub const MB_TYPEMASK : i32 = 15;
pub const MB_ICONMASK : i32 = 240;
pub const MB_DEFMASK : i32 = 3840;
pub const MB_MODEMASK : i32 = 12288;
pub const MB_MISCMASK : i32 = 49152;
pub const CWP_ALL : i32 = 0;
pub const CWP_SKIPINVISIBLE : i32 = 1;
pub const CWP_SKIPDISABLED : i32 = 2;
pub const CWP_SKIPTRANSPARENT : i32 = 4;
pub const CTLCOLOR_MSGBOX : i32 = 0;
pub const CTLCOLOR_EDIT : i32 = 1;
pub const CTLCOLOR_LISTBOX : i32 = 2;
pub const CTLCOLOR_BTN : i32 = 3;
pub const CTLCOLOR_DLG : i32 = 4;
pub const CTLCOLOR_SCROLLBAR : i32 = 5;
pub const CTLCOLOR_STATIC : i32 = 6;
pub const CTLCOLOR_MAX : i32 = 7;
pub const COLOR_SCROLLBAR : i32 = 0;
pub const COLOR_BACKGROUND : i32 = 1;
pub const COLOR_ACTIVECAPTION : i32 = 2;
pub const COLOR_INACTIVECAPTION : i32 = 3;
pub const COLOR_MENU : i32 = 4;
pub const COLOR_WINDOW : i32 = 5;
pub const COLOR_WINDOWFRAME : i32 = 6;
pub const COLOR_MENUTEXT : i32 = 7;
pub const COLOR_WINDOWTEXT : i32 = 8;
pub const COLOR_CAPTIONTEXT : i32 = 9;
pub const COLOR_ACTIVEBORDER : i32 = 10;
pub const COLOR_INACTIVEBORDER : i32 = 11;
pub const COLOR_APPWORKSPACE : i32 = 12;
pub const COLOR_HIGHLIGHT : i32 = 13;
pub const COLOR_HIGHLIGHTTEXT : i32 = 14;
pub const COLOR_BTNFACE : i32 = 15;
pub const COLOR_BTNSHADOW : i32 = 16;
pub const COLOR_GRAYTEXT : i32 = 17;
pub const COLOR_BTNTEXT : i32 = 18;
pub const COLOR_INACTIVECAPTIONTEXT : i32 = 19;
pub const COLOR_BTNHIGHLIGHT : i32 = 20;
pub const COLOR_3DDKSHADOW : i32 = 21;
pub const COLOR_3DLIGHT : i32 = 22;
pub const COLOR_INFOTEXT : i32 = 23;
pub const COLOR_INFOBK : i32 = 24;
pub const COLOR_HOTLIGHT : i32 = 26;
pub const COLOR_GRADIENTACTIVECAPTION : i32 = 27;
pub const COLOR_GRADIENTINACTIVECAPTION : i32 = 28;
pub const COLOR_MENUHILIGHT : i32 = 29;
pub const COLOR_MENUBAR : i32 = 30;
pub const COLOR_DESKTOP : i32 = 1;
pub const COLOR_3DFACE : i32 = 15;
pub const COLOR_3DSHADOW : i32 = 16;
pub const COLOR_3DHIGHLIGHT : i32 = 20;
pub const COLOR_3DHILIGHT : i32 = 20;
pub const COLOR_BTNHILIGHT : i32 = 20;
pub const GW_HWNDFIRST : i32 = 0;
pub const GW_HWNDLAST : i32 = 1;
pub const GW_HWNDNEXT : i32 = 2;
pub const GW_HWNDPREV : i32 = 3;
pub const GW_OWNER : i32 = 4;
pub const GW_CHILD : i32 = 5;
pub const GW_ENABLEDPOPUP : i32 = 6;
pub const GW_MAX : i32 = 6;
pub const MF_INSERT : i32 = 0;
pub const MF_CHANGE : i32 = 128;
pub const MF_APPEND : i32 = 256;
pub const MF_DELETE : i32 = 512;
pub const MF_REMOVE : i32 = 4096;
pub const MF_BYCOMMAND : i32 = 0;
pub const MF_BYPOSITION : i32 = 1024;
pub const MF_SEPARATOR : i32 = 2048;
pub const MF_ENABLED : i32 = 0;
pub const MF_GRAYED : i32 = 1;
pub const MF_DISABLED : i32 = 2;
pub const MF_UNCHECKED : i32 = 0;
pub const MF_CHECKED : i32 = 8;
pub const MF_USECHECKBITMAPS : i32 = 512;
pub const MF_STRING : i32 = 0;
pub const MF_BITMAP : i32 = 4;
pub const MF_OWNERDRAW : i32 = 256;
pub const MF_POPUP : i32 = 16;
pub const MF_MENUBARBREAK : i32 = 32;
pub const MF_MENUBREAK : i32 = 64;
pub const MF_UNHILITE : i32 = 0;
pub const MF_HILITE : i32 = 128;
pub const MF_DEFAULT : i32 = 4096;
pub const MF_SYSMENU : i32 = 8192;
pub const MF_HELP : i32 = 16384;
pub const MF_RIGHTJUSTIFY : i32 = 16384;
pub const MF_MOUSESELECT : i32 = 32768;
pub const MF_END : i32 = 128;
pub const MFT_STRING : i32 = 0;
pub const MFT_BITMAP : i32 = 4;
pub const MFT_MENUBARBREAK : i32 = 32;
pub const MFT_MENUBREAK : i32 = 64;
pub const MFT_OWNERDRAW : i32 = 256;
pub const MFT_RADIOCHECK : i32 = 512;
pub const MFT_SEPARATOR : i32 = 2048;
pub const MFT_RIGHTORDER : i32 = 8192;
pub const MFT_RIGHTJUSTIFY : i32 = 16384;
pub const MFS_GRAYED : i32 = 3;
pub const MFS_DISABLED : i32 = 3;
pub const MFS_CHECKED : i32 = 8;
pub const MFS_HILITE : i32 = 128;
pub const MFS_ENABLED : i32 = 0;
pub const MFS_UNCHECKED : i32 = 0;
pub const MFS_UNHILITE : i32 = 0;
pub const MFS_DEFAULT : i32 = 4096;
pub const SC_SIZE : i32 = 61440;
pub const SC_MOVE : i32 = 61456;
pub const SC_MINIMIZE : i32 = 61472;
pub const SC_MAXIMIZE : i32 = 61488;
pub const SC_NEXTWINDOW : i32 = 61504;
pub const SC_PREVWINDOW : i32 = 61520;
pub const SC_CLOSE : i32 = 61536;
pub const SC_VSCROLL : i32 = 61552;
pub const SC_HSCROLL : i32 = 61568;
pub const SC_MOUSEMENU : i32 = 61584;
pub const SC_KEYMENU : i32 = 61696;
pub const SC_ARRANGE : i32 = 61712;
pub const SC_RESTORE : i32 = 61728;
pub const SC_TASKLIST : i32 = 61744;
pub const SC_SCREENSAVE : i32 = 61760;
pub const SC_HOTKEY : i32 = 61776;
pub const SC_DEFAULT : i32 = 61792;
pub const SC_MONITORPOWER : i32 = 61808;
pub const SC_CONTEXTHELP : i32 = 61824;
pub const SC_SEPARATOR : i32 = 61455;
pub const SCF_ISSECURE : i32 = 1;
pub const SC_ICON : i32 = 61472;
pub const SC_ZOOM : i32 = 61488;
pub const IDC_ARROW : u16 = 32512;
pub const IDC_IBEAM : u16 = 32513;
pub const IDC_WAIT : u16 = 32514;
pub const IDC_CROSS : u16 = 32515;
pub const IDC_UPARROW : u16 = 32516;
// [Obselete("use IDC_SIZEALL")] (TODO: can Zig do something with this?)
pub const IDC_SIZE : u16 = 32640;
// [Obselete("use IDC_ARROW")] (TODO: can Zig do something with this?)
pub const IDC_ICON : u16 = 32641;
pub const IDC_SIZENWSE : u16 = 32642;
pub const IDC_SIZENESW : u16 = 32643;
pub const IDC_SIZEWE : u16 = 32644;
pub const IDC_SIZENS : u16 = 32645;
pub const IDC_SIZEALL : u16 = 32646;
pub const IDC_NO : u16 = 32648;
pub const IDC_HAND : u16 = 32649;
pub const IDC_APPSTARTING : i32 = 32650;
pub const IDC_HELP : i32 = 32651;
pub const IDC_PIN : i32 = 32671;
pub const IDC_PERSON : i32 = 32672;
pub const IMAGE_BITMAP : i32 = 0;
pub const IMAGE_ICON : i32 = 1;
pub const IMAGE_CURSOR : i32 = 2;
pub const IMAGE_ENHMETAFILE : i32 = 3;
pub const LR_DEFAULTCOLOR : i32 = 0;
pub const LR_MONOCHROME : i32 = 1;
pub const LR_COLOR : i32 = 2;
pub const LR_COPYRETURNORG : i32 = 4;
pub const LR_COPYDELETEORG : i32 = 8;
pub const LR_LOADFROMFILE : i32 = 16;
pub const LR_LOADTRANSPARENT : i32 = 32;
pub const LR_DEFAULTSIZE : i32 = 64;
pub const LR_VGACOLOR : i32 = 128;
pub const LR_LOADMAP3DCOLORS : i32 = 4096;
pub const LR_CREATEDIBSECTION : i32 = 8192;
pub const LR_COPYFROMRESOURCE : i32 = 16384;
pub const LR_SHARED : i32 = 32768;
pub const DI_MASK : i32 = 1;
pub const DI_IMAGE : i32 = 2;
pub const DI_NORMAL : i32 = 3;
pub const DI_COMPAT : i32 = 4;
pub const DI_DEFAULTSIZE : i32 = 8;
pub const DI_NOMIRROR : i32 = 16;
pub const RES_ICON : i32 = 1;
pub const RES_CURSOR : i32 = 2;
pub const OBM_CLOSE : i32 = 32754;
pub const OBM_UPARROW : i32 = 32753;
pub const OBM_DNARROW : i32 = 32752;
pub const OBM_RGARROW : i32 = 32751;
pub const OBM_LFARROW : i32 = 32750;
pub const OBM_REDUCE : i32 = 32749;
pub const OBM_ZOOM : i32 = 32748;
pub const OBM_RESTORE : i32 = 32747;
pub const OBM_REDUCED : i32 = 32746;
pub const OBM_ZOOMD : i32 = 32745;
pub const OBM_RESTORED : i32 = 32744;
pub const OBM_UPARROWD : i32 = 32743;
pub const OBM_DNARROWD : i32 = 32742;
pub const OBM_RGARROWD : i32 = 32741;
pub const OBM_LFARROWD : i32 = 32740;
pub const OBM_MNARROW : i32 = 32739;
pub const OBM_COMBO : i32 = 32738;
pub const OBM_UPARROWI : i32 = 32737;
pub const OBM_DNARROWI : i32 = 32736;
pub const OBM_RGARROWI : i32 = 32735;
pub const OBM_LFARROWI : i32 = 32734;
pub const OBM_OLD_CLOSE : i32 = 32767;
pub const OBM_SIZE : i32 = 32766;
pub const OBM_OLD_UPARROW : i32 = 32765;
pub const OBM_OLD_DNARROW : i32 = 32764;
pub const OBM_OLD_RGARROW : i32 = 32763;
pub const OBM_OLD_LFARROW : i32 = 32762;
pub const OBM_BTSIZE : i32 = 32761;
pub const OBM_CHECK : i32 = 32760;
pub const OBM_CHECKBOXES : i32 = 32759;
pub const OBM_BTNCORNERS : i32 = 32758;
pub const OBM_OLD_REDUCE : i32 = 32757;
pub const OBM_OLD_ZOOM : i32 = 32756;
pub const OBM_OLD_RESTORE : i32 = 32755;
pub const OCR_NORMAL : i32 = 32512;
pub const OCR_IBEAM : i32 = 32513;
pub const OCR_WAIT : i32 = 32514;
pub const OCR_CROSS : i32 = 32515;
pub const OCR_UP : i32 = 32516;
// [Obselete("use OCR_SIZEALL")] (TODO: can Zig do something with this?)
pub const OCR_SIZE : i32 = 32640;
// [Obselete("use OCR_NORMAL")] (TODO: can Zig do something with this?)
pub const OCR_ICON : i32 = 32641;
pub const OCR_SIZENWSE : i32 = 32642;
pub const OCR_SIZENESW : i32 = 32643;
pub const OCR_SIZEWE : i32 = 32644;
pub const OCR_SIZENS : i32 = 32645;
pub const OCR_SIZEALL : i32 = 32646;
// [Obselete("use OIC_WINLOGO")] (TODO: can Zig do something with this?)
pub const OCR_ICOCUR : i32 = 32647;
pub const OCR_NO : i32 = 32648;
pub const OCR_HAND : i32 = 32649;
pub const OCR_APPSTARTING : i32 = 32650;
pub const OIC_SAMPLE : i32 = 32512;
pub const OIC_HAND : i32 = 32513;
pub const OIC_QUES : i32 = 32514;
pub const OIC_BANG : i32 = 32515;
pub const OIC_NOTE : i32 = 32516;
pub const OIC_WINLOGO : i32 = 32517;
pub const OIC_WARNING : i32 = 32515;
pub const OIC_ERROR : i32 = 32513;
pub const OIC_INFORMATION : i32 = 32516;
pub const OIC_SHIELD : i32 = 32518;
pub const ORD_LANGDRIVER : i32 = 1;
pub const IDI_APPLICATION : u16 = 32512;
pub const IDI_HAND : u16 = 32513;
pub const IDI_QUESTION : u16 = 32514;
pub const IDI_EXCLAMATION : u16 = 32515;
pub const IDI_ASTERISK : u16 = 32516;
pub const IDI_WINLOGO : u16 = 32517;
pub const IDI_SHIELD : u16 = 32518;
pub const IDI_WARNING : u16 = 32515;
pub const IDI_ERROR : u16 = 32513;
pub const IDI_INFORMATION : u16 = 32516;
pub const IDOK : i32 = 1;
pub const IDCANCEL : i32 = 2;
pub const IDABORT : i32 = 3;
pub const IDRETRY : i32 = 4;
pub const IDIGNORE : i32 = 5;
pub const IDYES : i32 = 6;
pub const IDNO : i32 = 7;
pub const IDCLOSE : i32 = 8;
pub const IDHELP : i32 = 9;
pub const IDTRYAGAIN : i32 = 10;
pub const IDCONTINUE : i32 = 11;
pub const IDTIMEOUT : i32 = 32000;
pub const ES_LEFT : i32 = 0;
pub const ES_CENTER : i32 = 1;
pub const ES_RIGHT : i32 = 2;
pub const ES_MULTILINE : i32 = 4;
pub const ES_UPPERCASE : i32 = 8;
pub const ES_LOWERCASE : i32 = 16;
pub const ES_PASSWORD : i32 = 32;
pub const ES_AUTOVSCROLL : i32 = 64;
pub const ES_AUTOHSCROLL : i32 = 128;
pub const ES_NOHIDESEL : i32 = 256;
pub const ES_OEMCONVERT : i32 = 1024;
pub const ES_READONLY : i32 = 2048;
pub const ES_WANTRETURN : i32 = 4096;
pub const ES_NUMBER : i32 = 8192;
pub const EN_SETFOCUS : i32 = 256;
pub const EN_KILLFOCUS : i32 = 512;
pub const EN_CHANGE : i32 = 768;
pub const EN_UPDATE : i32 = 1024;
pub const EN_ERRSPACE : i32 = 1280;
pub const EN_MAXTEXT : i32 = 1281;
pub const EN_HSCROLL : i32 = 1537;
pub const EN_VSCROLL : i32 = 1538;
pub const EN_ALIGN_LTR_EC : i32 = 1792;
pub const EN_ALIGN_RTL_EC : i32 = 1793;
pub const EN_BEFORE_PASTE : i32 = 2048;
pub const EN_AFTER_PASTE : i32 = 2049;
pub const EC_LEFTMARGIN : i32 = 1;
pub const EC_RIGHTMARGIN : i32 = 2;
pub const EC_USEFONTINFO : i32 = 65535;
pub const EMSIS_COMPOSITIONSTRING : i32 = 1;
pub const EIMES_GETCOMPSTRATONCE : i32 = 1;
pub const EIMES_CANCELCOMPSTRINFOCUS : i32 = 2;
pub const EIMES_COMPLETECOMPSTRKILLFOCUS : i32 = 4;
pub const EM_GETSEL : i32 = 176;
pub const EM_SETSEL : i32 = 177;
pub const EM_GETRECT : i32 = 178;
pub const EM_SETRECT : i32 = 179;
pub const EM_SETRECTNP : i32 = 180;
pub const EM_SCROLL : i32 = 181;
pub const EM_LINESCROLL : i32 = 182;
pub const EM_SCROLLCARET : i32 = 183;
pub const EM_GETMODIFY : i32 = 184;
pub const EM_SETMODIFY : i32 = 185;
pub const EM_GETLINECOUNT : i32 = 186;
pub const EM_LINEINDEX : i32 = 187;
pub const EM_SETHANDLE : i32 = 188;
pub const EM_GETHANDLE : i32 = 189;
pub const EM_GETTHUMB : i32 = 190;
pub const EM_LINELENGTH : i32 = 193;
pub const EM_REPLACESEL : i32 = 194;
pub const EM_GETLINE : i32 = 196;
pub const EM_LIMITTEXT : i32 = 197;
pub const EM_CANUNDO : i32 = 198;
pub const EM_UNDO : i32 = 199;
pub const EM_FMTLINES : i32 = 200;
pub const EM_LINEFROMCHAR : i32 = 201;
pub const EM_SETTABSTOPS : i32 = 203;
pub const EM_SETPASSWORDCHAR : i32 = 204;
pub const EM_EMPTYUNDOBUFFER : i32 = 205;
pub const EM_GETFIRSTVISIBLELINE : i32 = 206;
pub const EM_SETREADONLY : i32 = 207;
pub const EM_SETWORDBREAKPROC : i32 = 208;
pub const EM_GETWORDBREAKPROC : i32 = 209;
pub const EM_GETPASSWORDCHAR : i32 = 210;
pub const EM_SETMARGINS : i32 = 211;
pub const EM_GETMARGINS : i32 = 212;
pub const EM_SETLIMITTEXT : i32 = 197;
pub const EM_GETLIMITTEXT : i32 = 213;
pub const EM_POSFROMCHAR : i32 = 214;
pub const EM_CHARFROMPOS : i32 = 215;
pub const EM_SETIMESTATUS : i32 = 216;
pub const EM_GETIMESTATUS : i32 = 217;
pub const EM_ENABLEFEATURE : i32 = 218;
pub const WB_LEFT : i32 = 0;
pub const WB_RIGHT : i32 = 1;
pub const WB_ISDELIMITER : i32 = 2;
pub const BS_PUSHBUTTON : i32 = 0;
pub const BS_DEFPUSHBUTTON : i32 = 1;
pub const BS_CHECKBOX : i32 = 2;
pub const BS_AUTOCHECKBOX : i32 = 3;
pub const BS_RADIOBUTTON : i32 = 4;
pub const BS_3STATE : i32 = 5;
pub const BS_AUTO3STATE : i32 = 6;
pub const BS_GROUPBOX : i32 = 7;
pub const BS_USERBUTTON : i32 = 8;
pub const BS_AUTORADIOBUTTON : i32 = 9;
pub const BS_PUSHBOX : i32 = 10;
pub const BS_OWNERDRAW : i32 = 11;
pub const BS_TYPEMASK : i32 = 15;
pub const BS_LEFTTEXT : i32 = 32;
pub const BS_TEXT : i32 = 0;
pub const BS_ICON : i32 = 64;
pub const BS_BITMAP : i32 = 128;
pub const BS_LEFT : i32 = 256;
pub const BS_RIGHT : i32 = 512;
pub const BS_CENTER : i32 = 768;
pub const BS_TOP : i32 = 1024;
pub const BS_BOTTOM : i32 = 2048;
pub const BS_VCENTER : i32 = 3072;
pub const BS_PUSHLIKE : i32 = 4096;
pub const BS_MULTILINE : i32 = 8192;
pub const BS_NOTIFY : i32 = 16384;
pub const BS_FLAT : i32 = 32768;
pub const BS_RIGHTBUTTON : i32 = 32;
pub const BN_CLICKED : i32 = 0;
pub const BN_PAINT : i32 = 1;
pub const BN_HILITE : i32 = 2;
pub const BN_UNHILITE : i32 = 3;
pub const BN_DISABLE : i32 = 4;
pub const BN_DOUBLECLICKED : i32 = 5;
pub const BN_PUSHED : i32 = 2;
pub const BN_UNPUSHED : i32 = 3;
pub const BN_DBLCLK : i32 = 5;
pub const BN_SETFOCUS : i32 = 6;
pub const BN_KILLFOCUS : i32 = 7;
pub const BM_GETCHECK : i32 = 240;
pub const BM_SETCHECK : i32 = 241;
pub const BM_GETSTATE : i32 = 242;
pub const BM_SETSTATE : i32 = 243;
pub const BM_SETSTYLE : i32 = 244;
pub const BM_CLICK : i32 = 245;
pub const BM_GETIMAGE : i32 = 246;
pub const BM_SETIMAGE : i32 = 247;
pub const BM_SETDONTCLICK : i32 = 248;
pub const BST_UNCHECKED : i32 = 0;
pub const BST_CHECKED : i32 = 1;
pub const BST_INDETERMINATE : i32 = 2;
pub const BST_PUSHED : i32 = 4;
pub const BST_FOCUS : i32 = 8;
pub const SS_LEFT : i32 = 0;
pub const SS_CENTER : i32 = 1;
pub const SS_RIGHT : i32 = 2;
pub const SS_ICON : i32 = 3;
pub const SS_BLACKRECT : i32 = 4;
pub const SS_GRAYRECT : i32 = 5;
pub const SS_WHITERECT : i32 = 6;
pub const SS_BLACKFRAME : i32 = 7;
pub const SS_GRAYFRAME : i32 = 8;
pub const SS_WHITEFRAME : i32 = 9;
pub const SS_USERITEM : i32 = 10;
pub const SS_SIMPLE : i32 = 11;
pub const SS_LEFTNOWORDWRAP : i32 = 12;
pub const SS_OWNERDRAW : i32 = 13;
pub const SS_BITMAP : i32 = 14;
pub const SS_ENHMETAFILE : i32 = 15;
pub const SS_ETCHEDHORZ : i32 = 16;
pub const SS_ETCHEDVERT : i32 = 17;
pub const SS_ETCHEDFRAME : i32 = 18;
pub const SS_TYPEMASK : i32 = 31;
pub const SS_REALSIZECONTROL : i32 = 64;
pub const SS_NOPREFIX : i32 = 128;
pub const SS_NOTIFY : i32 = 256;
pub const SS_CENTERIMAGE : i32 = 512;
pub const SS_RIGHTJUST : i32 = 1024;
pub const SS_REALSIZEIMAGE : i32 = 2048;
pub const SS_SUNKEN : i32 = 4096;
pub const SS_EDITCONTROL : i32 = 8192;
pub const SS_ENDELLIPSIS : i32 = 16384;
pub const SS_PATHELLIPSIS : i32 = 32768;
pub const SS_WORDELLIPSIS : i32 = 49152;
pub const SS_ELLIPSISMASK : i32 = 49152;
pub const STM_SETICON : i32 = 368;
pub const STM_GETICON : i32 = 369;
pub const STM_SETIMAGE : i32 = 370;
pub const STM_GETIMAGE : i32 = 371;
pub const STN_CLICKED : i32 = 0;
pub const STN_DBLCLK : i32 = 1;
pub const STN_ENABLE : i32 = 2;
pub const STN_DISABLE : i32 = 3;
pub const STM_MSGMAX : i32 = 372;
pub const WC_DIALOG : u16 = 32770;
pub const DWL_MSGRESULT : i32 = 0;
pub const DWL_DLGPROC : i32 = 4;
pub const DWL_USER : i32 = 8;
pub const DWLP_MSGRESULT : i32 = 0;
pub const DDL_READWRITE : i32 = 0;
pub const DDL_READONLY : i32 = 1;
pub const DDL_HIDDEN : i32 = 2;
pub const DDL_SYSTEM : i32 = 4;
pub const DDL_DIRECTORY : i32 = 16;
pub const DDL_ARCHIVE : i32 = 32;
pub const DDL_POSTMSGS : i32 = 8192;
pub const DDL_DRIVES : i32 = 16384;
pub const DDL_EXCLUSIVE : i32 = 32768;
pub const DS_ABSALIGN : i32 = 1;
pub const DS_SYSMODAL : i32 = 2;
pub const DS_LOCALEDIT : i32 = 32;
pub const DS_SETFONT : i32 = 64;
pub const DS_MODALFRAME : i32 = 128;
pub const DS_NOIDLEMSG : i32 = 256;
pub const DS_SETFOREGROUND : i32 = 512;
pub const DS_3DLOOK : i32 = 4;
pub const DS_FIXEDSYS : i32 = 8;
pub const DS_NOFAILCREATE : i32 = 16;
pub const DS_CONTROL : i32 = 1024;
pub const DS_CENTER : i32 = 2048;
pub const DS_CENTERMOUSE : i32 = 4096;
pub const DS_CONTEXTHELP : i32 = 8192;
pub const DS_SHELLFONT : i32 = 72;
pub const DS_USEPIXELS : i32 = 32768;
pub const DM_GETDEFID : i32 = 1024;
pub const DM_SETDEFID : i32 = 1025;
pub const DM_REPOSITION : i32 = 1026;
pub const DC_HASDEFID : i32 = 21323;
pub const DLGC_WANTARROWS : i32 = 1;
pub const DLGC_WANTTAB : i32 = 2;
pub const DLGC_WANTALLKEYS : i32 = 4;
pub const DLGC_WANTMESSAGE : i32 = 4;
pub const DLGC_HASSETSEL : i32 = 8;
pub const DLGC_DEFPUSHBUTTON : i32 = 16;
pub const DLGC_UNDEFPUSHBUTTON : i32 = 32;
pub const DLGC_RADIOBUTTON : i32 = 64;
pub const DLGC_WANTCHARS : i32 = 128;
pub const DLGC_STATIC : i32 = 256;
pub const DLGC_BUTTON : i32 = 8192;
pub const LB_CTLCODE : i32 = 0;
pub const LB_OKAY : i32 = 0;
pub const LB_ERR : i32 = -1;
pub const LB_ERRSPACE : i32 = -2;
pub const LBN_ERRSPACE : i32 = -2;
pub const LBN_SELCHANGE : i32 = 1;
pub const LBN_DBLCLK : i32 = 2;
pub const LBN_SELCANCEL : i32 = 3;
pub const LBN_SETFOCUS : i32 = 4;
pub const LBN_KILLFOCUS : i32 = 5;
pub const LB_ADDSTRING : i32 = 384;
pub const LB_INSERTSTRING : i32 = 385;
pub const LB_DELETESTRING : i32 = 386;
pub const LB_SELITEMRANGEEX : i32 = 387;
pub const LB_RESETCONTENT : i32 = 388;
pub const LB_SETSEL : i32 = 389;
pub const LB_SETCURSEL : i32 = 390;
pub const LB_GETSEL : i32 = 391;
pub const LB_GETCURSEL : i32 = 392;
pub const LB_GETTEXT : i32 = 393;
pub const LB_GETTEXTLEN : i32 = 394;
pub const LB_GETCOUNT : i32 = 395;
pub const LB_SELECTSTRING : i32 = 396;
pub const LB_DIR : i32 = 397;
pub const LB_GETTOPINDEX : i32 = 398;
pub const LB_FINDSTRING : i32 = 399;
pub const LB_GETSELCOUNT : i32 = 400;
pub const LB_GETSELITEMS : i32 = 401;
pub const LB_SETTABSTOPS : i32 = 402;
pub const LB_GETHORIZONTALEXTENT : i32 = 403;
pub const LB_SETHORIZONTALEXTENT : i32 = 404;
pub const LB_SETCOLUMNWIDTH : i32 = 405;
pub const LB_ADDFILE : i32 = 406;
pub const LB_SETTOPINDEX : i32 = 407;
pub const LB_GETITEMRECT : i32 = 408;
pub const LB_GETITEMDATA : i32 = 409;
pub const LB_SETITEMDATA : i32 = 410;
pub const LB_SELITEMRANGE : i32 = 411;
pub const LB_SETANCHORINDEX : i32 = 412;
pub const LB_GETANCHORINDEX : i32 = 413;
pub const LB_SETCARETINDEX : i32 = 414;
pub const LB_GETCARETINDEX : i32 = 415;
pub const LB_SETITEMHEIGHT : i32 = 416;
pub const LB_GETITEMHEIGHT : i32 = 417;
pub const LB_FINDSTRINGEXACT : i32 = 418;
pub const LB_SETLOCALE : i32 = 421;
pub const LB_GETLOCALE : i32 = 422;
pub const LB_SETCOUNT : i32 = 423;
pub const LB_INITSTORAGE : i32 = 424;
pub const LB_ITEMFROMPOINT : i32 = 425;
pub const LB_MULTIPLEADDSTRING : i32 = 433;
pub const LB_GETLISTBOXINFO : i32 = 434;
pub const LB_MSGMAX : i32 = 435;
pub const LBS_NOTIFY : u32 = 1;
pub const LBS_SORT : u32 = 2;
pub const LBS_NOREDRAW : u32 = 4;
pub const LBS_MULTIPLESEL : u32 = 8;
pub const LBS_OWNERDRAWFIXED : u32 = 16;
pub const LBS_OWNERDRAWVARIABLE : u32 = 32;
pub const LBS_HASSTRINGS : u32 = 64;
pub const LBS_USETABSTOPS : u32 = 128;
pub const LBS_NOINTEGRALHEIGHT : u32 = 256;
pub const LBS_MULTICOLUMN : u32 = 512;
pub const LBS_WANTKEYBOARDINPUT : u32 = 1024;
pub const LBS_EXTENDEDSEL : u32 = 2048;
pub const LBS_DISABLENOSCROLL : u32 = 4096;
pub const LBS_NODATA : u32 = 8192;
pub const LBS_NOSEL : u32 = 16384;
pub const LBS_COMBOBOX : u32 = 32768;
pub const LBS_STANDARD : u32 = 10485763;
pub const CB_OKAY : i32 = 0;
pub const CB_ERR : i32 = -1;
pub const CB_ERRSPACE : i32 = -2;
pub const CBN_ERRSPACE : i32 = -1;
pub const CBN_SELCHANGE : i32 = 1;
pub const CBN_DBLCLK : i32 = 2;
pub const CBN_SETFOCUS : i32 = 3;
pub const CBN_KILLFOCUS : i32 = 4;
pub const CBN_EDITCHANGE : i32 = 5;
pub const CBN_EDITUPDATE : i32 = 6;
pub const CBN_DROPDOWN : i32 = 7;
pub const CBN_CLOSEUP : i32 = 8;
pub const CBN_SELENDOK : i32 = 9;
pub const CBN_SELENDCANCEL : i32 = 10;
pub const CBS_SIMPLE : i32 = 1;
pub const CBS_DROPDOWN : i32 = 2;
pub const CBS_DROPDOWNLIST : i32 = 3;
pub const CBS_OWNERDRAWFIXED : i32 = 16;
pub const CBS_OWNERDRAWVARIABLE : i32 = 32;
pub const CBS_AUTOHSCROLL : i32 = 64;
pub const CBS_OEMCONVERT : i32 = 128;
pub const CBS_SORT : i32 = 256;
pub const CBS_HASSTRINGS : i32 = 512;
pub const CBS_NOINTEGRALHEIGHT : i32 = 1024;
pub const CBS_DISABLENOSCROLL : i32 = 2048;
pub const CBS_UPPERCASE : i32 = 8192;
pub const CBS_LOWERCASE : i32 = 16384;
pub const CB_GETEDITSEL : i32 = 320;
pub const CB_LIMITTEXT : i32 = 321;
pub const CB_SETEDITSEL : i32 = 322;
pub const CB_ADDSTRING : i32 = 323;
pub const CB_DELETESTRING : i32 = 324;
pub const CB_DIR : i32 = 325;
pub const CB_GETCOUNT : i32 = 326;
pub const CB_GETCURSEL : i32 = 327;
pub const CB_GETLBTEXT : i32 = 328;
pub const CB_GETLBTEXTLEN : i32 = 329;
pub const CB_INSERTSTRING : i32 = 330;
pub const CB_RESETCONTENT : i32 = 331;
pub const CB_FINDSTRING : i32 = 332;
pub const CB_SELECTSTRING : i32 = 333;
pub const CB_SETCURSEL : i32 = 334;
pub const CB_SHOWDROPDOWN : i32 = 335;
pub const CB_GETITEMDATA : i32 = 336;
pub const CB_SETITEMDATA : i32 = 337;
pub const CB_GETDROPPEDCONTROLRECT : i32 = 338;
pub const CB_SETITEMHEIGHT : i32 = 339;
pub const CB_GETITEMHEIGHT : i32 = 340;
pub const CB_SETEXTENDEDUI : i32 = 341;
pub const CB_GETEXTENDEDUI : i32 = 342;
pub const CB_GETDROPPEDSTATE : i32 = 343;
pub const CB_FINDSTRINGEXACT : i32 = 344;
pub const CB_SETLOCALE : i32 = 345;
pub const CB_GETLOCALE : i32 = 346;
pub const CB_GETTOPINDEX : i32 = 347;
pub const CB_SETTOPINDEX : i32 = 348;
pub const CB_GETHORIZONTALEXTENT : i32 = 349;
pub const CB_SETHORIZONTALEXTENT : i32 = 350;
pub const CB_GETDROPPEDWIDTH : i32 = 351;
pub const CB_SETDROPPEDWIDTH : i32 = 352;
pub const CB_INITSTORAGE : i32 = 353;
pub const CB_MULTIPLEADDSTRING : i32 = 355;
pub const CB_GETCOMBOBOXINFO : i32 = 356;
pub const CB_MSGMAX : i32 = 357;
pub const SBS_HORZ : i32 = 0;
pub const SBS_VERT : i32 = 1;
pub const SBS_TOPALIGN : i32 = 2;
pub const SBS_LEFTALIGN : i32 = 2;
pub const SBS_BOTTOMALIGN : i32 = 4;
pub const SBS_RIGHTALIGN : i32 = 4;
pub const SBS_SIZEBOXTOPLEFTALIGN : i32 = 2;
pub const SBS_SIZEBOXBOTTOMRIGHTALIGN : i32 = 4;
pub const SBS_SIZEBOX : i32 = 8;
pub const SBS_SIZEGRIP : i32 = 16;
pub const SBM_SETPOS : i32 = 224;
pub const SBM_GETPOS : i32 = 225;
pub const SBM_SETRANGE : i32 = 226;
pub const SBM_SETRANGEREDRAW : i32 = 230;
pub const SBM_GETRANGE : i32 = 227;
pub const SBM_ENABLE_ARROWS : i32 = 228;
pub const SBM_SETSCROLLINFO : i32 = 233;
pub const SBM_GETSCROLLINFO : i32 = 234;
pub const SBM_GETSCROLLBARINFO : i32 = 235;
pub const SIF_RANGE : i32 = 1;
pub const SIF_PAGE : i32 = 2;
pub const SIF_POS : i32 = 4;
pub const SIF_DISABLENOSCROLL : i32 = 8;
pub const SIF_TRACKPOS : i32 = 16;
pub const SIF_ALL : i32 = 23;
pub const MDIS_ALLCHILDSTYLES : i32 = 1;
pub const MDITILE_VERTICAL : i32 = 0;
pub const MDITILE_HORIZONTAL : i32 = 1;
pub const MDITILE_SKIPDISABLED : i32 = 2;
pub const MDITILE_ZORDER : i32 = 4;
pub const HELP_CONTEXT : i32 = 1;
pub const HELP_QUIT : i32 = 2;
pub const HELP_INDEX : i32 = 3;
pub const HELP_CONTENTS : i32 = 3;
pub const HELP_HELPONHELP : i32 = 4;
pub const HELP_SETINDEX : i32 = 5;
pub const HELP_SETCONTENTS : i32 = 5;
pub const HELP_CONTEXTPOPUP : i32 = 8;
pub const HELP_FORCEFILE : i32 = 9;
pub const HELP_KEY : i32 = 257;
pub const HELP_COMMAND : i32 = 258;
pub const HELP_PARTIALKEY : i32 = 261;
pub const HELP_MULTIKEY : i32 = 513;
pub const HELP_SETWINPOS : i32 = 515;
pub const HELP_CONTEXTMENU : i32 = 10;
pub const HELP_FINDER : i32 = 11;
pub const HELP_WM_HELP : i32 = 12;
pub const HELP_SETPOPUP_POS : i32 = 13;
pub const HELP_TCARD : i32 = 32768;
pub const HELP_TCARD_DATA : i32 = 16;
pub const HELP_TCARD_OTHER_CALLER : i32 = 17;
pub const IDH_NO_HELP : i32 = 28440;
pub const IDH_MISSING_CONTEXT : i32 = 28441;
pub const IDH_GENERIC_HELP_BUTTON : i32 = 28442;
pub const IDH_OK : i32 = 28443;
pub const IDH_CANCEL : i32 = 28444;
pub const IDH_HELP : i32 = 28445;
pub const GR_GDIOBJECTS : i32 = 0;
pub const GR_USEROBJECTS : i32 = 1;
pub const GR_GDIOBJECTS_PEAK : i32 = 2;
pub const GR_USEROBJECTS_PEAK : i32 = 4;
pub const GR_GLOBAL : i32 = -2;
pub const SPI_GETBEEP : i32 = 1;
pub const SPI_SETBEEP : i32 = 2;
pub const SPI_GETMOUSE : i32 = 3;
pub const SPI_SETMOUSE : i32 = 4;
pub const SPI_GETBORDER : i32 = 5;
pub const SPI_SETBORDER : i32 = 6;
pub const SPI_GETKEYBOARDSPEED : i32 = 10;
pub const SPI_SETKEYBOARDSPEED : i32 = 11;
pub const SPI_LANGDRIVER : i32 = 12;
pub const SPI_ICONHORIZONTALSPACING : i32 = 13;
pub const SPI_GETSCREENSAVETIMEOUT : i32 = 14;
pub const SPI_SETSCREENSAVETIMEOUT : i32 = 15;
pub const SPI_GETSCREENSAVEACTIVE : i32 = 16;
pub const SPI_SETSCREENSAVEACTIVE : i32 = 17;
pub const SPI_GETGRIDGRANULARITY : i32 = 18;
pub const SPI_SETGRIDGRANULARITY : i32 = 19;
pub const SPI_SETDESKWALLPAPER : i32 = 20;
pub const SPI_SETDESKPATTERN : i32 = 21;
pub const SPI_GETKEYBOARDDELAY : i32 = 22;
pub const SPI_SETKEYBOARDDELAY : i32 = 23;
pub const SPI_ICONVERTICALSPACING : i32 = 24;
pub const SPI_GETICONTITLEWRAP : i32 = 25;
pub const SPI_SETICONTITLEWRAP : i32 = 26;
pub const SPI_GETMENUDROPALIGNMENT : i32 = 27;
pub const SPI_SETMENUDROPALIGNMENT : i32 = 28;
pub const SPI_SETDOUBLECLKWIDTH : i32 = 29;
pub const SPI_SETDOUBLECLKHEIGHT : i32 = 30;
pub const SPI_GETICONTITLELOGFONT : i32 = 31;
pub const SPI_SETDOUBLECLICKTIME : i32 = 32;
pub const SPI_SETMOUSEBUTTONSWAP : i32 = 33;
pub const SPI_SETICONTITLELOGFONT : i32 = 34;
pub const SPI_GETFASTTASKSWITCH : i32 = 35;
pub const SPI_SETFASTTASKSWITCH : i32 = 36;
pub const SPI_SETDRAGFULLWINDOWS : i32 = 37;
pub const SPI_GETDRAGFULLWINDOWS : i32 = 38;
pub const SPI_GETNONCLIENTMETRICS : i32 = 41;
pub const SPI_SETNONCLIENTMETRICS : i32 = 42;
pub const SPI_GETMINIMIZEDMETRICS : i32 = 43;
pub const SPI_SETMINIMIZEDMETRICS : i32 = 44;
pub const SPI_GETICONMETRICS : i32 = 45;
pub const SPI_SETICONMETRICS : i32 = 46;
pub const SPI_SETWORKAREA : i32 = 47;
pub const SPI_GETWORKAREA : i32 = 48;
pub const SPI_SETPENWINDOWS : i32 = 49;
pub const SPI_GETHIGHCONTRAST : i32 = 66;
pub const SPI_SETHIGHCONTRAST : i32 = 67;
pub const SPI_GETKEYBOARDPREF : i32 = 68;
pub const SPI_SETKEYBOARDPREF : i32 = 69;
pub const SPI_GETSCREENREADER : i32 = 70;
pub const SPI_SETSCREENREADER : i32 = 71;
pub const SPI_GETANIMATION : i32 = 72;
pub const SPI_SETANIMATION : i32 = 73;
pub const SPI_GETFONTSMOOTHING : i32 = 74;
pub const SPI_SETFONTSMOOTHING : i32 = 75;
pub const SPI_SETDRAGWIDTH : i32 = 76;
pub const SPI_SETDRAGHEIGHT : i32 = 77;
pub const SPI_SETHANDHELD : i32 = 78;
pub const SPI_GETLOWPOWERTIMEOUT : i32 = 79;
pub const SPI_GETPOWEROFFTIMEOUT : i32 = 80;
pub const SPI_SETLOWPOWERTIMEOUT : i32 = 81;
pub const SPI_SETPOWEROFFTIMEOUT : i32 = 82;
pub const SPI_GETLOWPOWERACTIVE : i32 = 83;
pub const SPI_GETPOWEROFFACTIVE : i32 = 84;
pub const SPI_SETLOWPOWERACTIVE : i32 = 85;
pub const SPI_SETPOWEROFFACTIVE : i32 = 86;
pub const SPI_SETCURSORS : i32 = 87;
pub const SPI_SETICONS : i32 = 88;
pub const SPI_GETDEFAULTINPUTLANG : i32 = 89;
pub const SPI_SETDEFAULTINPUTLANG : i32 = 90;
pub const SPI_SETLANGTOGGLE : i32 = 91;
pub const SPI_GETWINDOWSEXTENSION : i32 = 92;
pub const SPI_SETMOUSETRAILS : i32 = 93;
pub const SPI_GETMOUSETRAILS : i32 = 94;
pub const SPI_SETSCREENSAVERRUNNING : i32 = 97;
pub const SPI_SCREENSAVERRUNNING : i32 = 97;
pub const SPI_GETFILTERKEYS : i32 = 50;
pub const SPI_SETFILTERKEYS : i32 = 51;
pub const SPI_GETTOGGLEKEYS : i32 = 52;
pub const SPI_SETTOGGLEKEYS : i32 = 53;
pub const SPI_GETMOUSEKEYS : i32 = 54;
pub const SPI_SETMOUSEKEYS : i32 = 55;
pub const SPI_GETSHOWSOUNDS : i32 = 56;
pub const SPI_SETSHOWSOUNDS : i32 = 57;
pub const SPI_GETSTICKYKEYS : i32 = 58;
pub const SPI_SETSTICKYKEYS : i32 = 59;
pub const SPI_GETACCESSTIMEOUT : i32 = 60;
pub const SPI_SETACCESSTIMEOUT : i32 = 61;
pub const SPI_GETSERIALKEYS : i32 = 62;
pub const SPI_SETSERIALKEYS : i32 = 63;
pub const SPI_GETSOUNDSENTRY : i32 = 64;
pub const SPI_SETSOUNDSENTRY : i32 = 65;
pub const SPI_GETSNAPTODEFBUTTON : i32 = 95;
pub const SPI_SETSNAPTODEFBUTTON : i32 = 96;
pub const SPI_GETMOUSEHOVERWIDTH : i32 = 98;
pub const SPI_SETMOUSEHOVERWIDTH : i32 = 99;
pub const SPI_GETMOUSEHOVERHEIGHT : i32 = 100;
pub const SPI_SETMOUSEHOVERHEIGHT : i32 = 101;
pub const SPI_GETMOUSEHOVERTIME : i32 = 102;
pub const SPI_SETMOUSEHOVERTIME : i32 = 103;
pub const SPI_GETWHEELSCROLLLINES : i32 = 104;
pub const SPI_SETWHEELSCROLLLINES : i32 = 105;
pub const SPI_GETMENUSHOWDELAY : i32 = 106;
pub const SPI_SETMENUSHOWDELAY : i32 = 107;
pub const SPI_GETWHEELSCROLLCHARS : i32 = 108;
pub const SPI_SETWHEELSCROLLCHARS : i32 = 109;
pub const SPI_GETSHOWIMEUI : i32 = 110;
pub const SPI_SETSHOWIMEUI : i32 = 111;
pub const SPI_GETMOUSESPEED : i32 = 112;
pub const SPI_SETMOUSESPEED : i32 = 113;
pub const SPI_GETSCREENSAVERRUNNING : i32 = 114;
pub const SPI_GETDESKWALLPAPER : i32 = 115;
pub const SPI_GETAUDIODESCRIPTION : i32 = 116;
pub const SPI_SETAUDIODESCRIPTION : i32 = 117;
pub const SPI_GETSCREENSAVESECURE : i32 = 118;
pub const SPI_SETSCREENSAVESECURE : i32 = 119;
pub const SPI_GETHUNGAPPTIMEOUT : i32 = 120;
pub const SPI_SETHUNGAPPTIMEOUT : i32 = 121;
pub const SPI_GETWAITTOKILLTIMEOUT : i32 = 122;
pub const SPI_SETWAITTOKILLTIMEOUT : i32 = 123;
pub const SPI_GETWAITTOKILLSERVICETIMEOUT : i32 = 124;
pub const SPI_SETWAITTOKILLSERVICETIMEOUT : i32 = 125;
pub const SPI_GETMOUSEDOCKTHRESHOLD : i32 = 126;
pub const SPI_SETMOUSEDOCKTHRESHOLD : i32 = 127;
pub const SPI_GETPENDOCKTHRESHOLD : i32 = 128;
pub const SPI_SETPENDOCKTHRESHOLD : i32 = 129;
pub const SPI_GETWINARRANGING : i32 = 130;
pub const SPI_SETWINARRANGING : i32 = 131;
pub const SPI_GETMOUSEDRAGOUTTHRESHOLD : i32 = 132;
pub const SPI_SETMOUSEDRAGOUTTHRESHOLD : i32 = 133;
pub const SPI_GETPENDRAGOUTTHRESHOLD : i32 = 134;
pub const SPI_SETPENDRAGOUTTHRESHOLD : i32 = 135;
pub const SPI_GETMOUSESIDEMOVETHRESHOLD : i32 = 136;
pub const SPI_SETMOUSESIDEMOVETHRESHOLD : i32 = 137;
pub const SPI_GETPENSIDEMOVETHRESHOLD : i32 = 138;
pub const SPI_SETPENSIDEMOVETHRESHOLD : i32 = 139;
pub const SPI_GETDRAGFROMMAXIMIZE : i32 = 140;
pub const SPI_SETDRAGFROMMAXIMIZE : i32 = 141;
pub const SPI_GETSNAPSIZING : i32 = 142;
pub const SPI_SETSNAPSIZING : i32 = 143;
pub const SPI_GETDOCKMOVING : i32 = 144;
pub const SPI_SETDOCKMOVING : i32 = 145;
pub const MAX_TOUCH_PREDICTION_FILTER_TAPS : i32 = 3;
pub const TOUCHPREDICTIONPARAMETERS_DEFAULT_LATENCY : i32 = 8;
pub const TOUCHPREDICTIONPARAMETERS_DEFAULT_SAMPLETIME : i32 = 8;
pub const TOUCHPREDICTIONPARAMETERS_DEFAULT_USE_HW_TIMESTAMP : i32 = 1;
pub const TOUCHPREDICTIONPARAMETERS_DEFAULT_RLS_DELTA : f32 = 0.001;
pub const TOUCHPREDICTIONPARAMETERS_DEFAULT_RLS_LAMBDA_MIN : f32 = 0.9;
pub const TOUCHPREDICTIONPARAMETERS_DEFAULT_RLS_LAMBDA_MAX : f32 = 0.999;
pub const TOUCHPREDICTIONPARAMETERS_DEFAULT_RLS_LAMBDA_LEARNING_RATE : f32 = 0.001;
pub const TOUCHPREDICTIONPARAMETERS_DEFAULT_RLS_EXPO_SMOOTH_ALPHA : f32 = 0.99;
pub const SPI_GETTOUCHPREDICTIONPARAMETERS : i32 = 156;
pub const SPI_SETTOUCHPREDICTIONPARAMETERS : i32 = 157;
pub const MAX_LOGICALDPIOVERRIDE : i32 = 2;
pub const MIN_LOGICALDPIOVERRIDE : i32 = -2;
pub const SPI_GETLOGICALDPIOVERRIDE : i32 = 158;
pub const SPI_SETLOGICALDPIOVERRIDE : i32 = 159;
pub const SPI_GETMENURECT : i32 = 162;
pub const SPI_SETMENURECT : i32 = 163;
pub const SPI_GETACTIVEWINDOWTRACKING : i32 = 4096;
pub const SPI_SETACTIVEWINDOWTRACKING : i32 = 4097;
pub const SPI_GETMENUANIMATION : i32 = 4098;
pub const SPI_SETMENUANIMATION : i32 = 4099;
pub const SPI_GETCOMBOBOXANIMATION : i32 = 4100;
pub const SPI_SETCOMBOBOXANIMATION : i32 = 4101;
pub const SPI_GETLISTBOXSMOOTHSCROLLING : i32 = 4102;
pub const SPI_SETLISTBOXSMOOTHSCROLLING : i32 = 4103;
pub const SPI_GETGRADIENTCAPTIONS : i32 = 4104;
pub const SPI_SETGRADIENTCAPTIONS : i32 = 4105;
pub const SPI_GETKEYBOARDCUES : i32 = 4106;
pub const SPI_SETKEYBOARDCUES : i32 = 4107;
pub const SPI_GETMENUUNDERLINES : i32 = 4106;
pub const SPI_SETMENUUNDERLINES : i32 = 4107;
pub const SPI_GETACTIVEWNDTRKZORDER : i32 = 4108;
pub const SPI_SETACTIVEWNDTRKZORDER : i32 = 4109;
pub const SPI_GETHOTTRACKING : i32 = 4110;
pub const SPI_SETHOTTRACKING : i32 = 4111;
pub const SPI_GETMENUFADE : i32 = 4114;
pub const SPI_SETMENUFADE : i32 = 4115;
pub const SPI_GETSELECTIONFADE : i32 = 4116;
pub const SPI_SETSELECTIONFADE : i32 = 4117;
pub const SPI_GETTOOLTIPANIMATION : i32 = 4118;
pub const SPI_SETTOOLTIPANIMATION : i32 = 4119;
pub const SPI_GETTOOLTIPFADE : i32 = 4120;
pub const SPI_SETTOOLTIPFADE : i32 = 4121;
pub const SPI_GETCURSORSHADOW : i32 = 4122;
pub const SPI_SETCURSORSHADOW : i32 = 4123;
pub const SPI_GETMOUSESONAR : i32 = 4124;
pub const SPI_SETMOUSESONAR : i32 = 4125;
pub const SPI_GETMOUSECLICKLOCK : i32 = 4126;
pub const SPI_SETMOUSECLICKLOCK : i32 = 4127;
pub const SPI_GETMOUSEVANISH : i32 = 4128;
pub const SPI_SETMOUSEVANISH : i32 = 4129;
pub const SPI_GETFLATMENU : i32 = 4130;
pub const SPI_SETFLATMENU : i32 = 4131;
pub const SPI_GETDROPSHADOW : i32 = 4132;
pub const SPI_SETDROPSHADOW : i32 = 4133;
pub const SPI_GETBLOCKSENDINPUTRESETS : i32 = 4134;
pub const SPI_SETBLOCKSENDINPUTRESETS : i32 = 4135;
pub const SPI_GETUIEFFECTS : i32 = 4158;
pub const SPI_SETUIEFFECTS : i32 = 4159;
pub const SPI_GETDISABLEOVERLAPPEDCONTENT : i32 = 4160;
pub const SPI_SETDISABLEOVERLAPPEDCONTENT : i32 = 4161;
pub const SPI_GETCLIENTAREAANIMATION : i32 = 4162;
pub const SPI_SETCLIENTAREAANIMATION : i32 = 4163;
pub const SPI_GETCLEARTYPE : i32 = 4168;
pub const SPI_SETCLEARTYPE : i32 = 4169;
pub const SPI_GETSPEECHRECOGNITION : i32 = 4170;
pub const SPI_SETSPEECHRECOGNITION : i32 = 4171;
pub const SPI_GETCARETBROWSING : i32 = 4172;
pub const SPI_SETCARETBROWSING : i32 = 4173;
pub const SPI_GETTHREADLOCALINPUTSETTINGS : i32 = 4174;
pub const SPI_SETTHREADLOCALINPUTSETTINGS : i32 = 4175;
pub const SPI_GETSYSTEMLANGUAGEBAR : i32 = 4176;
pub const SPI_SETSYSTEMLANGUAGEBAR : i32 = 4177;
pub const SPI_GETFOREGROUNDLOCKTIMEOUT : i32 = 8192;
pub const SPI_SETFOREGROUNDLOCKTIMEOUT : i32 = 8193;
pub const SPI_GETACTIVEWNDTRKTIMEOUT : i32 = 8194;
pub const SPI_SETACTIVEWNDTRKTIMEOUT : i32 = 8195;
pub const SPI_GETFOREGROUNDFLASHCOUNT : i32 = 8196;
pub const SPI_SETFOREGROUNDFLASHCOUNT : i32 = 8197;
pub const SPI_GETCARETWIDTH : i32 = 8198;
pub const SPI_SETCARETWIDTH : i32 = 8199;
pub const SPI_GETMOUSECLICKLOCKTIME : i32 = 8200;
pub const SPI_SETMOUSECLICKLOCKTIME : i32 = 8201;
pub const SPI_GETFONTSMOOTHINGTYPE : i32 = 8202;
pub const SPI_SETFONTSMOOTHINGTYPE : i32 = 8203;
pub const FE_FONTSMOOTHINGSTANDARD : i32 = 1;
pub const FE_FONTSMOOTHINGCLEARTYPE : i32 = 2;
pub const SPI_GETFONTSMOOTHINGCONTRAST : i32 = 8204;
pub const SPI_SETFONTSMOOTHINGCONTRAST : i32 = 8205;
pub const SPI_GETFOCUSBORDERWIDTH : i32 = 8206;
pub const SPI_SETFOCUSBORDERWIDTH : i32 = 8207;
pub const SPI_GETFOCUSBORDERHEIGHT : i32 = 8208;
pub const SPI_SETFOCUSBORDERHEIGHT : i32 = 8209;
pub const SPI_GETFONTSMOOTHINGORIENTATION : i32 = 8210;
pub const SPI_SETFONTSMOOTHINGORIENTATION : i32 = 8211;
pub const FE_FONTSMOOTHINGORIENTATIONBGR : i32 = 0;
pub const FE_FONTSMOOTHINGORIENTATIONRGB : i32 = 1;
pub const SPI_GETMINIMUMHITRADIUS : i32 = 8212;
pub const SPI_SETMINIMUMHITRADIUS : i32 = 8213;
pub const SPI_GETMESSAGEDURATION : i32 = 8214;
pub const SPI_SETMESSAGEDURATION : i32 = 8215;
pub const SPI_GETCONTACTVISUALIZATION : i32 = 8216;
pub const SPI_SETCONTACTVISUALIZATION : i32 = 8217;
pub const CONTACTVISUALIZATION_OFF : i32 = 0;
pub const CONTACTVISUALIZATION_ON : i32 = 1;
pub const CONTACTVISUALIZATION_PRESENTATIONMODE : i32 = 2;
pub const SPI_GETGESTUREVISUALIZATION : i32 = 8218;
pub const SPI_SETGESTUREVISUALIZATION : i32 = 8219;
pub const GESTUREVISUALIZATION_OFF : i32 = 0;
pub const GESTUREVISUALIZATION_ON : i32 = 31;
pub const GESTUREVISUALIZATION_TAP : i32 = 1;
pub const GESTUREVISUALIZATION_DOUBLETAP : i32 = 2;
pub const GESTUREVISUALIZATION_PRESSANDTAP : i32 = 4;
pub const GESTUREVISUALIZATION_PRESSANDHOLD : i32 = 8;
pub const GESTUREVISUALIZATION_RIGHTTAP : i32 = 16;
pub const SPI_GETMOUSEWHEELROUTING : i32 = 8220;
pub const SPI_SETMOUSEWHEELROUTING : i32 = 8221;
pub const MOUSEWHEEL_ROUTING_FOCUS : i32 = 0;
pub const MOUSEWHEEL_ROUTING_HYBRID : i32 = 1;
pub const MOUSEWHEEL_ROUTING_MOUSE_POS : i32 = 2;
pub const SPI_GETPENVISUALIZATION : i32 = 8222;
pub const SPI_SETPENVISUALIZATION : i32 = 8223;
pub const PENVISUALIZATION_ON : i32 = 35;
pub const PENVISUALIZATION_OFF : i32 = 0;
pub const PENVISUALIZATION_TAP : i32 = 1;
pub const PENVISUALIZATION_DOUBLETAP : i32 = 2;
pub const PENVISUALIZATION_CURSOR : i32 = 32;
pub const SPI_GETPENARBITRATIONTYPE : i32 = 8224;
pub const SPI_SETPENARBITRATIONTYPE : i32 = 8225;
pub const PENARBITRATIONTYPE_NONE : i32 = 0;
pub const PENARBITRATIONTYPE_WIN8 : i32 = 1;
pub const PENARBITRATIONTYPE_FIS : i32 = 2;
pub const PENARBITRATIONTYPE_SPT : i32 = 3;
pub const PENARBITRATIONTYPE_MAX : i32 = 4;
pub const SPI_GETCARETTIMEOUT : i32 = 8226;
pub const SPI_SETCARETTIMEOUT : i32 = 8227;
pub const SPI_GETHANDEDNESS : i32 = 8228;
pub const SPI_SETHANDEDNESS : i32 = 8229;
pub const SPIF_UPDATEINIFILE : i32 = 1;
pub const SPIF_SENDWININICHANGE : i32 = 2;
pub const SPIF_SENDCHANGE : i32 = 2;
pub const METRICS_USEDEFAULT : i32 = -1;
pub const ARW_BOTTOMLEFT : i32 = 0;
pub const ARW_BOTTOMRIGHT : i32 = 1;
pub const ARW_TOPLEFT : i32 = 2;
pub const ARW_TOPRIGHT : i32 = 3;
pub const ARW_STARTMASK : i32 = 3;
pub const ARW_STARTRIGHT : i32 = 1;
pub const ARW_STARTTOP : i32 = 2;
pub const ARW_LEFT : i32 = 0;
pub const ARW_RIGHT : i32 = 0;
pub const ARW_UP : i32 = 4;
pub const ARW_DOWN : i32 = 4;
pub const ARW_HIDE : i32 = 8;
pub const SERKF_SERIALKEYSON : i32 = 1;
pub const SERKF_AVAILABLE : i32 = 2;
pub const SERKF_INDICATOR : i32 = 4;
pub const HCF_HIGHCONTRASTON : i32 = 1;
pub const HCF_AVAILABLE : i32 = 2;
pub const HCF_HOTKEYACTIVE : i32 = 4;
pub const HCF_CONFIRMHOTKEY : i32 = 8;
pub const HCF_HOTKEYSOUND : i32 = 16;
pub const HCF_INDICATOR : i32 = 32;
pub const HCF_HOTKEYAVAILABLE : i32 = 64;
pub const HCF_LOGONDESKTOP : i32 = 256;
pub const HCF_DEFAULTDESKTOP : i32 = 512;
pub const HCF_OPTION_NOTHEMECHANGE : i32 = 4096;
pub const CDS_UPDATEREGISTRY : i32 = 1;
pub const CDS_TEST : i32 = 2;
pub const CDS_FULLSCREEN : i32 = 4;
pub const CDS_GLOBAL : i32 = 8;
pub const CDS_SET_PRIMARY : i32 = 16;
pub const CDS_VIDEOPARAMETERS : i32 = 32;
pub const CDS_ENABLE_UNSAFE_MODES : i32 = 256;
pub const CDS_DISABLE_UNSAFE_MODES : i32 = 512;
pub const CDS_RESET : i32 = 1073741824;
pub const CDS_RESET_EX : i32 = 536870912;
pub const CDS_NORESET : i32 = 268435456;
pub const DISP_CHANGE_SUCCESSFUL : i32 = 0;
pub const DISP_CHANGE_RESTART : i32 = 1;
pub const DISP_CHANGE_FAILED : i32 = -1;
pub const DISP_CHANGE_BADMODE : i32 = -2;
pub const DISP_CHANGE_NOTUPDATED : i32 = -3;
pub const DISP_CHANGE_BADFLAGS : i32 = -4;
pub const DISP_CHANGE_BADPARAM : i32 = -5;
pub const DISP_CHANGE_BADDUALVIEW : i32 = -6;
pub const ENUM_CURRENT_SETTINGS : u32 = 4294967295;
pub const ENUM_REGISTRY_SETTINGS : u32 = 4294967294;
pub const EDS_RAWMODE : i32 = 2;
pub const EDS_ROTATEDMODE : i32 = 4;
pub const EDD_GET_DEVICE_INTERFACE_NAME : i32 = 1;
pub const FKF_FILTERKEYSON : i32 = 1;
pub const FKF_AVAILABLE : i32 = 2;
pub const FKF_HOTKEYACTIVE : i32 = 4;
pub const FKF_CONFIRMHOTKEY : i32 = 8;
pub const FKF_HOTKEYSOUND : i32 = 16;
pub const FKF_INDICATOR : i32 = 32;
pub const FKF_CLICKON : i32 = 64;
pub const SKF_STICKYKEYSON : u32 = 1;
pub const SKF_AVAILABLE : u32 = 2;
pub const SKF_HOTKEYACTIVE : u32 = 4;
pub const SKF_CONFIRMHOTKEY : u32 = 8;
pub const SKF_HOTKEYSOUND : u32 = 16;
pub const SKF_INDICATOR : u32 = 32;
pub const SKF_AUDIBLEFEEDBACK : u32 = 64;
pub const SKF_TRISTATE : u32 = 128;
pub const SKF_TWOKEYSOFF : u32 = 256;
pub const SKF_LALTLATCHED : u32 = 268435456;
pub const SKF_LCTLLATCHED : u32 = 67108864;
pub const SKF_LSHIFTLATCHED : u32 = 16777216;
pub const SKF_RALTLATCHED : u32 = 536870912;
pub const SKF_RCTLLATCHED : u32 = 134217728;
pub const SKF_RSHIFTLATCHED : u32 = 33554432;
pub const SKF_LWINLATCHED : u32 = 1073741824;
pub const SKF_RWINLATCHED : u32 = 2147483648;
pub const SKF_LALTLOCKED : u32 = 1048576;
pub const SKF_LCTLLOCKED : u32 = 262144;
pub const SKF_LSHIFTLOCKED : u32 = 65536;
pub const SKF_RALTLOCKED : u32 = 2097152;
pub const SKF_RCTLLOCKED : u32 = 524288;
pub const SKF_RSHIFTLOCKED : u32 = 131072;
pub const SKF_LWINLOCKED : u32 = 4194304;
pub const SKF_RWINLOCKED : u32 = 8388608;
pub const MKF_MOUSEKEYSON : u32 = 1;
pub const MKF_AVAILABLE : u32 = 2;
pub const MKF_HOTKEYACTIVE : u32 = 4;
pub const MKF_CONFIRMHOTKEY : u32 = 8;
pub const MKF_HOTKEYSOUND : u32 = 16;
pub const MKF_INDICATOR : u32 = 32;
pub const MKF_MODIFIERS : u32 = 64;
pub const MKF_REPLACENUMBERS : u32 = 128;
pub const MKF_LEFTBUTTONSEL : u32 = 268435456;
pub const MKF_RIGHTBUTTONSEL : u32 = 536870912;
pub const MKF_LEFTBUTTONDOWN : u32 = 16777216;
pub const MKF_RIGHTBUTTONDOWN : u32 = 33554432;
pub const MKF_MOUSEMODE : u32 = 2147483648;
pub const ATF_TIMEOUTON : i32 = 1;
pub const ATF_ONOFFFEEDBACK : i32 = 2;
pub const SSGF_NONE : i32 = 0;
pub const SSGF_DISPLAY : i32 = 3;
pub const SSTF_NONE : i32 = 0;
pub const SSTF_CHARS : i32 = 1;
pub const SSTF_BORDER : i32 = 2;
pub const SSTF_DISPLAY : i32 = 3;
pub const SSWF_NONE : i32 = 0;
pub const SSWF_TITLE : i32 = 1;
pub const SSWF_WINDOW : i32 = 2;
pub const SSWF_DISPLAY : i32 = 3;
pub const SSWF_CUSTOM : i32 = 4;
pub const SSF_SOUNDSENTRYON : i32 = 1;
pub const SSF_AVAILABLE : i32 = 2;
pub const SSF_INDICATOR : i32 = 4;
pub const TKF_TOGGLEKEYSON : i32 = 1;
pub const TKF_AVAILABLE : i32 = 2;
pub const TKF_HOTKEYACTIVE : i32 = 4;
pub const TKF_CONFIRMHOTKEY : i32 = 8;
pub const TKF_HOTKEYSOUND : i32 = 16;
pub const TKF_INDICATOR : i32 = 32;
pub const SLE_ERROR : i32 = 1;
pub const SLE_MINORERROR : i32 = 2;
pub const SLE_WARNING : i32 = 3;
pub const MONITOR_DEFAULTTONULL : i32 = 0;
pub const MONITOR_DEFAULTTOPRIMARY : i32 = 1;
pub const MONITOR_DEFAULTTONEAREST : i32 = 2;
pub const MONITORINFOF_PRIMARY : i32 = 1;
pub const CCHDEVICENAME : i32 = 32;
pub const WINEVENT_OUTOFCONTEXT : i32 = 0;
pub const WINEVENT_SKIPOWNTHREAD : i32 = 1;
pub const WINEVENT_SKIPOWNPROCESS : i32 = 2;
pub const WINEVENT_INCONTEXT : i32 = 4;
pub const CHILDID_SELF : i32 = 0;
pub const INDEXID_OBJECT : i32 = 0;
pub const INDEXID_CONTAINER : i32 = 0;
pub const OBJID_WINDOW : i32 = 0;
pub const OBJID_SYSMENU : i32 = -1;
pub const OBJID_TITLEBAR : i32 = -2;
pub const OBJID_MENU : i32 = -3;
pub const OBJID_CLIENT : i32 = -4;
pub const OBJID_VSCROLL : i32 = -5;
pub const OBJID_HSCROLL : i32 = -6;
pub const OBJID_SIZEGRIP : i32 = -7;
pub const OBJID_CARET : i32 = -8;
pub const OBJID_CURSOR : i32 = -9;
pub const OBJID_ALERT : i32 = -10;
pub const OBJID_SOUND : i32 = -11;
pub const OBJID_QUERYCLASSNAMEIDX : i32 = -12;
pub const OBJID_NATIVEOM : i32 = -16;
pub const EVENT_MIN : i32 = 1;
pub const EVENT_MAX : i32 = 2147483647;
pub const EVENT_SYSTEM_SOUND : i32 = 1;
pub const EVENT_SYSTEM_ALERT : i32 = 2;
pub const EVENT_SYSTEM_FOREGROUND : i32 = 3;
pub const EVENT_SYSTEM_MENUSTART : i32 = 4;
pub const EVENT_SYSTEM_MENUEND : i32 = 5;
pub const EVENT_SYSTEM_MENUPOPUPSTART : i32 = 6;
pub const EVENT_SYSTEM_MENUPOPUPEND : i32 = 7;
pub const EVENT_SYSTEM_CAPTURESTART : i32 = 8;
pub const EVENT_SYSTEM_CAPTUREEND : i32 = 9;
pub const EVENT_SYSTEM_MOVESIZESTART : i32 = 10;
pub const EVENT_SYSTEM_MOVESIZEEND : i32 = 11;
pub const EVENT_SYSTEM_CONTEXTHELPSTART : i32 = 12;
pub const EVENT_SYSTEM_CONTEXTHELPEND : i32 = 13;
pub const EVENT_SYSTEM_DRAGDROPSTART : i32 = 14;
pub const EVENT_SYSTEM_DRAGDROPEND : i32 = 15;
pub const EVENT_SYSTEM_DIALOGSTART : i32 = 16;
pub const EVENT_SYSTEM_DIALOGEND : i32 = 17;
pub const EVENT_SYSTEM_SCROLLINGSTART : i32 = 18;
pub const EVENT_SYSTEM_SCROLLINGEND : i32 = 19;
pub const EVENT_SYSTEM_SWITCHSTART : i32 = 20;
pub const EVENT_SYSTEM_SWITCHEND : i32 = 21;
pub const EVENT_SYSTEM_MINIMIZESTART : i32 = 22;
pub const EVENT_SYSTEM_MINIMIZEEND : i32 = 23;
pub const EVENT_SYSTEM_DESKTOPSWITCH : i32 = 32;
pub const EVENT_SYSTEM_SWITCHER_APPGRABBED : i32 = 36;
pub const EVENT_SYSTEM_SWITCHER_APPOVERTARGET : i32 = 37;
pub const EVENT_SYSTEM_SWITCHER_APPDROPPED : i32 = 38;
pub const EVENT_SYSTEM_SWITCHER_CANCELLED : i32 = 39;
pub const EVENT_SYSTEM_IME_KEY_NOTIFICATION : i32 = 41;
pub const EVENT_SYSTEM_END : i32 = 255;
pub const EVENT_OEM_DEFINED_START : i32 = 257;
pub const EVENT_OEM_DEFINED_END : i32 = 511;
pub const EVENT_UIA_EVENTID_START : i32 = 19968;
pub const EVENT_UIA_EVENTID_END : i32 = 20223;
pub const EVENT_UIA_PROPID_START : i32 = 29952;
pub const EVENT_UIA_PROPID_END : i32 = 30207;
pub const EVENT_CONSOLE_CARET : i32 = 16385;
pub const EVENT_CONSOLE_UPDATE_REGION : i32 = 16386;
pub const EVENT_CONSOLE_UPDATE_SIMPLE : i32 = 16387;
pub const EVENT_CONSOLE_UPDATE_SCROLL : i32 = 16388;
pub const EVENT_CONSOLE_LAYOUT : i32 = 16389;
pub const EVENT_CONSOLE_START_APPLICATION : i32 = 16390;
pub const EVENT_CONSOLE_END_APPLICATION : i32 = 16391;
pub const CONSOLE_APPLICATION_16BIT : i32 = 1;
pub const CONSOLE_CARET_SELECTION : i32 = 1;
pub const CONSOLE_CARET_VISIBLE : i32 = 2;
pub const EVENT_CONSOLE_END : i32 = 16639;
pub const EVENT_OBJECT_CREATE : i32 = 32768;
pub const EVENT_OBJECT_DESTROY : i32 = 32769;
pub const EVENT_OBJECT_SHOW : i32 = 32770;
pub const EVENT_OBJECT_HIDE : i32 = 32771;
pub const EVENT_OBJECT_REORDER : i32 = 32772;
pub const EVENT_OBJECT_FOCUS : i32 = 32773;
pub const EVENT_OBJECT_SELECTION : i32 = 32774;
pub const EVENT_OBJECT_SELECTIONADD : i32 = 32775;
pub const EVENT_OBJECT_SELECTIONREMOVE : i32 = 32776;
pub const EVENT_OBJECT_SELECTIONWITHIN : i32 = 32777;
pub const EVENT_OBJECT_STATECHANGE : i32 = 32778;
pub const EVENT_OBJECT_LOCATIONCHANGE : i32 = 32779;
pub const EVENT_OBJECT_NAMECHANGE : i32 = 32780;
pub const EVENT_OBJECT_DESCRIPTIONCHANGE : i32 = 32781;
pub const EVENT_OBJECT_VALUECHANGE : i32 = 32782;
pub const EVENT_OBJECT_PARENTCHANGE : i32 = 32783;
pub const EVENT_OBJECT_HELPCHANGE : i32 = 32784;
pub const EVENT_OBJECT_DEFACTIONCHANGE : i32 = 32785;
pub const EVENT_OBJECT_ACCELERATORCHANGE : i32 = 32786;
pub const EVENT_OBJECT_INVOKED : i32 = 32787;
pub const EVENT_OBJECT_TEXTSELECTIONCHANGED : i32 = 32788;
pub const EVENT_OBJECT_CONTENTSCROLLED : i32 = 32789;
pub const EVENT_SYSTEM_ARRANGMENTPREVIEW : i32 = 32790;
pub const EVENT_OBJECT_CLOAKED : i32 = 32791;
pub const EVENT_OBJECT_UNCLOAKED : i32 = 32792;
pub const EVENT_OBJECT_LIVEREGIONCHANGED : i32 = 32793;
pub const EVENT_OBJECT_HOSTEDOBJECTSINVALIDATED : i32 = 32800;
pub const EVENT_OBJECT_DRAGSTART : i32 = 32801;
pub const EVENT_OBJECT_DRAGCANCEL : i32 = 32802;
pub const EVENT_OBJECT_DRAGCOMPLETE : i32 = 32803;
pub const EVENT_OBJECT_DRAGENTER : i32 = 32804;
pub const EVENT_OBJECT_DRAGLEAVE : i32 = 32805;
pub const EVENT_OBJECT_DRAGDROPPED : i32 = 32806;
pub const EVENT_OBJECT_IME_SHOW : i32 = 32807;
pub const EVENT_OBJECT_IME_HIDE : i32 = 32808;
pub const EVENT_OBJECT_IME_CHANGE : i32 = 32809;
pub const EVENT_OBJECT_TEXTEDIT_CONVERSIONTARGETCHANGED : i32 = 32816;
pub const EVENT_OBJECT_END : i32 = 33023;
pub const EVENT_AIA_START : i32 = 40960;
pub const EVENT_AIA_END : i32 = 45055;
pub const SOUND_SYSTEM_STARTUP : i32 = 1;
pub const SOUND_SYSTEM_SHUTDOWN : i32 = 2;
pub const SOUND_SYSTEM_BEEP : i32 = 3;
pub const SOUND_SYSTEM_ERROR : i32 = 4;
pub const SOUND_SYSTEM_QUESTION : i32 = 5;
pub const SOUND_SYSTEM_WARNING : i32 = 6;
pub const SOUND_SYSTEM_INFORMATION : i32 = 7;
pub const SOUND_SYSTEM_MAXIMIZE : i32 = 8;
pub const SOUND_SYSTEM_MINIMIZE : i32 = 9;
pub const SOUND_SYSTEM_RESTOREUP : i32 = 10;
pub const SOUND_SYSTEM_RESTOREDOWN : i32 = 11;
pub const SOUND_SYSTEM_APPSTART : i32 = 12;
pub const SOUND_SYSTEM_FAULT : i32 = 13;
pub const SOUND_SYSTEM_APPEND : i32 = 14;
pub const SOUND_SYSTEM_MENUCOMMAND : i32 = 15;
pub const SOUND_SYSTEM_MENUPOPUP : i32 = 16;
pub const CSOUND_SYSTEM : i32 = 16;
pub const ALERT_SYSTEM_INFORMATIONAL : i32 = 1;
pub const ALERT_SYSTEM_WARNING : i32 = 2;
pub const ALERT_SYSTEM_ERROR : i32 = 3;
pub const ALERT_SYSTEM_QUERY : i32 = 4;
pub const ALERT_SYSTEM_CRITICAL : i32 = 5;
pub const CALERT_SYSTEM : i32 = 6;
pub const GUI_CARETBLINKING : i32 = 1;
pub const GUI_INMOVESIZE : i32 = 2;
pub const GUI_INMENUMODE : i32 = 4;
pub const GUI_SYSTEMMENUMODE : i32 = 8;
pub const GUI_POPUPMENUMODE : i32 = 16;
pub const GUI_16BITTASK : i32 = 32;
pub const USER_DEFAULT_SCREEN_DPI : i32 = 96;
pub const STATE_SYSTEM_UNAVAILABLE : i32 = 1;
pub const STATE_SYSTEM_SELECTED : i32 = 2;
pub const STATE_SYSTEM_FOCUSED : i32 = 4;
pub const STATE_SYSTEM_PRESSED : i32 = 8;
pub const STATE_SYSTEM_CHECKED : i32 = 16;
pub const STATE_SYSTEM_MIXED : i32 = 32;
pub const STATE_SYSTEM_INDETERMINATE : i32 = 32;
pub const STATE_SYSTEM_READONLY : i32 = 64;
pub const STATE_SYSTEM_HOTTRACKED : i32 = 128;
pub const STATE_SYSTEM_DEFAULT : i32 = 256;
pub const STATE_SYSTEM_EXPANDED : i32 = 512;
pub const STATE_SYSTEM_COLLAPSED : i32 = 1024;
pub const STATE_SYSTEM_BUSY : i32 = 2048;
pub const STATE_SYSTEM_FLOATING : i32 = 4096;
pub const STATE_SYSTEM_MARQUEED : i32 = 8192;
pub const STATE_SYSTEM_ANIMATED : i32 = 16384;
pub const STATE_SYSTEM_INVISIBLE : i32 = 32768;
pub const STATE_SYSTEM_OFFSCREEN : i32 = 65536;
pub const STATE_SYSTEM_SIZEABLE : i32 = 131072;
pub const STATE_SYSTEM_MOVEABLE : i32 = 262144;
pub const STATE_SYSTEM_SELFVOICING : i32 = 524288;
pub const STATE_SYSTEM_FOCUSABLE : i32 = 1048576;
pub const STATE_SYSTEM_SELECTABLE : i32 = 2097152;
pub const STATE_SYSTEM_LINKED : i32 = 4194304;
pub const STATE_SYSTEM_TRAVERSED : i32 = 8388608;
pub const STATE_SYSTEM_MULTISELECTABLE : i32 = 16777216;
pub const STATE_SYSTEM_EXTSELECTABLE : i32 = 33554432;
pub const STATE_SYSTEM_ALERT_LOW : i32 = 67108864;
pub const STATE_SYSTEM_ALERT_MEDIUM : i32 = 134217728;
pub const STATE_SYSTEM_ALERT_HIGH : i32 = 268435456;
pub const STATE_SYSTEM_PROTECTED : i32 = 536870912;
pub const STATE_SYSTEM_VALID : i32 = 1073741823;
pub const CCHILDREN_TITLEBAR : i32 = 5;
pub const CCHILDREN_SCROLLBAR : i32 = 5;
pub const CURSOR_SHOWING : i32 = 1;
pub const CURSOR_SUPPRESSED : i32 = 2;
pub const WS_ACTIVECAPTION : i32 = 1;
pub const GA_PARENT : i32 = 1;
pub const GA_ROOT : i32 = 2;
pub const GA_ROOTOWNER : i32 = 3;
pub const RIM_INPUT : i32 = 0;
pub const RIM_INPUTSINK : i32 = 1;
pub const RIM_TYPEMOUSE : i32 = 0;
pub const RIM_TYPEKEYBOARD : i32 = 1;
pub const RIM_TYPEHID : i32 = 2;
pub const RIM_TYPEMAX : i32 = 2;
pub const RI_MOUSE_LEFT_BUTTON_DOWN : i32 = 1;
pub const RI_MOUSE_LEFT_BUTTON_UP : i32 = 2;
pub const RI_MOUSE_RIGHT_BUTTON_DOWN : i32 = 4;
pub const RI_MOUSE_RIGHT_BUTTON_UP : i32 = 8;
pub const RI_MOUSE_MIDDLE_BUTTON_DOWN : i32 = 16;
pub const RI_MOUSE_MIDDLE_BUTTON_UP : i32 = 32;
pub const RI_MOUSE_BUTTON_1_DOWN : i32 = 1;
pub const RI_MOUSE_BUTTON_1_UP : i32 = 2;
pub const RI_MOUSE_BUTTON_2_DOWN : i32 = 4;
pub const RI_MOUSE_BUTTON_2_UP : i32 = 8;
pub const RI_MOUSE_BUTTON_3_DOWN : i32 = 16;
pub const RI_MOUSE_BUTTON_3_UP : i32 = 32;
pub const RI_MOUSE_BUTTON_4_DOWN : i32 = 64;
pub const RI_MOUSE_BUTTON_4_UP : i32 = 128;
pub const RI_MOUSE_BUTTON_5_DOWN : i32 = 256;
pub const RI_MOUSE_BUTTON_5_UP : i32 = 512;
pub const RI_MOUSE_WHEEL : i32 = 1024;
pub const RI_MOUSE_HWHEEL : i32 = 2048;
pub const MOUSE_MOVE_RELATIVE : i32 = 0;
pub const MOUSE_MOVE_ABSOLUTE : i32 = 1;
pub const MOUSE_VIRTUAL_DESKTOP : i32 = 2;
pub const MOUSE_ATTRIBUTES_CHANGED : i32 = 4;
pub const MOUSE_MOVE_NOCOALESCE : i32 = 8;
pub const KEYBOARD_OVERRUN_MAKE_CODE : i32 = 255;
pub const RI_KEY_MAKE : i32 = 0;
pub const RI_KEY_BREAK : i32 = 1;
pub const RI_KEY_E0 : i32 = 2;
pub const RI_KEY_E1 : i32 = 4;
pub const RI_KEY_TERMSRV_SET_LED : i32 = 8;
pub const RI_KEY_TERMSRV_SHADOW : i32 = 16;
pub const RID_INPUT : i32 = 268435459;
pub const RID_HEADER : i32 = 268435461;
pub const RIDI_PREPARSEDDATA : i32 = 536870917;
pub const RIDI_DEVICENAME : i32 = 536870919;
pub const RIDI_DEVICEINFO : i32 = 536870923;
pub const RIDEV_REMOVE : i32 = 1;
pub const RIDEV_EXCLUDE : i32 = 16;
pub const RIDEV_PAGEONLY : i32 = 32;
pub const RIDEV_NOLEGACY : i32 = 48;
pub const RIDEV_INPUTSINK : i32 = 256;
pub const RIDEV_CAPTUREMOUSE : i32 = 512;
pub const RIDEV_NOHOTKEYS : i32 = 512;
pub const RIDEV_APPKEYS : i32 = 1024;
pub const RIDEV_EXINPUTSINK : i32 = 4096;
pub const RIDEV_DEVNOTIFY : i32 = 8192;
pub const RIDEV_EXMODEMASK : i32 = 240;
pub const GIDC_ARRIVAL : i32 = 1;
pub const GIDC_REMOVAL : i32 = 2;
pub const POINTER_DEVICE_PRODUCT_STRING_MAX : i32 = 520;
pub const PDC_ARRIVAL : i32 = 1;
pub const PDC_REMOVAL : i32 = 2;
pub const PDC_ORIENTATION_0 : i32 = 4;
pub const PDC_ORIENTATION_90 : i32 = 8;
pub const PDC_ORIENTATION_180 : i32 = 16;
pub const PDC_ORIENTATION_270 : i32 = 32;
pub const PDC_MODE_DEFAULT : i32 = 64;
pub const PDC_MODE_CENTERED : i32 = 128;
pub const PDC_MAPPING_CHANGE : i32 = 256;
pub const PDC_RESOLUTION : i32 = 512;
pub const PDC_ORIGIN : i32 = 1024;
pub const PDC_MODE_ASPECTRATIOPRESERVED : i32 = 2048;
pub const MSGFLT_ADD : i32 = 1;
pub const MSGFLT_REMOVE : i32 = 2;
pub const MSGFLTINFO_NONE : i32 = 0;
pub const MSGFLTINFO_ALREADYALLOWED_FORWND : i32 = 1;
pub const MSGFLTINFO_ALREADYDISALLOWED_FORWND : i32 = 2;
pub const MSGFLTINFO_ALLOWED_HIGHER : i32 = 3;
pub const MSGFLT_RESET : i32 = 0;
pub const MSGFLT_ALLOW : i32 = 1;
pub const MSGFLT_DISALLOW : i32 = 2;
pub const GF_BEGIN : i32 = 1;
pub const GF_INERTIA : i32 = 2;
pub const GF_END : i32 = 4;
pub const GID_BEGIN : i32 = 1;
pub const GID_END : i32 = 2;
pub const GID_ZOOM : i32 = 3;
pub const GID_PAN : i32 = 4;
pub const GID_ROTATE : i32 = 5;
pub const GID_TWOFINGERTAP : i32 = 6;
pub const GID_PRESSANDTAP : i32 = 7;
pub const GID_ROLLOVER : i32 = 7;
pub const GC_ALLGESTURES : i32 = 1;
pub const GC_ZOOM : i32 = 1;
pub const GC_PAN : i32 = 1;
pub const GC_PAN_WITH_SINGLE_FINGER_VERTICALLY : i32 = 2;
pub const GC_PAN_WITH_SINGLE_FINGER_HORIZONTALLY : i32 = 4;
pub const GC_PAN_WITH_GUTTER : i32 = 8;
pub const GC_PAN_WITH_INERTIA : i32 = 16;
pub const GC_ROTATE : i32 = 1;
pub const GC_TWOFINGERTAP : i32 = 1;
pub const GC_PRESSANDTAP : i32 = 1;
pub const GC_ROLLOVER : i32 = 1;
pub const GESTURECONFIGMAXCOUNT : i32 = 256;
pub const NID_INTEGRATED_TOUCH : i32 = 1;
pub const NID_EXTERNAL_TOUCH : i32 = 2;
pub const NID_INTEGRATED_PEN : i32 = 4;
pub const NID_EXTERNAL_PEN : i32 = 8;
pub const NID_MULTI_INPUT : i32 = 64;
pub const NID_READY : i32 = 128;
pub const MAX_STR_BLOCKREASON : i32 = 256;
pub const DXGI_CREATE_FACTORY_DEBUG : u32 = 1;
pub const INFINITE : u32 = 4294967295;
pub const FACILITY_NULL : i32 = 0;
pub const FACILITY_RPC : i32 = 1;
pub const FACILITY_DISPATCH : i32 = 2;
pub const FACILITY_STORAGE : i32 = 3;
pub const FACILITY_ITF : i32 = 4;
pub const FACILITY_WIN32 : i32 = 7;
pub const FACILITY_WINDOWS : i32 = 8;
pub const FACILITY_SSPI : i32 = 9;
pub const FACILITY_SECURITY : i32 = 9;
pub const FACILITY_CONTROL : i32 = 10;
pub const FACILITY_CERT : i32 = 11;
pub const FACILITY_INTERNET : i32 = 12;
pub const FACILITY_MEDIASERVER : i32 = 13;
pub const FACILITY_MSMQ : i32 = 14;
pub const FACILITY_SETUPAPI : i32 = 15;
pub const FACILITY_SCARD : i32 = 16;
pub const FACILITY_COMPLUS : i32 = 17;
pub const FACILITY_AAF : i32 = 18;
pub const FACILITY_URT : i32 = 19;
pub const FACILITY_ACS : i32 = 20;
pub const FACILITY_DPLAY : i32 = 21;
pub const FACILITY_UMI : i32 = 22;
pub const FACILITY_SXS : i32 = 23;
pub const FACILITY_WINDOWS_CE : i32 = 24;
pub const FACILITY_HTTP : i32 = 25;
pub const FACILITY_USERMODE_COMMONLOG : i32 = 26;
pub const FACILITY_WER : i32 = 27;
pub const FACILITY_USERMODE_FILTER_MANAGER : i32 = 31;
pub const FACILITY_BACKGROUNDCOPY : i32 = 32;
pub const FACILITY_CONFIGURATION : i32 = 33;
pub const FACILITY_WIA : i32 = 33;
pub const FACILITY_STATE_MANAGEMENT : i32 = 34;
pub const FACILITY_METADIRECTORY : i32 = 35;
pub const FACILITY_WINDOWSUPDATE : i32 = 36;
pub const FACILITY_DIRECTORYSERVICE : i32 = 37;
pub const FACILITY_GRAPHICS : i32 = 38;
pub const FACILITY_SHELL : i32 = 39;
pub const FACILITY_NAP : i32 = 39;
pub const FACILITY_TPM_SERVICES : i32 = 40;
pub const FACILITY_TPM_SOFTWARE : i32 = 41;
pub const FACILITY_UI : i32 = 42;
pub const FACILITY_XAML : i32 = 43;
pub const FACILITY_ACTION_QUEUE : i32 = 44;
pub const FACILITY_PLA : i32 = 48;
pub const FACILITY_WINDOWS_SETUP : i32 = 48;
pub const FACILITY_FVE : i32 = 49;
pub const FACILITY_FWP : i32 = 50;
pub const FACILITY_WINRM : i32 = 51;
pub const FACILITY_NDIS : i32 = 52;
pub const FACILITY_USERMODE_HYPERVISOR : i32 = 53;
pub const FACILITY_CMI : i32 = 54;
pub const FACILITY_USERMODE_VIRTUALIZATION : i32 = 55;
pub const FACILITY_USERMODE_VOLMGR : i32 = 56;
pub const FACILITY_BCD : i32 = 57;
pub const FACILITY_USERMODE_VHD : i32 = 58;
pub const FACILITY_USERMODE_HNS : i32 = 59;
pub const FACILITY_SDIAG : i32 = 60;
pub const FACILITY_WEBSERVICES : i32 = 61;
pub const FACILITY_WINPE : i32 = 61;
pub const FACILITY_WPN : i32 = 62;
pub const FACILITY_WINDOWS_STORE : i32 = 63;
pub const FACILITY_INPUT : i32 = 64;
pub const FACILITY_QUIC : i32 = 65;
pub const FACILITY_EAP : i32 = 66;
pub const FACILITY_WINDOWS_DEFENDER : i32 = 80;
pub const FACILITY_OPC : i32 = 81;
pub const FACILITY_XPS : i32 = 82;
pub const FACILITY_MBN : i32 = 84;
pub const FACILITY_POWERSHELL : i32 = 84;
pub const FACILITY_RAS : i32 = 83;
pub const FACILITY_P2P_INT : i32 = 98;
pub const FACILITY_P2P : i32 = 99;
pub const FACILITY_DAF : i32 = 100;
pub const FACILITY_BLUETOOTH_ATT : i32 = 101;
pub const FACILITY_AUDIO : i32 = 102;
pub const FACILITY_STATEREPOSITORY : i32 = 103;
pub const FACILITY_VISUALCPP : i32 = 109;
pub const FACILITY_SCRIPT : i32 = 112;
pub const FACILITY_PARSE : i32 = 113;
pub const FACILITY_BLB : i32 = 120;
pub const FACILITY_BLB_CLI : i32 = 121;
pub const FACILITY_WSBAPP : i32 = 122;
pub const FACILITY_BLBUI : i32 = 128;
pub const FACILITY_USN : i32 = 129;
pub const FACILITY_USERMODE_VOLSNAP : i32 = 130;
pub const FACILITY_TIERING : i32 = 131;
pub const FACILITY_WSB_ONLINE : i32 = 133;
pub const FACILITY_ONLINE_ID : i32 = 134;
pub const FACILITY_DEVICE_UPDATE_AGENT : i32 = 135;
pub const FACILITY_DRVSERVICING : i32 = 136;
pub const FACILITY_DLS : i32 = 153;
pub const FACILITY_DELIVERY_OPTIMIZATION : i32 = 208;
pub const FACILITY_USERMODE_SPACES : i32 = 231;
pub const FACILITY_USER_MODE_SECURITY_CORE : i32 = 232;
pub const FACILITY_USERMODE_LICENSING : i32 = 234;
pub const FACILITY_SOS : i32 = 160;
pub const FACILITY_DEBUGGERS : i32 = 176;
pub const FACILITY_SPP : i32 = 256;
pub const FACILITY_RESTORE : i32 = 256;
pub const FACILITY_DMSERVER : i32 = 256;
pub const FACILITY_DEPLOYMENT_SERVICES_SERVER : i32 = 257;
pub const FACILITY_DEPLOYMENT_SERVICES_IMAGING : i32 = 258;
pub const FACILITY_DEPLOYMENT_SERVICES_MANAGEMENT : i32 = 259;
pub const FACILITY_DEPLOYMENT_SERVICES_UTIL : i32 = 260;
pub const FACILITY_DEPLOYMENT_SERVICES_BINLSVC : i32 = 261;
pub const FACILITY_DEPLOYMENT_SERVICES_PXE : i32 = 263;
pub const FACILITY_DEPLOYMENT_SERVICES_TFTP : i32 = 264;
pub const FACILITY_DEPLOYMENT_SERVICES_TRANSPORT_MANAGEMENT : i32 = 272;
pub const FACILITY_DEPLOYMENT_SERVICES_DRIVER_PROVISIONING : i32 = 278;
pub const FACILITY_DEPLOYMENT_SERVICES_MULTICAST_SERVER : i32 = 289;
pub const FACILITY_DEPLOYMENT_SERVICES_MULTICAST_CLIENT : i32 = 290;
pub const FACILITY_DEPLOYMENT_SERVICES_CONTENT_PROVIDER : i32 = 293;
pub const FACILITY_LINGUISTIC_SERVICES : i32 = 305;
pub const FACILITY_AUDIOSTREAMING : i32 = 1094;
pub const FACILITY_TTD : i32 = 1490;
pub const FACILITY_ACCELERATOR : i32 = 1536;
pub const FACILITY_WMAAECMA : i32 = 1996;
pub const FACILITY_DIRECTMUSIC : i32 = 2168;
pub const FACILITY_DIRECT3D10 : i32 = 2169;
pub const FACILITY_DXGI : i32 = 2170;
pub const FACILITY_DXGI_DDI : i32 = 2171;
pub const FACILITY_DIRECT3D11 : i32 = 2172;
pub const FACILITY_DIRECT3D11_DEBUG : i32 = 2173;
pub const FACILITY_DIRECT3D12 : i32 = 2174;
pub const FACILITY_DIRECT3D12_DEBUG : i32 = 2175;
pub const FACILITY_DXCORE : i32 = 2176;
pub const FACILITY_LEAP : i32 = 2184;
pub const FACILITY_AUDCLNT : i32 = 2185;
pub const FACILITY_WINCODEC_DWRITE_DWM : i32 = 2200;
pub const FACILITY_WINML : i32 = 2192;
pub const FACILITY_DIRECT2D : i32 = 2201;
pub const FACILITY_DEFRAG : i32 = 2304;
pub const FACILITY_USERMODE_SDBUS : i32 = 2305;
pub const FACILITY_JSCRIPT : i32 = 2306;
pub const FACILITY_PIDGENX : i32 = 2561;
pub const FACILITY_EAS : i32 = 85;
pub const FACILITY_WEB : i32 = 885;
pub const FACILITY_WEB_SOCKET : i32 = 886;
pub const FACILITY_MOBILE : i32 = 1793;
pub const FACILITY_SQLITE : i32 = 1967;
pub const FACILITY_UTC : i32 = 1989;
pub const FACILITY_WEP : i32 = 2049;
pub const FACILITY_SYNCENGINE : i32 = 2050;
pub const FACILITY_XBOX : i32 = 2339;
pub const FACILITY_GAME : i32 = 2340;
pub const FACILITY_PIX : i32 = 2748;
pub const ERROR_SUCCESS : i32 = 0;
pub const NO_ERROR : i32 = 0;
pub const SEC_E_OK : i32 = 0;
pub const ERROR_INVALID_FUNCTION : i32 = 1;
pub const ERROR_FILE_NOT_FOUND : i32 = 2;
pub const ERROR_PATH_NOT_FOUND : i32 = 3;
pub const ERROR_TOO_MANY_OPEN_FILES : i32 = 4;
pub const ERROR_ACCESS_DENIED : i32 = 5;
pub const ERROR_INVALID_HANDLE : i32 = 6;
pub const ERROR_ARENA_TRASHED : i32 = 7;
pub const ERROR_NOT_ENOUGH_MEMORY : i32 = 8;
pub const ERROR_INVALID_BLOCK : i32 = 9;
pub const ERROR_BAD_ENVIRONMENT : i32 = 10;
pub const ERROR_BAD_FORMAT : i32 = 11;
pub const ERROR_INVALID_ACCESS : i32 = 12;
pub const ERROR_INVALID_DATA : i32 = 13;
pub const ERROR_OUTOFMEMORY : i32 = 14;
pub const ERROR_INVALID_DRIVE : i32 = 15;
pub const ERROR_CURRENT_DIRECTORY : i32 = 16;
pub const ERROR_NOT_SAME_DEVICE : i32 = 17;
pub const ERROR_NO_MORE_FILES : i32 = 18;
pub const ERROR_WRITE_PROTECT : i32 = 19;
pub const ERROR_BAD_UNIT : i32 = 20;
pub const ERROR_NOT_READY : i32 = 21;
pub const ERROR_BAD_COMMAND : i32 = 22;
pub const ERROR_CRC : i32 = 23;
pub const ERROR_BAD_LENGTH : i32 = 24;
pub const ERROR_SEEK : i32 = 25;
pub const ERROR_NOT_DOS_DISK : i32 = 26;
pub const ERROR_SECTOR_NOT_FOUND : i32 = 27;
pub const ERROR_OUT_OF_PAPER : i32 = 28;
pub const ERROR_WRITE_FAULT : i32 = 29;
pub const ERROR_READ_FAULT : i32 = 30;
pub const ERROR_GEN_FAILURE : i32 = 31;
pub const ERROR_SHARING_VIOLATION : i32 = 32;
pub const ERROR_LOCK_VIOLATION : i32 = 33;
pub const ERROR_WRONG_DISK : i32 = 34;
pub const ERROR_SHARING_BUFFER_EXCEEDED : i32 = 36;
pub const ERROR_HANDLE_EOF : i32 = 38;
pub const ERROR_HANDLE_DISK_FULL : i32 = 39;
pub const ERROR_NOT_SUPPORTED : i32 = 50;
pub const ERROR_REM_NOT_LIST : i32 = 51;
pub const ERROR_DUP_NAME : i32 = 52;
pub const ERROR_BAD_NETPATH : i32 = 53;
pub const ERROR_NETWORK_BUSY : i32 = 54;
pub const ERROR_DEV_NOT_EXIST : i32 = 55;
pub const ERROR_TOO_MANY_CMDS : i32 = 56;
pub const ERROR_ADAP_HDW_ERR : i32 = 57;
pub const ERROR_BAD_NET_RESP : i32 = 58;
pub const ERROR_UNEXP_NET_ERR : i32 = 59;
pub const ERROR_BAD_REM_ADAP : i32 = 60;
pub const ERROR_PRINTQ_FULL : i32 = 61;
pub const ERROR_NO_SPOOL_SPACE : i32 = 62;
pub const ERROR_PRINT_CANCELLED : i32 = 63;
pub const ERROR_NETNAME_DELETED : i32 = 64;
pub const ERROR_NETWORK_ACCESS_DENIED : i32 = 65;
pub const ERROR_BAD_DEV_TYPE : i32 = 66;
pub const ERROR_BAD_NET_NAME : i32 = 67;
pub const ERROR_TOO_MANY_NAMES : i32 = 68;
pub const ERROR_TOO_MANY_SESS : i32 = 69;
pub const ERROR_SHARING_PAUSED : i32 = 70;
pub const ERROR_REQ_NOT_ACCEP : i32 = 71;
pub const ERROR_REDIR_PAUSED : i32 = 72;
pub const ERROR_FILE_EXISTS : i32 = 80;
pub const ERROR_CANNOT_MAKE : i32 = 82;
pub const ERROR_FAIL_I24 : i32 = 83;
pub const ERROR_OUT_OF_STRUCTURES : i32 = 84;
pub const ERROR_ALREADY_ASSIGNED : i32 = 85;
pub const ERROR_INVALID_PASSWORD : i32 = 86;
pub const ERROR_INVALID_PARAMETER : i32 = 87;
pub const ERROR_NET_WRITE_FAULT : i32 = 88;
pub const ERROR_NO_PROC_SLOTS : i32 = 89;
pub const ERROR_TOO_MANY_SEMAPHORES : i32 = 100;
pub const ERROR_EXCL_SEM_ALREADY_OWNED : i32 = 101;
pub const ERROR_SEM_IS_SET : i32 = 102;
pub const ERROR_TOO_MANY_SEM_REQUESTS : i32 = 103;
pub const ERROR_INVALID_AT_INTERRUPT_TIME : i32 = 104;
pub const ERROR_SEM_OWNER_DIED : i32 = 105;
pub const ERROR_SEM_USER_LIMIT : i32 = 106;
pub const ERROR_DISK_CHANGE : i32 = 107;
pub const ERROR_DRIVE_LOCKED : i32 = 108;
pub const ERROR_BROKEN_PIPE : i32 = 109;
pub const ERROR_OPEN_FAILED : i32 = 110;
pub const ERROR_BUFFER_OVERFLOW : i32 = 111;
pub const ERROR_DISK_FULL : i32 = 112;
pub const ERROR_NO_MORE_SEARCH_HANDLES : i32 = 113;
pub const ERROR_INVALID_TARGET_HANDLE : i32 = 114;
pub const ERROR_INVALID_CATEGORY : i32 = 117;
pub const ERROR_INVALID_VERIFY_SWITCH : i32 = 118;
pub const ERROR_BAD_DRIVER_LEVEL : i32 = 119;
pub const ERROR_CALL_NOT_IMPLEMENTED : i32 = 120;
pub const ERROR_SEM_TIMEOUT : i32 = 121;
pub const ERROR_INSUFFICIENT_BUFFER : i32 = 122;
pub const ERROR_INVALID_NAME : i32 = 123;
pub const ERROR_INVALID_LEVEL : i32 = 124;
pub const ERROR_NO_VOLUME_LABEL : i32 = 125;
pub const ERROR_MOD_NOT_FOUND : i32 = 126;
pub const ERROR_PROC_NOT_FOUND : i32 = 127;
pub const ERROR_WAIT_NO_CHILDREN : i32 = 128;
pub const ERROR_CHILD_NOT_COMPLETE : i32 = 129;
pub const ERROR_DIRECT_ACCESS_HANDLE : i32 = 130;
pub const ERROR_NEGATIVE_SEEK : i32 = 131;
pub const ERROR_SEEK_ON_DEVICE : i32 = 132;
pub const ERROR_IS_JOIN_TARGET : i32 = 133;
pub const ERROR_IS_JOINED : i32 = 134;
pub const ERROR_IS_SUBSTED : i32 = 135;
pub const ERROR_NOT_JOINED : i32 = 136;
pub const ERROR_NOT_SUBSTED : i32 = 137;
pub const ERROR_JOIN_TO_JOIN : i32 = 138;
pub const ERROR_SUBST_TO_SUBST : i32 = 139;
pub const ERROR_JOIN_TO_SUBST : i32 = 140;
pub const ERROR_SUBST_TO_JOIN : i32 = 141;
pub const ERROR_BUSY_DRIVE : i32 = 142;
pub const ERROR_SAME_DRIVE : i32 = 143;
pub const ERROR_DIR_NOT_ROOT : i32 = 144;
pub const ERROR_DIR_NOT_EMPTY : i32 = 145;
pub const ERROR_IS_SUBST_PATH : i32 = 146;
pub const ERROR_IS_JOIN_PATH : i32 = 147;
pub const ERROR_PATH_BUSY : i32 = 148;
pub const ERROR_IS_SUBST_TARGET : i32 = 149;
pub const ERROR_SYSTEM_TRACE : i32 = 150;
pub const ERROR_INVALID_EVENT_COUNT : i32 = 151;
pub const ERROR_TOO_MANY_MUXWAITERS : i32 = 152;
pub const ERROR_INVALID_LIST_FORMAT : i32 = 153;
pub const ERROR_LABEL_TOO_LONG : i32 = 154;
pub const ERROR_TOO_MANY_TCBS : i32 = 155;
pub const ERROR_SIGNAL_REFUSED : i32 = 156;
pub const ERROR_DISCARDED : i32 = 157;
pub const ERROR_NOT_LOCKED : i32 = 158;
pub const ERROR_BAD_THREADID_ADDR : i32 = 159;
pub const ERROR_BAD_ARGUMENTS : i32 = 160;
pub const ERROR_BAD_PATHNAME : i32 = 161;
pub const ERROR_SIGNAL_PENDING : i32 = 162;
pub const ERROR_MAX_THRDS_REACHED : i32 = 164;
pub const ERROR_LOCK_FAILED : i32 = 167;
pub const ERROR_BUSY : i32 = 170;
pub const ERROR_DEVICE_SUPPORT_IN_PROGRESS : i32 = 171;
pub const ERROR_CANCEL_VIOLATION : i32 = 173;
pub const ERROR_ATOMIC_LOCKS_NOT_SUPPORTED : i32 = 174;
pub const ERROR_INVALID_SEGMENT_NUMBER : i32 = 180;
pub const ERROR_INVALID_ORDINAL : i32 = 182;
pub const ERROR_ALREADY_EXISTS : i32 = 183;
pub const ERROR_INVALID_FLAG_NUMBER : i32 = 186;
pub const ERROR_SEM_NOT_FOUND : i32 = 187;
pub const ERROR_INVALID_STARTING_CODESEG : i32 = 188;
pub const ERROR_INVALID_STACKSEG : i32 = 189;
pub const ERROR_INVALID_MODULETYPE : i32 = 190;
pub const ERROR_INVALID_EXE_SIGNATURE : i32 = 191;
pub const ERROR_EXE_MARKED_INVALID : i32 = 192;
pub const ERROR_BAD_EXE_FORMAT : i32 = 193;
pub const ERROR_ITERATED_DATA_EXCEEDS_64k : i32 = 194;
pub const ERROR_INVALID_MINALLOCSIZE : i32 = 195;
pub const ERROR_DYNLINK_FROM_INVALID_RING : i32 = 196;
pub const ERROR_IOPL_NOT_ENABLED : i32 = 197;
pub const ERROR_INVALID_SEGDPL : i32 = 198;
pub const ERROR_AUTODATASEG_EXCEEDS_64k : i32 = 199;
pub const ERROR_RING2SEG_MUST_BE_MOVABLE : i32 = 200;
pub const ERROR_RELOC_CHAIN_XEEDS_SEGLIM : i32 = 201;
pub const ERROR_INFLOOP_IN_RELOC_CHAIN : i32 = 202;
pub const ERROR_ENVVAR_NOT_FOUND : i32 = 203;
pub const ERROR_NO_SIGNAL_SENT : i32 = 205;
pub const ERROR_FILENAME_EXCED_RANGE : i32 = 206;
pub const ERROR_RING2_STACK_IN_USE : i32 = 207;
pub const ERROR_META_EXPANSION_TOO_LONG : i32 = 208;
pub const ERROR_INVALID_SIGNAL_NUMBER : i32 = 209;
pub const ERROR_THREAD_1_INACTIVE : i32 = 210;
pub const ERROR_LOCKED : i32 = 212;
pub const ERROR_TOO_MANY_MODULES : i32 = 214;
pub const ERROR_NESTING_NOT_ALLOWED : i32 = 215;
pub const ERROR_EXE_MACHINE_TYPE_MISMATCH : i32 = 216;
pub const ERROR_EXE_CANNOT_MODIFY_SIGNED_BINARY : i32 = 217;
pub const ERROR_EXE_CANNOT_MODIFY_STRONG_SIGNED_BINARY : i32 = 218;
pub const ERROR_FILE_CHECKED_OUT : i32 = 220;
pub const ERROR_CHECKOUT_REQUIRED : i32 = 221;
pub const ERROR_BAD_FILE_TYPE : i32 = 222;
pub const ERROR_FILE_TOO_LARGE : i32 = 223;
pub const ERROR_FORMS_AUTH_REQUIRED : i32 = 224;
pub const ERROR_VIRUS_INFECTED : i32 = 225;
pub const ERROR_VIRUS_DELETED : i32 = 226;
pub const ERROR_PIPE_LOCAL : i32 = 229;
pub const ERROR_BAD_PIPE : i32 = 230;
pub const ERROR_PIPE_BUSY : i32 = 231;
pub const ERROR_NO_DATA : i32 = 232;
pub const ERROR_PIPE_NOT_CONNECTED : i32 = 233;
pub const ERROR_MORE_DATA : i32 = 234;
pub const ERROR_NO_WORK_DONE : i32 = 235;
pub const ERROR_VC_DISCONNECTED : i32 = 240;
pub const ERROR_INVALID_EA_NAME : i32 = 254;
pub const ERROR_EA_LIST_INCONSISTENT : i32 = 255;
pub const WAIT_TIMEOUT : i32 = 258;
pub const ERROR_NO_MORE_ITEMS : i32 = 259;
pub const ERROR_CANNOT_COPY : i32 = 266;
pub const ERROR_DIRECTORY : i32 = 267;
pub const ERROR_EAS_DIDNT_FIT : i32 = 275;
pub const ERROR_EA_FILE_CORRUPT : i32 = 276;
pub const ERROR_EA_TABLE_FULL : i32 = 277;
pub const ERROR_INVALID_EA_HANDLE : i32 = 278;
pub const ERROR_EAS_NOT_SUPPORTED : i32 = 282;
pub const ERROR_NOT_OWNER : i32 = 288;
pub const ERROR_TOO_MANY_POSTS : i32 = 298;
pub const ERROR_PARTIAL_COPY : i32 = 299;
pub const ERROR_OPLOCK_NOT_GRANTED : i32 = 300;
pub const ERROR_INVALID_OPLOCK_PROTOCOL : i32 = 301;
pub const ERROR_DISK_TOO_FRAGMENTED : i32 = 302;
pub const ERROR_DELETE_PENDING : i32 = 303;
pub const ERROR_INCOMPATIBLE_WITH_GLOBAL_SHORT_NAME_REGISTRY_SETTING : i32 = 304;
pub const ERROR_SHORT_NAMES_NOT_ENABLED_ON_VOLUME : i32 = 305;
pub const ERROR_SECURITY_STREAM_IS_INCONSISTENT : i32 = 306;
pub const ERROR_INVALID_LOCK_RANGE : i32 = 307;
pub const ERROR_IMAGE_SUBSYSTEM_NOT_PRESENT : i32 = 308;
pub const ERROR_NOTIFICATION_GUID_ALREADY_DEFINED : i32 = 309;
pub const ERROR_INVALID_EXCEPTION_HANDLER : i32 = 310;
pub const ERROR_DUPLICATE_PRIVILEGES : i32 = 311;
pub const ERROR_NO_RANGES_PROCESSED : i32 = 312;
pub const ERROR_NOT_ALLOWED_ON_SYSTEM_FILE : i32 = 313;
pub const ERROR_DISK_RESOURCES_EXHAUSTED : i32 = 314;
pub const ERROR_INVALID_TOKEN : i32 = 315;
pub const ERROR_DEVICE_FEATURE_NOT_SUPPORTED : i32 = 316;
pub const ERROR_MR_MID_NOT_FOUND : i32 = 317;
pub const ERROR_SCOPE_NOT_FOUND : i32 = 318;
pub const ERROR_UNDEFINED_SCOPE : i32 = 319;
pub const ERROR_INVALID_CAP : i32 = 320;
pub const ERROR_DEVICE_UNREACHABLE : i32 = 321;
pub const ERROR_DEVICE_NO_RESOURCES : i32 = 322;
pub const ERROR_DATA_CHECKSUM_ERROR : i32 = 323;
pub const ERROR_INTERMIXED_KERNEL_EA_OPERATION : i32 = 324;
pub const ERROR_FILE_LEVEL_TRIM_NOT_SUPPORTED : i32 = 326;
pub const ERROR_OFFSET_ALIGNMENT_VIOLATION : i32 = 327;
pub const ERROR_INVALID_FIELD_IN_PARAMETER_LIST : i32 = 328;
pub const ERROR_OPERATION_IN_PROGRESS : i32 = 329;
pub const ERROR_BAD_DEVICE_PATH : i32 = 330;
pub const ERROR_TOO_MANY_DESCRIPTORS : i32 = 331;
pub const ERROR_SCRUB_DATA_DISABLED : i32 = 332;
pub const ERROR_NOT_REDUNDANT_STORAGE : i32 = 333;
pub const ERROR_RESIDENT_FILE_NOT_SUPPORTED : i32 = 334;
pub const ERROR_COMPRESSED_FILE_NOT_SUPPORTED : i32 = 335;
pub const ERROR_DIRECTORY_NOT_SUPPORTED : i32 = 336;
pub const ERROR_NOT_READ_FROM_COPY : i32 = 337;
pub const ERROR_FT_WRITE_FAILURE : i32 = 338;
pub const ERROR_FT_DI_SCAN_REQUIRED : i32 = 339;
pub const ERROR_INVALID_KERNEL_INFO_VERSION : i32 = 340;
pub const ERROR_INVALID_PEP_INFO_VERSION : i32 = 341;
pub const ERROR_OBJECT_NOT_EXTERNALLY_BACKED : i32 = 342;
pub const ERROR_EXTERNAL_BACKING_PROVIDER_UNKNOWN : i32 = 343;
pub const ERROR_COMPRESSION_NOT_BENEFICIAL : i32 = 344;
pub const ERROR_STORAGE_TOPOLOGY_ID_MISMATCH : i32 = 345;
pub const ERROR_BLOCKED_BY_PARENTAL_CONTROLS : i32 = 346;
pub const ERROR_BLOCK_TOO_MANY_REFERENCES : i32 = 347;
pub const ERROR_MARKED_TO_DISALLOW_WRITES : i32 = 348;
pub const ERROR_ENCLAVE_FAILURE : i32 = 349;
pub const ERROR_FAIL_NOACTION_REBOOT : i32 = 350;
pub const ERROR_FAIL_SHUTDOWN : i32 = 351;
pub const ERROR_FAIL_RESTART : i32 = 352;
pub const ERROR_MAX_SESSIONS_REACHED : i32 = 353;
pub const ERROR_NETWORK_ACCESS_DENIED_EDP : i32 = 354;
pub const ERROR_DEVICE_HINT_NAME_BUFFER_TOO_SMALL : i32 = 355;
pub const ERROR_EDP_POLICY_DENIES_OPERATION : i32 = 356;
pub const ERROR_EDP_DPL_POLICY_CANT_BE_SATISFIED : i32 = 357;
pub const ERROR_CLOUD_FILE_SYNC_ROOT_METADATA_CORRUPT : i32 = 358;
pub const ERROR_DEVICE_IN_MAINTENANCE : i32 = 359;
pub const ERROR_NOT_SUPPORTED_ON_DAX : i32 = 360;
pub const ERROR_DAX_MAPPING_EXISTS : i32 = 361;
pub const ERROR_CLOUD_FILE_PROVIDER_NOT_RUNNING : i32 = 362;
pub const ERROR_CLOUD_FILE_METADATA_CORRUPT : i32 = 363;
pub const ERROR_CLOUD_FILE_METADATA_TOO_LARGE : i32 = 364;
pub const ERROR_CLOUD_FILE_PROPERTY_BLOB_TOO_LARGE : i32 = 365;
pub const ERROR_CLOUD_FILE_PROPERTY_BLOB_CHECKSUM_MISMATCH : i32 = 366;
pub const ERROR_CHILD_PROCESS_BLOCKED : i32 = 367;
pub const ERROR_STORAGE_LOST_DATA_PERSISTENCE : i32 = 368;
pub const ERROR_FILE_SYSTEM_VIRTUALIZATION_UNAVAILABLE : i32 = 369;
pub const ERROR_FILE_SYSTEM_VIRTUALIZATION_METADATA_CORRUPT : i32 = 370;
pub const ERROR_FILE_SYSTEM_VIRTUALIZATION_BUSY : i32 = 371;
pub const ERROR_FILE_SYSTEM_VIRTUALIZATION_PROVIDER_UNKNOWN : i32 = 372;
pub const ERROR_GDI_HANDLE_LEAK : i32 = 373;
pub const ERROR_CLOUD_FILE_TOO_MANY_PROPERTY_BLOBS : i32 = 374;
pub const ERROR_CLOUD_FILE_PROPERTY_VERSION_NOT_SUPPORTED : i32 = 375;
pub const ERROR_NOT_A_CLOUD_FILE : i32 = 376;
pub const ERROR_CLOUD_FILE_NOT_IN_SYNC : i32 = 377;
pub const ERROR_CLOUD_FILE_ALREADY_CONNECTED : i32 = 378;
pub const ERROR_CLOUD_FILE_NOT_SUPPORTED : i32 = 379;
pub const ERROR_CLOUD_FILE_INVALID_REQUEST : i32 = 380;
pub const ERROR_CLOUD_FILE_READ_ONLY_VOLUME : i32 = 381;
pub const ERROR_CLOUD_FILE_CONNECTED_PROVIDER_ONLY : i32 = 382;
pub const ERROR_CLOUD_FILE_VALIDATION_FAILED : i32 = 383;
pub const ERROR_SMB1_NOT_AVAILABLE : i32 = 384;
pub const ERROR_FILE_SYSTEM_VIRTUALIZATION_INVALID_OPERATION : i32 = 385;
pub const ERROR_CLOUD_FILE_AUTHENTICATION_FAILED : i32 = 386;
pub const ERROR_CLOUD_FILE_INSUFFICIENT_RESOURCES : i32 = 387;
pub const ERROR_CLOUD_FILE_NETWORK_UNAVAILABLE : i32 = 388;
pub const ERROR_CLOUD_FILE_UNSUCCESSFUL : i32 = 389;
pub const ERROR_CLOUD_FILE_NOT_UNDER_SYNC_ROOT : i32 = 390;
pub const ERROR_CLOUD_FILE_IN_USE : i32 = 391;
pub const ERROR_CLOUD_FILE_PINNED : i32 = 392;
pub const ERROR_CLOUD_FILE_REQUEST_ABORTED : i32 = 393;
pub const ERROR_CLOUD_FILE_PROPERTY_CORRUPT : i32 = 394;
pub const ERROR_CLOUD_FILE_ACCESS_DENIED : i32 = 395;
pub const ERROR_CLOUD_FILE_INCOMPATIBLE_HARDLINKS : i32 = 396;
pub const ERROR_CLOUD_FILE_PROPERTY_LOCK_CONFLICT : i32 = 397;
pub const ERROR_CLOUD_FILE_REQUEST_CANCELED : i32 = 398;
pub const ERROR_EXTERNAL_SYSKEY_NOT_SUPPORTED : i32 = 399;
pub const ERROR_THREAD_MODE_ALREADY_BACKGROUND : i32 = 400;
pub const ERROR_THREAD_MODE_NOT_BACKGROUND : i32 = 401;
pub const ERROR_PROCESS_MODE_ALREADY_BACKGROUND : i32 = 402;
pub const ERROR_PROCESS_MODE_NOT_BACKGROUND : i32 = 403;
pub const ERROR_CLOUD_FILE_PROVIDER_TERMINATED : i32 = 404;
pub const ERROR_NOT_A_CLOUD_SYNC_ROOT : i32 = 405;
pub const ERROR_FILE_PROTECTED_UNDER_DPL : i32 = 406;
pub const ERROR_VOLUME_NOT_CLUSTER_ALIGNED : i32 = 407;
pub const ERROR_NO_PHYSICALLY_ALIGNED_FREE_SPACE_FOUND : i32 = 408;
pub const ERROR_APPX_FILE_NOT_ENCRYPTED : i32 = 409;
pub const ERROR_RWRAW_ENCRYPTED_FILE_NOT_ENCRYPTED : i32 = 410;
pub const ERROR_RWRAW_ENCRYPTED_INVALID_EDATAINFO_FILEOFFSET : i32 = 411;
pub const ERROR_RWRAW_ENCRYPTED_INVALID_EDATAINFO_FILERANGE : i32 = 412;
pub const ERROR_RWRAW_ENCRYPTED_INVALID_EDATAINFO_PARAMETER : i32 = 413;
pub const ERROR_LINUX_SUBSYSTEM_NOT_PRESENT : i32 = 414;
pub const ERROR_FT_READ_FAILURE : i32 = 415;
pub const ERROR_STORAGE_RESERVE_ID_INVALID : i32 = 416;
pub const ERROR_STORAGE_RESERVE_DOES_NOT_EXIST : i32 = 417;
pub const ERROR_STORAGE_RESERVE_ALREADY_EXISTS : i32 = 418;
pub const ERROR_STORAGE_RESERVE_NOT_EMPTY : i32 = 419;
pub const ERROR_NOT_A_DAX_VOLUME : i32 = 420;
pub const ERROR_NOT_DAX_MAPPABLE : i32 = 421;
pub const ERROR_TIME_SENSITIVE_THREAD : i32 = 422;
pub const ERROR_DPL_NOT_SUPPORTED_FOR_USER : i32 = 423;
pub const ERROR_CASE_DIFFERING_NAMES_IN_DIR : i32 = 424;
pub const ERROR_FILE_NOT_SUPPORTED : i32 = 425;
pub const ERROR_CLOUD_FILE_REQUEST_TIMEOUT : i32 = 426;
pub const ERROR_NO_TASK_QUEUE : i32 = 427;
pub const ERROR_SRC_SRV_DLL_LOAD_FAILED : i32 = 428;
pub const ERROR_NOT_SUPPORTED_WITH_BTT : i32 = 429;
pub const ERROR_ENCRYPTION_DISABLED : i32 = 430;
pub const ERROR_ENCRYPTING_METADATA_DISALLOWED : i32 = 431;
pub const ERROR_CANT_CLEAR_ENCRYPTION_FLAG : i32 = 432;
pub const ERROR_NO_SUCH_DEVICE : i32 = 433;
pub const ERROR_CLOUD_FILE_DEHYDRATION_DISALLOWED : i32 = 434;
pub const ERROR_FILE_SNAP_IN_PROGRESS : i32 = 435;
pub const ERROR_FILE_SNAP_USER_SECTION_NOT_SUPPORTED : i32 = 436;
pub const ERROR_FILE_SNAP_MODIFY_NOT_SUPPORTED : i32 = 437;
pub const ERROR_FILE_SNAP_IO_NOT_COORDINATED : i32 = 438;
pub const ERROR_FILE_SNAP_UNEXPECTED_ERROR : i32 = 439;
pub const ERROR_FILE_SNAP_INVALID_PARAMETER : i32 = 440;
pub const ERROR_UNSATISFIED_DEPENDENCIES : i32 = 441;
pub const ERROR_CASE_SENSITIVE_PATH : i32 = 442;
pub const ERROR_UNEXPECTED_NTCACHEMANAGER_ERROR : i32 = 443;
pub const ERROR_CAPAUTHZ_NOT_DEVUNLOCKED : i32 = 450;
pub const ERROR_CAPAUTHZ_CHANGE_TYPE : i32 = 451;
pub const ERROR_CAPAUTHZ_NOT_PROVISIONED : i32 = 452;
pub const ERROR_CAPAUTHZ_NOT_AUTHORIZED : i32 = 453;
pub const ERROR_CAPAUTHZ_NO_POLICY : i32 = 454;
pub const ERROR_CAPAUTHZ_DB_CORRUPTED : i32 = 455;
pub const ERROR_CAPAUTHZ_SCCD_INVALID_CATALOG : i32 = 456;
pub const ERROR_CAPAUTHZ_SCCD_NO_AUTH_ENTITY : i32 = 457;
pub const ERROR_CAPAUTHZ_SCCD_PARSE_ERROR : i32 = 458;
pub const ERROR_CAPAUTHZ_SCCD_DEV_MODE_REQUIRED : i32 = 459;
pub const ERROR_CAPAUTHZ_SCCD_NO_CAPABILITY_MATCH : i32 = 460;
pub const ERROR_PNP_QUERY_REMOVE_DEVICE_TIMEOUT : i32 = 480;
pub const ERROR_PNP_QUERY_REMOVE_RELATED_DEVICE_TIMEOUT : i32 = 481;
pub const ERROR_PNP_QUERY_REMOVE_UNRELATED_DEVICE_TIMEOUT : i32 = 482;
pub const ERROR_DEVICE_HARDWARE_ERROR : i32 = 483;
pub const ERROR_INVALID_ADDRESS : i32 = 487;
pub const ERROR_VRF_CFG_AND_IO_ENABLED : i32 = 1183;
pub const ERROR_PARTITION_TERMINATING : i32 = 1184;
pub const ERROR_USER_PROFILE_LOAD : i32 = 500;
pub const ERROR_ARITHMETIC_OVERFLOW : i32 = 534;
pub const ERROR_PIPE_CONNECTED : i32 = 535;
pub const ERROR_PIPE_LISTENING : i32 = 536;
pub const ERROR_VERIFIER_STOP : i32 = 537;
pub const ERROR_ABIOS_ERROR : i32 = 538;
pub const ERROR_WX86_WARNING : i32 = 539;
pub const ERROR_WX86_ERROR : i32 = 540;
pub const ERROR_TIMER_NOT_CANCELED : i32 = 541;
pub const ERROR_UNWIND : i32 = 542;
pub const ERROR_BAD_STACK : i32 = 543;
pub const ERROR_INVALID_UNWIND_TARGET : i32 = 544;
pub const ERROR_INVALID_PORT_ATTRIBUTES : i32 = 545;
pub const ERROR_PORT_MESSAGE_TOO_LONG : i32 = 546;
pub const ERROR_INVALID_QUOTA_LOWER : i32 = 547;
pub const ERROR_DEVICE_ALREADY_ATTACHED : i32 = 548;
pub const ERROR_INSTRUCTION_MISALIGNMENT : i32 = 549;
pub const ERROR_PROFILING_NOT_STARTED : i32 = 550;
pub const ERROR_PROFILING_NOT_STOPPED : i32 = 551;
pub const ERROR_COULD_NOT_INTERPRET : i32 = 552;
pub const ERROR_PROFILING_AT_LIMIT : i32 = 553;
pub const ERROR_CANT_WAIT : i32 = 554;
pub const ERROR_CANT_TERMINATE_SELF : i32 = 555;
pub const ERROR_UNEXPECTED_MM_CREATE_ERR : i32 = 556;
pub const ERROR_UNEXPECTED_MM_MAP_ERROR : i32 = 557;
pub const ERROR_UNEXPECTED_MM_EXTEND_ERR : i32 = 558;
pub const ERROR_BAD_FUNCTION_TABLE : i32 = 559;
pub const ERROR_NO_GUID_TRANSLATION : i32 = 560;
pub const ERROR_INVALID_LDT_SIZE : i32 = 561;
pub const ERROR_INVALID_LDT_OFFSET : i32 = 563;
pub const ERROR_INVALID_LDT_DESCRIPTOR : i32 = 564;
pub const ERROR_TOO_MANY_THREADS : i32 = 565;
pub const ERROR_THREAD_NOT_IN_PROCESS : i32 = 566;
pub const ERROR_PAGEFILE_QUOTA_EXCEEDED : i32 = 567;
pub const ERROR_LOGON_SERVER_CONFLICT : i32 = 568;
pub const ERROR_SYNCHRONIZATION_REQUIRED : i32 = 569;
pub const ERROR_NET_OPEN_FAILED : i32 = 570;
pub const ERROR_IO_PRIVILEGE_FAILED : i32 = 571;
pub const ERROR_CONTROL_C_EXIT : i32 = 572;
pub const ERROR_MISSING_SYSTEMFILE : i32 = 573;
pub const ERROR_UNHANDLED_EXCEPTION : i32 = 574;
pub const ERROR_APP_INIT_FAILURE : i32 = 575;
pub const ERROR_PAGEFILE_CREATE_FAILED : i32 = 576;
pub const ERROR_INVALID_IMAGE_HASH : i32 = 577;
pub const ERROR_NO_PAGEFILE : i32 = 578;
pub const ERROR_ILLEGAL_FLOAT_CONTEXT : i32 = 579;
pub const ERROR_NO_EVENT_PAIR : i32 = 580;
pub const ERROR_DOMAIN_CTRLR_CONFIG_ERROR : i32 = 581;
pub const ERROR_ILLEGAL_CHARACTER : i32 = 582;
pub const ERROR_UNDEFINED_CHARACTER : i32 = 583;
pub const ERROR_FLOPPY_VOLUME : i32 = 584;
pub const ERROR_BIOS_FAILED_TO_CONNECT_INTERRUPT : i32 = 585;
pub const ERROR_BACKUP_CONTROLLER : i32 = 586;
pub const ERROR_MUTANT_LIMIT_EXCEEDED : i32 = 587;
pub const ERROR_FS_DRIVER_REQUIRED : i32 = 588;
pub const ERROR_CANNOT_LOAD_REGISTRY_FILE : i32 = 589;
pub const ERROR_DEBUG_ATTACH_FAILED : i32 = 590;
pub const ERROR_SYSTEM_PROCESS_TERMINATED : i32 = 591;
pub const ERROR_DATA_NOT_ACCEPTED : i32 = 592;
pub const ERROR_VDM_HARD_ERROR : i32 = 593;
pub const ERROR_DRIVER_CANCEL_TIMEOUT : i32 = 594;
pub const ERROR_REPLY_MESSAGE_MISMATCH : i32 = 595;
pub const ERROR_LOST_WRITEBEHIND_DATA : i32 = 596;
pub const ERROR_CLIENT_SERVER_PARAMETERS_INVALID : i32 = 597;
pub const ERROR_NOT_TINY_STREAM : i32 = 598;
pub const ERROR_STACK_OVERFLOW_READ : i32 = 599;
pub const ERROR_CONVERT_TO_LARGE : i32 = 600;
pub const ERROR_FOUND_OUT_OF_SCOPE : i32 = 601;
pub const ERROR_ALLOCATE_BUCKET : i32 = 602;
pub const ERROR_MARSHALL_OVERFLOW : i32 = 603;
pub const ERROR_INVALID_VARIANT : i32 = 604;
pub const ERROR_BAD_COMPRESSION_BUFFER : i32 = 605;
pub const ERROR_AUDIT_FAILED : i32 = 606;
pub const ERROR_TIMER_RESOLUTION_NOT_SET : i32 = 607;
pub const ERROR_INSUFFICIENT_LOGON_INFO : i32 = 608;
pub const ERROR_BAD_DLL_ENTRYPOINT : i32 = 609;
pub const ERROR_BAD_SERVICE_ENTRYPOINT : i32 = 610;
pub const ERROR_IP_ADDRESS_CONFLICT1 : i32 = 611;
pub const ERROR_IP_ADDRESS_CONFLICT2 : i32 = 612;
pub const ERROR_REGISTRY_QUOTA_LIMIT : i32 = 613;
pub const ERROR_NO_CALLBACK_ACTIVE : i32 = 614;
pub const ERROR_PWD_TOO_SHORT : i32 = 615;
pub const ERROR_PWD_TOO_RECENT : i32 = 616;
pub const ERROR_PWD_HISTORY_CONFLICT : i32 = 617;
pub const ERROR_UNSUPPORTED_COMPRESSION : i32 = 618;
pub const ERROR_INVALID_HW_PROFILE : i32 = 619;
pub const ERROR_INVALID_PLUGPLAY_DEVICE_PATH : i32 = 620;
pub const ERROR_QUOTA_LIST_INCONSISTENT : i32 = 621;
pub const ERROR_EVALUATION_EXPIRATION : i32 = 622;
pub const ERROR_ILLEGAL_DLL_RELOCATION : i32 = 623;
pub const ERROR_DLL_INIT_FAILED_LOGOFF : i32 = 624;
pub const ERROR_VALIDATE_CONTINUE : i32 = 625;
pub const ERROR_NO_MORE_MATCHES : i32 = 626;
pub const ERROR_RANGE_LIST_CONFLICT : i32 = 627;
pub const ERROR_SERVER_SID_MISMATCH : i32 = 628;
pub const ERROR_CANT_ENABLE_DENY_ONLY : i32 = 629;
pub const ERROR_FLOAT_MULTIPLE_FAULTS : i32 = 630;
pub const ERROR_FLOAT_MULTIPLE_TRAPS : i32 = 631;
pub const ERROR_NOINTERFACE : i32 = 632;
pub const ERROR_DRIVER_FAILED_SLEEP : i32 = 633;
pub const ERROR_CORRUPT_SYSTEM_FILE : i32 = 634;
pub const ERROR_COMMITMENT_MINIMUM : i32 = 635;
pub const ERROR_PNP_RESTART_ENUMERATION : i32 = 636;
pub const ERROR_SYSTEM_IMAGE_BAD_SIGNATURE : i32 = 637;
pub const ERROR_PNP_REBOOT_REQUIRED : i32 = 638;
pub const ERROR_INSUFFICIENT_POWER : i32 = 639;
pub const ERROR_MULTIPLE_FAULT_VIOLATION : i32 = 640;
pub const ERROR_SYSTEM_SHUTDOWN : i32 = 641;
pub const ERROR_PORT_NOT_SET : i32 = 642;
pub const ERROR_DS_VERSION_CHECK_FAILURE : i32 = 643;
pub const ERROR_RANGE_NOT_FOUND : i32 = 644;
pub const ERROR_NOT_SAFE_MODE_DRIVER : i32 = 646;
pub const ERROR_FAILED_DRIVER_ENTRY : i32 = 647;
pub const ERROR_DEVICE_ENUMERATION_ERROR : i32 = 648;
pub const ERROR_MOUNT_POINT_NOT_RESOLVED : i32 = 649;
pub const ERROR_INVALID_DEVICE_OBJECT_PARAMETER : i32 = 650;
pub const ERROR_MCA_OCCURED : i32 = 651;
pub const ERROR_DRIVER_DATABASE_ERROR : i32 = 652;
pub const ERROR_SYSTEM_HIVE_TOO_LARGE : i32 = 653;
pub const ERROR_DRIVER_FAILED_PRIOR_UNLOAD : i32 = 654;
pub const ERROR_VOLSNAP_PREPARE_HIBERNATE : i32 = 655;
pub const ERROR_HIBERNATION_FAILURE : i32 = 656;
pub const ERROR_PWD_TOO_LONG : i32 = 657;
pub const ERROR_FILE_SYSTEM_LIMITATION : i32 = 665;
pub const ERROR_ASSERTION_FAILURE : i32 = 668;
pub const ERROR_ACPI_ERROR : i32 = 669;
pub const ERROR_WOW_ASSERTION : i32 = 670;
pub const ERROR_PNP_BAD_MPS_TABLE : i32 = 671;
pub const ERROR_PNP_TRANSLATION_FAILED : i32 = 672;
pub const ERROR_PNP_IRQ_TRANSLATION_FAILED : i32 = 673;
pub const ERROR_PNP_INVALID_ID : i32 = 674;
pub const ERROR_WAKE_SYSTEM_DEBUGGER : i32 = 675;
pub const ERROR_HANDLES_CLOSED : i32 = 676;
pub const ERROR_EXTRANEOUS_INFORMATION : i32 = 677;
pub const ERROR_RXACT_COMMIT_NECESSARY : i32 = 678;
pub const ERROR_MEDIA_CHECK : i32 = 679;
pub const ERROR_GUID_SUBSTITUTION_MADE : i32 = 680;
pub const ERROR_STOPPED_ON_SYMLINK : i32 = 681;
pub const ERROR_LONGJUMP : i32 = 682;
pub const ERROR_PLUGPLAY_QUERY_VETOED : i32 = 683;
pub const ERROR_UNWIND_CONSOLIDATE : i32 = 684;
pub const ERROR_REGISTRY_HIVE_RECOVERED : i32 = 685;
pub const ERROR_DLL_MIGHT_BE_INSECURE : i32 = 686;
pub const ERROR_DLL_MIGHT_BE_INCOMPATIBLE : i32 = 687;
pub const ERROR_DBG_EXCEPTION_NOT_HANDLED : i32 = 688;
pub const ERROR_DBG_REPLY_LATER : i32 = 689;
pub const ERROR_DBG_UNABLE_TO_PROVIDE_HANDLE : i32 = 690;
pub const ERROR_DBG_TERMINATE_THREAD : i32 = 691;
pub const ERROR_DBG_TERMINATE_PROCESS : i32 = 692;
pub const ERROR_DBG_CONTROL_C : i32 = 693;
pub const ERROR_DBG_PRINTEXCEPTION_C : i32 = 694;
pub const ERROR_DBG_RIPEXCEPTION : i32 = 695;
pub const ERROR_DBG_CONTROL_BREAK : i32 = 696;
pub const ERROR_DBG_COMMAND_EXCEPTION : i32 = 697;
pub const ERROR_OBJECT_NAME_EXISTS : i32 = 698;
pub const ERROR_THREAD_WAS_SUSPENDED : i32 = 699;
pub const ERROR_IMAGE_NOT_AT_BASE : i32 = 700;
pub const ERROR_RXACT_STATE_CREATED : i32 = 701;
pub const ERROR_SEGMENT_NOTIFICATION : i32 = 702;
pub const ERROR_BAD_CURRENT_DIRECTORY : i32 = 703;
pub const ERROR_FT_READ_RECOVERY_FROM_BACKUP : i32 = 704;
pub const ERROR_FT_WRITE_RECOVERY : i32 = 705;
pub const ERROR_IMAGE_MACHINE_TYPE_MISMATCH : i32 = 706;
pub const ERROR_RECEIVE_PARTIAL : i32 = 707;
pub const ERROR_RECEIVE_EXPEDITED : i32 = 708;
pub const ERROR_RECEIVE_PARTIAL_EXPEDITED : i32 = 709;
pub const ERROR_EVENT_DONE : i32 = 710;
pub const ERROR_EVENT_PENDING : i32 = 711;
pub const ERROR_CHECKING_FILE_SYSTEM : i32 = 712;
pub const ERROR_FATAL_APP_EXIT : i32 = 713;
pub const ERROR_PREDEFINED_HANDLE : i32 = 714;
pub const ERROR_WAS_UNLOCKED : i32 = 715;
pub const ERROR_SERVICE_NOTIFICATION : i32 = 716;
pub const ERROR_WAS_LOCKED : i32 = 717;
pub const ERROR_LOG_HARD_ERROR : i32 = 718;
pub const ERROR_ALREADY_WIN32 : i32 = 719;
pub const ERROR_IMAGE_MACHINE_TYPE_MISMATCH_EXE : i32 = 720;
pub const ERROR_NO_YIELD_PERFORMED : i32 = 721;
pub const ERROR_TIMER_RESUME_IGNORED : i32 = 722;
pub const ERROR_ARBITRATION_UNHANDLED : i32 = 723;
pub const ERROR_CARDBUS_NOT_SUPPORTED : i32 = 724;
pub const ERROR_MP_PROCESSOR_MISMATCH : i32 = 725;
pub const ERROR_HIBERNATED : i32 = 726;
pub const ERROR_RESUME_HIBERNATION : i32 = 727;
pub const ERROR_FIRMWARE_UPDATED : i32 = 728;
pub const ERROR_DRIVERS_LEAKING_LOCKED_PAGES : i32 = 729;
pub const ERROR_WAKE_SYSTEM : i32 = 730;
pub const ERROR_WAIT_1 : i32 = 731;
pub const ERROR_WAIT_2 : i32 = 732;
pub const ERROR_WAIT_3 : i32 = 733;
pub const ERROR_WAIT_63 : i32 = 734;
pub const ERROR_ABANDONED_WAIT_0 : i32 = 735;
pub const ERROR_ABANDONED_WAIT_63 : i32 = 736;
pub const ERROR_USER_APC : i32 = 737;
pub const ERROR_KERNEL_APC : i32 = 738;
pub const ERROR_ALERTED : i32 = 739;
pub const ERROR_ELEVATION_REQUIRED : i32 = 740;
pub const ERROR_REPARSE : i32 = 741;
pub const ERROR_OPLOCK_BREAK_IN_PROGRESS : i32 = 742;
pub const ERROR_VOLUME_MOUNTED : i32 = 743;
pub const ERROR_RXACT_COMMITTED : i32 = 744;
pub const ERROR_NOTIFY_CLEANUP : i32 = 745;
pub const ERROR_PRIMARY_TRANSPORT_CONNECT_FAILED : i32 = 746;
pub const ERROR_PAGE_FAULT_TRANSITION : i32 = 747;
pub const ERROR_PAGE_FAULT_DEMAND_ZERO : i32 = 748;
pub const ERROR_PAGE_FAULT_COPY_ON_WRITE : i32 = 749;
pub const ERROR_PAGE_FAULT_GUARD_PAGE : i32 = 750;
pub const ERROR_PAGE_FAULT_PAGING_FILE : i32 = 751;
pub const ERROR_CACHE_PAGE_LOCKED : i32 = 752;
pub const ERROR_CRASH_DUMP : i32 = 753;
pub const ERROR_BUFFER_ALL_ZEROS : i32 = 754;
pub const ERROR_REPARSE_OBJECT : i32 = 755;
pub const ERROR_RESOURCE_REQUIREMENTS_CHANGED : i32 = 756;
pub const ERROR_TRANSLATION_COMPLETE : i32 = 757;
pub const ERROR_NOTHING_TO_TERMINATE : i32 = 758;
pub const ERROR_PROCESS_NOT_IN_JOB : i32 = 759;
pub const ERROR_PROCESS_IN_JOB : i32 = 760;
pub const ERROR_VOLSNAP_HIBERNATE_READY : i32 = 761;
pub const ERROR_FSFILTER_OP_COMPLETED_SUCCESSFULLY : i32 = 762;
pub const ERROR_INTERRUPT_VECTOR_ALREADY_CONNECTED : i32 = 763;
pub const ERROR_INTERRUPT_STILL_CONNECTED : i32 = 764;
pub const ERROR_WAIT_FOR_OPLOCK : i32 = 765;
pub const ERROR_DBG_EXCEPTION_HANDLED : i32 = 766;
pub const ERROR_DBG_CONTINUE : i32 = 767;
pub const ERROR_CALLBACK_POP_STACK : i32 = 768;
pub const ERROR_COMPRESSION_DISABLED : i32 = 769;
pub const ERROR_CANTFETCHBACKWARDS : i32 = 770;
pub const ERROR_CANTSCROLLBACKWARDS : i32 = 771;
pub const ERROR_ROWSNOTRELEASED : i32 = 772;
pub const ERROR_BAD_ACCESSOR_FLAGS : i32 = 773;
pub const ERROR_ERRORS_ENCOUNTERED : i32 = 774;
pub const ERROR_NOT_CAPABLE : i32 = 775;
pub const ERROR_REQUEST_OUT_OF_SEQUENCE : i32 = 776;
pub const ERROR_VERSION_PARSE_ERROR : i32 = 777;
pub const ERROR_BADSTARTPOSITION : i32 = 778;
pub const ERROR_MEMORY_HARDWARE : i32 = 779;
pub const ERROR_DISK_REPAIR_DISABLED : i32 = 780;
pub const ERROR_INSUFFICIENT_RESOURCE_FOR_SPECIFIED_SHARED_SECTION_SIZE : i32 = 781;
pub const ERROR_SYSTEM_POWERSTATE_TRANSITION : i32 = 782;
pub const ERROR_SYSTEM_POWERSTATE_COMPLEX_TRANSITION : i32 = 783;
pub const ERROR_MCA_EXCEPTION : i32 = 784;
pub const ERROR_ACCESS_AUDIT_BY_POLICY : i32 = 785;
pub const ERROR_ACCESS_DISABLED_NO_SAFER_UI_BY_POLICY : i32 = 786;
pub const ERROR_ABANDON_HIBERFILE : i32 = 787;
pub const ERROR_LOST_WRITEBEHIND_DATA_NETWORK_DISCONNECTED : i32 = 788;
pub const ERROR_LOST_WRITEBEHIND_DATA_NETWORK_SERVER_ERROR : i32 = 789;
pub const ERROR_LOST_WRITEBEHIND_DATA_LOCAL_DISK_ERROR : i32 = 790;
pub const ERROR_BAD_MCFG_TABLE : i32 = 791;
pub const ERROR_DISK_REPAIR_REDIRECTED : i32 = 792;
pub const ERROR_DISK_REPAIR_UNSUCCESSFUL : i32 = 793;
pub const ERROR_CORRUPT_LOG_OVERFULL : i32 = 794;
pub const ERROR_CORRUPT_LOG_CORRUPTED : i32 = 795;
pub const ERROR_CORRUPT_LOG_UNAVAILABLE : i32 = 796;
pub const ERROR_CORRUPT_LOG_DELETED_FULL : i32 = 797;
pub const ERROR_CORRUPT_LOG_CLEARED : i32 = 798;
pub const ERROR_ORPHAN_NAME_EXHAUSTED : i32 = 799;
pub const ERROR_OPLOCK_SWITCHED_TO_NEW_HANDLE : i32 = 800;
pub const ERROR_CANNOT_GRANT_REQUESTED_OPLOCK : i32 = 801;
pub const ERROR_CANNOT_BREAK_OPLOCK : i32 = 802;
pub const ERROR_OPLOCK_HANDLE_CLOSED : i32 = 803;
pub const ERROR_NO_ACE_CONDITION : i32 = 804;
pub const ERROR_INVALID_ACE_CONDITION : i32 = 805;
pub const ERROR_FILE_HANDLE_REVOKED : i32 = 806;
pub const ERROR_IMAGE_AT_DIFFERENT_BASE : i32 = 807;
pub const ERROR_ENCRYPTED_IO_NOT_POSSIBLE : i32 = 808;
pub const ERROR_FILE_METADATA_OPTIMIZATION_IN_PROGRESS : i32 = 809;
pub const ERROR_QUOTA_ACTIVITY : i32 = 810;
pub const ERROR_HANDLE_REVOKED : i32 = 811;
pub const ERROR_CALLBACK_INVOKE_INLINE : i32 = 812;
pub const ERROR_CPU_SET_INVALID : i32 = 813;
pub const ERROR_ENCLAVE_NOT_TERMINATED : i32 = 814;
pub const ERROR_ENCLAVE_VIOLATION : i32 = 815;
pub const ERROR_EA_ACCESS_DENIED : i32 = 994;
pub const ERROR_OPERATION_ABORTED : i32 = 995;
pub const ERROR_IO_INCOMPLETE : i32 = 996;
pub const ERROR_IO_PENDING : i32 = 997;
pub const ERROR_NOACCESS : i32 = 998;
pub const ERROR_SWAPERROR : i32 = 999;
pub const ERROR_STACK_OVERFLOW : i32 = 1001;
pub const ERROR_INVALID_MESSAGE : i32 = 1002;
pub const ERROR_CAN_NOT_COMPLETE : i32 = 1003;
pub const ERROR_INVALID_FLAGS : i32 = 1004;
pub const ERROR_UNRECOGNIZED_VOLUME : i32 = 1005;
pub const ERROR_FILE_INVALID : i32 = 1006;
pub const ERROR_FULLSCREEN_MODE : i32 = 1007;
pub const ERROR_NO_TOKEN : i32 = 1008;
pub const ERROR_BADDB : i32 = 1009;
pub const ERROR_BADKEY : i32 = 1010;
pub const ERROR_CANTOPEN : i32 = 1011;
pub const ERROR_CANTREAD : i32 = 1012;
pub const ERROR_CANTWRITE : i32 = 1013;
pub const ERROR_REGISTRY_RECOVERED : i32 = 1014;
pub const ERROR_REGISTRY_CORRUPT : i32 = 1015;
pub const ERROR_REGISTRY_IO_FAILED : i32 = 1016;
pub const ERROR_NOT_REGISTRY_FILE : i32 = 1017;
pub const ERROR_KEY_DELETED : i32 = 1018;
pub const ERROR_NO_LOG_SPACE : i32 = 1019;
pub const ERROR_KEY_HAS_CHILDREN : i32 = 1020;
pub const ERROR_CHILD_MUST_BE_VOLATILE : i32 = 1021;
pub const ERROR_NOTIFY_ENUM_DIR : i32 = 1022;
pub const ERROR_DEPENDENT_SERVICES_RUNNING : i32 = 1051;
pub const ERROR_INVALID_SERVICE_CONTROL : i32 = 1052;
pub const ERROR_SERVICE_REQUEST_TIMEOUT : i32 = 1053;
pub const ERROR_SERVICE_NO_THREAD : i32 = 1054;
pub const ERROR_SERVICE_DATABASE_LOCKED : i32 = 1055;
pub const ERROR_SERVICE_ALREADY_RUNNING : i32 = 1056;
pub const ERROR_INVALID_SERVICE_ACCOUNT : i32 = 1057;
pub const ERROR_SERVICE_DISABLED : i32 = 1058;
pub const ERROR_CIRCULAR_DEPENDENCY : i32 = 1059;
pub const ERROR_SERVICE_DOES_NOT_EXIST : i32 = 1060;
pub const ERROR_SERVICE_CANNOT_ACCEPT_CTRL : i32 = 1061;
pub const ERROR_SERVICE_NOT_ACTIVE : i32 = 1062;
pub const ERROR_FAILED_SERVICE_CONTROLLER_CONNECT : i32 = 1063;
pub const ERROR_EXCEPTION_IN_SERVICE : i32 = 1064;
pub const ERROR_DATABASE_DOES_NOT_EXIST : i32 = 1065;
pub const ERROR_SERVICE_SPECIFIC_ERROR : i32 = 1066;
pub const ERROR_PROCESS_ABORTED : i32 = 1067;
pub const ERROR_SERVICE_DEPENDENCY_FAIL : i32 = 1068;
pub const ERROR_SERVICE_LOGON_FAILED : i32 = 1069;
pub const ERROR_SERVICE_START_HANG : i32 = 1070;
pub const ERROR_INVALID_SERVICE_LOCK : i32 = 1071;
pub const ERROR_SERVICE_MARKED_FOR_DELETE : i32 = 1072;
pub const ERROR_SERVICE_EXISTS : i32 = 1073;
pub const ERROR_ALREADY_RUNNING_LKG : i32 = 1074;
pub const ERROR_SERVICE_DEPENDENCY_DELETED : i32 = 1075;
pub const ERROR_BOOT_ALREADY_ACCEPTED : i32 = 1076;
pub const ERROR_SERVICE_NEVER_STARTED : i32 = 1077;
pub const ERROR_DUPLICATE_SERVICE_NAME : i32 = 1078;
pub const ERROR_DIFFERENT_SERVICE_ACCOUNT : i32 = 1079;
pub const ERROR_CANNOT_DETECT_DRIVER_FAILURE : i32 = 1080;
pub const ERROR_CANNOT_DETECT_PROCESS_ABORT : i32 = 1081;
pub const ERROR_NO_RECOVERY_PROGRAM : i32 = 1082;
pub const ERROR_SERVICE_NOT_IN_EXE : i32 = 1083;
pub const ERROR_NOT_SAFEBOOT_SERVICE : i32 = 1084;
pub const ERROR_END_OF_MEDIA : i32 = 1100;
pub const ERROR_FILEMARK_DETECTED : i32 = 1101;
pub const ERROR_BEGINNING_OF_MEDIA : i32 = 1102;
pub const ERROR_SETMARK_DETECTED : i32 = 1103;
pub const ERROR_NO_DATA_DETECTED : i32 = 1104;
pub const ERROR_PARTITION_FAILURE : i32 = 1105;
pub const ERROR_INVALID_BLOCK_LENGTH : i32 = 1106;
pub const ERROR_DEVICE_NOT_PARTITIONED : i32 = 1107;
pub const ERROR_UNABLE_TO_LOCK_MEDIA : i32 = 1108;
pub const ERROR_UNABLE_TO_UNLOAD_MEDIA : i32 = 1109;
pub const ERROR_MEDIA_CHANGED : i32 = 1110;
pub const ERROR_BUS_RESET : i32 = 1111;
pub const ERROR_NO_MEDIA_IN_DRIVE : i32 = 1112;
pub const ERROR_NO_UNICODE_TRANSLATION : i32 = 1113;
pub const ERROR_DLL_INIT_FAILED : i32 = 1114;
pub const ERROR_SHUTDOWN_IN_PROGRESS : i32 = 1115;
pub const ERROR_NO_SHUTDOWN_IN_PROGRESS : i32 = 1116;
pub const ERROR_IO_DEVICE : i32 = 1117;
pub const ERROR_SERIAL_NO_DEVICE : i32 = 1118;
pub const ERROR_IRQ_BUSY : i32 = 1119;
pub const ERROR_MORE_WRITES : i32 = 1120;
pub const ERROR_COUNTER_TIMEOUT : i32 = 1121;
pub const ERROR_FLOPPY_ID_MARK_NOT_FOUND : i32 = 1122;
pub const ERROR_FLOPPY_WRONG_CYLINDER : i32 = 1123;
pub const ERROR_FLOPPY_UNKNOWN_ERROR : i32 = 1124;
pub const ERROR_FLOPPY_BAD_REGISTERS : i32 = 1125;
pub const ERROR_DISK_RECALIBRATE_FAILED : i32 = 1126;
pub const ERROR_DISK_OPERATION_FAILED : i32 = 1127;
pub const ERROR_DISK_RESET_FAILED : i32 = 1128;
pub const ERROR_EOM_OVERFLOW : i32 = 1129;
pub const ERROR_NOT_ENOUGH_SERVER_MEMORY : i32 = 1130;
pub const ERROR_POSSIBLE_DEADLOCK : i32 = 1131;
pub const ERROR_MAPPED_ALIGNMENT : i32 = 1132;
pub const ERROR_SET_POWER_STATE_VETOED : i32 = 1140;
pub const ERROR_SET_POWER_STATE_FAILED : i32 = 1141;
pub const ERROR_TOO_MANY_LINKS : i32 = 1142;
pub const ERROR_OLD_WIN_VERSION : i32 = 1150;
pub const ERROR_APP_WRONG_OS : i32 = 1151;
pub const ERROR_SINGLE_INSTANCE_APP : i32 = 1152;
pub const ERROR_RMODE_APP : i32 = 1153;
pub const ERROR_INVALID_DLL : i32 = 1154;
pub const ERROR_NO_ASSOCIATION : i32 = 1155;
pub const ERROR_DDE_FAIL : i32 = 1156;
pub const ERROR_DLL_NOT_FOUND : i32 = 1157;
pub const ERROR_NO_MORE_USER_HANDLES : i32 = 1158;
pub const ERROR_MESSAGE_SYNC_ONLY : i32 = 1159;
pub const ERROR_SOURCE_ELEMENT_EMPTY : i32 = 1160;
pub const ERROR_DESTINATION_ELEMENT_FULL : i32 = 1161;
pub const ERROR_ILLEGAL_ELEMENT_ADDRESS : i32 = 1162;
pub const ERROR_MAGAZINE_NOT_PRESENT : i32 = 1163;
pub const ERROR_DEVICE_REINITIALIZATION_NEEDED : i32 = 1164;
pub const ERROR_DEVICE_REQUIRES_CLEANING : i32 = 1165;
pub const ERROR_DEVICE_DOOR_OPEN : i32 = 1166;
pub const ERROR_DEVICE_NOT_CONNECTED : i32 = 1167;
pub const ERROR_NOT_FOUND : i32 = 1168;
pub const ERROR_NO_MATCH : i32 = 1169;
pub const ERROR_SET_NOT_FOUND : i32 = 1170;
pub const ERROR_POINT_NOT_FOUND : i32 = 1171;
pub const ERROR_NO_TRACKING_SERVICE : i32 = 1172;
pub const ERROR_NO_VOLUME_ID : i32 = 1173;
pub const ERROR_UNABLE_TO_REMOVE_REPLACED : i32 = 1175;
pub const ERROR_UNABLE_TO_MOVE_REPLACEMENT : i32 = 1176;
pub const ERROR_UNABLE_TO_MOVE_REPLACEMENT_2 : i32 = 1177;
pub const ERROR_JOURNAL_DELETE_IN_PROGRESS : i32 = 1178;
pub const ERROR_JOURNAL_NOT_ACTIVE : i32 = 1179;
pub const ERROR_POTENTIAL_FILE_FOUND : i32 = 1180;
pub const ERROR_JOURNAL_ENTRY_DELETED : i32 = 1181;
pub const ERROR_SHUTDOWN_IS_SCHEDULED : i32 = 1190;
pub const ERROR_SHUTDOWN_USERS_LOGGED_ON : i32 = 1191;
pub const ERROR_BAD_DEVICE : i32 = 1200;
pub const ERROR_CONNECTION_UNAVAIL : i32 = 1201;
pub const ERROR_DEVICE_ALREADY_REMEMBERED : i32 = 1202;
pub const ERROR_NO_NET_OR_BAD_PATH : i32 = 1203;
pub const ERROR_BAD_PROVIDER : i32 = 1204;
pub const ERROR_CANNOT_OPEN_PROFILE : i32 = 1205;
pub const ERROR_BAD_PROFILE : i32 = 1206;
pub const ERROR_NOT_CONTAINER : i32 = 1207;
pub const ERROR_EXTENDED_ERROR : i32 = 1208;
pub const ERROR_INVALID_GROUPNAME : i32 = 1209;
pub const ERROR_INVALID_COMPUTERNAME : i32 = 1210;
pub const ERROR_INVALID_EVENTNAME : i32 = 1211;
pub const ERROR_INVALID_DOMAINNAME : i32 = 1212;
pub const ERROR_INVALID_SERVICENAME : i32 = 1213;
pub const ERROR_INVALID_NETNAME : i32 = 1214;
pub const ERROR_INVALID_SHARENAME : i32 = 1215;
pub const ERROR_INVALID_PASSWORDNAME : i32 = 1216;
pub const ERROR_INVALID_MESSAGENAME : i32 = 1217;
pub const ERROR_INVALID_MESSAGEDEST : i32 = 1218;
pub const ERROR_SESSION_CREDENTIAL_CONFLICT : i32 = 1219;
pub const ERROR_REMOTE_SESSION_LIMIT_EXCEEDED : i32 = 1220;
pub const ERROR_DUP_DOMAINNAME : i32 = 1221;
pub const ERROR_NO_NETWORK : i32 = 1222;
pub const ERROR_CANCELLED : i32 = 1223;
pub const ERROR_USER_MAPPED_FILE : i32 = 1224;
pub const ERROR_CONNECTION_REFUSED : i32 = 1225;
pub const ERROR_GRACEFUL_DISCONNECT : i32 = 1226;
pub const ERROR_ADDRESS_ALREADY_ASSOCIATED : i32 = 1227;
pub const ERROR_ADDRESS_NOT_ASSOCIATED : i32 = 1228;
pub const ERROR_CONNECTION_INVALID : i32 = 1229;
pub const ERROR_CONNECTION_ACTIVE : i32 = 1230;
pub const ERROR_NETWORK_UNREACHABLE : i32 = 1231;
pub const ERROR_HOST_UNREACHABLE : i32 = 1232;
pub const ERROR_PROTOCOL_UNREACHABLE : i32 = 1233;
pub const ERROR_PORT_UNREACHABLE : i32 = 1234;
pub const ERROR_REQUEST_ABORTED : i32 = 1235;
pub const ERROR_CONNECTION_ABORTED : i32 = 1236;
pub const ERROR_RETRY : i32 = 1237;
pub const ERROR_CONNECTION_COUNT_LIMIT : i32 = 1238;
pub const ERROR_LOGIN_TIME_RESTRICTION : i32 = 1239;
pub const ERROR_LOGIN_WKSTA_RESTRICTION : i32 = 1240;
pub const ERROR_INCORRECT_ADDRESS : i32 = 1241;
pub const ERROR_ALREADY_REGISTERED : i32 = 1242;
pub const ERROR_SERVICE_NOT_FOUND : i32 = 1243;
pub const ERROR_NOT_AUTHENTICATED : i32 = 1244;
pub const ERROR_NOT_LOGGED_ON : i32 = 1245;
pub const ERROR_CONTINUE : i32 = 1246;
pub const ERROR_ALREADY_INITIALIZED : i32 = 1247;
pub const ERROR_NO_MORE_DEVICES : i32 = 1248;
pub const ERROR_NO_SUCH_SITE : i32 = 1249;
pub const ERROR_DOMAIN_CONTROLLER_EXISTS : i32 = 1250;
pub const ERROR_ONLY_IF_CONNECTED : i32 = 1251;
pub const ERROR_OVERRIDE_NOCHANGES : i32 = 1252;
pub const ERROR_BAD_USER_PROFILE : i32 = 1253;
pub const ERROR_NOT_SUPPORTED_ON_SBS : i32 = 1254;
pub const ERROR_SERVER_SHUTDOWN_IN_PROGRESS : i32 = 1255;
pub const ERROR_HOST_DOWN : i32 = 1256;
pub const ERROR_NON_ACCOUNT_SID : i32 = 1257;
pub const ERROR_NON_DOMAIN_SID : i32 = 1258;
pub const ERROR_APPHELP_BLOCK : i32 = 1259;
pub const ERROR_ACCESS_DISABLED_BY_POLICY : i32 = 1260;
pub const ERROR_REG_NAT_CONSUMPTION : i32 = 1261;
pub const ERROR_CSCSHARE_OFFLINE : i32 = 1262;
pub const ERROR_PKINIT_FAILURE : i32 = 1263;
pub const ERROR_SMARTCARD_SUBSYSTEM_FAILURE : i32 = 1264;
pub const ERROR_DOWNGRADE_DETECTED : i32 = 1265;
pub const ERROR_MACHINE_LOCKED : i32 = 1271;
pub const ERROR_SMB_GUEST_LOGON_BLOCKED : i32 = 1272;
pub const ERROR_CALLBACK_SUPPLIED_INVALID_DATA : i32 = 1273;
pub const ERROR_SYNC_FOREGROUND_REFRESH_REQUIRED : i32 = 1274;
pub const ERROR_DRIVER_BLOCKED : i32 = 1275;
pub const ERROR_INVALID_IMPORT_OF_NON_DLL : i32 = 1276;
pub const ERROR_ACCESS_DISABLED_WEBBLADE : i32 = 1277;
pub const ERROR_ACCESS_DISABLED_WEBBLADE_TAMPER : i32 = 1278;
pub const ERROR_RECOVERY_FAILURE : i32 = 1279;
pub const ERROR_ALREADY_FIBER : i32 = 1280;
pub const ERROR_ALREADY_THREAD : i32 = 1281;
pub const ERROR_STACK_BUFFER_OVERRUN : i32 = 1282;
pub const ERROR_PARAMETER_QUOTA_EXCEEDED : i32 = 1283;
pub const ERROR_DEBUGGER_INACTIVE : i32 = 1284;
pub const ERROR_DELAY_LOAD_FAILED : i32 = 1285;
pub const ERROR_VDM_DISALLOWED : i32 = 1286;
pub const ERROR_UNIDENTIFIED_ERROR : i32 = 1287;
pub const ERROR_INVALID_CRUNTIME_PARAMETER : i32 = 1288;
pub const ERROR_BEYOND_VDL : i32 = 1289;
pub const ERROR_INCOMPATIBLE_SERVICE_SID_TYPE : i32 = 1290;
pub const ERROR_DRIVER_PROCESS_TERMINATED : i32 = 1291;
pub const ERROR_IMPLEMENTATION_LIMIT : i32 = 1292;
pub const ERROR_PROCESS_IS_PROTECTED : i32 = 1293;
pub const ERROR_SERVICE_NOTIFY_CLIENT_LAGGING : i32 = 1294;
pub const ERROR_DISK_QUOTA_EXCEEDED : i32 = 1295;
pub const ERROR_CONTENT_BLOCKED : i32 = 1296;
pub const ERROR_INCOMPATIBLE_SERVICE_PRIVILEGE : i32 = 1297;
pub const ERROR_APP_HANG : i32 = 1298;
pub const ERROR_INVALID_LABEL : i32 = 1299;
pub const ERROR_NOT_ALL_ASSIGNED : i32 = 1300;
pub const ERROR_SOME_NOT_MAPPED : i32 = 1301;
pub const ERROR_NO_QUOTAS_FOR_ACCOUNT : i32 = 1302;
pub const ERROR_LOCAL_USER_SESSION_KEY : i32 = 1303;
pub const ERROR_NULL_LM_PASSWORD : i32 = 1304;
pub const ERROR_UNKNOWN_REVISION : i32 = 1305;
pub const ERROR_REVISION_MISMATCH : i32 = 1306;
pub const ERROR_INVALID_OWNER : i32 = 1307;
pub const ERROR_INVALID_PRIMARY_GROUP : i32 = 1308;
pub const ERROR_NO_IMPERSONATION_TOKEN : i32 = 1309;
pub const ERROR_CANT_DISABLE_MANDATORY : i32 = 1310;
pub const ERROR_NO_LOGON_SERVERS : i32 = 1311;
pub const ERROR_NO_SUCH_LOGON_SESSION : i32 = 1312;
pub const ERROR_NO_SUCH_PRIVILEGE : i32 = 1313;
pub const ERROR_PRIVILEGE_NOT_HELD : i32 = 1314;
pub const ERROR_INVALID_ACCOUNT_NAME : i32 = 1315;
pub const ERROR_USER_EXISTS : i32 = 1316;
pub const ERROR_NO_SUCH_USER : i32 = 1317;
pub const ERROR_GROUP_EXISTS : i32 = 1318;
pub const ERROR_NO_SUCH_GROUP : i32 = 1319;
pub const ERROR_MEMBER_IN_GROUP : i32 = 1320;
pub const ERROR_MEMBER_NOT_IN_GROUP : i32 = 1321;
pub const ERROR_LAST_ADMIN : i32 = 1322;
pub const ERROR_WRONG_PASSWORD : i32 = 1323;
pub const ERROR_ILL_FORMED_PASSWORD : i32 = 1324;
pub const ERROR_PASSWORD_RESTRICTION : i32 = 1325;
pub const ERROR_LOGON_FAILURE : i32 = 1326;
pub const ERROR_ACCOUNT_RESTRICTION : i32 = 1327;
pub const ERROR_INVALID_LOGON_HOURS : i32 = 1328;
pub const ERROR_INVALID_WORKSTATION : i32 = 1329;
pub const ERROR_PASSWORD_EXPIRED : i32 = 1330;
pub const ERROR_ACCOUNT_DISABLED : i32 = 1331;
pub const ERROR_NONE_MAPPED : i32 = 1332;
pub const ERROR_TOO_MANY_LUIDS_REQUESTED : i32 = 1333;
pub const ERROR_LUIDS_EXHAUSTED : i32 = 1334;
pub const ERROR_INVALID_SUB_AUTHORITY : i32 = 1335;
pub const ERROR_INVALID_ACL : i32 = 1336;
pub const ERROR_INVALID_SID : i32 = 1337;
pub const ERROR_INVALID_SECURITY_DESCR : i32 = 1338;
pub const ERROR_BAD_INHERITANCE_ACL : i32 = 1340;
pub const ERROR_SERVER_DISABLED : i32 = 1341;
pub const ERROR_SERVER_NOT_DISABLED : i32 = 1342;
pub const ERROR_INVALID_ID_AUTHORITY : i32 = 1343;
pub const ERROR_ALLOTTED_SPACE_EXCEEDED : i32 = 1344;
pub const ERROR_INVALID_GROUP_ATTRIBUTES : i32 = 1345;
pub const ERROR_BAD_IMPERSONATION_LEVEL : i32 = 1346;
pub const ERROR_CANT_OPEN_ANONYMOUS : i32 = 1347;
pub const ERROR_BAD_VALIDATION_CLASS : i32 = 1348;
pub const ERROR_BAD_TOKEN_TYPE : i32 = 1349;
pub const ERROR_NO_SECURITY_ON_OBJECT : i32 = 1350;
pub const ERROR_CANT_ACCESS_DOMAIN_INFO : i32 = 1351;
pub const ERROR_INVALID_SERVER_STATE : i32 = 1352;
pub const ERROR_INVALID_DOMAIN_STATE : i32 = 1353;
pub const ERROR_INVALID_DOMAIN_ROLE : i32 = 1354;
pub const ERROR_NO_SUCH_DOMAIN : i32 = 1355;
pub const ERROR_DOMAIN_EXISTS : i32 = 1356;
pub const ERROR_DOMAIN_LIMIT_EXCEEDED : i32 = 1357;
pub const ERROR_INTERNAL_DB_CORRUPTION : i32 = 1358;
pub const ERROR_INTERNAL_ERROR : i32 = 1359;
pub const ERROR_GENERIC_NOT_MAPPED : i32 = 1360;
pub const ERROR_BAD_DESCRIPTOR_FORMAT : i32 = 1361;
pub const ERROR_NOT_LOGON_PROCESS : i32 = 1362;
pub const ERROR_LOGON_SESSION_EXISTS : i32 = 1363;
pub const ERROR_NO_SUCH_PACKAGE : i32 = 1364;
pub const ERROR_BAD_LOGON_SESSION_STATE : i32 = 1365;
pub const ERROR_LOGON_SESSION_COLLISION : i32 = 1366;
pub const ERROR_INVALID_LOGON_TYPE : i32 = 1367;
pub const ERROR_CANNOT_IMPERSONATE : i32 = 1368;
pub const ERROR_RXACT_INVALID_STATE : i32 = 1369;
pub const ERROR_RXACT_COMMIT_FAILURE : i32 = 1370;
pub const ERROR_SPECIAL_ACCOUNT : i32 = 1371;
pub const ERROR_SPECIAL_GROUP : i32 = 1372;
pub const ERROR_SPECIAL_USER : i32 = 1373;
pub const ERROR_MEMBERS_PRIMARY_GROUP : i32 = 1374;
pub const ERROR_TOKEN_ALREADY_IN_USE : i32 = 1375;
pub const ERROR_NO_SUCH_ALIAS : i32 = 1376;
pub const ERROR_MEMBER_NOT_IN_ALIAS : i32 = 1377;
pub const ERROR_MEMBER_IN_ALIAS : i32 = 1378;
pub const ERROR_ALIAS_EXISTS : i32 = 1379;
pub const ERROR_LOGON_NOT_GRANTED : i32 = 1380;
pub const ERROR_TOO_MANY_SECRETS : i32 = 1381;
pub const ERROR_SECRET_TOO_LONG : i32 = 1382;
pub const ERROR_INTERNAL_DB_ERROR : i32 = 1383;
pub const ERROR_TOO_MANY_CONTEXT_IDS : i32 = 1384;
pub const ERROR_LOGON_TYPE_NOT_GRANTED : i32 = 1385;
pub const ERROR_NT_CROSS_ENCRYPTION_REQUIRED : i32 = 1386;
pub const ERROR_NO_SUCH_MEMBER : i32 = 1387;
pub const ERROR_INVALID_MEMBER : i32 = 1388;
pub const ERROR_TOO_MANY_SIDS : i32 = 1389;
pub const ERROR_LM_CROSS_ENCRYPTION_REQUIRED : i32 = 1390;
pub const ERROR_NO_INHERITANCE : i32 = 1391;
pub const ERROR_FILE_CORRUPT : i32 = 1392;
pub const ERROR_DISK_CORRUPT : i32 = 1393;
pub const ERROR_NO_USER_SESSION_KEY : i32 = 1394;
pub const ERROR_LICENSE_QUOTA_EXCEEDED : i32 = 1395;
pub const ERROR_WRONG_TARGET_NAME : i32 = 1396;
pub const ERROR_MUTUAL_AUTH_FAILED : i32 = 1397;
pub const ERROR_TIME_SKEW : i32 = 1398;
pub const ERROR_CURRENT_DOMAIN_NOT_ALLOWED : i32 = 1399;
pub const ERROR_INVALID_WINDOW_HANDLE : i32 = 1400;
pub const ERROR_INVALID_MENU_HANDLE : i32 = 1401;
pub const ERROR_INVALID_CURSOR_HANDLE : i32 = 1402;
pub const ERROR_INVALID_ACCEL_HANDLE : i32 = 1403;
pub const ERROR_INVALID_HOOK_HANDLE : i32 = 1404;
pub const ERROR_INVALID_DWP_HANDLE : i32 = 1405;
pub const ERROR_TLW_WITH_WSCHILD : i32 = 1406;
pub const ERROR_CANNOT_FIND_WND_CLASS : i32 = 1407;
pub const ERROR_WINDOW_OF_OTHER_THREAD : i32 = 1408;
pub const ERROR_HOTKEY_ALREADY_REGISTERED : i32 = 1409;
pub const ERROR_CLASS_ALREADY_EXISTS : i32 = 1410;
pub const ERROR_CLASS_DOES_NOT_EXIST : i32 = 1411;
pub const ERROR_CLASS_HAS_WINDOWS : i32 = 1412;
pub const ERROR_INVALID_INDEX : i32 = 1413;
pub const ERROR_INVALID_ICON_HANDLE : i32 = 1414;
pub const ERROR_PRIVATE_DIALOG_INDEX : i32 = 1415;
pub const ERROR_LISTBOX_ID_NOT_FOUND : i32 = 1416;
pub const ERROR_NO_WILDCARD_CHARACTERS : i32 = 1417;
pub const ERROR_CLIPBOARD_NOT_OPEN : i32 = 1418;
pub const ERROR_HOTKEY_NOT_REGISTERED : i32 = 1419;
pub const ERROR_WINDOW_NOT_DIALOG : i32 = 1420;
pub const ERROR_CONTROL_ID_NOT_FOUND : i32 = 1421;
pub const ERROR_INVALID_COMBOBOX_MESSAGE : i32 = 1422;
pub const ERROR_WINDOW_NOT_COMBOBOX : i32 = 1423;
pub const ERROR_INVALID_EDIT_HEIGHT : i32 = 1424;
pub const ERROR_DC_NOT_FOUND : i32 = 1425;
pub const ERROR_INVALID_HOOK_FILTER : i32 = 1426;
pub const ERROR_INVALID_FILTER_PROC : i32 = 1427;
pub const ERROR_HOOK_NEEDS_HMOD : i32 = 1428;
pub const ERROR_GLOBAL_ONLY_HOOK : i32 = 1429;
pub const ERROR_JOURNAL_HOOK_SET : i32 = 1430;
pub const ERROR_HOOK_NOT_INSTALLED : i32 = 1431;
pub const ERROR_INVALID_LB_MESSAGE : i32 = 1432;
pub const ERROR_SETCOUNT_ON_BAD_LB : i32 = 1433;
pub const ERROR_LB_WITHOUT_TABSTOPS : i32 = 1434;
pub const ERROR_DESTROY_OBJECT_OF_OTHER_THREAD : i32 = 1435;
pub const ERROR_CHILD_WINDOW_MENU : i32 = 1436;
pub const ERROR_NO_SYSTEM_MENU : i32 = 1437;
pub const ERROR_INVALID_MSGBOX_STYLE : i32 = 1438;
pub const ERROR_INVALID_SPI_VALUE : i32 = 1439;
pub const ERROR_SCREEN_ALREADY_LOCKED : i32 = 1440;
pub const ERROR_HWNDS_HAVE_DIFF_PARENT : i32 = 1441;
pub const ERROR_NOT_CHILD_WINDOW : i32 = 1442;
pub const ERROR_INVALID_GW_COMMAND : i32 = 1443;
pub const ERROR_INVALID_THREAD_ID : i32 = 1444;
pub const ERROR_NON_MDICHILD_WINDOW : i32 = 1445;
pub const ERROR_POPUP_ALREADY_ACTIVE : i32 = 1446;
pub const ERROR_NO_SCROLLBARS : i32 = 1447;
pub const ERROR_INVALID_SCROLLBAR_RANGE : i32 = 1448;
pub const ERROR_INVALID_SHOWWIN_COMMAND : i32 = 1449;
pub const ERROR_NO_SYSTEM_RESOURCES : i32 = 1450;
pub const ERROR_NONPAGED_SYSTEM_RESOURCES : i32 = 1451;
pub const ERROR_PAGED_SYSTEM_RESOURCES : i32 = 1452;
pub const ERROR_WORKING_SET_QUOTA : i32 = 1453;
pub const ERROR_PAGEFILE_QUOTA : i32 = 1454;
pub const ERROR_COMMITMENT_LIMIT : i32 = 1455;
pub const ERROR_MENU_ITEM_NOT_FOUND : i32 = 1456;
pub const ERROR_INVALID_KEYBOARD_HANDLE : i32 = 1457;
pub const ERROR_HOOK_TYPE_NOT_ALLOWED : i32 = 1458;
pub const ERROR_REQUIRES_INTERACTIVE_WINDOWSTATION : i32 = 1459;
pub const ERROR_TIMEOUT : i32 = 1460;
pub const ERROR_INVALID_MONITOR_HANDLE : i32 = 1461;
pub const ERROR_INCORRECT_SIZE : i32 = 1462;
pub const ERROR_SYMLINK_CLASS_DISABLED : i32 = 1463;
pub const ERROR_SYMLINK_NOT_SUPPORTED : i32 = 1464;
pub const ERROR_XML_PARSE_ERROR : i32 = 1465;
pub const ERROR_XMLDSIG_ERROR : i32 = 1466;
pub const ERROR_RESTART_APPLICATION : i32 = 1467;
pub const ERROR_WRONG_COMPARTMENT : i32 = 1468;
pub const ERROR_AUTHIP_FAILURE : i32 = 1469;
pub const ERROR_NO_NVRAM_RESOURCES : i32 = 1470;
pub const ERROR_NOT_GUI_PROCESS : i32 = 1471;
pub const ERROR_EVENTLOG_FILE_CORRUPT : i32 = 1500;
pub const ERROR_EVENTLOG_CANT_START : i32 = 1501;
pub const ERROR_LOG_FILE_FULL : i32 = 1502;
pub const ERROR_EVENTLOG_FILE_CHANGED : i32 = 1503;
pub const ERROR_CONTAINER_ASSIGNED : i32 = 1504;
pub const ERROR_JOB_NO_CONTAINER : i32 = 1505;
pub const ERROR_INVALID_TASK_NAME : i32 = 1550;
pub const ERROR_INVALID_TASK_INDEX : i32 = 1551;
pub const ERROR_THREAD_ALREADY_IN_TASK : i32 = 1552;
pub const ERROR_INSTALL_SERVICE_FAILURE : i32 = 1601;
pub const ERROR_INSTALL_USEREXIT : i32 = 1602;
pub const ERROR_INSTALL_FAILURE : i32 = 1603;
pub const ERROR_INSTALL_SUSPEND : i32 = 1604;
pub const ERROR_UNKNOWN_PRODUCT : i32 = 1605;
pub const ERROR_UNKNOWN_FEATURE : i32 = 1606;
pub const ERROR_UNKNOWN_COMPONENT : i32 = 1607;
pub const ERROR_UNKNOWN_PROPERTY : i32 = 1608;
pub const ERROR_INVALID_HANDLE_STATE : i32 = 1609;
pub const ERROR_BAD_CONFIGURATION : i32 = 1610;
pub const ERROR_INDEX_ABSENT : i32 = 1611;
pub const ERROR_INSTALL_SOURCE_ABSENT : i32 = 1612;
pub const ERROR_INSTALL_PACKAGE_VERSION : i32 = 1613;
pub const ERROR_PRODUCT_UNINSTALLED : i32 = 1614;
pub const ERROR_BAD_QUERY_SYNTAX : i32 = 1615;
pub const ERROR_INVALID_FIELD : i32 = 1616;
pub const ERROR_DEVICE_REMOVED : i32 = 1617;
pub const ERROR_INSTALL_ALREADY_RUNNING : i32 = 1618;
pub const ERROR_INSTALL_PACKAGE_OPEN_FAILED : i32 = 1619;
pub const ERROR_INSTALL_PACKAGE_INVALID : i32 = 1620;
pub const ERROR_INSTALL_UI_FAILURE : i32 = 1621;
pub const ERROR_INSTALL_LOG_FAILURE : i32 = 1622;
pub const ERROR_INSTALL_LANGUAGE_UNSUPPORTED : i32 = 1623;
pub const ERROR_INSTALL_TRANSFORM_FAILURE : i32 = 1624;
pub const ERROR_INSTALL_PACKAGE_REJECTED : i32 = 1625;
pub const ERROR_FUNCTION_NOT_CALLED : i32 = 1626;
pub const ERROR_FUNCTION_FAILED : i32 = 1627;
pub const ERROR_INVALID_TABLE : i32 = 1628;
pub const ERROR_DATATYPE_MISMATCH : i32 = 1629;
pub const ERROR_UNSUPPORTED_TYPE : i32 = 1630;
pub const ERROR_CREATE_FAILED : i32 = 1631;
pub const ERROR_INSTALL_TEMP_UNWRITABLE : i32 = 1632;
pub const ERROR_INSTALL_PLATFORM_UNSUPPORTED : i32 = 1633;
pub const ERROR_INSTALL_NOTUSED : i32 = 1634;
pub const ERROR_PATCH_PACKAGE_OPEN_FAILED : i32 = 1635;
pub const ERROR_PATCH_PACKAGE_INVALID : i32 = 1636;
pub const ERROR_PATCH_PACKAGE_UNSUPPORTED : i32 = 1637;
pub const ERROR_PRODUCT_VERSION : i32 = 1638;
pub const ERROR_INVALID_COMMAND_LINE : i32 = 1639;
pub const ERROR_INSTALL_REMOTE_DISALLOWED : i32 = 1640;
pub const ERROR_SUCCESS_REBOOT_INITIATED : i32 = 1641;
pub const ERROR_PATCH_TARGET_NOT_FOUND : i32 = 1642;
pub const ERROR_PATCH_PACKAGE_REJECTED : i32 = 1643;
pub const ERROR_INSTALL_TRANSFORM_REJECTED : i32 = 1644;
pub const ERROR_INSTALL_REMOTE_PROHIBITED : i32 = 1645;
pub const ERROR_PATCH_REMOVAL_UNSUPPORTED : i32 = 1646;
pub const ERROR_UNKNOWN_PATCH : i32 = 1647;
pub const ERROR_PATCH_NO_SEQUENCE : i32 = 1648;
pub const ERROR_PATCH_REMOVAL_DISALLOWED : i32 = 1649;
pub const ERROR_INVALID_PATCH_XML : i32 = 1650;
pub const ERROR_PATCH_MANAGED_ADVERTISED_PRODUCT : i32 = 1651;
pub const ERROR_INSTALL_SERVICE_SAFEBOOT : i32 = 1652;
pub const ERROR_FAIL_FAST_EXCEPTION : i32 = 1653;
pub const ERROR_INSTALL_REJECTED : i32 = 1654;
pub const ERROR_DYNAMIC_CODE_BLOCKED : i32 = 1655;
pub const ERROR_NOT_SAME_OBJECT : i32 = 1656;
pub const ERROR_STRICT_CFG_VIOLATION : i32 = 1657;
pub const ERROR_SET_CONTEXT_DENIED : i32 = 1660;
pub const ERROR_CROSS_PARTITION_VIOLATION : i32 = 1661;
pub const ERROR_RETURN_ADDRESS_HIJACK_ATTEMPT : i32 = 1662;
pub const RPC_S_INVALID_STRING_BINDING : i32 = 1700;
pub const RPC_S_WRONG_KIND_OF_BINDING : i32 = 1701;
pub const RPC_S_INVALID_BINDING : i32 = 1702;
pub const RPC_S_PROTSEQ_NOT_SUPPORTED : i32 = 1703;
pub const RPC_S_INVALID_RPC_PROTSEQ : i32 = 1704;
pub const RPC_S_INVALID_STRING_UUID : i32 = 1705;
pub const RPC_S_INVALID_ENDPOINT_FORMAT : i32 = 1706;
pub const RPC_S_INVALID_NET_ADDR : i32 = 1707;
pub const RPC_S_NO_ENDPOINT_FOUND : i32 = 1708;
pub const RPC_S_INVALID_TIMEOUT : i32 = 1709;
pub const RPC_S_OBJECT_NOT_FOUND : i32 = 1710;
pub const RPC_S_ALREADY_REGISTERED : i32 = 1711;
pub const RPC_S_TYPE_ALREADY_REGISTERED : i32 = 1712;
pub const RPC_S_ALREADY_LISTENING : i32 = 1713;
pub const RPC_S_NO_PROTSEQS_REGISTERED : i32 = 1714;
pub const RPC_S_NOT_LISTENING : i32 = 1715;
pub const RPC_S_UNKNOWN_MGR_TYPE : i32 = 1716;
pub const RPC_S_UNKNOWN_IF : i32 = 1717;
pub const RPC_S_NO_BINDINGS : i32 = 1718;
pub const RPC_S_NO_PROTSEQS : i32 = 1719;
pub const RPC_S_CANT_CREATE_ENDPOINT : i32 = 1720;
pub const RPC_S_OUT_OF_RESOURCES : i32 = 1721;
pub const RPC_S_SERVER_UNAVAILABLE : i32 = 1722;
pub const RPC_S_SERVER_TOO_BUSY : i32 = 1723;
pub const RPC_S_INVALID_NETWORK_OPTIONS : i32 = 1724;
pub const RPC_S_NO_CALL_ACTIVE : i32 = 1725;
pub const RPC_S_CALL_FAILED : i32 = 1726;
pub const RPC_S_CALL_FAILED_DNE : i32 = 1727;
pub const RPC_S_PROTOCOL_ERROR : i32 = 1728;
pub const RPC_S_PROXY_ACCESS_DENIED : i32 = 1729;
pub const RPC_S_UNSUPPORTED_TRANS_SYN : i32 = 1730;
pub const RPC_S_UNSUPPORTED_TYPE : i32 = 1732;
pub const RPC_S_INVALID_TAG : i32 = 1733;
pub const RPC_S_INVALID_BOUND : i32 = 1734;
pub const RPC_S_NO_ENTRY_NAME : i32 = 1735;
pub const RPC_S_INVALID_NAME_SYNTAX : i32 = 1736;
pub const RPC_S_UNSUPPORTED_NAME_SYNTAX : i32 = 1737;
pub const RPC_S_UUID_NO_ADDRESS : i32 = 1739;
pub const RPC_S_DUPLICATE_ENDPOINT : i32 = 1740;
pub const RPC_S_UNKNOWN_AUTHN_TYPE : i32 = 1741;
pub const RPC_S_MAX_CALLS_TOO_SMALL : i32 = 1742;
pub const RPC_S_STRING_TOO_LONG : i32 = 1743;
pub const RPC_S_PROTSEQ_NOT_FOUND : i32 = 1744;
pub const RPC_S_PROCNUM_OUT_OF_RANGE : i32 = 1745;
pub const RPC_S_BINDING_HAS_NO_AUTH : i32 = 1746;
pub const RPC_S_UNKNOWN_AUTHN_SERVICE : i32 = 1747;
pub const RPC_S_UNKNOWN_AUTHN_LEVEL : i32 = 1748;
pub const RPC_S_INVALID_AUTH_IDENTITY : i32 = 1749;
pub const RPC_S_UNKNOWN_AUTHZ_SERVICE : i32 = 1750;
pub const EPT_S_INVALID_ENTRY : i32 = 1751;
pub const EPT_S_CANT_PERFORM_OP : i32 = 1752;
pub const EPT_S_NOT_REGISTERED : i32 = 1753;
pub const RPC_S_NOTHING_TO_EXPORT : i32 = 1754;
pub const RPC_S_INCOMPLETE_NAME : i32 = 1755;
pub const RPC_S_INVALID_VERS_OPTION : i32 = 1756;
pub const RPC_S_NO_MORE_MEMBERS : i32 = 1757;
pub const RPC_S_NOT_ALL_OBJS_UNEXPORTED : i32 = 1758;
pub const RPC_S_INTERFACE_NOT_FOUND : i32 = 1759;
pub const RPC_S_ENTRY_ALREADY_EXISTS : i32 = 1760;
pub const RPC_S_ENTRY_NOT_FOUND : i32 = 1761;
pub const RPC_S_NAME_SERVICE_UNAVAILABLE : i32 = 1762;
pub const RPC_S_INVALID_NAF_ID : i32 = 1763;
pub const RPC_S_CANNOT_SUPPORT : i32 = 1764;
pub const RPC_S_NO_CONTEXT_AVAILABLE : i32 = 1765;
pub const RPC_S_INTERNAL_ERROR : i32 = 1766;
pub const RPC_S_ZERO_DIVIDE : i32 = 1767;
pub const RPC_S_ADDRESS_ERROR : i32 = 1768;
pub const RPC_S_FP_DIV_ZERO : i32 = 1769;
pub const RPC_S_FP_UNDERFLOW : i32 = 1770;
pub const RPC_S_FP_OVERFLOW : i32 = 1771;
pub const RPC_X_NO_MORE_ENTRIES : i32 = 1772;
pub const RPC_X_SS_CHAR_TRANS_OPEN_FAIL : i32 = 1773;
pub const RPC_X_SS_CHAR_TRANS_SHORT_FILE : i32 = 1774;
pub const RPC_X_SS_IN_NULL_CONTEXT : i32 = 1775;
pub const RPC_X_SS_CONTEXT_DAMAGED : i32 = 1777;
pub const RPC_X_SS_HANDLES_MISMATCH : i32 = 1778;
pub const RPC_X_SS_CANNOT_GET_CALL_HANDLE : i32 = 1779;
pub const RPC_X_NULL_REF_POINTER : i32 = 1780;
pub const RPC_X_ENUM_VALUE_OUT_OF_RANGE : i32 = 1781;
pub const RPC_X_BYTE_COUNT_TOO_SMALL : i32 = 1782;
pub const RPC_X_BAD_STUB_DATA : i32 = 1783;
pub const ERROR_INVALID_USER_BUFFER : i32 = 1784;
pub const ERROR_UNRECOGNIZED_MEDIA : i32 = 1785;
pub const ERROR_NO_TRUST_LSA_SECRET : i32 = 1786;
pub const ERROR_NO_TRUST_SAM_ACCOUNT : i32 = 1787;
pub const ERROR_TRUSTED_DOMAIN_FAILURE : i32 = 1788;
pub const ERROR_TRUSTED_RELATIONSHIP_FAILURE : i32 = 1789;
pub const ERROR_TRUST_FAILURE : i32 = 1790;
pub const RPC_S_CALL_IN_PROGRESS : i32 = 1791;
pub const ERROR_NETLOGON_NOT_STARTED : i32 = 1792;
pub const ERROR_ACCOUNT_EXPIRED : i32 = 1793;
pub const ERROR_REDIRECTOR_HAS_OPEN_HANDLES : i32 = 1794;
pub const ERROR_PRINTER_DRIVER_ALREADY_INSTALLED : i32 = 1795;
pub const ERROR_UNKNOWN_PORT : i32 = 1796;
pub const ERROR_UNKNOWN_PRINTER_DRIVER : i32 = 1797;
pub const ERROR_UNKNOWN_PRINTPROCESSOR : i32 = 1798;
pub const ERROR_INVALID_SEPARATOR_FILE : i32 = 1799;
pub const ERROR_INVALID_PRIORITY : i32 = 1800;
pub const ERROR_INVALID_PRINTER_NAME : i32 = 1801;
pub const ERROR_PRINTER_ALREADY_EXISTS : i32 = 1802;
pub const ERROR_INVALID_PRINTER_COMMAND : i32 = 1803;
pub const ERROR_INVALID_DATATYPE : i32 = 1804;
pub const ERROR_INVALID_ENVIRONMENT : i32 = 1805;
pub const RPC_S_NO_MORE_BINDINGS : i32 = 1806;
pub const ERROR_NOLOGON_INTERDOMAIN_TRUST_ACCOUNT : i32 = 1807;
pub const ERROR_NOLOGON_WORKSTATION_TRUST_ACCOUNT : i32 = 1808;
pub const ERROR_NOLOGON_SERVER_TRUST_ACCOUNT : i32 = 1809;
pub const ERROR_DOMAIN_TRUST_INCONSISTENT : i32 = 1810;
pub const ERROR_SERVER_HAS_OPEN_HANDLES : i32 = 1811;
pub const ERROR_RESOURCE_DATA_NOT_FOUND : i32 = 1812;
pub const ERROR_RESOURCE_TYPE_NOT_FOUND : i32 = 1813;
pub const ERROR_RESOURCE_NAME_NOT_FOUND : i32 = 1814;
pub const ERROR_RESOURCE_LANG_NOT_FOUND : i32 = 1815;
pub const ERROR_NOT_ENOUGH_QUOTA : i32 = 1816;
pub const RPC_S_NO_INTERFACES : i32 = 1817;
pub const RPC_S_CALL_CANCELLED : i32 = 1818;
pub const RPC_S_BINDING_INCOMPLETE : i32 = 1819;
pub const RPC_S_COMM_FAILURE : i32 = 1820;
pub const RPC_S_UNSUPPORTED_AUTHN_LEVEL : i32 = 1821;
pub const RPC_S_NO_PRINC_NAME : i32 = 1822;
pub const RPC_S_NOT_RPC_ERROR : i32 = 1823;
pub const RPC_S_UUID_LOCAL_ONLY : i32 = 1824;
pub const RPC_S_SEC_PKG_ERROR : i32 = 1825;
pub const RPC_S_NOT_CANCELLED : i32 = 1826;
pub const RPC_X_INVALID_ES_ACTION : i32 = 1827;
pub const RPC_X_WRONG_ES_VERSION : i32 = 1828;
pub const RPC_X_WRONG_STUB_VERSION : i32 = 1829;
pub const RPC_X_INVALID_PIPE_OBJECT : i32 = 1830;
pub const RPC_X_WRONG_PIPE_ORDER : i32 = 1831;
pub const RPC_X_WRONG_PIPE_VERSION : i32 = 1832;
pub const RPC_S_COOKIE_AUTH_FAILED : i32 = 1833;
pub const RPC_S_DO_NOT_DISTURB : i32 = 1834;
pub const RPC_S_SYSTEM_HANDLE_COUNT_EXCEEDED : i32 = 1835;
pub const RPC_S_SYSTEM_HANDLE_TYPE_MISMATCH : i32 = 1836;
pub const RPC_S_GROUP_MEMBER_NOT_FOUND : i32 = 1898;
pub const EPT_S_CANT_CREATE : i32 = 1899;
pub const RPC_S_INVALID_OBJECT : i32 = 1900;
pub const ERROR_INVALID_TIME : i32 = 1901;
pub const ERROR_INVALID_FORM_NAME : i32 = 1902;
pub const ERROR_INVALID_FORM_SIZE : i32 = 1903;
pub const ERROR_ALREADY_WAITING : i32 = 1904;
pub const ERROR_PRINTER_DELETED : i32 = 1905;
pub const ERROR_INVALID_PRINTER_STATE : i32 = 1906;
pub const ERROR_PASSWORD_MUST_CHANGE : i32 = 1907;
pub const ERROR_DOMAIN_CONTROLLER_NOT_FOUND : i32 = 1908;
pub const ERROR_ACCOUNT_LOCKED_OUT : i32 = 1909;
pub const OR_INVALID_OXID : i32 = 1910;
pub const OR_INVALID_OID : i32 = 1911;
pub const OR_INVALID_SET : i32 = 1912;
pub const RPC_S_SEND_INCOMPLETE : i32 = 1913;
pub const RPC_S_INVALID_ASYNC_HANDLE : i32 = 1914;
pub const RPC_S_INVALID_ASYNC_CALL : i32 = 1915;
pub const RPC_X_PIPE_CLOSED : i32 = 1916;
pub const RPC_X_PIPE_DISCIPLINE_ERROR : i32 = 1917;
pub const RPC_X_PIPE_EMPTY : i32 = 1918;
pub const ERROR_NO_SITENAME : i32 = 1919;
pub const ERROR_CANT_ACCESS_FILE : i32 = 1920;
pub const ERROR_CANT_RESOLVE_FILENAME : i32 = 1921;
pub const RPC_S_ENTRY_TYPE_MISMATCH : i32 = 1922;
pub const RPC_S_NOT_ALL_OBJS_EXPORTED : i32 = 1923;
pub const RPC_S_INTERFACE_NOT_EXPORTED : i32 = 1924;
pub const RPC_S_PROFILE_NOT_ADDED : i32 = 1925;
pub const RPC_S_PRF_ELT_NOT_ADDED : i32 = 1926;
pub const RPC_S_PRF_ELT_NOT_REMOVED : i32 = 1927;
pub const RPC_S_GRP_ELT_NOT_ADDED : i32 = 1928;
pub const RPC_S_GRP_ELT_NOT_REMOVED : i32 = 1929;
pub const ERROR_KM_DRIVER_BLOCKED : i32 = 1930;
pub const ERROR_CONTEXT_EXPIRED : i32 = 1931;
pub const ERROR_PER_USER_TRUST_QUOTA_EXCEEDED : i32 = 1932;
pub const ERROR_ALL_USER_TRUST_QUOTA_EXCEEDED : i32 = 1933;
pub const ERROR_USER_DELETE_TRUST_QUOTA_EXCEEDED : i32 = 1934;
pub const ERROR_AUTHENTICATION_FIREWALL_FAILED : i32 = 1935;
pub const ERROR_REMOTE_PRINT_CONNECTIONS_BLOCKED : i32 = 1936;
pub const ERROR_NTLM_BLOCKED : i32 = 1937;
pub const ERROR_PASSWORD_CHANGE_REQUIRED : i32 = 1938;
pub const ERROR_LOST_MODE_LOGON_RESTRICTION : i32 = 1939;
pub const ERROR_INVALID_PIXEL_FORMAT : i32 = 2000;
pub const ERROR_BAD_DRIVER : i32 = 2001;
pub const ERROR_INVALID_WINDOW_STYLE : i32 = 2002;
pub const ERROR_METAFILE_NOT_SUPPORTED : i32 = 2003;
pub const ERROR_TRANSFORM_NOT_SUPPORTED : i32 = 2004;
pub const ERROR_CLIPPING_NOT_SUPPORTED : i32 = 2005;
pub const ERROR_INVALID_CMM : i32 = 2010;
pub const ERROR_INVALID_PROFILE : i32 = 2011;
pub const ERROR_TAG_NOT_FOUND : i32 = 2012;
pub const ERROR_TAG_NOT_PRESENT : i32 = 2013;
pub const ERROR_DUPLICATE_TAG : i32 = 2014;
pub const ERROR_PROFILE_NOT_ASSOCIATED_WITH_DEVICE : i32 = 2015;
pub const ERROR_PROFILE_NOT_FOUND : i32 = 2016;
pub const ERROR_INVALID_COLORSPACE : i32 = 2017;
pub const ERROR_ICM_NOT_ENABLED : i32 = 2018;
pub const ERROR_DELETING_ICM_XFORM : i32 = 2019;
pub const ERROR_INVALID_TRANSFORM : i32 = 2020;
pub const ERROR_COLORSPACE_MISMATCH : i32 = 2021;
pub const ERROR_INVALID_COLORINDEX : i32 = 2022;
pub const ERROR_PROFILE_DOES_NOT_MATCH_DEVICE : i32 = 2023;
pub const ERROR_CONNECTED_OTHER_PASSWORD : i32 = 2108;
pub const ERROR_CONNECTED_OTHER_PASSWORD_DEFAULT : i32 = 2109;
pub const ERROR_BAD_USERNAME : i32 = 2202;
pub const ERROR_NOT_CONNECTED : i32 = 2250;
pub const ERROR_OPEN_FILES : i32 = 2401;
pub const ERROR_ACTIVE_CONNECTIONS : i32 = 2402;
pub const ERROR_DEVICE_IN_USE : i32 = 2404;
pub const ERROR_UNKNOWN_PRINT_MONITOR : i32 = 3000;
pub const ERROR_PRINTER_DRIVER_IN_USE : i32 = 3001;
pub const ERROR_SPOOL_FILE_NOT_FOUND : i32 = 3002;
pub const ERROR_SPL_NO_STARTDOC : i32 = 3003;
pub const ERROR_SPL_NO_ADDJOB : i32 = 3004;
pub const ERROR_PRINT_PROCESSOR_ALREADY_INSTALLED : i32 = 3005;
pub const ERROR_PRINT_MONITOR_ALREADY_INSTALLED : i32 = 3006;
pub const ERROR_INVALID_PRINT_MONITOR : i32 = 3007;
pub const ERROR_PRINT_MONITOR_IN_USE : i32 = 3008;
pub const ERROR_PRINTER_HAS_JOBS_QUEUED : i32 = 3009;
pub const ERROR_SUCCESS_REBOOT_REQUIRED : i32 = 3010;
pub const ERROR_SUCCESS_RESTART_REQUIRED : i32 = 3011;
pub const ERROR_PRINTER_NOT_FOUND : i32 = 3012;
pub const ERROR_PRINTER_DRIVER_WARNED : i32 = 3013;
pub const ERROR_PRINTER_DRIVER_BLOCKED : i32 = 3014;
pub const ERROR_PRINTER_DRIVER_PACKAGE_IN_USE : i32 = 3015;
pub const ERROR_CORE_DRIVER_PACKAGE_NOT_FOUND : i32 = 3016;
pub const ERROR_FAIL_REBOOT_REQUIRED : i32 = 3017;
pub const ERROR_FAIL_REBOOT_INITIATED : i32 = 3018;
pub const ERROR_PRINTER_DRIVER_DOWNLOAD_NEEDED : i32 = 3019;
pub const ERROR_PRINT_JOB_RESTART_REQUIRED : i32 = 3020;
pub const ERROR_INVALID_PRINTER_DRIVER_MANIFEST : i32 = 3021;
pub const ERROR_PRINTER_NOT_SHAREABLE : i32 = 3022;
pub const ERROR_REQUEST_PAUSED : i32 = 3050;
pub const ERROR_APPEXEC_CONDITION_NOT_SATISFIED : i32 = 3060;
pub const ERROR_APPEXEC_HANDLE_INVALIDATED : i32 = 3061;
pub const ERROR_APPEXEC_INVALID_HOST_GENERATION : i32 = 3062;
pub const ERROR_APPEXEC_UNEXPECTED_PROCESS_REGISTRATION : i32 = 3063;
pub const ERROR_APPEXEC_INVALID_HOST_STATE : i32 = 3064;
pub const ERROR_APPEXEC_NO_DONOR : i32 = 3065;
pub const ERROR_APPEXEC_HOST_ID_MISMATCH : i32 = 3066;
pub const ERROR_APPEXEC_UNKNOWN_USER : i32 = 3067;
pub const ERROR_IO_REISSUE_AS_CACHED : i32 = 3950;
pub const ERROR_WINS_INTERNAL : i32 = 4000;
pub const ERROR_CAN_NOT_DEL_LOCAL_WINS : i32 = 4001;
pub const ERROR_STATIC_INIT : i32 = 4002;
pub const ERROR_INC_BACKUP : i32 = 4003;
pub const ERROR_FULL_BACKUP : i32 = 4004;
pub const ERROR_REC_NON_EXISTENT : i32 = 4005;
pub const ERROR_RPL_NOT_ALLOWED : i32 = 4006;
pub const PEERDIST_ERROR_CONTENTINFO_VERSION_UNSUPPORTED : i32 = 4050;
pub const PEERDIST_ERROR_CANNOT_PARSE_CONTENTINFO : i32 = 4051;
pub const PEERDIST_ERROR_MISSING_DATA : i32 = 4052;
pub const PEERDIST_ERROR_NO_MORE : i32 = 4053;
pub const PEERDIST_ERROR_NOT_INITIALIZED : i32 = 4054;
pub const PEERDIST_ERROR_ALREADY_INITIALIZED : i32 = 4055;
pub const PEERDIST_ERROR_SHUTDOWN_IN_PROGRESS : i32 = 4056;
pub const PEERDIST_ERROR_INVALIDATED : i32 = 4057;
pub const PEERDIST_ERROR_ALREADY_EXISTS : i32 = 4058;
pub const PEERDIST_ERROR_OPERATION_NOTFOUND : i32 = 4059;
pub const PEERDIST_ERROR_ALREADY_COMPLETED : i32 = 4060;
pub const PEERDIST_ERROR_OUT_OF_BOUNDS : i32 = 4061;
pub const PEERDIST_ERROR_VERSION_UNSUPPORTED : i32 = 4062;
pub const PEERDIST_ERROR_INVALID_CONFIGURATION : i32 = 4063;
pub const PEERDIST_ERROR_NOT_LICENSED : i32 = 4064;
pub const PEERDIST_ERROR_SERVICE_UNAVAILABLE : i32 = 4065;
pub const PEERDIST_ERROR_TRUST_FAILURE : i32 = 4066;
pub const ERROR_DHCP_ADDRESS_CONFLICT : i32 = 4100;
pub const ERROR_WMI_GUID_NOT_FOUND : i32 = 4200;
pub const ERROR_WMI_INSTANCE_NOT_FOUND : i32 = 4201;
pub const ERROR_WMI_ITEMID_NOT_FOUND : i32 = 4202;
pub const ERROR_WMI_TRY_AGAIN : i32 = 4203;
pub const ERROR_WMI_DP_NOT_FOUND : i32 = 4204;
pub const ERROR_WMI_UNRESOLVED_INSTANCE_REF : i32 = 4205;
pub const ERROR_WMI_ALREADY_ENABLED : i32 = 4206;
pub const ERROR_WMI_GUID_DISCONNECTED : i32 = 4207;
pub const ERROR_WMI_SERVER_UNAVAILABLE : i32 = 4208;
pub const ERROR_WMI_DP_FAILED : i32 = 4209;
pub const ERROR_WMI_INVALID_MOF : i32 = 4210;
pub const ERROR_WMI_INVALID_REGINFO : i32 = 4211;
pub const ERROR_WMI_ALREADY_DISABLED : i32 = 4212;
pub const ERROR_WMI_READ_ONLY : i32 = 4213;
pub const ERROR_WMI_SET_FAILURE : i32 = 4214;
pub const ERROR_NOT_APPCONTAINER : i32 = 4250;
pub const ERROR_APPCONTAINER_REQUIRED : i32 = 4251;
pub const ERROR_NOT_SUPPORTED_IN_APPCONTAINER : i32 = 4252;
pub const ERROR_INVALID_PACKAGE_SID_LENGTH : i32 = 4253;
pub const ERROR_INVALID_MEDIA : i32 = 4300;
pub const ERROR_INVALID_LIBRARY : i32 = 4301;
pub const ERROR_INVALID_MEDIA_POOL : i32 = 4302;
pub const ERROR_DRIVE_MEDIA_MISMATCH : i32 = 4303;
pub const ERROR_MEDIA_OFFLINE : i32 = 4304;
pub const ERROR_LIBRARY_OFFLINE : i32 = 4305;
pub const ERROR_EMPTY : i32 = 4306;
pub const ERROR_NOT_EMPTY : i32 = 4307;
pub const ERROR_MEDIA_UNAVAILABLE : i32 = 4308;
pub const ERROR_RESOURCE_DISABLED : i32 = 4309;
pub const ERROR_INVALID_CLEANER : i32 = 4310;
pub const ERROR_UNABLE_TO_CLEAN : i32 = 4311;
pub const ERROR_OBJECT_NOT_FOUND : i32 = 4312;
pub const ERROR_DATABASE_FAILURE : i32 = 4313;
pub const ERROR_DATABASE_FULL : i32 = 4314;
pub const ERROR_MEDIA_INCOMPATIBLE : i32 = 4315;
pub const ERROR_RESOURCE_NOT_PRESENT : i32 = 4316;
pub const ERROR_INVALID_OPERATION : i32 = 4317;
pub const ERROR_MEDIA_NOT_AVAILABLE : i32 = 4318;
pub const ERROR_DEVICE_NOT_AVAILABLE : i32 = 4319;
pub const ERROR_REQUEST_REFUSED : i32 = 4320;
pub const ERROR_INVALID_DRIVE_OBJECT : i32 = 4321;
pub const ERROR_LIBRARY_FULL : i32 = 4322;
pub const ERROR_MEDIUM_NOT_ACCESSIBLE : i32 = 4323;
pub const ERROR_UNABLE_TO_LOAD_MEDIUM : i32 = 4324;
pub const ERROR_UNABLE_TO_INVENTORY_DRIVE : i32 = 4325;
pub const ERROR_UNABLE_TO_INVENTORY_SLOT : i32 = 4326;
pub const ERROR_UNABLE_TO_INVENTORY_TRANSPORT : i32 = 4327;
pub const ERROR_TRANSPORT_FULL : i32 = 4328;
pub const ERROR_CONTROLLING_IEPORT : i32 = 4329;
pub const ERROR_UNABLE_TO_EJECT_MOUNTED_MEDIA : i32 = 4330;
pub const ERROR_CLEANER_SLOT_SET : i32 = 4331;
pub const ERROR_CLEANER_SLOT_NOT_SET : i32 = 4332;
pub const ERROR_CLEANER_CARTRIDGE_SPENT : i32 = 4333;
pub const ERROR_UNEXPECTED_OMID : i32 = 4334;
pub const ERROR_CANT_DELETE_LAST_ITEM : i32 = 4335;
pub const ERROR_MESSAGE_EXCEEDS_MAX_SIZE : i32 = 4336;
pub const ERROR_VOLUME_CONTAINS_SYS_FILES : i32 = 4337;
pub const ERROR_INDIGENOUS_TYPE : i32 = 4338;
pub const ERROR_NO_SUPPORTING_DRIVES : i32 = 4339;
pub const ERROR_CLEANER_CARTRIDGE_INSTALLED : i32 = 4340;
pub const ERROR_IEPORT_FULL : i32 = 4341;
pub const ERROR_FILE_OFFLINE : i32 = 4350;
pub const ERROR_REMOTE_STORAGE_NOT_ACTIVE : i32 = 4351;
pub const ERROR_REMOTE_STORAGE_MEDIA_ERROR : i32 = 4352;
pub const ERROR_NOT_A_REPARSE_POINT : i32 = 4390;
pub const ERROR_REPARSE_ATTRIBUTE_CONFLICT : i32 = 4391;
pub const ERROR_INVALID_REPARSE_DATA : i32 = 4392;
pub const ERROR_REPARSE_TAG_INVALID : i32 = 4393;
pub const ERROR_REPARSE_TAG_MISMATCH : i32 = 4394;
pub const ERROR_REPARSE_POINT_ENCOUNTERED : i32 = 4395;
pub const ERROR_APP_DATA_NOT_FOUND : i32 = 4400;
pub const ERROR_APP_DATA_EXPIRED : i32 = 4401;
pub const ERROR_APP_DATA_CORRUPT : i32 = 4402;
pub const ERROR_APP_DATA_LIMIT_EXCEEDED : i32 = 4403;
pub const ERROR_APP_DATA_REBOOT_REQUIRED : i32 = 4404;
pub const ERROR_SECUREBOOT_ROLLBACK_DETECTED : i32 = 4420;
pub const ERROR_SECUREBOOT_POLICY_VIOLATION : i32 = 4421;
pub const ERROR_SECUREBOOT_INVALID_POLICY : i32 = 4422;
pub const ERROR_SECUREBOOT_POLICY_PUBLISHER_NOT_FOUND : i32 = 4423;
pub const ERROR_SECUREBOOT_POLICY_NOT_SIGNED : i32 = 4424;
pub const ERROR_SECUREBOOT_NOT_ENABLED : i32 = 4425;
pub const ERROR_SECUREBOOT_FILE_REPLACED : i32 = 4426;
pub const ERROR_SECUREBOOT_POLICY_NOT_AUTHORIZED : i32 = 4427;
pub const ERROR_SECUREBOOT_POLICY_UNKNOWN : i32 = 4428;
pub const ERROR_SECUREBOOT_POLICY_MISSING_ANTIROLLBACKVERSION : i32 = 4429;
pub const ERROR_SECUREBOOT_PLATFORM_ID_MISMATCH : i32 = 4430;
pub const ERROR_SECUREBOOT_POLICY_ROLLBACK_DETECTED : i32 = 4431;
pub const ERROR_SECUREBOOT_POLICY_UPGRADE_MISMATCH : i32 = 4432;
pub const ERROR_SECUREBOOT_REQUIRED_POLICY_FILE_MISSING : i32 = 4433;
pub const ERROR_SECUREBOOT_NOT_BASE_POLICY : i32 = 4434;
pub const ERROR_SECUREBOOT_NOT_SUPPLEMENTAL_POLICY : i32 = 4435;
pub const ERROR_OFFLOAD_READ_FLT_NOT_SUPPORTED : i32 = 4440;
pub const ERROR_OFFLOAD_WRITE_FLT_NOT_SUPPORTED : i32 = 4441;
pub const ERROR_OFFLOAD_READ_FILE_NOT_SUPPORTED : i32 = 4442;
pub const ERROR_OFFLOAD_WRITE_FILE_NOT_SUPPORTED : i32 = 4443;
pub const ERROR_ALREADY_HAS_STREAM_ID : i32 = 4444;
pub const ERROR_SMR_GARBAGE_COLLECTION_REQUIRED : i32 = 4445;
pub const ERROR_WOF_WIM_HEADER_CORRUPT : i32 = 4446;
pub const ERROR_WOF_WIM_RESOURCE_TABLE_CORRUPT : i32 = 4447;
pub const ERROR_WOF_FILE_RESOURCE_TABLE_CORRUPT : i32 = 4448;
pub const ERROR_VOLUME_NOT_SIS_ENABLED : i32 = 4500;
pub const ERROR_SYSTEM_INTEGRITY_ROLLBACK_DETECTED : i32 = 4550;
pub const ERROR_SYSTEM_INTEGRITY_POLICY_VIOLATION : i32 = 4551;
pub const ERROR_SYSTEM_INTEGRITY_INVALID_POLICY : i32 = 4552;
pub const ERROR_SYSTEM_INTEGRITY_POLICY_NOT_SIGNED : i32 = 4553;
pub const ERROR_SYSTEM_INTEGRITY_TOO_MANY_POLICIES : i32 = 4554;
pub const ERROR_SYSTEM_INTEGRITY_SUPPLEMENTAL_POLICY_NOT_AUTHORIZED : i32 = 4555;
pub const ERROR_VSM_NOT_INITIALIZED : i32 = 4560;
pub const ERROR_VSM_DMA_PROTECTION_NOT_IN_USE : i32 = 4561;
pub const ERROR_PLATFORM_MANIFEST_NOT_AUTHORIZED : i32 = 4570;
pub const ERROR_PLATFORM_MANIFEST_INVALID : i32 = 4571;
pub const ERROR_PLATFORM_MANIFEST_FILE_NOT_AUTHORIZED : i32 = 4572;
pub const ERROR_PLATFORM_MANIFEST_CATALOG_NOT_AUTHORIZED : i32 = 4573;
pub const ERROR_PLATFORM_MANIFEST_BINARY_ID_NOT_FOUND : i32 = 4574;
pub const ERROR_PLATFORM_MANIFEST_NOT_ACTIVE : i32 = 4575;
pub const ERROR_PLATFORM_MANIFEST_NOT_SIGNED : i32 = 4576;
pub const ERROR_DEPENDENT_RESOURCE_EXISTS : i32 = 5001;
pub const ERROR_DEPENDENCY_NOT_FOUND : i32 = 5002;
pub const ERROR_DEPENDENCY_ALREADY_EXISTS : i32 = 5003;
pub const ERROR_RESOURCE_NOT_ONLINE : i32 = 5004;
pub const ERROR_HOST_NODE_NOT_AVAILABLE : i32 = 5005;
pub const ERROR_RESOURCE_NOT_AVAILABLE : i32 = 5006;
pub const ERROR_RESOURCE_NOT_FOUND : i32 = 5007;
pub const ERROR_SHUTDOWN_CLUSTER : i32 = 5008;
pub const ERROR_CANT_EVICT_ACTIVE_NODE : i32 = 5009;
pub const ERROR_OBJECT_ALREADY_EXISTS : i32 = 5010;
pub const ERROR_OBJECT_IN_LIST : i32 = 5011;
pub const ERROR_GROUP_NOT_AVAILABLE : i32 = 5012;
pub const ERROR_GROUP_NOT_FOUND : i32 = 5013;
pub const ERROR_GROUP_NOT_ONLINE : i32 = 5014;
pub const ERROR_HOST_NODE_NOT_RESOURCE_OWNER : i32 = 5015;
pub const ERROR_HOST_NODE_NOT_GROUP_OWNER : i32 = 5016;
pub const ERROR_RESMON_CREATE_FAILED : i32 = 5017;
pub const ERROR_RESMON_ONLINE_FAILED : i32 = 5018;
pub const ERROR_RESOURCE_ONLINE : i32 = 5019;
pub const ERROR_QUORUM_RESOURCE : i32 = 5020;
pub const ERROR_NOT_QUORUM_CAPABLE : i32 = 5021;
pub const ERROR_CLUSTER_SHUTTING_DOWN : i32 = 5022;
pub const ERROR_INVALID_STATE : i32 = 5023;
pub const ERROR_RESOURCE_PROPERTIES_STORED : i32 = 5024;
pub const ERROR_NOT_QUORUM_CLASS : i32 = 5025;
pub const ERROR_CORE_RESOURCE : i32 = 5026;
pub const ERROR_QUORUM_RESOURCE_ONLINE_FAILED : i32 = 5027;
pub const ERROR_QUORUMLOG_OPEN_FAILED : i32 = 5028;
pub const ERROR_CLUSTERLOG_CORRUPT : i32 = 5029;
pub const ERROR_CLUSTERLOG_RECORD_EXCEEDS_MAXSIZE : i32 = 5030;
pub const ERROR_CLUSTERLOG_EXCEEDS_MAXSIZE : i32 = 5031;
pub const ERROR_CLUSTERLOG_CHKPOINT_NOT_FOUND : i32 = 5032;
pub const ERROR_CLUSTERLOG_NOT_ENOUGH_SPACE : i32 = 5033;
pub const ERROR_QUORUM_OWNER_ALIVE : i32 = 5034;
pub const ERROR_NETWORK_NOT_AVAILABLE : i32 = 5035;
pub const ERROR_NODE_NOT_AVAILABLE : i32 = 5036;
pub const ERROR_ALL_NODES_NOT_AVAILABLE : i32 = 5037;
pub const ERROR_RESOURCE_FAILED : i32 = 5038;
pub const ERROR_CLUSTER_INVALID_NODE : i32 = 5039;
pub const ERROR_CLUSTER_NODE_EXISTS : i32 = 5040;
pub const ERROR_CLUSTER_JOIN_IN_PROGRESS : i32 = 5041;
pub const ERROR_CLUSTER_NODE_NOT_FOUND : i32 = 5042;
pub const ERROR_CLUSTER_LOCAL_NODE_NOT_FOUND : i32 = 5043;
pub const ERROR_CLUSTER_NETWORK_EXISTS : i32 = 5044;
pub const ERROR_CLUSTER_NETWORK_NOT_FOUND : i32 = 5045;
pub const ERROR_CLUSTER_NETINTERFACE_EXISTS : i32 = 5046;
pub const ERROR_CLUSTER_NETINTERFACE_NOT_FOUND : i32 = 5047;
pub const ERROR_CLUSTER_INVALID_REQUEST : i32 = 5048;
pub const ERROR_CLUSTER_INVALID_NETWORK_PROVIDER : i32 = 5049;
pub const ERROR_CLUSTER_NODE_DOWN : i32 = 5050;
pub const ERROR_CLUSTER_NODE_UNREACHABLE : i32 = 5051;
pub const ERROR_CLUSTER_NODE_NOT_MEMBER : i32 = 5052;
pub const ERROR_CLUSTER_JOIN_NOT_IN_PROGRESS : i32 = 5053;
pub const ERROR_CLUSTER_INVALID_NETWORK : i32 = 5054;
pub const ERROR_CLUSTER_NODE_UP : i32 = 5056;
pub const ERROR_CLUSTER_IPADDR_IN_USE : i32 = 5057;
pub const ERROR_CLUSTER_NODE_NOT_PAUSED : i32 = 5058;
pub const ERROR_CLUSTER_NO_SECURITY_CONTEXT : i32 = 5059;
pub const ERROR_CLUSTER_NETWORK_NOT_INTERNAL : i32 = 5060;
pub const ERROR_CLUSTER_NODE_ALREADY_UP : i32 = 5061;
pub const ERROR_CLUSTER_NODE_ALREADY_DOWN : i32 = 5062;
pub const ERROR_CLUSTER_NETWORK_ALREADY_ONLINE : i32 = 5063;
pub const ERROR_CLUSTER_NETWORK_ALREADY_OFFLINE : i32 = 5064;
pub const ERROR_CLUSTER_NODE_ALREADY_MEMBER : i32 = 5065;
pub const ERROR_CLUSTER_LAST_INTERNAL_NETWORK : i32 = 5066;
pub const ERROR_CLUSTER_NETWORK_HAS_DEPENDENTS : i32 = 5067;
pub const ERROR_INVALID_OPERATION_ON_QUORUM : i32 = 5068;
pub const ERROR_DEPENDENCY_NOT_ALLOWED : i32 = 5069;
pub const ERROR_CLUSTER_NODE_PAUSED : i32 = 5070;
pub const ERROR_NODE_CANT_HOST_RESOURCE : i32 = 5071;
pub const ERROR_CLUSTER_NODE_NOT_READY : i32 = 5072;
pub const ERROR_CLUSTER_NODE_SHUTTING_DOWN : i32 = 5073;
pub const ERROR_CLUSTER_JOIN_ABORTED : i32 = 5074;
pub const ERROR_CLUSTER_INCOMPATIBLE_VERSIONS : i32 = 5075;
pub const ERROR_CLUSTER_MAXNUM_OF_RESOURCES_EXCEEDED : i32 = 5076;
pub const ERROR_CLUSTER_SYSTEM_CONFIG_CHANGED : i32 = 5077;
pub const ERROR_CLUSTER_RESOURCE_TYPE_NOT_FOUND : i32 = 5078;
pub const ERROR_CLUSTER_RESTYPE_NOT_SUPPORTED : i32 = 5079;
pub const ERROR_CLUSTER_RESNAME_NOT_FOUND : i32 = 5080;
pub const ERROR_CLUSTER_NO_RPC_PACKAGES_REGISTERED : i32 = 5081;
pub const ERROR_CLUSTER_OWNER_NOT_IN_PREFLIST : i32 = 5082;
pub const ERROR_CLUSTER_DATABASE_SEQMISMATCH : i32 = 5083;
pub const ERROR_RESMON_INVALID_STATE : i32 = 5084;
pub const ERROR_CLUSTER_GUM_NOT_LOCKER : i32 = 5085;
pub const ERROR_QUORUM_DISK_NOT_FOUND : i32 = 5086;
pub const ERROR_DATABASE_BACKUP_CORRUPT : i32 = 5087;
pub const ERROR_CLUSTER_NODE_ALREADY_HAS_DFS_ROOT : i32 = 5088;
pub const ERROR_RESOURCE_PROPERTY_UNCHANGEABLE : i32 = 5089;
pub const ERROR_NO_ADMIN_ACCESS_POINT : i32 = 5090;
pub const ERROR_CLUSTER_MEMBERSHIP_INVALID_STATE : i32 = 5890;
pub const ERROR_CLUSTER_QUORUMLOG_NOT_FOUND : i32 = 5891;
pub const ERROR_CLUSTER_MEMBERSHIP_HALT : i32 = 5892;
pub const ERROR_CLUSTER_INSTANCE_ID_MISMATCH : i32 = 5893;
pub const ERROR_CLUSTER_NETWORK_NOT_FOUND_FOR_IP : i32 = 5894;
pub const ERROR_CLUSTER_PROPERTY_DATA_TYPE_MISMATCH : i32 = 5895;
pub const ERROR_CLUSTER_EVICT_WITHOUT_CLEANUP : i32 = 5896;
pub const ERROR_CLUSTER_PARAMETER_MISMATCH : i32 = 5897;
pub const ERROR_NODE_CANNOT_BE_CLUSTERED : i32 = 5898;
pub const ERROR_CLUSTER_WRONG_OS_VERSION : i32 = 5899;
pub const ERROR_CLUSTER_CANT_CREATE_DUP_CLUSTER_NAME : i32 = 5900;
pub const ERROR_CLUSCFG_ALREADY_COMMITTED : i32 = 5901;
pub const ERROR_CLUSCFG_ROLLBACK_FAILED : i32 = 5902;
pub const ERROR_CLUSCFG_SYSTEM_DISK_DRIVE_LETTER_CONFLICT : i32 = 5903;
pub const ERROR_CLUSTER_OLD_VERSION : i32 = 5904;
pub const ERROR_CLUSTER_MISMATCHED_COMPUTER_ACCT_NAME : i32 = 5905;
pub const ERROR_CLUSTER_NO_NET_ADAPTERS : i32 = 5906;
pub const ERROR_CLUSTER_POISONED : i32 = 5907;
pub const ERROR_CLUSTER_GROUP_MOVING : i32 = 5908;
pub const ERROR_CLUSTER_RESOURCE_TYPE_BUSY : i32 = 5909;
pub const ERROR_RESOURCE_CALL_TIMED_OUT : i32 = 5910;
pub const ERROR_INVALID_CLUSTER_IPV6_ADDRESS : i32 = 5911;
pub const ERROR_CLUSTER_INTERNAL_INVALID_FUNCTION : i32 = 5912;
pub const ERROR_CLUSTER_PARAMETER_OUT_OF_BOUNDS : i32 = 5913;
pub const ERROR_CLUSTER_PARTIAL_SEND : i32 = 5914;
pub const ERROR_CLUSTER_REGISTRY_INVALID_FUNCTION : i32 = 5915;
pub const ERROR_CLUSTER_INVALID_STRING_TERMINATION : i32 = 5916;
pub const ERROR_CLUSTER_INVALID_STRING_FORMAT : i32 = 5917;
pub const ERROR_CLUSTER_DATABASE_TRANSACTION_IN_PROGRESS : i32 = 5918;
pub const ERROR_CLUSTER_DATABASE_TRANSACTION_NOT_IN_PROGRESS : i32 = 5919;
pub const ERROR_CLUSTER_NULL_DATA : i32 = 5920;
pub const ERROR_CLUSTER_PARTIAL_READ : i32 = 5921;
pub const ERROR_CLUSTER_PARTIAL_WRITE : i32 = 5922;
pub const ERROR_CLUSTER_CANT_DESERIALIZE_DATA : i32 = 5923;
pub const ERROR_DEPENDENT_RESOURCE_PROPERTY_CONFLICT : i32 = 5924;
pub const ERROR_CLUSTER_NO_QUORUM : i32 = 5925;
pub const ERROR_CLUSTER_INVALID_IPV6_NETWORK : i32 = 5926;
pub const ERROR_CLUSTER_INVALID_IPV6_TUNNEL_NETWORK : i32 = 5927;
pub const ERROR_QUORUM_NOT_ALLOWED_IN_THIS_GROUP : i32 = 5928;
pub const ERROR_DEPENDENCY_TREE_TOO_COMPLEX : i32 = 5929;
pub const ERROR_EXCEPTION_IN_RESOURCE_CALL : i32 = 5930;
pub const ERROR_CLUSTER_RHS_FAILED_INITIALIZATION : i32 = 5931;
pub const ERROR_CLUSTER_NOT_INSTALLED : i32 = 5932;
pub const ERROR_CLUSTER_RESOURCES_MUST_BE_ONLINE_ON_THE_SAME_NODE : i32 = 5933;
pub const ERROR_CLUSTER_MAX_NODES_IN_CLUSTER : i32 = 5934;
pub const ERROR_CLUSTER_TOO_MANY_NODES : i32 = 5935;
pub const ERROR_CLUSTER_OBJECT_ALREADY_USED : i32 = 5936;
pub const ERROR_NONCORE_GROUPS_FOUND : i32 = 5937;
pub const ERROR_FILE_SHARE_RESOURCE_CONFLICT : i32 = 5938;
pub const ERROR_CLUSTER_EVICT_INVALID_REQUEST : i32 = 5939;
pub const ERROR_CLUSTER_SINGLETON_RESOURCE : i32 = 5940;
pub const ERROR_CLUSTER_GROUP_SINGLETON_RESOURCE : i32 = 5941;
pub const ERROR_CLUSTER_RESOURCE_PROVIDER_FAILED : i32 = 5942;
pub const ERROR_CLUSTER_RESOURCE_CONFIGURATION_ERROR : i32 = 5943;
pub const ERROR_CLUSTER_GROUP_BUSY : i32 = 5944;
pub const ERROR_CLUSTER_NOT_SHARED_VOLUME : i32 = 5945;
pub const ERROR_CLUSTER_INVALID_SECURITY_DESCRIPTOR : i32 = 5946;
pub const ERROR_CLUSTER_SHARED_VOLUMES_IN_USE : i32 = 5947;
pub const ERROR_CLUSTER_USE_SHARED_VOLUMES_API : i32 = 5948;
pub const ERROR_CLUSTER_BACKUP_IN_PROGRESS : i32 = 5949;
pub const ERROR_NON_CSV_PATH : i32 = 5950;
pub const ERROR_CSV_VOLUME_NOT_LOCAL : i32 = 5951;
pub const ERROR_CLUSTER_WATCHDOG_TERMINATING : i32 = 5952;
pub const ERROR_CLUSTER_RESOURCE_VETOED_MOVE_INCOMPATIBLE_NODES : i32 = 5953;
pub const ERROR_CLUSTER_INVALID_NODE_WEIGHT : i32 = 5954;
pub const ERROR_CLUSTER_RESOURCE_VETOED_CALL : i32 = 5955;
pub const ERROR_RESMON_SYSTEM_RESOURCES_LACKING : i32 = 5956;
pub const ERROR_CLUSTER_RESOURCE_VETOED_MOVE_NOT_ENOUGH_RESOURCES_ON_DESTINATION : i32 = 5957;
pub const ERROR_CLUSTER_RESOURCE_VETOED_MOVE_NOT_ENOUGH_RESOURCES_ON_SOURCE : i32 = 5958;
pub const ERROR_CLUSTER_GROUP_QUEUED : i32 = 5959;
pub const ERROR_CLUSTER_RESOURCE_LOCKED_STATUS : i32 = 5960;
pub const ERROR_CLUSTER_SHARED_VOLUME_FAILOVER_NOT_ALLOWED : i32 = 5961;
pub const ERROR_CLUSTER_NODE_DRAIN_IN_PROGRESS : i32 = 5962;
pub const ERROR_CLUSTER_DISK_NOT_CONNECTED : i32 = 5963;
pub const ERROR_DISK_NOT_CSV_CAPABLE : i32 = 5964;
pub const ERROR_RESOURCE_NOT_IN_AVAILABLE_STORAGE : i32 = 5965;
pub const ERROR_CLUSTER_SHARED_VOLUME_REDIRECTED : i32 = 5966;
pub const ERROR_CLUSTER_SHARED_VOLUME_NOT_REDIRECTED : i32 = 5967;
pub const ERROR_CLUSTER_CANNOT_RETURN_PROPERTIES : i32 = 5968;
pub const ERROR_CLUSTER_RESOURCE_CONTAINS_UNSUPPORTED_DIFF_AREA_FOR_SHARED_VOLUMES : i32 = 5969;
pub const ERROR_CLUSTER_RESOURCE_IS_IN_MAINTENANCE_MODE : i32 = 5970;
pub const ERROR_CLUSTER_AFFINITY_CONFLICT : i32 = 5971;
pub const ERROR_CLUSTER_RESOURCE_IS_REPLICA_VIRTUAL_MACHINE : i32 = 5972;
pub const ERROR_CLUSTER_UPGRADE_INCOMPATIBLE_VERSIONS : i32 = 5973;
pub const ERROR_CLUSTER_UPGRADE_FIX_QUORUM_NOT_SUPPORTED : i32 = 5974;
pub const ERROR_CLUSTER_UPGRADE_RESTART_REQUIRED : i32 = 5975;
pub const ERROR_CLUSTER_UPGRADE_IN_PROGRESS : i32 = 5976;
pub const ERROR_CLUSTER_UPGRADE_INCOMPLETE : i32 = 5977;
pub const ERROR_CLUSTER_NODE_IN_GRACE_PERIOD : i32 = 5978;
pub const ERROR_CLUSTER_CSV_IO_PAUSE_TIMEOUT : i32 = 5979;
pub const ERROR_NODE_NOT_ACTIVE_CLUSTER_MEMBER : i32 = 5980;
pub const ERROR_CLUSTER_RESOURCE_NOT_MONITORED : i32 = 5981;
pub const ERROR_CLUSTER_RESOURCE_DOES_NOT_SUPPORT_UNMONITORED : i32 = 5982;
pub const ERROR_CLUSTER_RESOURCE_IS_REPLICATED : i32 = 5983;
pub const ERROR_CLUSTER_NODE_ISOLATED : i32 = 5984;
pub const ERROR_CLUSTER_NODE_QUARANTINED : i32 = 5985;
pub const ERROR_CLUSTER_DATABASE_UPDATE_CONDITION_FAILED : i32 = 5986;
pub const ERROR_CLUSTER_SPACE_DEGRADED : i32 = 5987;
pub const ERROR_CLUSTER_TOKEN_DELEGATION_NOT_SUPPORTED : i32 = 5988;
pub const ERROR_CLUSTER_CSV_INVALID_HANDLE : i32 = 5989;
pub const ERROR_CLUSTER_CSV_SUPPORTED_ONLY_ON_COORDINATOR : i32 = 5990;
pub const ERROR_GROUPSET_NOT_AVAILABLE : i32 = 5991;
pub const ERROR_GROUPSET_NOT_FOUND : i32 = 5992;
pub const ERROR_GROUPSET_CANT_PROVIDE : i32 = 5993;
pub const ERROR_CLUSTER_FAULT_DOMAIN_PARENT_NOT_FOUND : i32 = 5994;
pub const ERROR_CLUSTER_FAULT_DOMAIN_INVALID_HIERARCHY : i32 = 5995;
pub const ERROR_CLUSTER_FAULT_DOMAIN_FAILED_S2D_VALIDATION : i32 = 5996;
pub const ERROR_CLUSTER_FAULT_DOMAIN_S2D_CONNECTIVITY_LOSS : i32 = 5997;
pub const ERROR_CLUSTER_INVALID_INFRASTRUCTURE_FILESERVER_NAME : i32 = 5998;
pub const ERROR_CLUSTERSET_MANAGEMENT_CLUSTER_UNREACHABLE : i32 = 5999;
pub const ERROR_ENCRYPTION_FAILED : i32 = 6000;
pub const ERROR_DECRYPTION_FAILED : i32 = 6001;
pub const ERROR_FILE_ENCRYPTED : i32 = 6002;
pub const ERROR_NO_RECOVERY_POLICY : i32 = 6003;
pub const ERROR_NO_EFS : i32 = 6004;
pub const ERROR_WRONG_EFS : i32 = 6005;
pub const ERROR_NO_USER_KEYS : i32 = 6006;
pub const ERROR_FILE_NOT_ENCRYPTED : i32 = 6007;
pub const ERROR_NOT_EXPORT_FORMAT : i32 = 6008;
pub const ERROR_FILE_READ_ONLY : i32 = 6009;
pub const ERROR_DIR_EFS_DISALLOWED : i32 = 6010;
pub const ERROR_EFS_SERVER_NOT_TRUSTED : i32 = 6011;
pub const ERROR_BAD_RECOVERY_POLICY : i32 = 6012;
pub const ERROR_EFS_ALG_BLOB_TOO_BIG : i32 = 6013;
pub const ERROR_VOLUME_NOT_SUPPORT_EFS : i32 = 6014;
pub const ERROR_EFS_DISABLED : i32 = 6015;
pub const ERROR_EFS_VERSION_NOT_SUPPORT : i32 = 6016;
pub const ERROR_CS_ENCRYPTION_INVALID_SERVER_RESPONSE : i32 = 6017;
pub const ERROR_CS_ENCRYPTION_UNSUPPORTED_SERVER : i32 = 6018;
pub const ERROR_CS_ENCRYPTION_EXISTING_ENCRYPTED_FILE : i32 = 6019;
pub const ERROR_CS_ENCRYPTION_NEW_ENCRYPTED_FILE : i32 = 6020;
pub const ERROR_CS_ENCRYPTION_FILE_NOT_CSE : i32 = 6021;
pub const ERROR_ENCRYPTION_POLICY_DENIES_OPERATION : i32 = 6022;
pub const ERROR_WIP_ENCRYPTION_FAILED : i32 = 6023;
pub const ERROR_NO_BROWSER_SERVERS_FOUND : i32 = 6118;
pub const SCHED_E_SERVICE_NOT_LOCALSYSTEM : i32 = 6200;
pub const ERROR_CLUSTER_OBJECT_IS_CLUSTER_SET_VM : i32 = 6250;
pub const ERROR_LOG_SECTOR_INVALID : i32 = 6600;
pub const ERROR_LOG_SECTOR_PARITY_INVALID : i32 = 6601;
pub const ERROR_LOG_SECTOR_REMAPPED : i32 = 6602;
pub const ERROR_LOG_BLOCK_INCOMPLETE : i32 = 6603;
pub const ERROR_LOG_INVALID_RANGE : i32 = 6604;
pub const ERROR_LOG_BLOCKS_EXHAUSTED : i32 = 6605;
pub const ERROR_LOG_READ_CONTEXT_INVALID : i32 = 6606;
pub const ERROR_LOG_RESTART_INVALID : i32 = 6607;
pub const ERROR_LOG_BLOCK_VERSION : i32 = 6608;
pub const ERROR_LOG_BLOCK_INVALID : i32 = 6609;
pub const ERROR_LOG_READ_MODE_INVALID : i32 = 6610;
pub const ERROR_LOG_NO_RESTART : i32 = 6611;
pub const ERROR_LOG_METADATA_CORRUPT : i32 = 6612;
pub const ERROR_LOG_METADATA_INVALID : i32 = 6613;
pub const ERROR_LOG_METADATA_INCONSISTENT : i32 = 6614;
pub const ERROR_LOG_RESERVATION_INVALID : i32 = 6615;
pub const ERROR_LOG_CANT_DELETE : i32 = 6616;
pub const ERROR_LOG_CONTAINER_LIMIT_EXCEEDED : i32 = 6617;
pub const ERROR_LOG_START_OF_LOG : i32 = 6618;
pub const ERROR_LOG_POLICY_ALREADY_INSTALLED : i32 = 6619;
pub const ERROR_LOG_POLICY_NOT_INSTALLED : i32 = 6620;
pub const ERROR_LOG_POLICY_INVALID : i32 = 6621;
pub const ERROR_LOG_POLICY_CONFLICT : i32 = 6622;
pub const ERROR_LOG_PINNED_ARCHIVE_TAIL : i32 = 6623;
pub const ERROR_LOG_RECORD_NONEXISTENT : i32 = 6624;
pub const ERROR_LOG_RECORDS_RESERVED_INVALID : i32 = 6625;
pub const ERROR_LOG_SPACE_RESERVED_INVALID : i32 = 6626;
pub const ERROR_LOG_TAIL_INVALID : i32 = 6627;
pub const ERROR_LOG_FULL : i32 = 6628;
pub const ERROR_COULD_NOT_RESIZE_LOG : i32 = 6629;
pub const ERROR_LOG_MULTIPLEXED : i32 = 6630;
pub const ERROR_LOG_DEDICATED : i32 = 6631;
pub const ERROR_LOG_ARCHIVE_NOT_IN_PROGRESS : i32 = 6632;
pub const ERROR_LOG_ARCHIVE_IN_PROGRESS : i32 = 6633;
pub const ERROR_LOG_EPHEMERAL : i32 = 6634;
pub const ERROR_LOG_NOT_ENOUGH_CONTAINERS : i32 = 6635;
pub const ERROR_LOG_CLIENT_ALREADY_REGISTERED : i32 = 6636;
pub const ERROR_LOG_CLIENT_NOT_REGISTERED : i32 = 6637;
pub const ERROR_LOG_FULL_HANDLER_IN_PROGRESS : i32 = 6638;
pub const ERROR_LOG_CONTAINER_READ_FAILED : i32 = 6639;
pub const ERROR_LOG_CONTAINER_WRITE_FAILED : i32 = 6640;
pub const ERROR_LOG_CONTAINER_OPEN_FAILED : i32 = 6641;
pub const ERROR_LOG_CONTAINER_STATE_INVALID : i32 = 6642;
pub const ERROR_LOG_STATE_INVALID : i32 = 6643;
pub const ERROR_LOG_PINNED : i32 = 6644;
pub const ERROR_LOG_METADATA_FLUSH_FAILED : i32 = 6645;
pub const ERROR_LOG_INCONSISTENT_SECURITY : i32 = 6646;
pub const ERROR_LOG_APPENDED_FLUSH_FAILED : i32 = 6647;
pub const ERROR_LOG_PINNED_RESERVATION : i32 = 6648;
pub const ERROR_INVALID_TRANSACTION : i32 = 6700;
pub const ERROR_TRANSACTION_NOT_ACTIVE : i32 = 6701;
pub const ERROR_TRANSACTION_REQUEST_NOT_VALID : i32 = 6702;
pub const ERROR_TRANSACTION_NOT_REQUESTED : i32 = 6703;
pub const ERROR_TRANSACTION_ALREADY_ABORTED : i32 = 6704;
pub const ERROR_TRANSACTION_ALREADY_COMMITTED : i32 = 6705;
pub const ERROR_TM_INITIALIZATION_FAILED : i32 = 6706;
pub const ERROR_RESOURCEMANAGER_READ_ONLY : i32 = 6707;
pub const ERROR_TRANSACTION_NOT_JOINED : i32 = 6708;
pub const ERROR_TRANSACTION_SUPERIOR_EXISTS : i32 = 6709;
pub const ERROR_CRM_PROTOCOL_ALREADY_EXISTS : i32 = 6710;
pub const ERROR_TRANSACTION_PROPAGATION_FAILED : i32 = 6711;
pub const ERROR_CRM_PROTOCOL_NOT_FOUND : i32 = 6712;
pub const ERROR_TRANSACTION_INVALID_MARSHALL_BUFFER : i32 = 6713;
pub const ERROR_CURRENT_TRANSACTION_NOT_VALID : i32 = 6714;
pub const ERROR_TRANSACTION_NOT_FOUND : i32 = 6715;
pub const ERROR_RESOURCEMANAGER_NOT_FOUND : i32 = 6716;
pub const ERROR_ENLISTMENT_NOT_FOUND : i32 = 6717;
pub const ERROR_TRANSACTIONMANAGER_NOT_FOUND : i32 = 6718;
pub const ERROR_TRANSACTIONMANAGER_NOT_ONLINE : i32 = 6719;
pub const ERROR_TRANSACTIONMANAGER_RECOVERY_NAME_COLLISION : i32 = 6720;
pub const ERROR_TRANSACTION_NOT_ROOT : i32 = 6721;
pub const ERROR_TRANSACTION_OBJECT_EXPIRED : i32 = 6722;
pub const ERROR_TRANSACTION_RESPONSE_NOT_ENLISTED : i32 = 6723;
pub const ERROR_TRANSACTION_RECORD_TOO_LONG : i32 = 6724;
pub const ERROR_IMPLICIT_TRANSACTION_NOT_SUPPORTED : i32 = 6725;
pub const ERROR_TRANSACTION_INTEGRITY_VIOLATED : i32 = 6726;
pub const ERROR_TRANSACTIONMANAGER_IDENTITY_MISMATCH : i32 = 6727;
pub const ERROR_RM_CANNOT_BE_FROZEN_FOR_SNAPSHOT : i32 = 6728;
pub const ERROR_TRANSACTION_MUST_WRITETHROUGH : i32 = 6729;
pub const ERROR_TRANSACTION_NO_SUPERIOR : i32 = 6730;
pub const ERROR_HEURISTIC_DAMAGE_POSSIBLE : i32 = 6731;
pub const ERROR_TRANSACTIONAL_CONFLICT : i32 = 6800;
pub const ERROR_RM_NOT_ACTIVE : i32 = 6801;
pub const ERROR_RM_METADATA_CORRUPT : i32 = 6802;
pub const ERROR_DIRECTORY_NOT_RM : i32 = 6803;
pub const ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE : i32 = 6805;
pub const ERROR_LOG_RESIZE_INVALID_SIZE : i32 = 6806;
pub const ERROR_OBJECT_NO_LONGER_EXISTS : i32 = 6807;
pub const ERROR_STREAM_MINIVERSION_NOT_FOUND : i32 = 6808;
pub const ERROR_STREAM_MINIVERSION_NOT_VALID : i32 = 6809;
pub const ERROR_MINIVERSION_INACCESSIBLE_FROM_SPECIFIED_TRANSACTION : i32 = 6810;
pub const ERROR_CANT_OPEN_MINIVERSION_WITH_MODIFY_INTENT : i32 = 6811;
pub const ERROR_CANT_CREATE_MORE_STREAM_MINIVERSIONS : i32 = 6812;
pub const ERROR_REMOTE_FILE_VERSION_MISMATCH : i32 = 6814;
pub const ERROR_HANDLE_NO_LONGER_VALID : i32 = 6815;
pub const ERROR_NO_TXF_METADATA : i32 = 6816;
pub const ERROR_LOG_CORRUPTION_DETECTED : i32 = 6817;
pub const ERROR_CANT_RECOVER_WITH_HANDLE_OPEN : i32 = 6818;
pub const ERROR_RM_DISCONNECTED : i32 = 6819;
pub const ERROR_ENLISTMENT_NOT_SUPERIOR : i32 = 6820;
pub const ERROR_RECOVERY_NOT_NEEDED : i32 = 6821;
pub const ERROR_RM_ALREADY_STARTED : i32 = 6822;
pub const ERROR_FILE_IDENTITY_NOT_PERSISTENT : i32 = 6823;
pub const ERROR_CANT_BREAK_TRANSACTIONAL_DEPENDENCY : i32 = 6824;
pub const ERROR_CANT_CROSS_RM_BOUNDARY : i32 = 6825;
pub const ERROR_TXF_DIR_NOT_EMPTY : i32 = 6826;
pub const ERROR_INDOUBT_TRANSACTIONS_EXIST : i32 = 6827;
pub const ERROR_TM_VOLATILE : i32 = 6828;
pub const ERROR_ROLLBACK_TIMER_EXPIRED : i32 = 6829;
pub const ERROR_TXF_ATTRIBUTE_CORRUPT : i32 = 6830;
pub const ERROR_EFS_NOT_ALLOWED_IN_TRANSACTION : i32 = 6831;
pub const ERROR_TRANSACTIONAL_OPEN_NOT_ALLOWED : i32 = 6832;
pub const ERROR_LOG_GROWTH_FAILED : i32 = 6833;
pub const ERROR_TRANSACTED_MAPPING_UNSUPPORTED_REMOTE : i32 = 6834;
pub const ERROR_TXF_METADATA_ALREADY_PRESENT : i32 = 6835;
pub const ERROR_TRANSACTION_SCOPE_CALLBACKS_NOT_SET : i32 = 6836;
pub const ERROR_TRANSACTION_REQUIRED_PROMOTION : i32 = 6837;
pub const ERROR_CANNOT_EXECUTE_FILE_IN_TRANSACTION : i32 = 6838;
pub const ERROR_TRANSACTIONS_NOT_FROZEN : i32 = 6839;
pub const ERROR_TRANSACTION_FREEZE_IN_PROGRESS : i32 = 6840;
pub const ERROR_NOT_SNAPSHOT_VOLUME : i32 = 6841;
pub const ERROR_NO_SAVEPOINT_WITH_OPEN_FILES : i32 = 6842;
pub const ERROR_DATA_LOST_REPAIR : i32 = 6843;
pub const ERROR_SPARSE_NOT_ALLOWED_IN_TRANSACTION : i32 = 6844;
pub const ERROR_TM_IDENTITY_MISMATCH : i32 = 6845;
pub const ERROR_FLOATED_SECTION : i32 = 6846;
pub const ERROR_CANNOT_ACCEPT_TRANSACTED_WORK : i32 = 6847;
pub const ERROR_CANNOT_ABORT_TRANSACTIONS : i32 = 6848;
pub const ERROR_BAD_CLUSTERS : i32 = 6849;
pub const ERROR_COMPRESSION_NOT_ALLOWED_IN_TRANSACTION : i32 = 6850;
pub const ERROR_VOLUME_DIRTY : i32 = 6851;
pub const ERROR_NO_LINK_TRACKING_IN_TRANSACTION : i32 = 6852;
pub const ERROR_OPERATION_NOT_SUPPORTED_IN_TRANSACTION : i32 = 6853;
pub const ERROR_EXPIRED_HANDLE : i32 = 6854;
pub const ERROR_TRANSACTION_NOT_ENLISTED : i32 = 6855;
pub const ERROR_CTX_WINSTATION_NAME_INVALID : i32 = 7001;
pub const ERROR_CTX_INVALID_PD : i32 = 7002;
pub const ERROR_CTX_PD_NOT_FOUND : i32 = 7003;
pub const ERROR_CTX_WD_NOT_FOUND : i32 = 7004;
pub const ERROR_CTX_CANNOT_MAKE_EVENTLOG_ENTRY : i32 = 7005;
pub const ERROR_CTX_SERVICE_NAME_COLLISION : i32 = 7006;
pub const ERROR_CTX_CLOSE_PENDING : i32 = 7007;
pub const ERROR_CTX_NO_OUTBUF : i32 = 7008;
pub const ERROR_CTX_MODEM_INF_NOT_FOUND : i32 = 7009;
pub const ERROR_CTX_INVALID_MODEMNAME : i32 = 7010;
pub const ERROR_CTX_MODEM_RESPONSE_ERROR : i32 = 7011;
pub const ERROR_CTX_MODEM_RESPONSE_TIMEOUT : i32 = 7012;
pub const ERROR_CTX_MODEM_RESPONSE_NO_CARRIER : i32 = 7013;
pub const ERROR_CTX_MODEM_RESPONSE_NO_DIALTONE : i32 = 7014;
pub const ERROR_CTX_MODEM_RESPONSE_BUSY : i32 = 7015;
pub const ERROR_CTX_MODEM_RESPONSE_VOICE : i32 = 7016;
pub const ERROR_CTX_TD_ERROR : i32 = 7017;
pub const ERROR_CTX_WINSTATION_NOT_FOUND : i32 = 7022;
pub const ERROR_CTX_WINSTATION_ALREADY_EXISTS : i32 = 7023;
pub const ERROR_CTX_WINSTATION_BUSY : i32 = 7024;
pub const ERROR_CTX_BAD_VIDEO_MODE : i32 = 7025;
pub const ERROR_CTX_GRAPHICS_INVALID : i32 = 7035;
pub const ERROR_CTX_LOGON_DISABLED : i32 = 7037;
pub const ERROR_CTX_NOT_CONSOLE : i32 = 7038;
pub const ERROR_CTX_CLIENT_QUERY_TIMEOUT : i32 = 7040;
pub const ERROR_CTX_CONSOLE_DISCONNECT : i32 = 7041;
pub const ERROR_CTX_CONSOLE_CONNECT : i32 = 7042;
pub const ERROR_CTX_SHADOW_DENIED : i32 = 7044;
pub const ERROR_CTX_WINSTATION_ACCESS_DENIED : i32 = 7045;
pub const ERROR_CTX_INVALID_WD : i32 = 7049;
pub const ERROR_CTX_SHADOW_INVALID : i32 = 7050;
pub const ERROR_CTX_SHADOW_DISABLED : i32 = 7051;
pub const ERROR_CTX_CLIENT_LICENSE_IN_USE : i32 = 7052;
pub const ERROR_CTX_CLIENT_LICENSE_NOT_SET : i32 = 7053;
pub const ERROR_CTX_LICENSE_NOT_AVAILABLE : i32 = 7054;
pub const ERROR_CTX_LICENSE_CLIENT_INVALID : i32 = 7055;
pub const ERROR_CTX_LICENSE_EXPIRED : i32 = 7056;
pub const ERROR_CTX_SHADOW_NOT_RUNNING : i32 = 7057;
pub const ERROR_CTX_SHADOW_ENDED_BY_MODE_CHANGE : i32 = 7058;
pub const ERROR_ACTIVATION_COUNT_EXCEEDED : i32 = 7059;
pub const ERROR_CTX_WINSTATIONS_DISABLED : i32 = 7060;
pub const ERROR_CTX_ENCRYPTION_LEVEL_REQUIRED : i32 = 7061;
pub const ERROR_CTX_SESSION_IN_USE : i32 = 7062;
pub const ERROR_CTX_NO_FORCE_LOGOFF : i32 = 7063;
pub const ERROR_CTX_ACCOUNT_RESTRICTION : i32 = 7064;
pub const ERROR_RDP_PROTOCOL_ERROR : i32 = 7065;
pub const ERROR_CTX_CDM_CONNECT : i32 = 7066;
pub const ERROR_CTX_CDM_DISCONNECT : i32 = 7067;
pub const ERROR_CTX_SECURITY_LAYER_ERROR : i32 = 7068;
pub const ERROR_TS_INCOMPATIBLE_SESSIONS : i32 = 7069;
pub const ERROR_TS_VIDEO_SUBSYSTEM_ERROR : i32 = 7070;
pub const FRS_ERR_INVALID_API_SEQUENCE : i32 = 8001;
pub const FRS_ERR_STARTING_SERVICE : i32 = 8002;
pub const FRS_ERR_STOPPING_SERVICE : i32 = 8003;
pub const FRS_ERR_INTERNAL_API : i32 = 8004;
pub const FRS_ERR_INTERNAL : i32 = 8005;
pub const FRS_ERR_SERVICE_COMM : i32 = 8006;
pub const FRS_ERR_INSUFFICIENT_PRIV : i32 = 8007;
pub const FRS_ERR_AUTHENTICATION : i32 = 8008;
pub const FRS_ERR_PARENT_INSUFFICIENT_PRIV : i32 = 8009;
pub const FRS_ERR_PARENT_AUTHENTICATION : i32 = 8010;
pub const FRS_ERR_CHILD_TO_PARENT_COMM : i32 = 8011;
pub const FRS_ERR_PARENT_TO_CHILD_COMM : i32 = 8012;
pub const FRS_ERR_SYSVOL_POPULATE : i32 = 8013;
pub const FRS_ERR_SYSVOL_POPULATE_TIMEOUT : i32 = 8014;
pub const FRS_ERR_SYSVOL_IS_BUSY : i32 = 8015;
pub const FRS_ERR_SYSVOL_DEMOTE : i32 = 8016;
pub const FRS_ERR_INVALID_SERVICE_PARAMETER : i32 = 8017;
pub const ERROR_DS_NOT_INSTALLED : i32 = 8200;
pub const ERROR_DS_MEMBERSHIP_EVALUATED_LOCALLY : i32 = 8201;
pub const ERROR_DS_NO_ATTRIBUTE_OR_VALUE : i32 = 8202;
pub const ERROR_DS_INVALID_ATTRIBUTE_SYNTAX : i32 = 8203;
pub const ERROR_DS_ATTRIBUTE_TYPE_UNDEFINED : i32 = 8204;
pub const ERROR_DS_ATTRIBUTE_OR_VALUE_EXISTS : i32 = 8205;
pub const ERROR_DS_BUSY : i32 = 8206;
pub const ERROR_DS_UNAVAILABLE : i32 = 8207;
pub const ERROR_DS_NO_RIDS_ALLOCATED : i32 = 8208;
pub const ERROR_DS_NO_MORE_RIDS : i32 = 8209;
pub const ERROR_DS_INCORRECT_ROLE_OWNER : i32 = 8210;
pub const ERROR_DS_RIDMGR_INIT_ERROR : i32 = 8211;
pub const ERROR_DS_OBJ_CLASS_VIOLATION : i32 = 8212;
pub const ERROR_DS_CANT_ON_NON_LEAF : i32 = 8213;
pub const ERROR_DS_CANT_ON_RDN : i32 = 8214;
pub const ERROR_DS_CANT_MOD_OBJ_CLASS : i32 = 8215;
pub const ERROR_DS_CROSS_DOM_MOVE_ERROR : i32 = 8216;
pub const ERROR_DS_GC_NOT_AVAILABLE : i32 = 8217;
pub const ERROR_SHARED_POLICY : i32 = 8218;
pub const ERROR_POLICY_OBJECT_NOT_FOUND : i32 = 8219;
pub const ERROR_POLICY_ONLY_IN_DS : i32 = 8220;
pub const ERROR_PROMOTION_ACTIVE : i32 = 8221;
pub const ERROR_NO_PROMOTION_ACTIVE : i32 = 8222;
pub const ERROR_DS_OPERATIONS_ERROR : i32 = 8224;
pub const ERROR_DS_PROTOCOL_ERROR : i32 = 8225;
pub const ERROR_DS_TIMELIMIT_EXCEEDED : i32 = 8226;
pub const ERROR_DS_SIZELIMIT_EXCEEDED : i32 = 8227;
pub const ERROR_DS_ADMIN_LIMIT_EXCEEDED : i32 = 8228;
pub const ERROR_DS_COMPARE_FALSE : i32 = 8229;
pub const ERROR_DS_COMPARE_TRUE : i32 = 8230;
pub const ERROR_DS_AUTH_METHOD_NOT_SUPPORTED : i32 = 8231;
pub const ERROR_DS_STRONG_AUTH_REQUIRED : i32 = 8232;
pub const ERROR_DS_INAPPROPRIATE_AUTH : i32 = 8233;
pub const ERROR_DS_AUTH_UNKNOWN : i32 = 8234;
pub const ERROR_DS_REFERRAL : i32 = 8235;
pub const ERROR_DS_UNAVAILABLE_CRIT_EXTENSION : i32 = 8236;
pub const ERROR_DS_CONFIDENTIALITY_REQUIRED : i32 = 8237;
pub const ERROR_DS_INAPPROPRIATE_MATCHING : i32 = 8238;
pub const ERROR_DS_CONSTRAINT_VIOLATION : i32 = 8239;
pub const ERROR_DS_NO_SUCH_OBJECT : i32 = 8240;
pub const ERROR_DS_ALIAS_PROBLEM : i32 = 8241;
pub const ERROR_DS_INVALID_DN_SYNTAX : i32 = 8242;
pub const ERROR_DS_IS_LEAF : i32 = 8243;
pub const ERROR_DS_ALIAS_DEREF_PROBLEM : i32 = 8244;
pub const ERROR_DS_UNWILLING_TO_PERFORM : i32 = 8245;
pub const ERROR_DS_LOOP_DETECT : i32 = 8246;
pub const ERROR_DS_NAMING_VIOLATION : i32 = 8247;
pub const ERROR_DS_OBJECT_RESULTS_TOO_LARGE : i32 = 8248;
pub const ERROR_DS_AFFECTS_MULTIPLE_DSAS : i32 = 8249;
pub const ERROR_DS_SERVER_DOWN : i32 = 8250;
pub const ERROR_DS_LOCAL_ERROR : i32 = 8251;
pub const ERROR_DS_ENCODING_ERROR : i32 = 8252;
pub const ERROR_DS_DECODING_ERROR : i32 = 8253;
pub const ERROR_DS_FILTER_UNKNOWN : i32 = 8254;
pub const ERROR_DS_PARAM_ERROR : i32 = 8255;
pub const ERROR_DS_NOT_SUPPORTED : i32 = 8256;
pub const ERROR_DS_NO_RESULTS_RETURNED : i32 = 8257;
pub const ERROR_DS_CONTROL_NOT_FOUND : i32 = 8258;
pub const ERROR_DS_CLIENT_LOOP : i32 = 8259;
pub const ERROR_DS_REFERRAL_LIMIT_EXCEEDED : i32 = 8260;
pub const ERROR_DS_SORT_CONTROL_MISSING : i32 = 8261;
pub const ERROR_DS_OFFSET_RANGE_ERROR : i32 = 8262;
pub const ERROR_DS_RIDMGR_DISABLED : i32 = 8263;
pub const ERROR_DS_ROOT_MUST_BE_NC : i32 = 8301;
pub const ERROR_DS_ADD_REPLICA_INHIBITED : i32 = 8302;
pub const ERROR_DS_ATT_NOT_DEF_IN_SCHEMA : i32 = 8303;
pub const ERROR_DS_MAX_OBJ_SIZE_EXCEEDED : i32 = 8304;
pub const ERROR_DS_OBJ_STRING_NAME_EXISTS : i32 = 8305;
pub const ERROR_DS_NO_RDN_DEFINED_IN_SCHEMA : i32 = 8306;
pub const ERROR_DS_RDN_DOESNT_MATCH_SCHEMA : i32 = 8307;
pub const ERROR_DS_NO_REQUESTED_ATTS_FOUND : i32 = 8308;
pub const ERROR_DS_USER_BUFFER_TO_SMALL : i32 = 8309;
pub const ERROR_DS_ATT_IS_NOT_ON_OBJ : i32 = 8310;
pub const ERROR_DS_ILLEGAL_MOD_OPERATION : i32 = 8311;
pub const ERROR_DS_OBJ_TOO_LARGE : i32 = 8312;
pub const ERROR_DS_BAD_INSTANCE_TYPE : i32 = 8313;
pub const ERROR_DS_MASTERDSA_REQUIRED : i32 = 8314;
pub const ERROR_DS_OBJECT_CLASS_REQUIRED : i32 = 8315;
pub const ERROR_DS_MISSING_REQUIRED_ATT : i32 = 8316;
pub const ERROR_DS_ATT_NOT_DEF_FOR_CLASS : i32 = 8317;
pub const ERROR_DS_ATT_ALREADY_EXISTS : i32 = 8318;
pub const ERROR_DS_CANT_ADD_ATT_VALUES : i32 = 8320;
pub const ERROR_DS_SINGLE_VALUE_CONSTRAINT : i32 = 8321;
pub const ERROR_DS_RANGE_CONSTRAINT : i32 = 8322;
pub const ERROR_DS_ATT_VAL_ALREADY_EXISTS : i32 = 8323;
pub const ERROR_DS_CANT_REM_MISSING_ATT : i32 = 8324;
pub const ERROR_DS_CANT_REM_MISSING_ATT_VAL : i32 = 8325;
pub const ERROR_DS_ROOT_CANT_BE_SUBREF : i32 = 8326;
pub const ERROR_DS_NO_CHAINING : i32 = 8327;
pub const ERROR_DS_NO_CHAINED_EVAL : i32 = 8328;
pub const ERROR_DS_NO_PARENT_OBJECT : i32 = 8329;
pub const ERROR_DS_PARENT_IS_AN_ALIAS : i32 = 8330;
pub const ERROR_DS_CANT_MIX_MASTER_AND_REPS : i32 = 8331;
pub const ERROR_DS_CHILDREN_EXIST : i32 = 8332;
pub const ERROR_DS_OBJ_NOT_FOUND : i32 = 8333;
pub const ERROR_DS_ALIASED_OBJ_MISSING : i32 = 8334;
pub const ERROR_DS_BAD_NAME_SYNTAX : i32 = 8335;
pub const ERROR_DS_ALIAS_POINTS_TO_ALIAS : i32 = 8336;
pub const ERROR_DS_CANT_DEREF_ALIAS : i32 = 8337;
pub const ERROR_DS_OUT_OF_SCOPE : i32 = 8338;
pub const ERROR_DS_OBJECT_BEING_REMOVED : i32 = 8339;
pub const ERROR_DS_CANT_DELETE_DSA_OBJ : i32 = 8340;
pub const ERROR_DS_GENERIC_ERROR : i32 = 8341;
pub const ERROR_DS_DSA_MUST_BE_INT_MASTER : i32 = 8342;
pub const ERROR_DS_CLASS_NOT_DSA : i32 = 8343;
pub const ERROR_DS_INSUFF_ACCESS_RIGHTS : i32 = 8344;
pub const ERROR_DS_ILLEGAL_SUPERIOR : i32 = 8345;
pub const ERROR_DS_ATTRIBUTE_OWNED_BY_SAM : i32 = 8346;
pub const ERROR_DS_NAME_TOO_MANY_PARTS : i32 = 8347;
pub const ERROR_DS_NAME_TOO_LONG : i32 = 8348;
pub const ERROR_DS_NAME_VALUE_TOO_LONG : i32 = 8349;
pub const ERROR_DS_NAME_UNPARSEABLE : i32 = 8350;
pub const ERROR_DS_NAME_TYPE_UNKNOWN : i32 = 8351;
pub const ERROR_DS_NOT_AN_OBJECT : i32 = 8352;
pub const ERROR_DS_SEC_DESC_TOO_SHORT : i32 = 8353;
pub const ERROR_DS_SEC_DESC_INVALID : i32 = 8354;
pub const ERROR_DS_NO_DELETED_NAME : i32 = 8355;
pub const ERROR_DS_SUBREF_MUST_HAVE_PARENT : i32 = 8356;
pub const ERROR_DS_NCNAME_MUST_BE_NC : i32 = 8357;
pub const ERROR_DS_CANT_ADD_SYSTEM_ONLY : i32 = 8358;
pub const ERROR_DS_CLASS_MUST_BE_CONCRETE : i32 = 8359;
pub const ERROR_DS_INVALID_DMD : i32 = 8360;
pub const ERROR_DS_OBJ_GUID_EXISTS : i32 = 8361;
pub const ERROR_DS_NOT_ON_BACKLINK : i32 = 8362;
pub const ERROR_DS_NO_CROSSREF_FOR_NC : i32 = 8363;
pub const ERROR_DS_SHUTTING_DOWN : i32 = 8364;
pub const ERROR_DS_UNKNOWN_OPERATION : i32 = 8365;
pub const ERROR_DS_INVALID_ROLE_OWNER : i32 = 8366;
pub const ERROR_DS_COULDNT_CONTACT_FSMO : i32 = 8367;
pub const ERROR_DS_CROSS_NC_DN_RENAME : i32 = 8368;
pub const ERROR_DS_CANT_MOD_SYSTEM_ONLY : i32 = 8369;
pub const ERROR_DS_REPLICATOR_ONLY : i32 = 8370;
pub const ERROR_DS_OBJ_CLASS_NOT_DEFINED : i32 = 8371;
pub const ERROR_DS_OBJ_CLASS_NOT_SUBCLASS : i32 = 8372;
pub const ERROR_DS_NAME_REFERENCE_INVALID : i32 = 8373;
pub const ERROR_DS_CROSS_REF_EXISTS : i32 = 8374;
pub const ERROR_DS_CANT_DEL_MASTER_CROSSREF : i32 = 8375;
pub const ERROR_DS_SUBTREE_NOTIFY_NOT_NC_HEAD : i32 = 8376;
pub const ERROR_DS_NOTIFY_FILTER_TOO_COMPLEX : i32 = 8377;
pub const ERROR_DS_DUP_RDN : i32 = 8378;
pub const ERROR_DS_DUP_OID : i32 = 8379;
pub const ERROR_DS_DUP_MAPI_ID : i32 = 8380;
pub const ERROR_DS_DUP_SCHEMA_ID_GUID : i32 = 8381;
pub const ERROR_DS_DUP_LDAP_DISPLAY_NAME : i32 = 8382;
pub const ERROR_DS_SEMANTIC_ATT_TEST : i32 = 8383;
pub const ERROR_DS_SYNTAX_MISMATCH : i32 = 8384;
pub const ERROR_DS_EXISTS_IN_MUST_HAVE : i32 = 8385;
pub const ERROR_DS_EXISTS_IN_MAY_HAVE : i32 = 8386;
pub const ERROR_DS_NONEXISTENT_MAY_HAVE : i32 = 8387;
pub const ERROR_DS_NONEXISTENT_MUST_HAVE : i32 = 8388;
pub const ERROR_DS_AUX_CLS_TEST_FAIL : i32 = 8389;
pub const ERROR_DS_NONEXISTENT_POSS_SUP : i32 = 8390;
pub const ERROR_DS_SUB_CLS_TEST_FAIL : i32 = 8391;
pub const ERROR_DS_BAD_RDN_ATT_ID_SYNTAX : i32 = 8392;
pub const ERROR_DS_EXISTS_IN_AUX_CLS : i32 = 8393;
pub const ERROR_DS_EXISTS_IN_SUB_CLS : i32 = 8394;
pub const ERROR_DS_EXISTS_IN_POSS_SUP : i32 = 8395;
pub const ERROR_DS_RECALCSCHEMA_FAILED : i32 = 8396;
pub const ERROR_DS_TREE_DELETE_NOT_FINISHED : i32 = 8397;
pub const ERROR_DS_CANT_DELETE : i32 = 8398;
pub const ERROR_DS_ATT_SCHEMA_REQ_ID : i32 = 8399;
pub const ERROR_DS_BAD_ATT_SCHEMA_SYNTAX : i32 = 8400;
pub const ERROR_DS_CANT_CACHE_ATT : i32 = 8401;
pub const ERROR_DS_CANT_CACHE_CLASS : i32 = 8402;
pub const ERROR_DS_CANT_REMOVE_ATT_CACHE : i32 = 8403;
pub const ERROR_DS_CANT_REMOVE_CLASS_CACHE : i32 = 8404;
pub const ERROR_DS_CANT_RETRIEVE_DN : i32 = 8405;
pub const ERROR_DS_MISSING_SUPREF : i32 = 8406;
pub const ERROR_DS_CANT_RETRIEVE_INSTANCE : i32 = 8407;
pub const ERROR_DS_CODE_INCONSISTENCY : i32 = 8408;
pub const ERROR_DS_DATABASE_ERROR : i32 = 8409;
pub const ERROR_DS_GOVERNSID_MISSING : i32 = 8410;
pub const ERROR_DS_MISSING_EXPECTED_ATT : i32 = 8411;
pub const ERROR_DS_NCNAME_MISSING_CR_REF : i32 = 8412;
pub const ERROR_DS_SECURITY_CHECKING_ERROR : i32 = 8413;
pub const ERROR_DS_SCHEMA_NOT_LOADED : i32 = 8414;
pub const ERROR_DS_SCHEMA_ALLOC_FAILED : i32 = 8415;
pub const ERROR_DS_ATT_SCHEMA_REQ_SYNTAX : i32 = 8416;
pub const ERROR_DS_GCVERIFY_ERROR : i32 = 8417;
pub const ERROR_DS_DRA_SCHEMA_MISMATCH : i32 = 8418;
pub const ERROR_DS_CANT_FIND_DSA_OBJ : i32 = 8419;
pub const ERROR_DS_CANT_FIND_EXPECTED_NC : i32 = 8420;
pub const ERROR_DS_CANT_FIND_NC_IN_CACHE : i32 = 8421;
pub const ERROR_DS_CANT_RETRIEVE_CHILD : i32 = 8422;
pub const ERROR_DS_SECURITY_ILLEGAL_MODIFY : i32 = 8423;
pub const ERROR_DS_CANT_REPLACE_HIDDEN_REC : i32 = 8424;
pub const ERROR_DS_BAD_HIERARCHY_FILE : i32 = 8425;
pub const ERROR_DS_BUILD_HIERARCHY_TABLE_FAILED : i32 = 8426;
pub const ERROR_DS_CONFIG_PARAM_MISSING : i32 = 8427;
pub const ERROR_DS_COUNTING_AB_INDICES_FAILED : i32 = 8428;
pub const ERROR_DS_HIERARCHY_TABLE_MALLOC_FAILED : i32 = 8429;
pub const ERROR_DS_INTERNAL_FAILURE : i32 = 8430;
pub const ERROR_DS_UNKNOWN_ERROR : i32 = 8431;
pub const ERROR_DS_ROOT_REQUIRES_CLASS_TOP : i32 = 8432;
pub const ERROR_DS_REFUSING_FSMO_ROLES : i32 = 8433;
pub const ERROR_DS_MISSING_FSMO_SETTINGS : i32 = 8434;
pub const ERROR_DS_UNABLE_TO_SURRENDER_ROLES : i32 = 8435;
pub const ERROR_DS_DRA_GENERIC : i32 = 8436;
pub const ERROR_DS_DRA_INVALID_PARAMETER : i32 = 8437;
pub const ERROR_DS_DRA_BUSY : i32 = 8438;
pub const ERROR_DS_DRA_BAD_DN : i32 = 8439;
pub const ERROR_DS_DRA_BAD_NC : i32 = 8440;
pub const ERROR_DS_DRA_DN_EXISTS : i32 = 8441;
pub const ERROR_DS_DRA_INTERNAL_ERROR : i32 = 8442;
pub const ERROR_DS_DRA_INCONSISTENT_DIT : i32 = 8443;
pub const ERROR_DS_DRA_CONNECTION_FAILED : i32 = 8444;
pub const ERROR_DS_DRA_BAD_INSTANCE_TYPE : i32 = 8445;
pub const ERROR_DS_DRA_OUT_OF_MEM : i32 = 8446;
pub const ERROR_DS_DRA_MAIL_PROBLEM : i32 = 8447;
pub const ERROR_DS_DRA_REF_ALREADY_EXISTS : i32 = 8448;
pub const ERROR_DS_DRA_REF_NOT_FOUND : i32 = 8449;
pub const ERROR_DS_DRA_OBJ_IS_REP_SOURCE : i32 = 8450;
pub const ERROR_DS_DRA_DB_ERROR : i32 = 8451;
pub const ERROR_DS_DRA_NO_REPLICA : i32 = 8452;
pub const ERROR_DS_DRA_ACCESS_DENIED : i32 = 8453;
pub const ERROR_DS_DRA_NOT_SUPPORTED : i32 = 8454;
pub const ERROR_DS_DRA_RPC_CANCELLED : i32 = 8455;
pub const ERROR_DS_DRA_SOURCE_DISABLED : i32 = 8456;
pub const ERROR_DS_DRA_SINK_DISABLED : i32 = 8457;
pub const ERROR_DS_DRA_NAME_COLLISION : i32 = 8458;
pub const ERROR_DS_DRA_SOURCE_REINSTALLED : i32 = 8459;
pub const ERROR_DS_DRA_MISSING_PARENT : i32 = 8460;
pub const ERROR_DS_DRA_PREEMPTED : i32 = 8461;
pub const ERROR_DS_DRA_ABANDON_SYNC : i32 = 8462;
pub const ERROR_DS_DRA_SHUTDOWN : i32 = 8463;
pub const ERROR_DS_DRA_INCOMPATIBLE_PARTIAL_SET : i32 = 8464;
pub const ERROR_DS_DRA_SOURCE_IS_PARTIAL_REPLICA : i32 = 8465;
pub const ERROR_DS_DRA_EXTN_CONNECTION_FAILED : i32 = 8466;
pub const ERROR_DS_INSTALL_SCHEMA_MISMATCH : i32 = 8467;
pub const ERROR_DS_DUP_LINK_ID : i32 = 8468;
pub const ERROR_DS_NAME_ERROR_RESOLVING : i32 = 8469;
pub const ERROR_DS_NAME_ERROR_NOT_FOUND : i32 = 8470;
pub const ERROR_DS_NAME_ERROR_NOT_UNIQUE : i32 = 8471;
pub const ERROR_DS_NAME_ERROR_NO_MAPPING : i32 = 8472;
pub const ERROR_DS_NAME_ERROR_DOMAIN_ONLY : i32 = 8473;
pub const ERROR_DS_NAME_ERROR_NO_SYNTACTICAL_MAPPING : i32 = 8474;
pub const ERROR_DS_CONSTRUCTED_ATT_MOD : i32 = 8475;
pub const ERROR_DS_WRONG_OM_OBJ_CLASS : i32 = 8476;
pub const ERROR_DS_DRA_REPL_PENDING : i32 = 8477;
pub const ERROR_DS_DS_REQUIRED : i32 = 8478;
pub const ERROR_DS_INVALID_LDAP_DISPLAY_NAME : i32 = 8479;
pub const ERROR_DS_NON_BASE_SEARCH : i32 = 8480;
pub const ERROR_DS_CANT_RETRIEVE_ATTS : i32 = 8481;
pub const ERROR_DS_BACKLINK_WITHOUT_LINK : i32 = 8482;
pub const ERROR_DS_EPOCH_MISMATCH : i32 = 8483;
pub const ERROR_DS_SRC_NAME_MISMATCH : i32 = 8484;
pub const ERROR_DS_SRC_AND_DST_NC_IDENTICAL : i32 = 8485;
pub const ERROR_DS_DST_NC_MISMATCH : i32 = 8486;
pub const ERROR_DS_NOT_AUTHORITIVE_FOR_DST_NC : i32 = 8487;
pub const ERROR_DS_SRC_GUID_MISMATCH : i32 = 8488;
pub const ERROR_DS_CANT_MOVE_DELETED_OBJECT : i32 = 8489;
pub const ERROR_DS_PDC_OPERATION_IN_PROGRESS : i32 = 8490;
pub const ERROR_DS_CROSS_DOMAIN_CLEANUP_REQD : i32 = 8491;
pub const ERROR_DS_ILLEGAL_XDOM_MOVE_OPERATION : i32 = 8492;
pub const ERROR_DS_CANT_WITH_ACCT_GROUP_MEMBERSHPS : i32 = 8493;
pub const ERROR_DS_NC_MUST_HAVE_NC_PARENT : i32 = 8494;
pub const ERROR_DS_CR_IMPOSSIBLE_TO_VALIDATE : i32 = 8495;
pub const ERROR_DS_DST_DOMAIN_NOT_NATIVE : i32 = 8496;
pub const ERROR_DS_MISSING_INFRASTRUCTURE_CONTAINER : i32 = 8497;
pub const ERROR_DS_CANT_MOVE_ACCOUNT_GROUP : i32 = 8498;
pub const ERROR_DS_CANT_MOVE_RESOURCE_GROUP : i32 = 8499;
pub const ERROR_DS_INVALID_SEARCH_FLAG : i32 = 8500;
pub const ERROR_DS_NO_TREE_DELETE_ABOVE_NC : i32 = 8501;
pub const ERROR_DS_COULDNT_LOCK_TREE_FOR_DELETE : i32 = 8502;
pub const ERROR_DS_COULDNT_IDENTIFY_OBJECTS_FOR_TREE_DELETE : i32 = 8503;
pub const ERROR_DS_SAM_INIT_FAILURE : i32 = 8504;
pub const ERROR_DS_SENSITIVE_GROUP_VIOLATION : i32 = 8505;
pub const ERROR_DS_CANT_MOD_PRIMARYGROUPID : i32 = 8506;
pub const ERROR_DS_ILLEGAL_BASE_SCHEMA_MOD : i32 = 8507;
pub const ERROR_DS_NONSAFE_SCHEMA_CHANGE : i32 = 8508;
pub const ERROR_DS_SCHEMA_UPDATE_DISALLOWED : i32 = 8509;
pub const ERROR_DS_CANT_CREATE_UNDER_SCHEMA : i32 = 8510;
pub const ERROR_DS_INSTALL_NO_SRC_SCH_VERSION : i32 = 8511;
pub const ERROR_DS_INSTALL_NO_SCH_VERSION_IN_INIFILE : i32 = 8512;
pub const ERROR_DS_INVALID_GROUP_TYPE : i32 = 8513;
pub const ERROR_DS_NO_NEST_GLOBALGROUP_IN_MIXEDDOMAIN : i32 = 8514;
pub const ERROR_DS_NO_NEST_LOCALGROUP_IN_MIXEDDOMAIN : i32 = 8515;
pub const ERROR_DS_GLOBAL_CANT_HAVE_LOCAL_MEMBER : i32 = 8516;
pub const ERROR_DS_GLOBAL_CANT_HAVE_UNIVERSAL_MEMBER : i32 = 8517;
pub const ERROR_DS_UNIVERSAL_CANT_HAVE_LOCAL_MEMBER : i32 = 8518;
pub const ERROR_DS_GLOBAL_CANT_HAVE_CROSSDOMAIN_MEMBER : i32 = 8519;
pub const ERROR_DS_LOCAL_CANT_HAVE_CROSSDOMAIN_LOCAL_MEMBER : i32 = 8520;
pub const ERROR_DS_HAVE_PRIMARY_MEMBERS : i32 = 8521;
pub const ERROR_DS_STRING_SD_CONVERSION_FAILED : i32 = 8522;
pub const ERROR_DS_NAMING_MASTER_GC : i32 = 8523;
pub const ERROR_DS_DNS_LOOKUP_FAILURE : i32 = 8524;
pub const ERROR_DS_COULDNT_UPDATE_SPNS : i32 = 8525;
pub const ERROR_DS_CANT_RETRIEVE_SD : i32 = 8526;
pub const ERROR_DS_KEY_NOT_UNIQUE : i32 = 8527;
pub const ERROR_DS_WRONG_LINKED_ATT_SYNTAX : i32 = 8528;
pub const ERROR_DS_SAM_NEED_BOOTKEY_PASSWORD : i32 = 8529;
pub const ERROR_DS_SAM_NEED_BOOTKEY_FLOPPY : i32 = 8530;
pub const ERROR_DS_CANT_START : i32 = 8531;
pub const ERROR_DS_INIT_FAILURE : i32 = 8532;
pub const ERROR_DS_NO_PKT_PRIVACY_ON_CONNECTION : i32 = 8533;
pub const ERROR_DS_SOURCE_DOMAIN_IN_FOREST : i32 = 8534;
pub const ERROR_DS_DESTINATION_DOMAIN_NOT_IN_FOREST : i32 = 8535;
pub const ERROR_DS_DESTINATION_AUDITING_NOT_ENABLED : i32 = 8536;
pub const ERROR_DS_CANT_FIND_DC_FOR_SRC_DOMAIN : i32 = 8537;
pub const ERROR_DS_SRC_OBJ_NOT_GROUP_OR_USER : i32 = 8538;
pub const ERROR_DS_SRC_SID_EXISTS_IN_FOREST : i32 = 8539;
pub const ERROR_DS_SRC_AND_DST_OBJECT_CLASS_MISMATCH : i32 = 8540;
pub const ERROR_SAM_INIT_FAILURE : i32 = 8541;
pub const ERROR_DS_DRA_SCHEMA_INFO_SHIP : i32 = 8542;
pub const ERROR_DS_DRA_SCHEMA_CONFLICT : i32 = 8543;
pub const ERROR_DS_DRA_EARLIER_SCHEMA_CONFLICT : i32 = 8544;
pub const ERROR_DS_DRA_OBJ_NC_MISMATCH : i32 = 8545;
pub const ERROR_DS_NC_STILL_HAS_DSAS : i32 = 8546;
pub const ERROR_DS_GC_REQUIRED : i32 = 8547;
pub const ERROR_DS_LOCAL_MEMBER_OF_LOCAL_ONLY : i32 = 8548;
pub const ERROR_DS_NO_FPO_IN_UNIVERSAL_GROUPS : i32 = 8549;
pub const ERROR_DS_CANT_ADD_TO_GC : i32 = 8550;
pub const ERROR_DS_NO_CHECKPOINT_WITH_PDC : i32 = 8551;
pub const ERROR_DS_SOURCE_AUDITING_NOT_ENABLED : i32 = 8552;
pub const ERROR_DS_CANT_CREATE_IN_NONDOMAIN_NC : i32 = 8553;
pub const ERROR_DS_INVALID_NAME_FOR_SPN : i32 = 8554;
pub const ERROR_DS_FILTER_USES_CONTRUCTED_ATTRS : i32 = 8555;
pub const ERROR_DS_UNICODEPWD_NOT_IN_QUOTES : i32 = 8556;
pub const ERROR_DS_MACHINE_ACCOUNT_QUOTA_EXCEEDED : i32 = 8557;
pub const ERROR_DS_MUST_BE_RUN_ON_DST_DC : i32 = 8558;
pub const ERROR_DS_SRC_DC_MUST_BE_SP4_OR_GREATER : i32 = 8559;
pub const ERROR_DS_CANT_TREE_DELETE_CRITICAL_OBJ : i32 = 8560;
pub const ERROR_DS_INIT_FAILURE_CONSOLE : i32 = 8561;
pub const ERROR_DS_SAM_INIT_FAILURE_CONSOLE : i32 = 8562;
pub const ERROR_DS_FOREST_VERSION_TOO_HIGH : i32 = 8563;
pub const ERROR_DS_DOMAIN_VERSION_TOO_HIGH : i32 = 8564;
pub const ERROR_DS_FOREST_VERSION_TOO_LOW : i32 = 8565;
pub const ERROR_DS_DOMAIN_VERSION_TOO_LOW : i32 = 8566;
pub const ERROR_DS_INCOMPATIBLE_VERSION : i32 = 8567;
pub const ERROR_DS_LOW_DSA_VERSION : i32 = 8568;
pub const ERROR_DS_NO_BEHAVIOR_VERSION_IN_MIXEDDOMAIN : i32 = 8569;
pub const ERROR_DS_NOT_SUPPORTED_SORT_ORDER : i32 = 8570;
pub const ERROR_DS_NAME_NOT_UNIQUE : i32 = 8571;
pub const ERROR_DS_MACHINE_ACCOUNT_CREATED_PRENT4 : i32 = 8572;
pub const ERROR_DS_OUT_OF_VERSION_STORE : i32 = 8573;
pub const ERROR_DS_INCOMPATIBLE_CONTROLS_USED : i32 = 8574;
pub const ERROR_DS_NO_REF_DOMAIN : i32 = 8575;
pub const ERROR_DS_RESERVED_LINK_ID : i32 = 8576;
pub const ERROR_DS_LINK_ID_NOT_AVAILABLE : i32 = 8577;
pub const ERROR_DS_AG_CANT_HAVE_UNIVERSAL_MEMBER : i32 = 8578;
pub const ERROR_DS_MODIFYDN_DISALLOWED_BY_INSTANCE_TYPE : i32 = 8579;
pub const ERROR_DS_NO_OBJECT_MOVE_IN_SCHEMA_NC : i32 = 8580;
pub const ERROR_DS_MODIFYDN_DISALLOWED_BY_FLAG : i32 = 8581;
pub const ERROR_DS_MODIFYDN_WRONG_GRANDPARENT : i32 = 8582;
pub const ERROR_DS_NAME_ERROR_TRUST_REFERRAL : i32 = 8583;
pub const ERROR_NOT_SUPPORTED_ON_STANDARD_SERVER : i32 = 8584;
pub const ERROR_DS_CANT_ACCESS_REMOTE_PART_OF_AD : i32 = 8585;
pub const ERROR_DS_CR_IMPOSSIBLE_TO_VALIDATE_V2 : i32 = 8586;
pub const ERROR_DS_THREAD_LIMIT_EXCEEDED : i32 = 8587;
pub const ERROR_DS_NOT_CLOSEST : i32 = 8588;
pub const ERROR_DS_CANT_DERIVE_SPN_WITHOUT_SERVER_REF : i32 = 8589;
pub const ERROR_DS_SINGLE_USER_MODE_FAILED : i32 = 8590;
pub const ERROR_DS_NTDSCRIPT_SYNTAX_ERROR : i32 = 8591;
pub const ERROR_DS_NTDSCRIPT_PROCESS_ERROR : i32 = 8592;
pub const ERROR_DS_DIFFERENT_REPL_EPOCHS : i32 = 8593;
pub const ERROR_DS_DRS_EXTENSIONS_CHANGED : i32 = 8594;
pub const ERROR_DS_REPLICA_SET_CHANGE_NOT_ALLOWED_ON_DISABLED_CR : i32 = 8595;
pub const ERROR_DS_NO_MSDS_INTID : i32 = 8596;
pub const ERROR_DS_DUP_MSDS_INTID : i32 = 8597;
pub const ERROR_DS_EXISTS_IN_RDNATTID : i32 = 8598;
pub const ERROR_DS_AUTHORIZATION_FAILED : i32 = 8599;
pub const ERROR_DS_INVALID_SCRIPT : i32 = 8600;
pub const ERROR_DS_REMOTE_CROSSREF_OP_FAILED : i32 = 8601;
pub const ERROR_DS_CROSS_REF_BUSY : i32 = 8602;
pub const ERROR_DS_CANT_DERIVE_SPN_FOR_DELETED_DOMAIN : i32 = 8603;
pub const ERROR_DS_CANT_DEMOTE_WITH_WRITEABLE_NC : i32 = 8604;
pub const ERROR_DS_DUPLICATE_ID_FOUND : i32 = 8605;
pub const ERROR_DS_INSUFFICIENT_ATTR_TO_CREATE_OBJECT : i32 = 8606;
pub const ERROR_DS_GROUP_CONVERSION_ERROR : i32 = 8607;
pub const ERROR_DS_CANT_MOVE_APP_BASIC_GROUP : i32 = 8608;
pub const ERROR_DS_CANT_MOVE_APP_QUERY_GROUP : i32 = 8609;
pub const ERROR_DS_ROLE_NOT_VERIFIED : i32 = 8610;
pub const ERROR_DS_WKO_CONTAINER_CANNOT_BE_SPECIAL : i32 = 8611;
pub const ERROR_DS_DOMAIN_RENAME_IN_PROGRESS : i32 = 8612;
pub const ERROR_DS_EXISTING_AD_CHILD_NC : i32 = 8613;
pub const ERROR_DS_REPL_LIFETIME_EXCEEDED : i32 = 8614;
pub const ERROR_DS_DISALLOWED_IN_SYSTEM_CONTAINER : i32 = 8615;
pub const ERROR_DS_LDAP_SEND_QUEUE_FULL : i32 = 8616;
pub const ERROR_DS_DRA_OUT_SCHEDULE_WINDOW : i32 = 8617;
pub const ERROR_DS_POLICY_NOT_KNOWN : i32 = 8618;
pub const ERROR_NO_SITE_SETTINGS_OBJECT : i32 = 8619;
pub const ERROR_NO_SECRETS : i32 = 8620;
pub const ERROR_NO_WRITABLE_DC_FOUND : i32 = 8621;
pub const ERROR_DS_NO_SERVER_OBJECT : i32 = 8622;
pub const ERROR_DS_NO_NTDSA_OBJECT : i32 = 8623;
pub const ERROR_DS_NON_ASQ_SEARCH : i32 = 8624;
pub const ERROR_DS_AUDIT_FAILURE : i32 = 8625;
pub const ERROR_DS_INVALID_SEARCH_FLAG_SUBTREE : i32 = 8626;
pub const ERROR_DS_INVALID_SEARCH_FLAG_TUPLE : i32 = 8627;
pub const ERROR_DS_HIERARCHY_TABLE_TOO_DEEP : i32 = 8628;
pub const ERROR_DS_DRA_CORRUPT_UTD_VECTOR : i32 = 8629;
pub const ERROR_DS_DRA_SECRETS_DENIED : i32 = 8630;
pub const ERROR_DS_RESERVED_MAPI_ID : i32 = 8631;
pub const ERROR_DS_MAPI_ID_NOT_AVAILABLE : i32 = 8632;
pub const ERROR_DS_DRA_MISSING_KRBTGT_SECRET : i32 = 8633;
pub const ERROR_DS_DOMAIN_NAME_EXISTS_IN_FOREST : i32 = 8634;
pub const ERROR_DS_FLAT_NAME_EXISTS_IN_FOREST : i32 = 8635;
pub const ERROR_INVALID_USER_PRINCIPAL_NAME : i32 = 8636;
pub const ERROR_DS_OID_MAPPED_GROUP_CANT_HAVE_MEMBERS : i32 = 8637;
pub const ERROR_DS_OID_NOT_FOUND : i32 = 8638;
pub const ERROR_DS_DRA_RECYCLED_TARGET : i32 = 8639;
pub const ERROR_DS_DISALLOWED_NC_REDIRECT : i32 = 8640;
pub const ERROR_DS_HIGH_ADLDS_FFL : i32 = 8641;
pub const ERROR_DS_HIGH_DSA_VERSION : i32 = 8642;
pub const ERROR_DS_LOW_ADLDS_FFL : i32 = 8643;
pub const ERROR_DOMAIN_SID_SAME_AS_LOCAL_WORKSTATION : i32 = 8644;
pub const ERROR_DS_UNDELETE_SAM_VALIDATION_FAILED : i32 = 8645;
pub const ERROR_INCORRECT_ACCOUNT_TYPE : i32 = 8646;
pub const ERROR_DS_SPN_VALUE_NOT_UNIQUE_IN_FOREST : i32 = 8647;
pub const ERROR_DS_UPN_VALUE_NOT_UNIQUE_IN_FOREST : i32 = 8648;
pub const ERROR_DS_MISSING_FOREST_TRUST : i32 = 8649;
pub const ERROR_DS_VALUE_KEY_NOT_UNIQUE : i32 = 8650;
pub const DNS_ERROR_RESPONSE_CODES_BASE : i32 = 9000;
pub const DNS_ERROR_MASK : i32 = 9000;
pub const DNS_ERROR_RCODE_FORMAT_ERROR : i32 = 9001;
pub const DNS_ERROR_RCODE_SERVER_FAILURE : i32 = 9002;
pub const DNS_ERROR_RCODE_NAME_ERROR : i32 = 9003;
pub const DNS_ERROR_RCODE_NOT_IMPLEMENTED : i32 = 9004;
pub const DNS_ERROR_RCODE_REFUSED : i32 = 9005;
pub const DNS_ERROR_RCODE_YXDOMAIN : i32 = 9006;
pub const DNS_ERROR_RCODE_YXRRSET : i32 = 9007;
pub const DNS_ERROR_RCODE_NXRRSET : i32 = 9008;
pub const DNS_ERROR_RCODE_NOTAUTH : i32 = 9009;
pub const DNS_ERROR_RCODE_NOTZONE : i32 = 9010;
pub const DNS_ERROR_RCODE_BADSIG : i32 = 9016;
pub const DNS_ERROR_RCODE_BADKEY : i32 = 9017;
pub const DNS_ERROR_RCODE_BADTIME : i32 = 9018;
pub const DNS_ERROR_DNSSEC_BASE : i32 = 9100;
pub const DNS_ERROR_KEYMASTER_REQUIRED : i32 = 9101;
pub const DNS_ERROR_NOT_ALLOWED_ON_SIGNED_ZONE : i32 = 9102;
pub const DNS_ERROR_NSEC3_INCOMPATIBLE_WITH_RSA_SHA1 : i32 = 9103;
pub const DNS_ERROR_NOT_ENOUGH_SIGNING_KEY_DESCRIPTORS : i32 = 9104;
pub const DNS_ERROR_UNSUPPORTED_ALGORITHM : i32 = 9105;
pub const DNS_ERROR_INVALID_KEY_SIZE : i32 = 9106;
pub const DNS_ERROR_SIGNING_KEY_NOT_ACCESSIBLE : i32 = 9107;
pub const DNS_ERROR_KSP_DOES_NOT_SUPPORT_PROTECTION : i32 = 9108;
pub const DNS_ERROR_UNEXPECTED_DATA_PROTECTION_ERROR : i32 = 9109;
pub const DNS_ERROR_UNEXPECTED_CNG_ERROR : i32 = 9110;
pub const DNS_ERROR_UNKNOWN_SIGNING_PARAMETER_VERSION : i32 = 9111;
pub const DNS_ERROR_KSP_NOT_ACCESSIBLE : i32 = 9112;
pub const DNS_ERROR_TOO_MANY_SKDS : i32 = 9113;
pub const DNS_ERROR_INVALID_ROLLOVER_PERIOD : i32 = 9114;
pub const DNS_ERROR_INVALID_INITIAL_ROLLOVER_OFFSET : i32 = 9115;
pub const DNS_ERROR_ROLLOVER_IN_PROGRESS : i32 = 9116;
pub const DNS_ERROR_STANDBY_KEY_NOT_PRESENT : i32 = 9117;
pub const DNS_ERROR_NOT_ALLOWED_ON_ZSK : i32 = 9118;
pub const DNS_ERROR_NOT_ALLOWED_ON_ACTIVE_SKD : i32 = 9119;
pub const DNS_ERROR_ROLLOVER_ALREADY_QUEUED : i32 = 9120;
pub const DNS_ERROR_NOT_ALLOWED_ON_UNSIGNED_ZONE : i32 = 9121;
pub const DNS_ERROR_BAD_KEYMASTER : i32 = 9122;
pub const DNS_ERROR_INVALID_SIGNATURE_VALIDITY_PERIOD : i32 = 9123;
pub const DNS_ERROR_INVALID_NSEC3_ITERATION_COUNT : i32 = 9124;
pub const DNS_ERROR_DNSSEC_IS_DISABLED : i32 = 9125;
pub const DNS_ERROR_INVALID_XML : i32 = 9126;
pub const DNS_ERROR_NO_VALID_TRUST_ANCHORS : i32 = 9127;
pub const DNS_ERROR_ROLLOVER_NOT_POKEABLE : i32 = 9128;
pub const DNS_ERROR_NSEC3_NAME_COLLISION : i32 = 9129;
pub const DNS_ERROR_NSEC_INCOMPATIBLE_WITH_NSEC3_RSA_SHA1 : i32 = 9130;
pub const DNS_ERROR_PACKET_FMT_BASE : i32 = 9500;
pub const DNS_INFO_NO_RECORDS : i32 = 9501;
pub const DNS_ERROR_BAD_PACKET : i32 = 9502;
pub const DNS_ERROR_NO_PACKET : i32 = 9503;
pub const DNS_ERROR_RCODE : i32 = 9504;
pub const DNS_ERROR_UNSECURE_PACKET : i32 = 9505;
pub const DNS_REQUEST_PENDING : i32 = 9506;
pub const DNS_ERROR_GENERAL_API_BASE : i32 = 9550;
pub const DNS_ERROR_INVALID_TYPE : i32 = 9551;
pub const DNS_ERROR_INVALID_IP_ADDRESS : i32 = 9552;
pub const DNS_ERROR_INVALID_PROPERTY : i32 = 9553;
pub const DNS_ERROR_TRY_AGAIN_LATER : i32 = 9554;
pub const DNS_ERROR_NOT_UNIQUE : i32 = 9555;
pub const DNS_ERROR_NON_RFC_NAME : i32 = 9556;
pub const DNS_STATUS_FQDN : i32 = 9557;
pub const DNS_STATUS_DOTTED_NAME : i32 = 9558;
pub const DNS_STATUS_SINGLE_PART_NAME : i32 = 9559;
pub const DNS_ERROR_INVALID_NAME_CHAR : i32 = 9560;
pub const DNS_ERROR_NUMERIC_NAME : i32 = 9561;
pub const DNS_ERROR_NOT_ALLOWED_ON_ROOT_SERVER : i32 = 9562;
pub const DNS_ERROR_NOT_ALLOWED_UNDER_DELEGATION : i32 = 9563;
pub const DNS_ERROR_CANNOT_FIND_ROOT_HINTS : i32 = 9564;
pub const DNS_ERROR_INCONSISTENT_ROOT_HINTS : i32 = 9565;
pub const DNS_ERROR_DWORD_VALUE_TOO_SMALL : i32 = 9566;
pub const DNS_ERROR_DWORD_VALUE_TOO_LARGE : i32 = 9567;
pub const DNS_ERROR_BACKGROUND_LOADING : i32 = 9568;
pub const DNS_ERROR_NOT_ALLOWED_ON_RODC : i32 = 9569;
pub const DNS_ERROR_NOT_ALLOWED_UNDER_DNAME : i32 = 9570;
pub const DNS_ERROR_DELEGATION_REQUIRED : i32 = 9571;
pub const DNS_ERROR_INVALID_POLICY_TABLE : i32 = 9572;
pub const DNS_ERROR_ADDRESS_REQUIRED : i32 = 9573;
pub const DNS_ERROR_ZONE_BASE : i32 = 9600;
pub const DNS_ERROR_ZONE_DOES_NOT_EXIST : i32 = 9601;
pub const DNS_ERROR_NO_ZONE_INFO : i32 = 9602;
pub const DNS_ERROR_INVALID_ZONE_OPERATION : i32 = 9603;
pub const DNS_ERROR_ZONE_CONFIGURATION_ERROR : i32 = 9604;
pub const DNS_ERROR_ZONE_HAS_NO_SOA_RECORD : i32 = 9605;
pub const DNS_ERROR_ZONE_HAS_NO_NS_RECORDS : i32 = 9606;
pub const DNS_ERROR_ZONE_LOCKED : i32 = 9607;
pub const DNS_ERROR_ZONE_CREATION_FAILED : i32 = 9608;
pub const DNS_ERROR_ZONE_ALREADY_EXISTS : i32 = 9609;
pub const DNS_ERROR_AUTOZONE_ALREADY_EXISTS : i32 = 9610;
pub const DNS_ERROR_INVALID_ZONE_TYPE : i32 = 9611;
pub const DNS_ERROR_SECONDARY_REQUIRES_MASTER_IP : i32 = 9612;
pub const DNS_ERROR_ZONE_NOT_SECONDARY : i32 = 9613;
pub const DNS_ERROR_NEED_SECONDARY_ADDRESSES : i32 = 9614;
pub const DNS_ERROR_WINS_INIT_FAILED : i32 = 9615;
pub const DNS_ERROR_NEED_WINS_SERVERS : i32 = 9616;
pub const DNS_ERROR_NBSTAT_INIT_FAILED : i32 = 9617;
pub const DNS_ERROR_SOA_DELETE_INVALID : i32 = 9618;
pub const DNS_ERROR_FORWARDER_ALREADY_EXISTS : i32 = 9619;
pub const DNS_ERROR_ZONE_REQUIRES_MASTER_IP : i32 = 9620;
pub const DNS_ERROR_ZONE_IS_SHUTDOWN : i32 = 9621;
pub const DNS_ERROR_ZONE_LOCKED_FOR_SIGNING : i32 = 9622;
pub const DNS_ERROR_DATAFILE_BASE : i32 = 9650;
pub const DNS_ERROR_PRIMARY_REQUIRES_DATAFILE : i32 = 9651;
pub const DNS_ERROR_INVALID_DATAFILE_NAME : i32 = 9652;
pub const DNS_ERROR_DATAFILE_OPEN_FAILURE : i32 = 9653;
pub const DNS_ERROR_FILE_WRITEBACK_FAILED : i32 = 9654;
pub const DNS_ERROR_DATAFILE_PARSING : i32 = 9655;
pub const DNS_ERROR_DATABASE_BASE : i32 = 9700;
pub const DNS_ERROR_RECORD_DOES_NOT_EXIST : i32 = 9701;
pub const DNS_ERROR_RECORD_FORMAT : i32 = 9702;
pub const DNS_ERROR_NODE_CREATION_FAILED : i32 = 9703;
pub const DNS_ERROR_UNKNOWN_RECORD_TYPE : i32 = 9704;
pub const DNS_ERROR_RECORD_TIMED_OUT : i32 = 9705;
pub const DNS_ERROR_NAME_NOT_IN_ZONE : i32 = 9706;
pub const DNS_ERROR_CNAME_LOOP : i32 = 9707;
pub const DNS_ERROR_NODE_IS_CNAME : i32 = 9708;
pub const DNS_ERROR_CNAME_COLLISION : i32 = 9709;
pub const DNS_ERROR_RECORD_ONLY_AT_ZONE_ROOT : i32 = 9710;
pub const DNS_ERROR_RECORD_ALREADY_EXISTS : i32 = 9711;
pub const DNS_ERROR_SECONDARY_DATA : i32 = 9712;
pub const DNS_ERROR_NO_CREATE_CACHE_DATA : i32 = 9713;
pub const DNS_ERROR_NAME_DOES_NOT_EXIST : i32 = 9714;
pub const DNS_WARNING_PTR_CREATE_FAILED : i32 = 9715;
pub const DNS_WARNING_DOMAIN_UNDELETED : i32 = 9716;
pub const DNS_ERROR_DS_UNAVAILABLE : i32 = 9717;
pub const DNS_ERROR_DS_ZONE_ALREADY_EXISTS : i32 = 9718;
pub const DNS_ERROR_NO_BOOTFILE_IF_DS_ZONE : i32 = 9719;
pub const DNS_ERROR_NODE_IS_DNAME : i32 = 9720;
pub const DNS_ERROR_DNAME_COLLISION : i32 = 9721;
pub const DNS_ERROR_ALIAS_LOOP : i32 = 9722;
pub const DNS_ERROR_OPERATION_BASE : i32 = 9750;
pub const DNS_INFO_AXFR_COMPLETE : i32 = 9751;
pub const DNS_ERROR_AXFR : i32 = 9752;
pub const DNS_INFO_ADDED_LOCAL_WINS : i32 = 9753;
pub const DNS_ERROR_SECURE_BASE : i32 = 9800;
pub const DNS_STATUS_CONTINUE_NEEDED : i32 = 9801;
pub const DNS_ERROR_SETUP_BASE : i32 = 9850;
pub const DNS_ERROR_NO_TCPIP : i32 = 9851;
pub const DNS_ERROR_NO_DNS_SERVERS : i32 = 9852;
pub const DNS_ERROR_DP_BASE : i32 = 9900;
pub const DNS_ERROR_DP_DOES_NOT_EXIST : i32 = 9901;
pub const DNS_ERROR_DP_ALREADY_EXISTS : i32 = 9902;
pub const DNS_ERROR_DP_NOT_ENLISTED : i32 = 9903;
pub const DNS_ERROR_DP_ALREADY_ENLISTED : i32 = 9904;
pub const DNS_ERROR_DP_NOT_AVAILABLE : i32 = 9905;
pub const DNS_ERROR_DP_FSMO_ERROR : i32 = 9906;
pub const DNS_ERROR_RRL_NOT_ENABLED : i32 = 9911;
pub const DNS_ERROR_RRL_INVALID_WINDOW_SIZE : i32 = 9912;
pub const DNS_ERROR_RRL_INVALID_IPV4_PREFIX : i32 = 9913;
pub const DNS_ERROR_RRL_INVALID_IPV6_PREFIX : i32 = 9914;
pub const DNS_ERROR_RRL_INVALID_TC_RATE : i32 = 9915;
pub const DNS_ERROR_RRL_INVALID_LEAK_RATE : i32 = 9916;
pub const DNS_ERROR_RRL_LEAK_RATE_LESSTHAN_TC_RATE : i32 = 9917;
pub const DNS_ERROR_VIRTUALIZATION_INSTANCE_ALREADY_EXISTS : i32 = 9921;
pub const DNS_ERROR_VIRTUALIZATION_INSTANCE_DOES_NOT_EXIST : i32 = 9922;
pub const DNS_ERROR_VIRTUALIZATION_TREE_LOCKED : i32 = 9923;
pub const DNS_ERROR_INVAILD_VIRTUALIZATION_INSTANCE_NAME : i32 = 9924;
pub const DNS_ERROR_DEFAULT_VIRTUALIZATION_INSTANCE : i32 = 9925;
pub const DNS_ERROR_ZONESCOPE_ALREADY_EXISTS : i32 = 9951;
pub const DNS_ERROR_ZONESCOPE_DOES_NOT_EXIST : i32 = 9952;
pub const DNS_ERROR_DEFAULT_ZONESCOPE : i32 = 9953;
pub const DNS_ERROR_INVALID_ZONESCOPE_NAME : i32 = 9954;
pub const DNS_ERROR_NOT_ALLOWED_WITH_ZONESCOPES : i32 = 9955;
pub const DNS_ERROR_LOAD_ZONESCOPE_FAILED : i32 = 9956;
pub const DNS_ERROR_ZONESCOPE_FILE_WRITEBACK_FAILED : i32 = 9957;
pub const DNS_ERROR_INVALID_SCOPE_NAME : i32 = 9958;
pub const DNS_ERROR_SCOPE_DOES_NOT_EXIST : i32 = 9959;
pub const DNS_ERROR_DEFAULT_SCOPE : i32 = 9960;
pub const DNS_ERROR_INVALID_SCOPE_OPERATION : i32 = 9961;
pub const DNS_ERROR_SCOPE_LOCKED : i32 = 9962;
pub const DNS_ERROR_SCOPE_ALREADY_EXISTS : i32 = 9963;
pub const DNS_ERROR_POLICY_ALREADY_EXISTS : i32 = 9971;
pub const DNS_ERROR_POLICY_DOES_NOT_EXIST : i32 = 9972;
pub const DNS_ERROR_POLICY_INVALID_CRITERIA : i32 = 9973;
pub const DNS_ERROR_POLICY_INVALID_SETTINGS : i32 = 9974;
pub const DNS_ERROR_CLIENT_SUBNET_IS_ACCESSED : i32 = 9975;
pub const DNS_ERROR_CLIENT_SUBNET_DOES_NOT_EXIST : i32 = 9976;
pub const DNS_ERROR_CLIENT_SUBNET_ALREADY_EXISTS : i32 = 9977;
pub const DNS_ERROR_SUBNET_DOES_NOT_EXIST : i32 = 9978;
pub const DNS_ERROR_SUBNET_ALREADY_EXISTS : i32 = 9979;
pub const DNS_ERROR_POLICY_LOCKED : i32 = 9980;
pub const DNS_ERROR_POLICY_INVALID_WEIGHT : i32 = 9981;
pub const DNS_ERROR_POLICY_INVALID_NAME : i32 = 9982;
pub const DNS_ERROR_POLICY_MISSING_CRITERIA : i32 = 9983;
pub const DNS_ERROR_INVALID_CLIENT_SUBNET_NAME : i32 = 9984;
pub const DNS_ERROR_POLICY_PROCESSING_ORDER_INVALID : i32 = 9985;
pub const DNS_ERROR_POLICY_SCOPE_MISSING : i32 = 9986;
pub const DNS_ERROR_POLICY_SCOPE_NOT_ALLOWED : i32 = 9987;
pub const DNS_ERROR_SERVERSCOPE_IS_REFERENCED : i32 = 9988;
pub const DNS_ERROR_ZONESCOPE_IS_REFERENCED : i32 = 9989;
pub const DNS_ERROR_POLICY_INVALID_CRITERIA_CLIENT_SUBNET : i32 = 9990;
pub const DNS_ERROR_POLICY_INVALID_CRITERIA_TRANSPORT_PROTOCOL : i32 = 9991;
pub const DNS_ERROR_POLICY_INVALID_CRITERIA_NETWORK_PROTOCOL : i32 = 9992;
pub const DNS_ERROR_POLICY_INVALID_CRITERIA_INTERFACE : i32 = 9993;
pub const DNS_ERROR_POLICY_INVALID_CRITERIA_FQDN : i32 = 9994;
pub const DNS_ERROR_POLICY_INVALID_CRITERIA_QUERY_TYPE : i32 = 9995;
pub const DNS_ERROR_POLICY_INVALID_CRITERIA_TIME_OF_DAY : i32 = 9996;
pub const WSABASEERR : i32 = 10000;
pub const WSAEINTR : i32 = 10004;
pub const WSAEBADF : i32 = 10009;
pub const WSAEACCES : i32 = 10013;
pub const WSAEFAULT : i32 = 10014;
pub const WSAEINVAL : i32 = 10022;
pub const WSAEMFILE : i32 = 10024;
pub const WSAEWOULDBLOCK : i32 = 10035;
pub const WSAEINPROGRESS : i32 = 10036;
pub const WSAEALREADY : i32 = 10037;
pub const WSAENOTSOCK : i32 = 10038;
pub const WSAEDESTADDRREQ : i32 = 10039;
pub const WSAEMSGSIZE : i32 = 10040;
pub const WSAEPROTOTYPE : i32 = 10041;
pub const WSAENOPROTOOPT : i32 = 10042;
pub const WSAEPROTONOSUPPORT : i32 = 10043;
pub const WSAESOCKTNOSUPPORT : i32 = 10044;
pub const WSAEOPNOTSUPP : i32 = 10045;
pub const WSAEPFNOSUPPORT : i32 = 10046;
pub const WSAEAFNOSUPPORT : i32 = 10047;
pub const WSAEADDRINUSE : i32 = 10048;
pub const WSAEADDRNOTAVAIL : i32 = 10049;
pub const WSAENETDOWN : i32 = 10050;
pub const WSAENETUNREACH : i32 = 10051;
pub const WSAENETRESET : i32 = 10052;
pub const WSAECONNABORTED : i32 = 10053;
pub const WSAECONNRESET : i32 = 10054;
pub const WSAENOBUFS : i32 = 10055;
pub const WSAEISCONN : i32 = 10056;
pub const WSAENOTCONN : i32 = 10057;
pub const WSAESHUTDOWN : i32 = 10058;
pub const WSAETOOMANYREFS : i32 = 10059;
pub const WSAETIMEDOUT : i32 = 10060;
pub const WSAECONNREFUSED : i32 = 10061;
pub const WSAELOOP : i32 = 10062;
pub const WSAENAMETOOLONG : i32 = 10063;
pub const WSAEHOSTDOWN : i32 = 10064;
pub const WSAEHOSTUNREACH : i32 = 10065;
pub const WSAENOTEMPTY : i32 = 10066;
pub const WSAEPROCLIM : i32 = 10067;
pub const WSAEUSERS : i32 = 10068;
pub const WSAEDQUOT : i32 = 10069;
pub const WSAESTALE : i32 = 10070;
pub const WSAEREMOTE : i32 = 10071;
pub const WSASYSNOTREADY : i32 = 10091;
pub const WSAVERNOTSUPPORTED : i32 = 10092;
pub const WSANOTINITIALISED : i32 = 10093;
pub const WSAEDISCON : i32 = 10101;
pub const WSAENOMORE : i32 = 10102;
pub const WSAECANCELLED : i32 = 10103;
pub const WSAEINVALIDPROCTABLE : i32 = 10104;
pub const WSAEINVALIDPROVIDER : i32 = 10105;
pub const WSAEPROVIDERFAILEDINIT : i32 = 10106;
pub const WSASYSCALLFAILURE : i32 = 10107;
pub const WSASERVICE_NOT_FOUND : i32 = 10108;
pub const WSATYPE_NOT_FOUND : i32 = 10109;
pub const WSA_E_NO_MORE : i32 = 10110;
pub const WSA_E_CANCELLED : i32 = 10111;
pub const WSAEREFUSED : i32 = 10112;
pub const WSAHOST_NOT_FOUND : i32 = 11001;
pub const WSATRY_AGAIN : i32 = 11002;
pub const WSANO_RECOVERY : i32 = 11003;
pub const WSANO_DATA : i32 = 11004;
pub const WSA_QOS_RECEIVERS : i32 = 11005;
pub const WSA_QOS_SENDERS : i32 = 11006;
pub const WSA_QOS_NO_SENDERS : i32 = 11007;
pub const WSA_QOS_NO_RECEIVERS : i32 = 11008;
pub const WSA_QOS_REQUEST_CONFIRMED : i32 = 11009;
pub const WSA_QOS_ADMISSION_FAILURE : i32 = 11010;
pub const WSA_QOS_POLICY_FAILURE : i32 = 11011;
pub const WSA_QOS_BAD_STYLE : i32 = 11012;
pub const WSA_QOS_BAD_OBJECT : i32 = 11013;
pub const WSA_QOS_TRAFFIC_CTRL_ERROR : i32 = 11014;
pub const WSA_QOS_GENERIC_ERROR : i32 = 11015;
pub const WSA_QOS_ESERVICETYPE : i32 = 11016;
pub const WSA_QOS_EFLOWSPEC : i32 = 11017;
pub const WSA_QOS_EPROVSPECBUF : i32 = 11018;
pub const WSA_QOS_EFILTERSTYLE : i32 = 11019;
pub const WSA_QOS_EFILTERTYPE : i32 = 11020;
pub const WSA_QOS_EFILTERCOUNT : i32 = 11021;
pub const WSA_QOS_EOBJLENGTH : i32 = 11022;
pub const WSA_QOS_EFLOWCOUNT : i32 = 11023;
pub const WSA_QOS_EUNKOWNPSOBJ : i32 = 11024;
pub const WSA_QOS_EPOLICYOBJ : i32 = 11025;
pub const WSA_QOS_EFLOWDESC : i32 = 11026;
pub const WSA_QOS_EPSFLOWSPEC : i32 = 11027;
pub const WSA_QOS_EPSFILTERSPEC : i32 = 11028;
pub const WSA_QOS_ESDMODEOBJ : i32 = 11029;
pub const WSA_QOS_ESHAPERATEOBJ : i32 = 11030;
pub const WSA_QOS_RESERVED_PETYPE : i32 = 11031;
pub const WSA_SECURE_HOST_NOT_FOUND : i32 = 11032;
pub const WSA_IPSEC_NAME_POLICY_ERROR : i32 = 11033;
pub const ERROR_IPSEC_QM_POLICY_EXISTS : i32 = 13000;
pub const ERROR_IPSEC_QM_POLICY_NOT_FOUND : i32 = 13001;
pub const ERROR_IPSEC_QM_POLICY_IN_USE : i32 = 13002;
pub const ERROR_IPSEC_MM_POLICY_EXISTS : i32 = 13003;
pub const ERROR_IPSEC_MM_POLICY_NOT_FOUND : i32 = 13004;
pub const ERROR_IPSEC_MM_POLICY_IN_USE : i32 = 13005;
pub const ERROR_IPSEC_MM_FILTER_EXISTS : i32 = 13006;
pub const ERROR_IPSEC_MM_FILTER_NOT_FOUND : i32 = 13007;
pub const ERROR_IPSEC_TRANSPORT_FILTER_EXISTS : i32 = 13008;
pub const ERROR_IPSEC_TRANSPORT_FILTER_NOT_FOUND : i32 = 13009;
pub const ERROR_IPSEC_MM_AUTH_EXISTS : i32 = 13010;
pub const ERROR_IPSEC_MM_AUTH_NOT_FOUND : i32 = 13011;
pub const ERROR_IPSEC_MM_AUTH_IN_USE : i32 = 13012;
pub const ERROR_IPSEC_DEFAULT_MM_POLICY_NOT_FOUND : i32 = 13013;
pub const ERROR_IPSEC_DEFAULT_MM_AUTH_NOT_FOUND : i32 = 13014;
pub const ERROR_IPSEC_DEFAULT_QM_POLICY_NOT_FOUND : i32 = 13015;
pub const ERROR_IPSEC_TUNNEL_FILTER_EXISTS : i32 = 13016;
pub const ERROR_IPSEC_TUNNEL_FILTER_NOT_FOUND : i32 = 13017;
pub const ERROR_IPSEC_MM_FILTER_PENDING_DELETION : i32 = 13018;
pub const ERROR_IPSEC_TRANSPORT_FILTER_PENDING_DELETION : i32 = 13019;
pub const ERROR_IPSEC_TUNNEL_FILTER_PENDING_DELETION : i32 = 13020;
pub const ERROR_IPSEC_MM_POLICY_PENDING_DELETION : i32 = 13021;
pub const ERROR_IPSEC_MM_AUTH_PENDING_DELETION : i32 = 13022;
pub const ERROR_IPSEC_QM_POLICY_PENDING_DELETION : i32 = 13023;
pub const WARNING_IPSEC_MM_POLICY_PRUNED : i32 = 13024;
pub const WARNING_IPSEC_QM_POLICY_PRUNED : i32 = 13025;
pub const ERROR_IPSEC_IKE_NEG_STATUS_BEGIN : i32 = 13800;
pub const ERROR_IPSEC_IKE_AUTH_FAIL : i32 = 13801;
pub const ERROR_IPSEC_IKE_ATTRIB_FAIL : i32 = 13802;
pub const ERROR_IPSEC_IKE_NEGOTIATION_PENDING : i32 = 13803;
pub const ERROR_IPSEC_IKE_GENERAL_PROCESSING_ERROR : i32 = 13804;
pub const ERROR_IPSEC_IKE_TIMED_OUT : i32 = 13805;
pub const ERROR_IPSEC_IKE_NO_CERT : i32 = 13806;
pub const ERROR_IPSEC_IKE_SA_DELETED : i32 = 13807;
pub const ERROR_IPSEC_IKE_SA_REAPED : i32 = 13808;
pub const ERROR_IPSEC_IKE_MM_ACQUIRE_DROP : i32 = 13809;
pub const ERROR_IPSEC_IKE_QM_ACQUIRE_DROP : i32 = 13810;
pub const ERROR_IPSEC_IKE_QUEUE_DROP_MM : i32 = 13811;
pub const ERROR_IPSEC_IKE_QUEUE_DROP_NO_MM : i32 = 13812;
pub const ERROR_IPSEC_IKE_DROP_NO_RESPONSE : i32 = 13813;
pub const ERROR_IPSEC_IKE_MM_DELAY_DROP : i32 = 13814;
pub const ERROR_IPSEC_IKE_QM_DELAY_DROP : i32 = 13815;
pub const ERROR_IPSEC_IKE_ERROR : i32 = 13816;
pub const ERROR_IPSEC_IKE_CRL_FAILED : i32 = 13817;
pub const ERROR_IPSEC_IKE_INVALID_KEY_USAGE : i32 = 13818;
pub const ERROR_IPSEC_IKE_INVALID_CERT_TYPE : i32 = 13819;
pub const ERROR_IPSEC_IKE_NO_PRIVATE_KEY : i32 = 13820;
pub const ERROR_IPSEC_IKE_SIMULTANEOUS_REKEY : i32 = 13821;
pub const ERROR_IPSEC_IKE_DH_FAIL : i32 = 13822;
pub const ERROR_IPSEC_IKE_CRITICAL_PAYLOAD_NOT_RECOGNIZED : i32 = 13823;
pub const ERROR_IPSEC_IKE_INVALID_HEADER : i32 = 13824;
pub const ERROR_IPSEC_IKE_NO_POLICY : i32 = 13825;
pub const ERROR_IPSEC_IKE_INVALID_SIGNATURE : i32 = 13826;
pub const ERROR_IPSEC_IKE_KERBEROS_ERROR : i32 = 13827;
pub const ERROR_IPSEC_IKE_NO_PUBLIC_KEY : i32 = 13828;
pub const ERROR_IPSEC_IKE_PROCESS_ERR : i32 = 13829;
pub const ERROR_IPSEC_IKE_PROCESS_ERR_SA : i32 = 13830;
pub const ERROR_IPSEC_IKE_PROCESS_ERR_PROP : i32 = 13831;
pub const ERROR_IPSEC_IKE_PROCESS_ERR_TRANS : i32 = 13832;
pub const ERROR_IPSEC_IKE_PROCESS_ERR_KE : i32 = 13833;
pub const ERROR_IPSEC_IKE_PROCESS_ERR_ID : i32 = 13834;
pub const ERROR_IPSEC_IKE_PROCESS_ERR_CERT : i32 = 13835;
pub const ERROR_IPSEC_IKE_PROCESS_ERR_CERT_REQ : i32 = 13836;
pub const ERROR_IPSEC_IKE_PROCESS_ERR_HASH : i32 = 13837;
pub const ERROR_IPSEC_IKE_PROCESS_ERR_SIG : i32 = 13838;
pub const ERROR_IPSEC_IKE_PROCESS_ERR_NONCE : i32 = 13839;
pub const ERROR_IPSEC_IKE_PROCESS_ERR_NOTIFY : i32 = 13840;
pub const ERROR_IPSEC_IKE_PROCESS_ERR_DELETE : i32 = 13841;
pub const ERROR_IPSEC_IKE_PROCESS_ERR_VENDOR : i32 = 13842;
pub const ERROR_IPSEC_IKE_INVALID_PAYLOAD : i32 = 13843;
pub const ERROR_IPSEC_IKE_LOAD_SOFT_SA : i32 = 13844;
pub const ERROR_IPSEC_IKE_SOFT_SA_TORN_DOWN : i32 = 13845;
pub const ERROR_IPSEC_IKE_INVALID_COOKIE : i32 = 13846;
pub const ERROR_IPSEC_IKE_NO_PEER_CERT : i32 = 13847;
pub const ERROR_IPSEC_IKE_PEER_CRL_FAILED : i32 = 13848;
pub const ERROR_IPSEC_IKE_POLICY_CHANGE : i32 = 13849;
pub const ERROR_IPSEC_IKE_NO_MM_POLICY : i32 = 13850;
pub const ERROR_IPSEC_IKE_NOTCBPRIV : i32 = 13851;
pub const ERROR_IPSEC_IKE_SECLOADFAIL : i32 = 13852;
pub const ERROR_IPSEC_IKE_FAILSSPINIT : i32 = 13853;
pub const ERROR_IPSEC_IKE_FAILQUERYSSP : i32 = 13854;
pub const ERROR_IPSEC_IKE_SRVACQFAIL : i32 = 13855;
pub const ERROR_IPSEC_IKE_SRVQUERYCRED : i32 = 13856;
pub const ERROR_IPSEC_IKE_GETSPIFAIL : i32 = 13857;
pub const ERROR_IPSEC_IKE_INVALID_FILTER : i32 = 13858;
pub const ERROR_IPSEC_IKE_OUT_OF_MEMORY : i32 = 13859;
pub const ERROR_IPSEC_IKE_ADD_UPDATE_KEY_FAILED : i32 = 13860;
pub const ERROR_IPSEC_IKE_INVALID_POLICY : i32 = 13861;
pub const ERROR_IPSEC_IKE_UNKNOWN_DOI : i32 = 13862;
pub const ERROR_IPSEC_IKE_INVALID_SITUATION : i32 = 13863;
pub const ERROR_IPSEC_IKE_DH_FAILURE : i32 = 13864;
pub const ERROR_IPSEC_IKE_INVALID_GROUP : i32 = 13865;
pub const ERROR_IPSEC_IKE_ENCRYPT : i32 = 13866;
pub const ERROR_IPSEC_IKE_DECRYPT : i32 = 13867;
pub const ERROR_IPSEC_IKE_POLICY_MATCH : i32 = 13868;
pub const ERROR_IPSEC_IKE_UNSUPPORTED_ID : i32 = 13869;
pub const ERROR_IPSEC_IKE_INVALID_HASH : i32 = 13870;
pub const ERROR_IPSEC_IKE_INVALID_HASH_ALG : i32 = 13871;
pub const ERROR_IPSEC_IKE_INVALID_HASH_SIZE : i32 = 13872;
pub const ERROR_IPSEC_IKE_INVALID_ENCRYPT_ALG : i32 = 13873;
pub const ERROR_IPSEC_IKE_INVALID_AUTH_ALG : i32 = 13874;
pub const ERROR_IPSEC_IKE_INVALID_SIG : i32 = 13875;
pub const ERROR_IPSEC_IKE_LOAD_FAILED : i32 = 13876;
pub const ERROR_IPSEC_IKE_RPC_DELETE : i32 = 13877;
pub const ERROR_IPSEC_IKE_BENIGN_REINIT : i32 = 13878;
pub const ERROR_IPSEC_IKE_INVALID_RESPONDER_LIFETIME_NOTIFY : i32 = 13879;
pub const ERROR_IPSEC_IKE_INVALID_MAJOR_VERSION : i32 = 13880;
pub const ERROR_IPSEC_IKE_INVALID_CERT_KEYLEN : i32 = 13881;
pub const ERROR_IPSEC_IKE_MM_LIMIT : i32 = 13882;
pub const ERROR_IPSEC_IKE_NEGOTIATION_DISABLED : i32 = 13883;
pub const ERROR_IPSEC_IKE_QM_LIMIT : i32 = 13884;
pub const ERROR_IPSEC_IKE_MM_EXPIRED : i32 = 13885;
pub const ERROR_IPSEC_IKE_PEER_MM_ASSUMED_INVALID : i32 = 13886;
pub const ERROR_IPSEC_IKE_CERT_CHAIN_POLICY_MISMATCH : i32 = 13887;
pub const ERROR_IPSEC_IKE_UNEXPECTED_MESSAGE_ID : i32 = 13888;
pub const ERROR_IPSEC_IKE_INVALID_AUTH_PAYLOAD : i32 = 13889;
pub const ERROR_IPSEC_IKE_DOS_COOKIE_SENT : i32 = 13890;
pub const ERROR_IPSEC_IKE_SHUTTING_DOWN : i32 = 13891;
pub const ERROR_IPSEC_IKE_CGA_AUTH_FAILED : i32 = 13892;
pub const ERROR_IPSEC_IKE_PROCESS_ERR_NATOA : i32 = 13893;
pub const ERROR_IPSEC_IKE_INVALID_MM_FOR_QM : i32 = 13894;
pub const ERROR_IPSEC_IKE_QM_EXPIRED : i32 = 13895;
pub const ERROR_IPSEC_IKE_TOO_MANY_FILTERS : i32 = 13896;
pub const ERROR_IPSEC_IKE_NEG_STATUS_END : i32 = 13897;
pub const ERROR_IPSEC_IKE_KILL_DUMMY_NAP_TUNNEL : i32 = 13898;
pub const ERROR_IPSEC_IKE_INNER_IP_ASSIGNMENT_FAILURE : i32 = 13899;
pub const ERROR_IPSEC_IKE_REQUIRE_CP_PAYLOAD_MISSING : i32 = 13900;
pub const ERROR_IPSEC_KEY_MODULE_IMPERSONATION_NEGOTIATION_PENDING : i32 = 13901;
pub const ERROR_IPSEC_IKE_COEXISTENCE_SUPPRESS : i32 = 13902;
pub const ERROR_IPSEC_IKE_RATELIMIT_DROP : i32 = 13903;
pub const ERROR_IPSEC_IKE_PEER_DOESNT_SUPPORT_MOBIKE : i32 = 13904;
pub const ERROR_IPSEC_IKE_AUTHORIZATION_FAILURE : i32 = 13905;
pub const ERROR_IPSEC_IKE_STRONG_CRED_AUTHORIZATION_FAILURE : i32 = 13906;
pub const ERROR_IPSEC_IKE_AUTHORIZATION_FAILURE_WITH_OPTIONAL_RETRY : i32 = 13907;
pub const ERROR_IPSEC_IKE_STRONG_CRED_AUTHORIZATION_AND_CERTMAP_FAILURE : i32 = 13908;
pub const ERROR_IPSEC_IKE_NEG_STATUS_EXTENDED_END : i32 = 13909;
pub const ERROR_IPSEC_BAD_SPI : i32 = 13910;
pub const ERROR_IPSEC_SA_LIFETIME_EXPIRED : i32 = 13911;
pub const ERROR_IPSEC_WRONG_SA : i32 = 13912;
pub const ERROR_IPSEC_REPLAY_CHECK_FAILED : i32 = 13913;
pub const ERROR_IPSEC_INVALID_PACKET : i32 = 13914;
pub const ERROR_IPSEC_INTEGRITY_CHECK_FAILED : i32 = 13915;
pub const ERROR_IPSEC_CLEAR_TEXT_DROP : i32 = 13916;
pub const ERROR_IPSEC_AUTH_FIREWALL_DROP : i32 = 13917;
pub const ERROR_IPSEC_THROTTLE_DROP : i32 = 13918;
pub const ERROR_IPSEC_DOSP_BLOCK : i32 = 13925;
pub const ERROR_IPSEC_DOSP_RECEIVED_MULTICAST : i32 = 13926;
pub const ERROR_IPSEC_DOSP_INVALID_PACKET : i32 = 13927;
pub const ERROR_IPSEC_DOSP_STATE_LOOKUP_FAILED : i32 = 13928;
pub const ERROR_IPSEC_DOSP_MAX_ENTRIES : i32 = 13929;
pub const ERROR_IPSEC_DOSP_KEYMOD_NOT_ALLOWED : i32 = 13930;
pub const ERROR_IPSEC_DOSP_NOT_INSTALLED : i32 = 13931;
pub const ERROR_IPSEC_DOSP_MAX_PER_IP_RATELIMIT_QUEUES : i32 = 13932;
pub const ERROR_SXS_SECTION_NOT_FOUND : i32 = 14000;
pub const ERROR_SXS_CANT_GEN_ACTCTX : i32 = 14001;
pub const ERROR_SXS_INVALID_ACTCTXDATA_FORMAT : i32 = 14002;
pub const ERROR_SXS_ASSEMBLY_NOT_FOUND : i32 = 14003;
pub const ERROR_SXS_MANIFEST_FORMAT_ERROR : i32 = 14004;
pub const ERROR_SXS_MANIFEST_PARSE_ERROR : i32 = 14005;
pub const ERROR_SXS_ACTIVATION_CONTEXT_DISABLED : i32 = 14006;
pub const ERROR_SXS_KEY_NOT_FOUND : i32 = 14007;
pub const ERROR_SXS_VERSION_CONFLICT : i32 = 14008;
pub const ERROR_SXS_WRONG_SECTION_TYPE : i32 = 14009;
pub const ERROR_SXS_THREAD_QUERIES_DISABLED : i32 = 14010;
pub const ERROR_SXS_PROCESS_DEFAULT_ALREADY_SET : i32 = 14011;
pub const ERROR_SXS_UNKNOWN_ENCODING_GROUP : i32 = 14012;
pub const ERROR_SXS_UNKNOWN_ENCODING : i32 = 14013;
pub const ERROR_SXS_INVALID_XML_NAMESPACE_URI : i32 = 14014;
pub const ERROR_SXS_ROOT_MANIFEST_DEPENDENCY_NOT_INSTALLED : i32 = 14015;
pub const ERROR_SXS_LEAF_MANIFEST_DEPENDENCY_NOT_INSTALLED : i32 = 14016;
pub const ERROR_SXS_INVALID_ASSEMBLY_IDENTITY_ATTRIBUTE : i32 = 14017;
pub const ERROR_SXS_MANIFEST_MISSING_REQUIRED_DEFAULT_NAMESPACE : i32 = 14018;
pub const ERROR_SXS_MANIFEST_INVALID_REQUIRED_DEFAULT_NAMESPACE : i32 = 14019;
pub const ERROR_SXS_PRIVATE_MANIFEST_CROSS_PATH_WITH_REPARSE_POINT : i32 = 14020;
pub const ERROR_SXS_DUPLICATE_DLL_NAME : i32 = 14021;
pub const ERROR_SXS_DUPLICATE_WINDOWCLASS_NAME : i32 = 14022;
pub const ERROR_SXS_DUPLICATE_CLSID : i32 = 14023;
pub const ERROR_SXS_DUPLICATE_IID : i32 = 14024;
pub const ERROR_SXS_DUPLICATE_TLBID : i32 = 14025;
pub const ERROR_SXS_DUPLICATE_PROGID : i32 = 14026;
pub const ERROR_SXS_DUPLICATE_ASSEMBLY_NAME : i32 = 14027;
pub const ERROR_SXS_FILE_HASH_MISMATCH : i32 = 14028;
pub const ERROR_SXS_POLICY_PARSE_ERROR : i32 = 14029;
pub const ERROR_SXS_XML_E_MISSINGQUOTE : i32 = 14030;
pub const ERROR_SXS_XML_E_COMMENTSYNTAX : i32 = 14031;
pub const ERROR_SXS_XML_E_BADSTARTNAMECHAR : i32 = 14032;
pub const ERROR_SXS_XML_E_BADNAMECHAR : i32 = 14033;
pub const ERROR_SXS_XML_E_BADCHARINSTRING : i32 = 14034;
pub const ERROR_SXS_XML_E_XMLDECLSYNTAX : i32 = 14035;
pub const ERROR_SXS_XML_E_BADCHARDATA : i32 = 14036;
pub const ERROR_SXS_XML_E_MISSINGWHITESPACE : i32 = 14037;
pub const ERROR_SXS_XML_E_EXPECTINGTAGEND : i32 = 14038;
pub const ERROR_SXS_XML_E_MISSINGSEMICOLON : i32 = 14039;
pub const ERROR_SXS_XML_E_UNBALANCEDPAREN : i32 = 14040;
pub const ERROR_SXS_XML_E_INTERNALERROR : i32 = 14041;
pub const ERROR_SXS_XML_E_UNEXPECTED_WHITESPACE : i32 = 14042;
pub const ERROR_SXS_XML_E_INCOMPLETE_ENCODING : i32 = 14043;
pub const ERROR_SXS_XML_E_MISSING_PAREN : i32 = 14044;
pub const ERROR_SXS_XML_E_EXPECTINGCLOSEQUOTE : i32 = 14045;
pub const ERROR_SXS_XML_E_MULTIPLE_COLONS : i32 = 14046;
pub const ERROR_SXS_XML_E_INVALID_DECIMAL : i32 = 14047;
pub const ERROR_SXS_XML_E_INVALID_HEXIDECIMAL : i32 = 14048;
pub const ERROR_SXS_XML_E_INVALID_UNICODE : i32 = 14049;
pub const ERROR_SXS_XML_E_WHITESPACEORQUESTIONMARK : i32 = 14050;
pub const ERROR_SXS_XML_E_UNEXPECTEDENDTAG : i32 = 14051;
pub const ERROR_SXS_XML_E_UNCLOSEDTAG : i32 = 14052;
pub const ERROR_SXS_XML_E_DUPLICATEATTRIBUTE : i32 = 14053;
pub const ERROR_SXS_XML_E_MULTIPLEROOTS : i32 = 14054;
pub const ERROR_SXS_XML_E_INVALIDATROOTLEVEL : i32 = 14055;
pub const ERROR_SXS_XML_E_BADXMLDECL : i32 = 14056;
pub const ERROR_SXS_XML_E_MISSINGROOT : i32 = 14057;
pub const ERROR_SXS_XML_E_UNEXPECTEDEOF : i32 = 14058;
pub const ERROR_SXS_XML_E_BADPEREFINSUBSET : i32 = 14059;
pub const ERROR_SXS_XML_E_UNCLOSEDSTARTTAG : i32 = 14060;
pub const ERROR_SXS_XML_E_UNCLOSEDENDTAG : i32 = 14061;
pub const ERROR_SXS_XML_E_UNCLOSEDSTRING : i32 = 14062;
pub const ERROR_SXS_XML_E_UNCLOSEDCOMMENT : i32 = 14063;
pub const ERROR_SXS_XML_E_UNCLOSEDDECL : i32 = 14064;
pub const ERROR_SXS_XML_E_UNCLOSEDCDATA : i32 = 14065;
pub const ERROR_SXS_XML_E_RESERVEDNAMESPACE : i32 = 14066;
pub const ERROR_SXS_XML_E_INVALIDENCODING : i32 = 14067;
pub const ERROR_SXS_XML_E_INVALIDSWITCH : i32 = 14068;
pub const ERROR_SXS_XML_E_BADXMLCASE : i32 = 14069;
pub const ERROR_SXS_XML_E_INVALID_STANDALONE : i32 = 14070;
pub const ERROR_SXS_XML_E_UNEXPECTED_STANDALONE : i32 = 14071;
pub const ERROR_SXS_XML_E_INVALID_VERSION : i32 = 14072;
pub const ERROR_SXS_XML_E_MISSINGEQUALS : i32 = 14073;
pub const ERROR_SXS_PROTECTION_RECOVERY_FAILED : i32 = 14074;
pub const ERROR_SXS_PROTECTION_PUBLIC_KEY_TOO_SHORT : i32 = 14075;
pub const ERROR_SXS_PROTECTION_CATALOG_NOT_VALID : i32 = 14076;
pub const ERROR_SXS_UNTRANSLATABLE_HRESULT : i32 = 14077;
pub const ERROR_SXS_PROTECTION_CATALOG_FILE_MISSING : i32 = 14078;
pub const ERROR_SXS_MISSING_ASSEMBLY_IDENTITY_ATTRIBUTE : i32 = 14079;
pub const ERROR_SXS_INVALID_ASSEMBLY_IDENTITY_ATTRIBUTE_NAME : i32 = 14080;
pub const ERROR_SXS_ASSEMBLY_MISSING : i32 = 14081;
pub const ERROR_SXS_CORRUPT_ACTIVATION_STACK : i32 = 14082;
pub const ERROR_SXS_CORRUPTION : i32 = 14083;
pub const ERROR_SXS_EARLY_DEACTIVATION : i32 = 14084;
pub const ERROR_SXS_INVALID_DEACTIVATION : i32 = 14085;
pub const ERROR_SXS_MULTIPLE_DEACTIVATION : i32 = 14086;
pub const ERROR_SXS_PROCESS_TERMINATION_REQUESTED : i32 = 14087;
pub const ERROR_SXS_RELEASE_ACTIVATION_CONTEXT : i32 = 14088;
pub const ERROR_SXS_SYSTEM_DEFAULT_ACTIVATION_CONTEXT_EMPTY : i32 = 14089;
pub const ERROR_SXS_INVALID_IDENTITY_ATTRIBUTE_VALUE : i32 = 14090;
pub const ERROR_SXS_INVALID_IDENTITY_ATTRIBUTE_NAME : i32 = 14091;
pub const ERROR_SXS_IDENTITY_DUPLICATE_ATTRIBUTE : i32 = 14092;
pub const ERROR_SXS_IDENTITY_PARSE_ERROR : i32 = 14093;
pub const ERROR_MALFORMED_SUBSTITUTION_STRING : i32 = 14094;
pub const ERROR_SXS_INCORRECT_PUBLIC_KEY_TOKEN : i32 = 14095;
pub const ERROR_UNMAPPED_SUBSTITUTION_STRING : i32 = 14096;
pub const ERROR_SXS_ASSEMBLY_NOT_LOCKED : i32 = 14097;
pub const ERROR_SXS_COMPONENT_STORE_CORRUPT : i32 = 14098;
pub const ERROR_ADVANCED_INSTALLER_FAILED : i32 = 14099;
pub const ERROR_XML_ENCODING_MISMATCH : i32 = 14100;
pub const ERROR_SXS_MANIFEST_IDENTITY_SAME_BUT_CONTENTS_DIFFERENT : i32 = 14101;
pub const ERROR_SXS_IDENTITIES_DIFFERENT : i32 = 14102;
pub const ERROR_SXS_ASSEMBLY_IS_NOT_A_DEPLOYMENT : i32 = 14103;
pub const ERROR_SXS_FILE_NOT_PART_OF_ASSEMBLY : i32 = 14104;
pub const ERROR_SXS_MANIFEST_TOO_BIG : i32 = 14105;
pub const ERROR_SXS_SETTING_NOT_REGISTERED : i32 = 14106;
pub const ERROR_SXS_TRANSACTION_CLOSURE_INCOMPLETE : i32 = 14107;
pub const ERROR_SMI_PRIMITIVE_INSTALLER_FAILED : i32 = 14108;
pub const ERROR_GENERIC_COMMAND_FAILED : i32 = 14109;
pub const ERROR_SXS_FILE_HASH_MISSING : i32 = 14110;
pub const ERROR_SXS_DUPLICATE_ACTIVATABLE_CLASS : i32 = 14111;
pub const ERROR_EVT_INVALID_CHANNEL_PATH : i32 = 15000;
pub const ERROR_EVT_INVALID_QUERY : i32 = 15001;
pub const ERROR_EVT_PUBLISHER_METADATA_NOT_FOUND : i32 = 15002;
pub const ERROR_EVT_EVENT_TEMPLATE_NOT_FOUND : i32 = 15003;
pub const ERROR_EVT_INVALID_PUBLISHER_NAME : i32 = 15004;
pub const ERROR_EVT_INVALID_EVENT_DATA : i32 = 15005;
pub const ERROR_EVT_CHANNEL_NOT_FOUND : i32 = 15007;
pub const ERROR_EVT_MALFORMED_XML_TEXT : i32 = 15008;
pub const ERROR_EVT_SUBSCRIPTION_TO_DIRECT_CHANNEL : i32 = 15009;
pub const ERROR_EVT_CONFIGURATION_ERROR : i32 = 15010;
pub const ERROR_EVT_QUERY_RESULT_STALE : i32 = 15011;
pub const ERROR_EVT_QUERY_RESULT_INVALID_POSITION : i32 = 15012;
pub const ERROR_EVT_NON_VALIDATING_MSXML : i32 = 15013;
pub const ERROR_EVT_FILTER_ALREADYSCOPED : i32 = 15014;
pub const ERROR_EVT_FILTER_NOTELTSET : i32 = 15015;
pub const ERROR_EVT_FILTER_INVARG : i32 = 15016;
pub const ERROR_EVT_FILTER_INVTEST : i32 = 15017;
pub const ERROR_EVT_FILTER_INVTYPE : i32 = 15018;
pub const ERROR_EVT_FILTER_PARSEERR : i32 = 15019;
pub const ERROR_EVT_FILTER_UNSUPPORTEDOP : i32 = 15020;
pub const ERROR_EVT_FILTER_UNEXPECTEDTOKEN : i32 = 15021;
pub const ERROR_EVT_INVALID_OPERATION_OVER_ENABLED_DIRECT_CHANNEL : i32 = 15022;
pub const ERROR_EVT_INVALID_CHANNEL_PROPERTY_VALUE : i32 = 15023;
pub const ERROR_EVT_INVALID_PUBLISHER_PROPERTY_VALUE : i32 = 15024;
pub const ERROR_EVT_CHANNEL_CANNOT_ACTIVATE : i32 = 15025;
pub const ERROR_EVT_FILTER_TOO_COMPLEX : i32 = 15026;
pub const ERROR_EVT_MESSAGE_NOT_FOUND : i32 = 15027;
pub const ERROR_EVT_MESSAGE_ID_NOT_FOUND : i32 = 15028;
pub const ERROR_EVT_UNRESOLVED_VALUE_INSERT : i32 = 15029;
pub const ERROR_EVT_UNRESOLVED_PARAMETER_INSERT : i32 = 15030;
pub const ERROR_EVT_MAX_INSERTS_REACHED : i32 = 15031;
pub const ERROR_EVT_EVENT_DEFINITION_NOT_FOUND : i32 = 15032;
pub const ERROR_EVT_MESSAGE_LOCALE_NOT_FOUND : i32 = 15033;
pub const ERROR_EVT_VERSION_TOO_OLD : i32 = 15034;
pub const ERROR_EVT_VERSION_TOO_NEW : i32 = 15035;
pub const ERROR_EVT_CANNOT_OPEN_CHANNEL_OF_QUERY : i32 = 15036;
pub const ERROR_EVT_PUBLISHER_DISABLED : i32 = 15037;
pub const ERROR_EVT_FILTER_OUT_OF_RANGE : i32 = 15038;
pub const ERROR_EC_SUBSCRIPTION_CANNOT_ACTIVATE : i32 = 15080;
pub const ERROR_EC_LOG_DISABLED : i32 = 15081;
pub const ERROR_EC_CIRCULAR_FORWARDING : i32 = 15082;
pub const ERROR_EC_CREDSTORE_FULL : i32 = 15083;
pub const ERROR_EC_CRED_NOT_FOUND : i32 = 15084;
pub const ERROR_EC_NO_ACTIVE_CHANNEL : i32 = 15085;
pub const ERROR_MUI_FILE_NOT_FOUND : i32 = 15100;
pub const ERROR_MUI_INVALID_FILE : i32 = 15101;
pub const ERROR_MUI_INVALID_RC_CONFIG : i32 = 15102;
pub const ERROR_MUI_INVALID_LOCALE_NAME : i32 = 15103;
pub const ERROR_MUI_INVALID_ULTIMATEFALLBACK_NAME : i32 = 15104;
pub const ERROR_MUI_FILE_NOT_LOADED : i32 = 15105;
pub const ERROR_RESOURCE_ENUM_USER_STOP : i32 = 15106;
pub const ERROR_MUI_INTLSETTINGS_UILANG_NOT_INSTALLED : i32 = 15107;
pub const ERROR_MUI_INTLSETTINGS_INVALID_LOCALE_NAME : i32 = 15108;
pub const ERROR_MRM_RUNTIME_NO_DEFAULT_OR_NEUTRAL_RESOURCE : i32 = 15110;
pub const ERROR_MRM_INVALID_PRICONFIG : i32 = 15111;
pub const ERROR_MRM_INVALID_FILE_TYPE : i32 = 15112;
pub const ERROR_MRM_UNKNOWN_QUALIFIER : i32 = 15113;
pub const ERROR_MRM_INVALID_QUALIFIER_VALUE : i32 = 15114;
pub const ERROR_MRM_NO_CANDIDATE : i32 = 15115;
pub const ERROR_MRM_NO_MATCH_OR_DEFAULT_CANDIDATE : i32 = 15116;
pub const ERROR_MRM_RESOURCE_TYPE_MISMATCH : i32 = 15117;
pub const ERROR_MRM_DUPLICATE_MAP_NAME : i32 = 15118;
pub const ERROR_MRM_DUPLICATE_ENTRY : i32 = 15119;
pub const ERROR_MRM_INVALID_RESOURCE_IDENTIFIER : i32 = 15120;
pub const ERROR_MRM_FILEPATH_TOO_LONG : i32 = 15121;
pub const ERROR_MRM_UNSUPPORTED_DIRECTORY_TYPE : i32 = 15122;
pub const ERROR_MRM_INVALID_PRI_FILE : i32 = 15126;
pub const ERROR_MRM_NAMED_RESOURCE_NOT_FOUND : i32 = 15127;
pub const ERROR_MRM_MAP_NOT_FOUND : i32 = 15135;
pub const ERROR_MRM_UNSUPPORTED_PROFILE_TYPE : i32 = 15136;
pub const ERROR_MRM_INVALID_QUALIFIER_OPERATOR : i32 = 15137;
pub const ERROR_MRM_INDETERMINATE_QUALIFIER_VALUE : i32 = 15138;
pub const ERROR_MRM_AUTOMERGE_ENABLED : i32 = 15139;
pub const ERROR_MRM_TOO_MANY_RESOURCES : i32 = 15140;
pub const ERROR_MRM_UNSUPPORTED_FILE_TYPE_FOR_MERGE : i32 = 15141;
pub const ERROR_MRM_UNSUPPORTED_FILE_TYPE_FOR_LOAD_UNLOAD_PRI_FILE : i32 = 15142;
pub const ERROR_MRM_NO_CURRENT_VIEW_ON_THREAD : i32 = 15143;
pub const ERROR_DIFFERENT_PROFILE_RESOURCE_MANAGER_EXIST : i32 = 15144;
pub const ERROR_OPERATION_NOT_ALLOWED_FROM_SYSTEM_COMPONENT : i32 = 15145;
pub const ERROR_MRM_DIRECT_REF_TO_NON_DEFAULT_RESOURCE : i32 = 15146;
pub const ERROR_MRM_GENERATION_COUNT_MISMATCH : i32 = 15147;
pub const ERROR_PRI_MERGE_VERSION_MISMATCH : i32 = 15148;
pub const ERROR_PRI_MERGE_MISSING_SCHEMA : i32 = 15149;
pub const ERROR_PRI_MERGE_LOAD_FILE_FAILED : i32 = 15150;
pub const ERROR_PRI_MERGE_ADD_FILE_FAILED : i32 = 15151;
pub const ERROR_PRI_MERGE_WRITE_FILE_FAILED : i32 = 15152;
pub const ERROR_PRI_MERGE_MULTIPLE_PACKAGE_FAMILIES_NOT_ALLOWED : i32 = 15153;
pub const ERROR_PRI_MERGE_MULTIPLE_MAIN_PACKAGES_NOT_ALLOWED : i32 = 15154;
pub const ERROR_PRI_MERGE_BUNDLE_PACKAGES_NOT_ALLOWED : i32 = 15155;
pub const ERROR_PRI_MERGE_MAIN_PACKAGE_REQUIRED : i32 = 15156;
pub const ERROR_PRI_MERGE_RESOURCE_PACKAGE_REQUIRED : i32 = 15157;
pub const ERROR_PRI_MERGE_INVALID_FILE_NAME : i32 = 15158;
pub const ERROR_MRM_PACKAGE_NOT_FOUND : i32 = 15159;
pub const ERROR_MRM_MISSING_DEFAULT_LANGUAGE : i32 = 15160;
pub const ERROR_MCA_INVALID_CAPABILITIES_STRING : i32 = 15200;
pub const ERROR_MCA_INVALID_VCP_VERSION : i32 = 15201;
pub const ERROR_MCA_MONITOR_VIOLATES_MCCS_SPECIFICATION : i32 = 15202;
pub const ERROR_MCA_MCCS_VERSION_MISMATCH : i32 = 15203;
pub const ERROR_MCA_UNSUPPORTED_MCCS_VERSION : i32 = 15204;
pub const ERROR_MCA_INTERNAL_ERROR : i32 = 15205;
pub const ERROR_MCA_INVALID_TECHNOLOGY_TYPE_RETURNED : i32 = 15206;
pub const ERROR_MCA_UNSUPPORTED_COLOR_TEMPERATURE : i32 = 15207;
pub const ERROR_AMBIGUOUS_SYSTEM_DEVICE : i32 = 15250;
pub const ERROR_SYSTEM_DEVICE_NOT_FOUND : i32 = 15299;
pub const ERROR_HASH_NOT_SUPPORTED : i32 = 15300;
pub const ERROR_HASH_NOT_PRESENT : i32 = 15301;
pub const ERROR_SECONDARY_IC_PROVIDER_NOT_REGISTERED : i32 = 15321;
pub const ERROR_GPIO_CLIENT_INFORMATION_INVALID : i32 = 15322;
pub const ERROR_GPIO_VERSION_NOT_SUPPORTED : i32 = 15323;
pub const ERROR_GPIO_INVALID_REGISTRATION_PACKET : i32 = 15324;
pub const ERROR_GPIO_OPERATION_DENIED : i32 = 15325;
pub const ERROR_GPIO_INCOMPATIBLE_CONNECT_MODE : i32 = 15326;
pub const ERROR_GPIO_INTERRUPT_ALREADY_UNMASKED : i32 = 15327;
pub const ERROR_CANNOT_SWITCH_RUNLEVEL : i32 = 15400;
pub const ERROR_INVALID_RUNLEVEL_SETTING : i32 = 15401;
pub const ERROR_RUNLEVEL_SWITCH_TIMEOUT : i32 = 15402;
pub const ERROR_RUNLEVEL_SWITCH_AGENT_TIMEOUT : i32 = 15403;
pub const ERROR_RUNLEVEL_SWITCH_IN_PROGRESS : i32 = 15404;
pub const ERROR_SERVICES_FAILED_AUTOSTART : i32 = 15405;
pub const ERROR_COM_TASK_STOP_PENDING : i32 = 15501;
pub const ERROR_INSTALL_OPEN_PACKAGE_FAILED : i32 = 15600;
pub const ERROR_INSTALL_PACKAGE_NOT_FOUND : i32 = 15601;
pub const ERROR_INSTALL_INVALID_PACKAGE : i32 = 15602;
pub const ERROR_INSTALL_RESOLVE_DEPENDENCY_FAILED : i32 = 15603;
pub const ERROR_INSTALL_OUT_OF_DISK_SPACE : i32 = 15604;
pub const ERROR_INSTALL_NETWORK_FAILURE : i32 = 15605;
pub const ERROR_INSTALL_REGISTRATION_FAILURE : i32 = 15606;
pub const ERROR_INSTALL_DEREGISTRATION_FAILURE : i32 = 15607;
pub const ERROR_INSTALL_CANCEL : i32 = 15608;
pub const ERROR_INSTALL_FAILED : i32 = 15609;
pub const ERROR_REMOVE_FAILED : i32 = 15610;
pub const ERROR_PACKAGE_ALREADY_EXISTS : i32 = 15611;
pub const ERROR_NEEDS_REMEDIATION : i32 = 15612;
pub const ERROR_INSTALL_PREREQUISITE_FAILED : i32 = 15613;
pub const ERROR_PACKAGE_REPOSITORY_CORRUPTED : i32 = 15614;
pub const ERROR_INSTALL_POLICY_FAILURE : i32 = 15615;
pub const ERROR_PACKAGE_UPDATING : i32 = 15616;
pub const ERROR_DEPLOYMENT_BLOCKED_BY_POLICY : i32 = 15617;
pub const ERROR_PACKAGES_IN_USE : i32 = 15618;
pub const ERROR_RECOVERY_FILE_CORRUPT : i32 = 15619;
pub const ERROR_INVALID_STAGED_SIGNATURE : i32 = 15620;
pub const ERROR_DELETING_EXISTING_APPLICATIONDATA_STORE_FAILED : i32 = 15621;
pub const ERROR_INSTALL_PACKAGE_DOWNGRADE : i32 = 15622;
pub const ERROR_SYSTEM_NEEDS_REMEDIATION : i32 = 15623;
pub const ERROR_APPX_INTEGRITY_FAILURE_CLR_NGEN : i32 = 15624;
pub const ERROR_RESILIENCY_FILE_CORRUPT : i32 = 15625;
pub const ERROR_INSTALL_FIREWALL_SERVICE_NOT_RUNNING : i32 = 15626;
pub const ERROR_PACKAGE_MOVE_FAILED : i32 = 15627;
pub const ERROR_INSTALL_VOLUME_NOT_EMPTY : i32 = 15628;
pub const ERROR_INSTALL_VOLUME_OFFLINE : i32 = 15629;
pub const ERROR_INSTALL_VOLUME_CORRUPT : i32 = 15630;
pub const ERROR_NEEDS_REGISTRATION : i32 = 15631;
pub const ERROR_INSTALL_WRONG_PROCESSOR_ARCHITECTURE : i32 = 15632;
pub const ERROR_DEV_SIDELOAD_LIMIT_EXCEEDED : i32 = 15633;
pub const ERROR_INSTALL_OPTIONAL_PACKAGE_REQUIRES_MAIN_PACKAGE : i32 = 15634;
pub const ERROR_PACKAGE_NOT_SUPPORTED_ON_FILESYSTEM : i32 = 15635;
pub const ERROR_PACKAGE_MOVE_BLOCKED_BY_STREAMING : i32 = 15636;
pub const ERROR_INSTALL_OPTIONAL_PACKAGE_APPLICATIONID_NOT_UNIQUE : i32 = 15637;
pub const ERROR_PACKAGE_STAGING_ONHOLD : i32 = 15638;
pub const ERROR_INSTALL_INVALID_RELATED_SET_UPDATE : i32 = 15639;
pub const ERROR_INSTALL_OPTIONAL_PACKAGE_REQUIRES_MAIN_PACKAGE_FULLTRUST_CAPABILITY : i32 = 15640;
pub const ERROR_DEPLOYMENT_BLOCKED_BY_USER_LOG_OFF : i32 = 15641;
pub const ERROR_PROVISION_OPTIONAL_PACKAGE_REQUIRES_MAIN_PACKAGE_PROVISIONED : i32 = 15642;
pub const ERROR_PACKAGES_REPUTATION_CHECK_FAILED : i32 = 15643;
pub const ERROR_PACKAGES_REPUTATION_CHECK_TIMEDOUT : i32 = 15644;
pub const ERROR_DEPLOYMENT_OPTION_NOT_SUPPORTED : i32 = 15645;
pub const ERROR_APPINSTALLER_ACTIVATION_BLOCKED : i32 = 15646;
pub const ERROR_REGISTRATION_FROM_REMOTE_DRIVE_NOT_SUPPORTED : i32 = 15647;
pub const ERROR_APPX_RAW_DATA_WRITE_FAILED : i32 = 15648;
pub const ERROR_DEPLOYMENT_BLOCKED_BY_VOLUME_POLICY_PACKAGE : i32 = 15649;
pub const ERROR_DEPLOYMENT_BLOCKED_BY_VOLUME_POLICY_MACHINE : i32 = 15650;
pub const ERROR_DEPLOYMENT_BLOCKED_BY_PROFILE_POLICY : i32 = 15651;
pub const ERROR_DEPLOYMENT_FAILED_CONFLICTING_MUTABLE_PACKAGE_DIRECTORY : i32 = 15652;
pub const ERROR_SINGLETON_RESOURCE_INSTALLED_IN_ACTIVE_USER : i32 = 15653;
pub const ERROR_DIFFERENT_VERSION_OF_PACKAGED_SERVICE_INSTALLED : i32 = 15654;
pub const ERROR_SERVICE_EXISTS_AS_NON_PACKAGED_SERVICE : i32 = 15655;
pub const ERROR_PACKAGED_SERVICE_REQUIRES_ADMIN_PRIVILEGES : i32 = 15656;
pub const ERROR_REDIRECTION_TO_DEFAULT_ACCOUNT_NOT_ALLOWED : i32 = 15657;
pub const ERROR_PACKAGE_LACKS_CAPABILITY_TO_DEPLOY_ON_HOST : i32 = 15658;
pub const ERROR_UNSIGNED_PACKAGE_INVALID_CONTENT : i32 = 15659;
pub const ERROR_UNSIGNED_PACKAGE_INVALID_PUBLISHER_NAMESPACE : i32 = 15660;
pub const ERROR_SIGNED_PACKAGE_INVALID_PUBLISHER_NAMESPACE : i32 = 15661;
pub const ERROR_PACKAGE_EXTERNAL_LOCATION_NOT_ALLOWED : i32 = 15662;
pub const ERROR_INSTALL_FULLTRUST_HOSTRUNTIME_REQUIRES_MAIN_PACKAGE_FULLTRUST_CAPABILITY : i32 = 15663;
pub const APPMODEL_ERROR_NO_PACKAGE : i32 = 15700;
pub const APPMODEL_ERROR_PACKAGE_RUNTIME_CORRUPT : i32 = 15701;
pub const APPMODEL_ERROR_PACKAGE_IDENTITY_CORRUPT : i32 = 15702;
pub const APPMODEL_ERROR_NO_APPLICATION : i32 = 15703;
pub const APPMODEL_ERROR_DYNAMIC_PROPERTY_READ_FAILED : i32 = 15704;
pub const APPMODEL_ERROR_DYNAMIC_PROPERTY_INVALID : i32 = 15705;
pub const APPMODEL_ERROR_PACKAGE_NOT_AVAILABLE : i32 = 15706;
pub const APPMODEL_ERROR_NO_MUTABLE_DIRECTORY : i32 = 15707;
pub const ERROR_STATE_LOAD_STORE_FAILED : i32 = 15800;
pub const ERROR_STATE_GET_VERSION_FAILED : i32 = 15801;
pub const ERROR_STATE_SET_VERSION_FAILED : i32 = 15802;
pub const ERROR_STATE_STRUCTURED_RESET_FAILED : i32 = 15803;
pub const ERROR_STATE_OPEN_CONTAINER_FAILED : i32 = 15804;
pub const ERROR_STATE_CREATE_CONTAINER_FAILED : i32 = 15805;
pub const ERROR_STATE_DELETE_CONTAINER_FAILED : i32 = 15806;
pub const ERROR_STATE_READ_SETTING_FAILED : i32 = 15807;
pub const ERROR_STATE_WRITE_SETTING_FAILED : i32 = 15808;
pub const ERROR_STATE_DELETE_SETTING_FAILED : i32 = 15809;
pub const ERROR_STATE_QUERY_SETTING_FAILED : i32 = 15810;
pub const ERROR_STATE_READ_COMPOSITE_SETTING_FAILED : i32 = 15811;
pub const ERROR_STATE_WRITE_COMPOSITE_SETTING_FAILED : i32 = 15812;
pub const ERROR_STATE_ENUMERATE_CONTAINER_FAILED : i32 = 15813;
pub const ERROR_STATE_ENUMERATE_SETTINGS_FAILED : i32 = 15814;
pub const ERROR_STATE_COMPOSITE_SETTING_VALUE_SIZE_LIMIT_EXCEEDED : i32 = 15815;
pub const ERROR_STATE_SETTING_VALUE_SIZE_LIMIT_EXCEEDED : i32 = 15816;
pub const ERROR_STATE_SETTING_NAME_SIZE_LIMIT_EXCEEDED : i32 = 15817;
pub const ERROR_STATE_CONTAINER_NAME_SIZE_LIMIT_EXCEEDED : i32 = 15818;
pub const ERROR_API_UNAVAILABLE : i32 = 15841;
pub const STORE_ERROR_UNLICENSED : i32 = 15861;
pub const STORE_ERROR_UNLICENSED_USER : i32 = 15862;
pub const STORE_ERROR_PENDING_COM_TRANSACTION : i32 = 15863;
pub const STORE_ERROR_LICENSE_REVOKED : i32 = 15864;
pub const SEVERITY_SUCCESS : i32 = 0;
pub const SEVERITY_ERROR : i32 = 1;
pub const FACILITY_NT_BIT : i32 = 268435456;
pub const NOERROR : i32 = 0;
pub const E_UNEXPECTED : i32 = -2147418113;
pub const E_NOTIMPL : i32 = -2147467263;
pub const E_OUTOFMEMORY : i32 = -2147024882;
pub const E_INVALIDARG : i32 = -2147024809;
pub const E_NOINTERFACE : i32 = -2147467262;
pub const E_POINTER : i32 = -2147467261;
pub const E_HANDLE : i32 = -2147024890;
pub const E_ABORT : i32 = -2147467260;
pub const E_FAIL : i32 = -2147467259;
pub const E_ACCESSDENIED : i32 = -2147024891;
pub const E_PENDING : i32 = -2147483638;
pub const E_BOUNDS : i32 = -2147483637;
pub const E_CHANGED_STATE : i32 = -2147483636;
pub const E_ILLEGAL_STATE_CHANGE : i32 = -2147483635;
pub const E_ILLEGAL_METHOD_CALL : i32 = -2147483634;
pub const RO_E_METADATA_NAME_NOT_FOUND : i32 = -2147483633;
pub const RO_E_METADATA_NAME_IS_NAMESPACE : i32 = -2147483632;
pub const RO_E_METADATA_INVALID_TYPE_FORMAT : i32 = -2147483631;
pub const RO_E_INVALID_METADATA_FILE : i32 = -2147483630;
pub const RO_E_CLOSED : i32 = -2147483629;
pub const RO_E_EXCLUSIVE_WRITE : i32 = -2147483628;
pub const RO_E_CHANGE_NOTIFICATION_IN_PROGRESS : i32 = -2147483627;
pub const RO_E_ERROR_STRING_NOT_FOUND : i32 = -2147483626;
pub const E_STRING_NOT_NULL_TERMINATED : i32 = -2147483625;
pub const E_ILLEGAL_DELEGATE_ASSIGNMENT : i32 = -2147483624;
pub const E_ASYNC_OPERATION_NOT_STARTED : i32 = -2147483623;
pub const E_APPLICATION_EXITING : i32 = -2147483622;
pub const E_APPLICATION_VIEW_EXITING : i32 = -2147483621;
pub const RO_E_MUST_BE_AGILE : i32 = -2147483620;
pub const RO_E_UNSUPPORTED_FROM_MTA : i32 = -2147483619;
pub const RO_E_COMMITTED : i32 = -2147483618;
pub const RO_E_BLOCKED_CROSS_ASTA_CALL : i32 = -2147483617;
pub const RO_E_CANNOT_ACTIVATE_FULL_TRUST_SERVER : i32 = -2147483616;
pub const RO_E_CANNOT_ACTIVATE_UNIVERSAL_APPLICATION_SERVER : i32 = -2147483615;
pub const CO_E_INIT_TLS : i32 = -2147467258;
pub const CO_E_INIT_SHARED_ALLOCATOR : i32 = -2147467257;
pub const CO_E_INIT_MEMORY_ALLOCATOR : i32 = -2147467256;
pub const CO_E_INIT_CLASS_CACHE : i32 = -2147467255;
pub const CO_E_INIT_RPC_CHANNEL : i32 = -2147467254;
pub const CO_E_INIT_TLS_SET_CHANNEL_CONTROL : i32 = -2147467253;
pub const CO_E_INIT_TLS_CHANNEL_CONTROL : i32 = -2147467252;
pub const CO_E_INIT_UNACCEPTED_USER_ALLOCATOR : i32 = -2147467251;
pub const CO_E_INIT_SCM_MUTEX_EXISTS : i32 = -2147467250;
pub const CO_E_INIT_SCM_FILE_MAPPING_EXISTS : i32 = -2147467249;
pub const CO_E_INIT_SCM_MAP_VIEW_OF_FILE : i32 = -2147467248;
pub const CO_E_INIT_SCM_EXEC_FAILURE : i32 = -2147467247;
pub const CO_E_INIT_ONLY_SINGLE_THREADED : i32 = -2147467246;
pub const CO_E_CANT_REMOTE : i32 = -2147467245;
pub const CO_E_BAD_SERVER_NAME : i32 = -2147467244;
pub const CO_E_WRONG_SERVER_IDENTITY : i32 = -2147467243;
pub const CO_E_OLE1DDE_DISABLED : i32 = -2147467242;
pub const CO_E_RUNAS_SYNTAX : i32 = -2147467241;
pub const CO_E_CREATEPROCESS_FAILURE : i32 = -2147467240;
pub const CO_E_RUNAS_CREATEPROCESS_FAILURE : i32 = -2147467239;
pub const CO_E_RUNAS_LOGON_FAILURE : i32 = -2147467238;
pub const CO_E_LAUNCH_PERMSSION_DENIED : i32 = -2147467237;
pub const CO_E_START_SERVICE_FAILURE : i32 = -2147467236;
pub const CO_E_REMOTE_COMMUNICATION_FAILURE : i32 = -2147467235;
pub const CO_E_SERVER_START_TIMEOUT : i32 = -2147467234;
pub const CO_E_CLSREG_INCONSISTENT : i32 = -2147467233;
pub const CO_E_IIDREG_INCONSISTENT : i32 = -2147467232;
pub const CO_E_NOT_SUPPORTED : i32 = -2147467231;
pub const CO_E_RELOAD_DLL : i32 = -2147467230;
pub const CO_E_MSI_ERROR : i32 = -2147467229;
pub const CO_E_ATTEMPT_TO_CREATE_OUTSIDE_CLIENT_CONTEXT : i32 = -2147467228;
pub const CO_E_SERVER_PAUSED : i32 = -2147467227;
pub const CO_E_SERVER_NOT_PAUSED : i32 = -2147467226;
pub const CO_E_CLASS_DISABLED : i32 = -2147467225;
pub const CO_E_CLRNOTAVAILABLE : i32 = -2147467224;
pub const CO_E_ASYNC_WORK_REJECTED : i32 = -2147467223;
pub const CO_E_SERVER_INIT_TIMEOUT : i32 = -2147467222;
pub const CO_E_NO_SECCTX_IN_ACTIVATE : i32 = -2147467221;
pub const CO_E_TRACKER_CONFIG : i32 = -2147467216;
pub const CO_E_THREADPOOL_CONFIG : i32 = -2147467215;
pub const CO_E_SXS_CONFIG : i32 = -2147467214;
pub const CO_E_MALFORMED_SPN : i32 = -2147467213;
pub const CO_E_UNREVOKED_REGISTRATION_ON_APARTMENT_SHUTDOWN : i32 = -2147467212;
pub const CO_E_PREMATURE_STUB_RUNDOWN : i32 = -2147467211;
pub const S_OK : i32 = 0;
pub const S_FALSE : i32 = 1;
pub const OLE_E_FIRST : i32 = -2147221504;
pub const OLE_E_LAST : i32 = -2147221249;
pub const OLE_S_FIRST : i32 = 262144;
pub const OLE_S_LAST : i32 = 262399;
pub const OLE_E_OLEVERB : i32 = -2147221504;
pub const OLE_E_ADVF : i32 = -2147221503;
pub const OLE_E_ENUM_NOMORE : i32 = -2147221502;
pub const OLE_E_ADVISENOTSUPPORTED : i32 = -2147221501;
pub const OLE_E_NOCONNECTION : i32 = -2147221500;
pub const OLE_E_NOTRUNNING : i32 = -2147221499;
pub const OLE_E_NOCACHE : i32 = -2147221498;
pub const OLE_E_BLANK : i32 = -2147221497;
pub const OLE_E_CLASSDIFF : i32 = -2147221496;
pub const OLE_E_CANT_GETMONIKER : i32 = -2147221495;
pub const OLE_E_CANT_BINDTOSOURCE : i32 = -2147221494;
pub const OLE_E_STATIC : i32 = -2147221493;
pub const OLE_E_PROMPTSAVECANCELLED : i32 = -2147221492;
pub const OLE_E_INVALIDRECT : i32 = -2147221491;
pub const OLE_E_WRONGCOMPOBJ : i32 = -2147221490;
pub const OLE_E_INVALIDHWND : i32 = -2147221489;
pub const OLE_E_NOT_INPLACEACTIVE : i32 = -2147221488;
pub const OLE_E_CANTCONVERT : i32 = -2147221487;
pub const OLE_E_NOSTORAGE : i32 = -2147221486;
pub const DV_E_FORMATETC : i32 = -2147221404;
pub const DV_E_DVTARGETDEVICE : i32 = -2147221403;
pub const DV_E_STGMEDIUM : i32 = -2147221402;
pub const DV_E_STATDATA : i32 = -2147221401;
pub const DV_E_LINDEX : i32 = -2147221400;
pub const DV_E_TYMED : i32 = -2147221399;
pub const DV_E_CLIPFORMAT : i32 = -2147221398;
pub const DV_E_DVASPECT : i32 = -2147221397;
pub const DV_E_DVTARGETDEVICE_SIZE : i32 = -2147221396;
pub const DV_E_NOIVIEWOBJECT : i32 = -2147221395;
pub const DRAGDROP_E_FIRST : i32 = -2147221248;
pub const DRAGDROP_E_LAST : i32 = -2147221233;
pub const DRAGDROP_S_FIRST : i32 = 262400;
pub const DRAGDROP_S_LAST : i32 = 262415;
pub const DRAGDROP_E_NOTREGISTERED : i32 = -2147221248;
pub const DRAGDROP_E_ALREADYREGISTERED : i32 = -2147221247;
pub const DRAGDROP_E_INVALIDHWND : i32 = -2147221246;
pub const DRAGDROP_E_CONCURRENT_DRAG_ATTEMPTED : i32 = -2147221245;
pub const CLASSFACTORY_E_FIRST : i32 = -2147221232;
pub const CLASSFACTORY_E_LAST : i32 = -2147221217;
pub const CLASSFACTORY_S_FIRST : i32 = 262416;
pub const CLASSFACTORY_S_LAST : i32 = 262431;
pub const CLASS_E_NOAGGREGATION : i32 = -2147221232;
pub const CLASS_E_CLASSNOTAVAILABLE : i32 = -2147221231;
pub const CLASS_E_NOTLICENSED : i32 = -2147221230;
pub const MARSHAL_E_FIRST : i32 = -2147221216;
pub const MARSHAL_E_LAST : i32 = -2147221201;
pub const MARSHAL_S_FIRST : i32 = 262432;
pub const MARSHAL_S_LAST : i32 = 262447;
pub const DATA_E_FIRST : i32 = -2147221200;
pub const DATA_E_LAST : i32 = -2147221185;
pub const DATA_S_FIRST : i32 = 262448;
pub const DATA_S_LAST : i32 = 262463;
pub const VIEW_E_FIRST : i32 = -2147221184;
pub const VIEW_E_LAST : i32 = -2147221169;
pub const VIEW_S_FIRST : i32 = 262464;
pub const VIEW_S_LAST : i32 = 262479;
pub const VIEW_E_DRAW : i32 = -2147221184;
pub const REGDB_E_FIRST : i32 = -2147221168;
pub const REGDB_E_LAST : i32 = -2147221153;
pub const REGDB_S_FIRST : i32 = 262480;
pub const REGDB_S_LAST : i32 = 262495;
pub const REGDB_E_READREGDB : i32 = -2147221168;
pub const REGDB_E_WRITEREGDB : i32 = -2147221167;
pub const REGDB_E_KEYMISSING : i32 = -2147221166;
pub const REGDB_E_INVALIDVALUE : i32 = -2147221165;
pub const REGDB_E_CLASSNOTREG : i32 = -2147221164;
pub const REGDB_E_IIDNOTREG : i32 = -2147221163;
pub const REGDB_E_BADTHREADINGMODEL : i32 = -2147221162;
pub const REGDB_E_PACKAGEPOLICYVIOLATION : i32 = -2147221161;
pub const CAT_E_FIRST : i32 = -2147221152;
pub const CAT_E_LAST : i32 = -2147221151;
pub const CAT_E_CATIDNOEXIST : i32 = -2147221152;
pub const CAT_E_NODESCRIPTION : i32 = -2147221151;
pub const CS_E_FIRST : i32 = -2147221148;
pub const CS_E_LAST : i32 = -2147221137;
pub const CS_E_PACKAGE_NOTFOUND : i32 = -2147221148;
pub const CS_E_NOT_DELETABLE : i32 = -2147221147;
pub const CS_E_CLASS_NOTFOUND : i32 = -2147221146;
pub const CS_E_INVALID_VERSION : i32 = -2147221145;
pub const CS_E_NO_CLASSSTORE : i32 = -2147221144;
pub const CS_E_OBJECT_NOTFOUND : i32 = -2147221143;
pub const CS_E_OBJECT_ALREADY_EXISTS : i32 = -2147221142;
pub const CS_E_INVALID_PATH : i32 = -2147221141;
pub const CS_E_NETWORK_ERROR : i32 = -2147221140;
pub const CS_E_ADMIN_LIMIT_EXCEEDED : i32 = -2147221139;
pub const CS_E_SCHEMA_MISMATCH : i32 = -2147221138;
pub const CS_E_INTERNAL_ERROR : i32 = -2147221137;
pub const CACHE_E_FIRST : i32 = -2147221136;
pub const CACHE_E_LAST : i32 = -2147221121;
pub const CACHE_S_FIRST : i32 = 262512;
pub const CACHE_S_LAST : i32 = 262527;
pub const CACHE_E_NOCACHE_UPDATED : i32 = -2147221136;
pub const OLEOBJ_E_FIRST : i32 = -2147221120;
pub const OLEOBJ_E_LAST : i32 = -2147221105;
pub const OLEOBJ_S_FIRST : i32 = 262528;
pub const OLEOBJ_S_LAST : i32 = 262543;
pub const OLEOBJ_E_NOVERBS : i32 = -2147221120;
pub const OLEOBJ_E_INVALIDVERB : i32 = -2147221119;
pub const CLIENTSITE_E_FIRST : i32 = -2147221104;
pub const CLIENTSITE_E_LAST : i32 = -2147221089;
pub const CLIENTSITE_S_FIRST : i32 = 262544;
pub const CLIENTSITE_S_LAST : i32 = 262559;
pub const INPLACE_E_NOTUNDOABLE : i32 = -2147221088;
pub const INPLACE_E_NOTOOLSPACE : i32 = -2147221087;
pub const INPLACE_E_FIRST : i32 = -2147221088;
pub const INPLACE_E_LAST : i32 = -2147221073;
pub const INPLACE_S_FIRST : i32 = 262560;
pub const INPLACE_S_LAST : i32 = 262575;
pub const ENUM_E_FIRST : i32 = -2147221072;
pub const ENUM_E_LAST : i32 = -2147221057;
pub const ENUM_S_FIRST : i32 = 262576;
pub const ENUM_S_LAST : i32 = 262591;
pub const CONVERT10_E_FIRST : i32 = -2147221056;
pub const CONVERT10_E_LAST : i32 = -2147221041;
pub const CONVERT10_S_FIRST : i32 = 262592;
pub const CONVERT10_S_LAST : i32 = 262607;
pub const CONVERT10_E_OLESTREAM_GET : i32 = -2147221056;
pub const CONVERT10_E_OLESTREAM_PUT : i32 = -2147221055;
pub const CONVERT10_E_OLESTREAM_FMT : i32 = -2147221054;
pub const CONVERT10_E_OLESTREAM_BITMAP_TO_DIB : i32 = -2147221053;
pub const CONVERT10_E_STG_FMT : i32 = -2147221052;
pub const CONVERT10_E_STG_NO_STD_STREAM : i32 = -2147221051;
pub const CONVERT10_E_STG_DIB_TO_BITMAP : i32 = -2147221050;
pub const CLIPBRD_E_FIRST : i32 = -2147221040;
pub const CLIPBRD_E_LAST : i32 = -2147221025;
pub const CLIPBRD_S_FIRST : i32 = 262608;
pub const CLIPBRD_S_LAST : i32 = 262623;
pub const CLIPBRD_E_CANT_OPEN : i32 = -2147221040;
pub const CLIPBRD_E_CANT_EMPTY : i32 = -2147221039;
pub const CLIPBRD_E_CANT_SET : i32 = -2147221038;
pub const CLIPBRD_E_BAD_DATA : i32 = -2147221037;
pub const CLIPBRD_E_CANT_CLOSE : i32 = -2147221036;
pub const MK_E_FIRST : i32 = -2147221024;
pub const MK_E_LAST : i32 = -2147221009;
pub const MK_S_FIRST : i32 = 262624;
pub const MK_S_LAST : i32 = 262639;
pub const MK_E_CONNECTMANUALLY : i32 = -2147221024;
pub const MK_E_EXCEEDEDDEADLINE : i32 = -2147221023;
pub const MK_E_NEEDGENERIC : i32 = -2147221022;
pub const MK_E_UNAVAILABLE : i32 = -2147221021;
pub const MK_E_SYNTAX : i32 = -2147221020;
pub const MK_E_NOOBJECT : i32 = -2147221019;
pub const MK_E_INVALIDEXTENSION : i32 = -2147221018;
pub const MK_E_INTERMEDIATEINTERFACENOTSUPPORTED : i32 = -2147221017;
pub const MK_E_NOTBINDABLE : i32 = -2147221016;
pub const MK_E_NOTBOUND : i32 = -2147221015;
pub const MK_E_CANTOPENFILE : i32 = -2147221014;
pub const MK_E_MUSTBOTHERUSER : i32 = -2147221013;
pub const MK_E_NOINVERSE : i32 = -2147221012;
pub const MK_E_NOSTORAGE : i32 = -2147221011;
pub const MK_E_NOPREFIX : i32 = -2147221010;
pub const MK_E_ENUMERATION_FAILED : i32 = -2147221009;
pub const CO_E_FIRST : i32 = -2147221008;
pub const CO_E_LAST : i32 = -2147220993;
pub const CO_S_FIRST : i32 = 262640;
pub const CO_S_LAST : i32 = 262655;
pub const CO_E_NOTINITIALIZED : i32 = -2147221008;
pub const CO_E_ALREADYINITIALIZED : i32 = -2147221007;
pub const CO_E_CANTDETERMINECLASS : i32 = -2147221006;
pub const CO_E_CLASSSTRING : i32 = -2147221005;
pub const CO_E_IIDSTRING : i32 = -2147221004;
pub const CO_E_APPNOTFOUND : i32 = -2147221003;
pub const CO_E_APPSINGLEUSE : i32 = -2147221002;
pub const CO_E_ERRORINAPP : i32 = -2147221001;
pub const CO_E_DLLNOTFOUND : i32 = -2147221000;
pub const CO_E_ERRORINDLL : i32 = -2147220999;
pub const CO_E_WRONGOSFORAPP : i32 = -2147220998;
pub const CO_E_OBJNOTREG : i32 = -2147220997;
pub const CO_E_OBJISREG : i32 = -2147220996;
pub const CO_E_OBJNOTCONNECTED : i32 = -2147220995;
pub const CO_E_APPDIDNTREG : i32 = -2147220994;
pub const CO_E_RELEASED : i32 = -2147220993;
pub const EVENT_E_FIRST : i32 = -2147220992;
pub const EVENT_E_LAST : i32 = -2147220961;
pub const EVENT_S_FIRST : i32 = 262656;
pub const EVENT_S_LAST : i32 = 262687;
pub const EVENT_S_SOME_SUBSCRIBERS_FAILED : i32 = 262656;
pub const EVENT_E_ALL_SUBSCRIBERS_FAILED : i32 = -2147220991;
pub const EVENT_S_NOSUBSCRIBERS : i32 = 262658;
pub const EVENT_E_QUERYSYNTAX : i32 = -2147220989;
pub const EVENT_E_QUERYFIELD : i32 = -2147220988;
pub const EVENT_E_INTERNALEXCEPTION : i32 = -2147220987;
pub const EVENT_E_INTERNALERROR : i32 = -2147220986;
pub const EVENT_E_INVALID_PER_USER_SID : i32 = -2147220985;
pub const EVENT_E_USER_EXCEPTION : i32 = -2147220984;
pub const EVENT_E_TOO_MANY_METHODS : i32 = -2147220983;
pub const EVENT_E_MISSING_EVENTCLASS : i32 = -2147220982;
pub const EVENT_E_NOT_ALL_REMOVED : i32 = -2147220981;
pub const EVENT_E_COMPLUS_NOT_INSTALLED : i32 = -2147220980;
pub const EVENT_E_CANT_MODIFY_OR_DELETE_UNCONFIGURED_OBJECT : i32 = -2147220979;
pub const EVENT_E_CANT_MODIFY_OR_DELETE_CONFIGURED_OBJECT : i32 = -2147220978;
pub const EVENT_E_INVALID_EVENT_CLASS_PARTITION : i32 = -2147220977;
pub const EVENT_E_PER_USER_SID_NOT_LOGGED_ON : i32 = -2147220976;
pub const TPC_E_INVALID_PROPERTY : i32 = -2147220927;
pub const TPC_E_NO_DEFAULT_TABLET : i32 = -2147220974;
pub const TPC_E_UNKNOWN_PROPERTY : i32 = -2147220965;
pub const TPC_E_INVALID_INPUT_RECT : i32 = -2147220967;
pub const TPC_E_INVALID_STROKE : i32 = -2147220958;
pub const TPC_E_INITIALIZE_FAIL : i32 = -2147220957;
pub const TPC_E_NOT_RELEVANT : i32 = -2147220942;
pub const TPC_E_INVALID_PACKET_DESCRIPTION : i32 = -2147220941;
pub const TPC_E_RECOGNIZER_NOT_REGISTERED : i32 = -2147220939;
pub const TPC_E_INVALID_RIGHTS : i32 = -2147220938;
pub const TPC_E_OUT_OF_ORDER_CALL : i32 = -2147220937;
pub const TPC_E_QUEUE_FULL : i32 = -2147220936;
pub const TPC_E_INVALID_CONFIGURATION : i32 = -2147220935;
pub const TPC_E_INVALID_DATA_FROM_RECOGNIZER : i32 = -2147220934;
pub const TPC_S_TRUNCATED : i32 = 262738;
pub const TPC_S_INTERRUPTED : i32 = 262739;
pub const TPC_S_NO_DATA_TO_PROCESS : i32 = 262740;
pub const XACT_E_FIRST : u32 = 2147799040;
pub const XACT_E_LAST : u32 = 2147799083;
pub const XACT_S_FIRST : i32 = 315392;
pub const XACT_S_LAST : i32 = 315408;
pub const XACT_E_ALREADYOTHERSINGLEPHASE : i32 = -2147168256;
pub const XACT_E_CANTRETAIN : i32 = -2147168255;
pub const XACT_E_COMMITFAILED : i32 = -2147168254;
pub const XACT_E_COMMITPREVENTED : i32 = -2147168253;
pub const XACT_E_HEURISTICABORT : i32 = -2147168252;
pub const XACT_E_HEURISTICCOMMIT : i32 = -2147168251;
pub const XACT_E_HEURISTICDAMAGE : i32 = -2147168250;
pub const XACT_E_HEURISTICDANGER : i32 = -2147168249;
pub const XACT_E_ISOLATIONLEVEL : i32 = -2147168248;
pub const XACT_E_NOASYNC : i32 = -2147168247;
pub const XACT_E_NOENLIST : i32 = -2147168246;
pub const XACT_E_NOISORETAIN : i32 = -2147168245;
pub const XACT_E_NORESOURCE : i32 = -2147168244;
pub const XACT_E_NOTCURRENT : i32 = -2147168243;
pub const XACT_E_NOTRANSACTION : i32 = -2147168242;
pub const XACT_E_NOTSUPPORTED : i32 = -2147168241;
pub const XACT_E_UNKNOWNRMGRID : i32 = -2147168240;
pub const XACT_E_WRONGSTATE : i32 = -2147168239;
pub const XACT_E_WRONGUOW : i32 = -2147168238;
pub const XACT_E_XTIONEXISTS : i32 = -2147168237;
pub const XACT_E_NOIMPORTOBJECT : i32 = -2147168236;
pub const XACT_E_INVALIDCOOKIE : i32 = -2147168235;
pub const XACT_E_INDOUBT : i32 = -2147168234;
pub const XACT_E_NOTIMEOUT : i32 = -2147168233;
pub const XACT_E_ALREADYINPROGRESS : i32 = -2147168232;
pub const XACT_E_ABORTED : i32 = -2147168231;
pub const XACT_E_LOGFULL : i32 = -2147168230;
pub const XACT_E_TMNOTAVAILABLE : i32 = -2147168229;
pub const XACT_E_CONNECTION_DOWN : i32 = -2147168228;
pub const XACT_E_CONNECTION_DENIED : i32 = -2147168227;
pub const XACT_E_REENLISTTIMEOUT : i32 = -2147168226;
pub const XACT_E_TIP_CONNECT_FAILED : i32 = -2147168225;
pub const XACT_E_TIP_PROTOCOL_ERROR : i32 = -2147168224;
pub const XACT_E_TIP_PULL_FAILED : i32 = -2147168223;
pub const XACT_E_DEST_TMNOTAVAILABLE : i32 = -2147168222;
pub const XACT_E_TIP_DISABLED : i32 = -2147168221;
pub const XACT_E_NETWORK_TX_DISABLED : i32 = -2147168220;
pub const XACT_E_PARTNER_NETWORK_TX_DISABLED : i32 = -2147168219;
pub const XACT_E_XA_TX_DISABLED : i32 = -2147168218;
pub const XACT_E_UNABLE_TO_READ_DTC_CONFIG : i32 = -2147168217;
pub const XACT_E_UNABLE_TO_LOAD_DTC_PROXY : i32 = -2147168216;
pub const XACT_E_ABORTING : i32 = -2147168215;
pub const XACT_E_PUSH_COMM_FAILURE : i32 = -2147168214;
pub const XACT_E_PULL_COMM_FAILURE : i32 = -2147168213;
pub const XACT_E_LU_TX_DISABLED : i32 = -2147168212;
pub const XACT_E_CLERKNOTFOUND : i32 = -2147168128;
pub const XACT_E_CLERKEXISTS : i32 = -2147168127;
pub const XACT_E_RECOVERYINPROGRESS : i32 = -2147168126;
pub const XACT_E_TRANSACTIONCLOSED : i32 = -2147168125;
pub const XACT_E_INVALIDLSN : i32 = -2147168124;
pub const XACT_E_REPLAYREQUEST : i32 = -2147168123;
pub const XACT_S_ASYNC : i32 = 315392;
pub const XACT_S_DEFECT : i32 = 315393;
pub const XACT_S_READONLY : i32 = 315394;
pub const XACT_S_SOMENORETAIN : i32 = 315395;
pub const XACT_S_OKINFORM : i32 = 315396;
pub const XACT_S_MADECHANGESCONTENT : i32 = 315397;
pub const XACT_S_MADECHANGESINFORM : i32 = 315398;
pub const XACT_S_ALLNORETAIN : i32 = 315399;
pub const XACT_S_ABORTING : i32 = 315400;
pub const XACT_S_SINGLEPHASE : i32 = 315401;
pub const XACT_S_LOCALLY_OK : i32 = 315402;
pub const XACT_S_LASTRESOURCEMANAGER : i32 = 315408;
pub const CONTEXT_E_FIRST : i32 = -2147164160;
pub const CONTEXT_E_LAST : i32 = -2147164113;
pub const CONTEXT_S_FIRST : i32 = 319488;
pub const CONTEXT_S_LAST : i32 = 319535;
pub const CONTEXT_E_ABORTED : i32 = -2147164158;
pub const CONTEXT_E_ABORTING : i32 = -2147164157;
pub const CONTEXT_E_NOCONTEXT : i32 = -2147164156;
pub const CONTEXT_E_WOULD_DEADLOCK : i32 = -2147164155;
pub const CONTEXT_E_SYNCH_TIMEOUT : i32 = -2147164154;
pub const CONTEXT_E_OLDREF : i32 = -2147164153;
pub const CONTEXT_E_ROLENOTFOUND : i32 = -2147164148;
pub const CONTEXT_E_TMNOTAVAILABLE : i32 = -2147164145;
pub const CO_E_ACTIVATIONFAILED : i32 = -2147164127;
pub const CO_E_ACTIVATIONFAILED_EVENTLOGGED : i32 = -2147164126;
pub const CO_E_ACTIVATIONFAILED_CATALOGERROR : i32 = -2147164125;
pub const CO_E_ACTIVATIONFAILED_TIMEOUT : i32 = -2147164124;
pub const CO_E_INITIALIZATIONFAILED : i32 = -2147164123;
pub const CONTEXT_E_NOJIT : i32 = -2147164122;
pub const CONTEXT_E_NOTRANSACTION : i32 = -2147164121;
pub const CO_E_THREADINGMODEL_CHANGED : i32 = -2147164120;
pub const CO_E_NOIISINTRINSICS : i32 = -2147164119;
pub const CO_E_NOCOOKIES : i32 = -2147164118;
pub const CO_E_DBERROR : i32 = -2147164117;
pub const CO_E_NOTPOOLED : i32 = -2147164116;
pub const CO_E_NOTCONSTRUCTED : i32 = -2147164115;
pub const CO_E_NOSYNCHRONIZATION : i32 = -2147164114;
pub const CO_E_ISOLEVELMISMATCH : i32 = -2147164113;
pub const CO_E_CALL_OUT_OF_TX_SCOPE_NOT_ALLOWED : i32 = -2147164112;
pub const CO_E_EXIT_TRANSACTION_SCOPE_NOT_CALLED : i32 = -2147164111;
pub const OLE_S_USEREG : i32 = 262144;
pub const OLE_S_STATIC : i32 = 262145;
pub const OLE_S_MAC_CLIPFORMAT : i32 = 262146;
pub const DRAGDROP_S_DROP : i32 = 262400;
pub const DRAGDROP_S_CANCEL : i32 = 262401;
pub const DRAGDROP_S_USEDEFAULTCURSORS : i32 = 262402;
pub const DATA_S_SAMEFORMATETC : i32 = 262448;
pub const VIEW_S_ALREADY_FROZEN : i32 = 262464;
pub const CACHE_S_FORMATETC_NOTSUPPORTED : i32 = 262512;
pub const CACHE_S_SAMECACHE : i32 = 262513;
pub const CACHE_S_SOMECACHES_NOTUPDATED : i32 = 262514;
pub const OLEOBJ_S_INVALIDVERB : i32 = 262528;
pub const OLEOBJ_S_CANNOT_DOVERB_NOW : i32 = 262529;
pub const OLEOBJ_S_INVALIDHWND : i32 = 262530;
pub const INPLACE_S_TRUNCATED : i32 = 262560;
pub const CONVERT10_S_NO_PRESENTATION : i32 = 262592;
pub const MK_S_REDUCED_TO_SELF : i32 = 262626;
pub const MK_S_ME : i32 = 262628;
pub const MK_S_HIM : i32 = 262629;
pub const MK_S_US : i32 = 262630;
pub const MK_S_MONIKERALREADYREGISTERED : i32 = 262631;
pub const SCHED_S_TASK_READY : i32 = 267008;
pub const SCHED_S_TASK_RUNNING : i32 = 267009;
pub const SCHED_S_TASK_DISABLED : i32 = 267010;
pub const SCHED_S_TASK_HAS_NOT_RUN : i32 = 267011;
pub const SCHED_S_TASK_NO_MORE_RUNS : i32 = 267012;
pub const SCHED_S_TASK_NOT_SCHEDULED : i32 = 267013;
pub const SCHED_S_TASK_TERMINATED : i32 = 267014;
pub const SCHED_S_TASK_NO_VALID_TRIGGERS : i32 = 267015;
pub const SCHED_S_EVENT_TRIGGER : i32 = 267016;
pub const SCHED_E_TRIGGER_NOT_FOUND : i32 = -2147216631;
pub const SCHED_E_TASK_NOT_READY : i32 = -2147216630;
pub const SCHED_E_TASK_NOT_RUNNING : i32 = -2147216629;
pub const SCHED_E_SERVICE_NOT_INSTALLED : i32 = -2147216628;
pub const SCHED_E_CANNOT_OPEN_TASK : i32 = -2147216627;
pub const SCHED_E_INVALID_TASK : i32 = -2147216626;
pub const SCHED_E_ACCOUNT_INFORMATION_NOT_SET : i32 = -2147216625;
pub const SCHED_E_ACCOUNT_NAME_NOT_FOUND : i32 = -2147216624;
pub const SCHED_E_ACCOUNT_DBASE_CORRUPT : i32 = -2147216623;
pub const SCHED_E_NO_SECURITY_SERVICES : i32 = -2147216622;
pub const SCHED_E_UNKNOWN_OBJECT_VERSION : i32 = -2147216621;
pub const SCHED_E_UNSUPPORTED_ACCOUNT_OPTION : i32 = -2147216620;
pub const SCHED_E_SERVICE_NOT_RUNNING : i32 = -2147216619;
pub const SCHED_E_UNEXPECTEDNODE : i32 = -2147216618;
pub const SCHED_E_NAMESPACE : i32 = -2147216617;
pub const SCHED_E_INVALIDVALUE : i32 = -2147216616;
pub const SCHED_E_MISSINGNODE : i32 = -2147216615;
pub const SCHED_E_MALFORMEDXML : i32 = -2147216614;
pub const SCHED_S_SOME_TRIGGERS_FAILED : i32 = 267035;
pub const SCHED_S_BATCH_LOGON_PROBLEM : i32 = 267036;
pub const SCHED_E_TOO_MANY_NODES : i32 = -2147216611;
pub const SCHED_E_PAST_END_BOUNDARY : i32 = -2147216610;
pub const SCHED_E_ALREADY_RUNNING : i32 = -2147216609;
pub const SCHED_E_USER_NOT_LOGGED_ON : i32 = -2147216608;
pub const SCHED_E_INVALID_TASK_HASH : i32 = -2147216607;
pub const SCHED_E_SERVICE_NOT_AVAILABLE : i32 = -2147216606;
pub const SCHED_E_SERVICE_TOO_BUSY : i32 = -2147216605;
pub const SCHED_E_TASK_ATTEMPTED : i32 = -2147216604;
pub const SCHED_S_TASK_QUEUED : i32 = 267045;
pub const SCHED_E_TASK_DISABLED : i32 = -2147216602;
pub const SCHED_E_TASK_NOT_V1_COMPAT : i32 = -2147216601;
pub const SCHED_E_START_ON_DEMAND : i32 = -2147216600;
pub const SCHED_E_TASK_NOT_UBPM_COMPAT : i32 = -2147216599;
pub const SCHED_E_DEPRECATED_FEATURE_USED : i32 = -2147216592;
pub const CO_E_CLASS_CREATE_FAILED : i32 = -2146959359;
pub const CO_E_SCM_ERROR : i32 = -2146959358;
pub const CO_E_SCM_RPC_FAILURE : i32 = -2146959357;
pub const CO_E_BAD_PATH : i32 = -2146959356;
pub const CO_E_SERVER_EXEC_FAILURE : i32 = -2146959355;
pub const CO_E_OBJSRV_RPC_FAILURE : i32 = -2146959354;
pub const MK_E_NO_NORMALIZED : i32 = -2146959353;
pub const CO_E_SERVER_STOPPING : i32 = -2146959352;
pub const MEM_E_INVALID_ROOT : i32 = -2146959351;
pub const MEM_E_INVALID_LINK : i32 = -2146959344;
pub const MEM_E_INVALID_SIZE : i32 = -2146959343;
pub const CO_S_NOTALLINTERFACES : i32 = 524306;
pub const CO_S_MACHINENAMENOTFOUND : i32 = 524307;
pub const CO_E_MISSING_DISPLAYNAME : i32 = -2146959339;
pub const CO_E_RUNAS_VALUE_MUST_BE_AAA : i32 = -2146959338;
pub const CO_E_ELEVATION_DISABLED : i32 = -2146959337;
pub const APPX_E_PACKAGING_INTERNAL : i32 = -2146958848;
pub const APPX_E_INTERLEAVING_NOT_ALLOWED : i32 = -2146958847;
pub const APPX_E_RELATIONSHIPS_NOT_ALLOWED : i32 = -2146958846;
pub const APPX_E_MISSING_REQUIRED_FILE : i32 = -2146958845;
pub const APPX_E_INVALID_MANIFEST : i32 = -2146958844;
pub const APPX_E_INVALID_BLOCKMAP : i32 = -2146958843;
pub const APPX_E_CORRUPT_CONTENT : i32 = -2146958842;
pub const APPX_E_BLOCK_HASH_INVALID : i32 = -2146958841;
pub const APPX_E_REQUESTED_RANGE_TOO_LARGE : i32 = -2146958840;
pub const APPX_E_INVALID_SIP_CLIENT_DATA : i32 = -2146958839;
pub const APPX_E_INVALID_KEY_INFO : i32 = -2146958838;
pub const APPX_E_INVALID_CONTENTGROUPMAP : i32 = -2146958837;
pub const APPX_E_INVALID_APPINSTALLER : i32 = -2146958836;
pub const APPX_E_DELTA_BASELINE_VERSION_MISMATCH : i32 = -2146958835;
pub const APPX_E_DELTA_PACKAGE_MISSING_FILE : i32 = -2146958834;
pub const APPX_E_INVALID_DELTA_PACKAGE : i32 = -2146958833;
pub const APPX_E_DELTA_APPENDED_PACKAGE_NOT_ALLOWED : i32 = -2146958832;
pub const APPX_E_INVALID_PACKAGING_LAYOUT : i32 = -2146958831;
pub const APPX_E_INVALID_PACKAGESIGNCONFIG : i32 = -2146958830;
pub const APPX_E_RESOURCESPRI_NOT_ALLOWED : i32 = -2146958829;
pub const APPX_E_FILE_COMPRESSION_MISMATCH : i32 = -2146958828;
pub const APPX_E_INVALID_PAYLOAD_PACKAGE_EXTENSION : i32 = -2146958827;
pub const APPX_E_INVALID_ENCRYPTION_EXCLUSION_FILE_LIST : i32 = -2146958826;
pub const BT_E_SPURIOUS_ACTIVATION : i32 = -2146958592;
pub const DISP_E_UNKNOWNINTERFACE : i32 = -2147352575;
pub const DISP_E_MEMBERNOTFOUND : i32 = -2147352573;
pub const DISP_E_PARAMNOTFOUND : i32 = -2147352572;
pub const DISP_E_TYPEMISMATCH : i32 = -2147352571;
pub const DISP_E_UNKNOWNNAME : i32 = -2147352570;
pub const DISP_E_NONAMEDARGS : i32 = -2147352569;
pub const DISP_E_BADVARTYPE : i32 = -2147352568;
pub const DISP_E_EXCEPTION : i32 = -2147352567;
pub const DISP_E_OVERFLOW : i32 = -2147352566;
pub const DISP_E_BADINDEX : i32 = -2147352565;
pub const DISP_E_UNKNOWNLCID : i32 = -2147352564;
pub const DISP_E_ARRAYISLOCKED : i32 = -2147352563;
pub const DISP_E_BADPARAMCOUNT : i32 = -2147352562;
pub const DISP_E_PARAMNOTOPTIONAL : i32 = -2147352561;
pub const DISP_E_BADCALLEE : i32 = -2147352560;
pub const DISP_E_NOTACOLLECTION : i32 = -2147352559;
pub const DISP_E_DIVBYZERO : i32 = -2147352558;
pub const DISP_E_BUFFERTOOSMALL : i32 = -2147352557;
pub const TYPE_E_BUFFERTOOSMALL : i32 = -2147319786;
pub const TYPE_E_FIELDNOTFOUND : i32 = -2147319785;
pub const TYPE_E_INVDATAREAD : i32 = -2147319784;
pub const TYPE_E_UNSUPFORMAT : i32 = -2147319783;
pub const TYPE_E_REGISTRYACCESS : i32 = -2147319780;
pub const TYPE_E_LIBNOTREGISTERED : i32 = -2147319779;
pub const TYPE_E_UNDEFINEDTYPE : i32 = -2147319769;
pub const TYPE_E_QUALIFIEDNAMEDISALLOWED : i32 = -2147319768;
pub const TYPE_E_INVALIDSTATE : i32 = -2147319767;
pub const TYPE_E_WRONGTYPEKIND : i32 = -2147319766;
pub const TYPE_E_ELEMENTNOTFOUND : i32 = -2147319765;
pub const TYPE_E_AMBIGUOUSNAME : i32 = -2147319764;
pub const TYPE_E_NAMECONFLICT : i32 = -2147319763;
pub const TYPE_E_UNKNOWNLCID : i32 = -2147319762;
pub const TYPE_E_DLLFUNCTIONNOTFOUND : i32 = -2147319761;
pub const TYPE_E_BADMODULEKIND : i32 = -2147317571;
pub const TYPE_E_SIZETOOBIG : i32 = -2147317563;
pub const TYPE_E_DUPLICATEID : i32 = -2147317562;
pub const TYPE_E_INVALIDID : i32 = -2147317553;
pub const TYPE_E_TYPEMISMATCH : i32 = -2147316576;
pub const TYPE_E_OUTOFBOUNDS : i32 = -2147316575;
pub const TYPE_E_IOERROR : i32 = -2147316574;
pub const TYPE_E_CANTCREATETMPFILE : i32 = -2147316573;
pub const TYPE_E_CANTLOADLIBRARY : i32 = -2147312566;
pub const TYPE_E_INCONSISTENTPROPFUNCS : i32 = -2147312509;
pub const TYPE_E_CIRCULARTYPE : i32 = -2147312508;
pub const STG_E_INVALIDFUNCTION : i32 = -2147287039;
pub const STG_E_FILENOTFOUND : i32 = -2147287038;
pub const STG_E_PATHNOTFOUND : i32 = -2147287037;
pub const STG_E_TOOMANYOPENFILES : i32 = -2147287036;
pub const STG_E_ACCESSDENIED : i32 = -2147287035;
pub const STG_E_INVALIDHANDLE : i32 = -2147287034;
pub const STG_E_INSUFFICIENTMEMORY : i32 = -2147287032;
pub const STG_E_INVALIDPOINTER : i32 = -2147287031;
pub const STG_E_NOMOREFILES : i32 = -2147287022;
pub const STG_E_DISKISWRITEPROTECTED : i32 = -2147287021;
pub const STG_E_SEEKERROR : i32 = -2147287015;
pub const STG_E_WRITEFAULT : i32 = -2147287011;
pub const STG_E_READFAULT : i32 = -2147287010;
pub const STG_E_SHAREVIOLATION : i32 = -2147287008;
pub const STG_E_LOCKVIOLATION : i32 = -2147287007;
pub const STG_E_FILEALREADYEXISTS : i32 = -2147286960;
pub const STG_E_INVALIDPARAMETER : i32 = -2147286953;
pub const STG_E_MEDIUMFULL : i32 = -2147286928;
pub const STG_E_PROPSETMISMATCHED : i32 = -2147286800;
pub const STG_E_ABNORMALAPIEXIT : i32 = -2147286790;
pub const STG_E_INVALIDHEADER : i32 = -2147286789;
pub const STG_E_INVALIDNAME : i32 = -2147286788;
pub const STG_E_UNKNOWN : i32 = -2147286787;
pub const STG_E_UNIMPLEMENTEDFUNCTION : i32 = -2147286786;
pub const STG_E_INVALIDFLAG : i32 = -2147286785;
pub const STG_E_INUSE : i32 = -2147286784;
pub const STG_E_NOTCURRENT : i32 = -2147286783;
pub const STG_E_REVERTED : i32 = -2147286782;
pub const STG_E_CANTSAVE : i32 = -2147286781;
pub const STG_E_OLDFORMAT : i32 = -2147286780;
pub const STG_E_OLDDLL : i32 = -2147286779;
pub const STG_E_SHAREREQUIRED : i32 = -2147286778;
pub const STG_E_NOTFILEBASEDSTORAGE : i32 = -2147286777;
pub const STG_E_EXTANTMARSHALLINGS : i32 = -2147286776;
pub const STG_E_DOCFILECORRUPT : i32 = -2147286775;
pub const STG_E_BADBASEADDRESS : i32 = -2147286768;
pub const STG_E_DOCFILETOOLARGE : i32 = -2147286767;
pub const STG_E_NOTSIMPLEFORMAT : i32 = -2147286766;
pub const STG_E_INCOMPLETE : i32 = -2147286527;
pub const STG_E_TERMINATED : i32 = -2147286526;
pub const STG_S_CONVERTED : i32 = 197120;
pub const STG_S_BLOCK : i32 = 197121;
pub const STG_S_RETRYNOW : i32 = 197122;
pub const STG_S_MONITORING : i32 = 197123;
pub const STG_S_MULTIPLEOPENS : i32 = 197124;
pub const STG_S_CONSOLIDATIONFAILED : i32 = 197125;
pub const STG_S_CANNOTCONSOLIDATE : i32 = 197126;
pub const STG_S_POWER_CYCLE_REQUIRED : i32 = 197127;
pub const STG_E_FIRMWARE_SLOT_INVALID : i32 = -2147286520;
pub const STG_E_FIRMWARE_IMAGE_INVALID : i32 = -2147286519;
pub const STG_E_DEVICE_UNRESPONSIVE : i32 = -2147286518;
pub const STG_E_STATUS_COPY_PROTECTION_FAILURE : i32 = -2147286267;
pub const STG_E_CSS_AUTHENTICATION_FAILURE : i32 = -2147286266;
pub const STG_E_CSS_KEY_NOT_PRESENT : i32 = -2147286265;
pub const STG_E_CSS_KEY_NOT_ESTABLISHED : i32 = -2147286264;
pub const STG_E_CSS_SCRAMBLED_SECTOR : i32 = -2147286263;
pub const STG_E_CSS_REGION_MISMATCH : i32 = -2147286262;
pub const STG_E_RESETS_EXHAUSTED : i32 = -2147286261;
pub const RPC_E_CALL_REJECTED : i32 = -2147418111;
pub const RPC_E_CALL_CANCELED : i32 = -2147418110;
pub const RPC_E_CANTPOST_INSENDCALL : i32 = -2147418109;
pub const RPC_E_CANTCALLOUT_INASYNCCALL : i32 = -2147418108;
pub const RPC_E_CANTCALLOUT_INEXTERNALCALL : i32 = -2147418107;
pub const RPC_E_CONNECTION_TERMINATED : i32 = -2147418106;
pub const RPC_E_SERVER_DIED : i32 = -2147418105;
pub const RPC_E_CLIENT_DIED : i32 = -2147418104;
pub const RPC_E_INVALID_DATAPACKET : i32 = -2147418103;
pub const RPC_E_CANTTRANSMIT_CALL : i32 = -2147418102;
pub const RPC_E_CLIENT_CANTMARSHAL_DATA : i32 = -2147418101;
pub const RPC_E_CLIENT_CANTUNMARSHAL_DATA : i32 = -2147418100;
pub const RPC_E_SERVER_CANTMARSHAL_DATA : i32 = -2147418099;
pub const RPC_E_SERVER_CANTUNMARSHAL_DATA : i32 = -2147418098;
pub const RPC_E_INVALID_DATA : i32 = -2147418097;
pub const RPC_E_INVALID_PARAMETER : i32 = -2147418096;
pub const RPC_E_CANTCALLOUT_AGAIN : i32 = -2147418095;
pub const RPC_E_SERVER_DIED_DNE : i32 = -2147418094;
pub const RPC_E_SYS_CALL_FAILED : i32 = -2147417856;
pub const RPC_E_OUT_OF_RESOURCES : i32 = -2147417855;
pub const RPC_E_ATTEMPTED_MULTITHREAD : i32 = -2147417854;
pub const RPC_E_NOT_REGISTERED : i32 = -2147417853;
pub const RPC_E_FAULT : i32 = -2147417852;
pub const RPC_E_SERVERFAULT : i32 = -2147417851;
pub const RPC_E_CHANGED_MODE : i32 = -2147417850;
pub const RPC_E_INVALIDMETHOD : i32 = -2147417849;
pub const RPC_E_DISCONNECTED : i32 = -2147417848;
pub const RPC_E_RETRY : i32 = -2147417847;
pub const RPC_E_SERVERCALL_RETRYLATER : i32 = -2147417846;
pub const RPC_E_SERVERCALL_REJECTED : i32 = -2147417845;
pub const RPC_E_INVALID_CALLDATA : i32 = -2147417844;
pub const RPC_E_CANTCALLOUT_ININPUTSYNCCALL : i32 = -2147417843;
pub const RPC_E_WRONG_THREAD : i32 = -2147417842;
pub const RPC_E_THREAD_NOT_INIT : i32 = -2147417841;
pub const RPC_E_VERSION_MISMATCH : i32 = -2147417840;
pub const RPC_E_INVALID_HEADER : i32 = -2147417839;
pub const RPC_E_INVALID_EXTENSION : i32 = -2147417838;
pub const RPC_E_INVALID_IPID : i32 = -2147417837;
pub const RPC_E_INVALID_OBJECT : i32 = -2147417836;
pub const RPC_S_CALLPENDING : i32 = -2147417835;
pub const RPC_S_WAITONTIMER : i32 = -2147417834;
pub const RPC_E_CALL_COMPLETE : i32 = -2147417833;
pub const RPC_E_UNSECURE_CALL : i32 = -2147417832;
pub const RPC_E_TOO_LATE : i32 = -2147417831;
pub const RPC_E_NO_GOOD_SECURITY_PACKAGES : i32 = -2147417830;
pub const RPC_E_ACCESS_DENIED : i32 = -2147417829;
pub const RPC_E_REMOTE_DISABLED : i32 = -2147417828;
pub const RPC_E_INVALID_OBJREF : i32 = -2147417827;
pub const RPC_E_NO_CONTEXT : i32 = -2147417826;
pub const RPC_E_TIMEOUT : i32 = -2147417825;
pub const RPC_E_NO_SYNC : i32 = -2147417824;
pub const RPC_E_FULLSIC_REQUIRED : i32 = -2147417823;
pub const RPC_E_INVALID_STD_NAME : i32 = -2147417822;
pub const CO_E_FAILEDTOIMPERSONATE : i32 = -2147417821;
pub const CO_E_FAILEDTOGETSECCTX : i32 = -2147417820;
pub const CO_E_FAILEDTOOPENTHREADTOKEN : i32 = -2147417819;
pub const CO_E_FAILEDTOGETTOKENINFO : i32 = -2147417818;
pub const CO_E_TRUSTEEDOESNTMATCHCLIENT : i32 = -2147417817;
pub const CO_E_FAILEDTOQUERYCLIENTBLANKET : i32 = -2147417816;
pub const CO_E_FAILEDTOSETDACL : i32 = -2147417815;
pub const CO_E_ACCESSCHECKFAILED : i32 = -2147417814;
pub const CO_E_NETACCESSAPIFAILED : i32 = -2147417813;
pub const CO_E_WRONGTRUSTEENAMESYNTAX : i32 = -2147417812;
pub const CO_E_INVALIDSID : i32 = -2147417811;
pub const CO_E_CONVERSIONFAILED : i32 = -2147417810;
pub const CO_E_NOMATCHINGSIDFOUND : i32 = -2147417809;
pub const CO_E_LOOKUPACCSIDFAILED : i32 = -2147417808;
pub const CO_E_NOMATCHINGNAMEFOUND : i32 = -2147417807;
pub const CO_E_LOOKUPACCNAMEFAILED : i32 = -2147417806;
pub const CO_E_SETSERLHNDLFAILED : i32 = -2147417805;
pub const CO_E_FAILEDTOGETWINDIR : i32 = -2147417804;
pub const CO_E_PATHTOOLONG : i32 = -2147417803;
pub const CO_E_FAILEDTOGENUUID : i32 = -2147417802;
pub const CO_E_FAILEDTOCREATEFILE : i32 = -2147417801;
pub const CO_E_FAILEDTOCLOSEHANDLE : i32 = -2147417800;
pub const CO_E_EXCEEDSYSACLLIMIT : i32 = -2147417799;
pub const CO_E_ACESINWRONGORDER : i32 = -2147417798;
pub const CO_E_INCOMPATIBLESTREAMVERSION : i32 = -2147417797;
pub const CO_E_FAILEDTOOPENPROCESSTOKEN : i32 = -2147417796;
pub const CO_E_DECODEFAILED : i32 = -2147417795;
pub const CO_E_ACNOTINITIALIZED : i32 = -2147417793;
pub const CO_E_CANCEL_DISABLED : i32 = -2147417792;
pub const RPC_E_UNEXPECTED : i32 = -2147352577;
pub const ERROR_AUDITING_DISABLED : i32 = -1073151999;
pub const ERROR_ALL_SIDS_FILTERED : i32 = -1073151998;
pub const ERROR_BIZRULES_NOT_ENABLED : i32 = -1073151997;
pub const NTE_BAD_UID : i32 = -2146893823;
pub const NTE_BAD_HASH : i32 = -2146893822;
pub const NTE_BAD_KEY : i32 = -2146893821;
pub const NTE_BAD_LEN : i32 = -2146893820;
pub const NTE_BAD_DATA : i32 = -2146893819;
pub const NTE_BAD_SIGNATURE : i32 = -2146893818;
pub const NTE_BAD_VER : i32 = -2146893817;
pub const NTE_BAD_ALGID : i32 = -2146893816;
pub const NTE_BAD_FLAGS : i32 = -2146893815;
pub const NTE_BAD_TYPE : i32 = -2146893814;
pub const NTE_BAD_KEY_STATE : i32 = -2146893813;
pub const NTE_BAD_HASH_STATE : i32 = -2146893812;
pub const NTE_NO_KEY : i32 = -2146893811;
pub const NTE_NO_MEMORY : i32 = -2146893810;
pub const NTE_EXISTS : i32 = -2146893809;
pub const NTE_PERM : i32 = -2146893808;
pub const NTE_NOT_FOUND : i32 = -2146893807;
pub const NTE_DOUBLE_ENCRYPT : i32 = -2146893806;
pub const NTE_BAD_PROVIDER : i32 = -2146893805;
pub const NTE_BAD_PROV_TYPE : i32 = -2146893804;
pub const NTE_BAD_PUBLIC_KEY : i32 = -2146893803;
pub const NTE_BAD_KEYSET : i32 = -2146893802;
pub const NTE_PROV_TYPE_NOT_DEF : i32 = -2146893801;
pub const NTE_PROV_TYPE_ENTRY_BAD : i32 = -2146893800;
pub const NTE_KEYSET_NOT_DEF : i32 = -2146893799;
pub const NTE_KEYSET_ENTRY_BAD : i32 = -2146893798;
pub const NTE_PROV_TYPE_NO_MATCH : i32 = -2146893797;
pub const NTE_SIGNATURE_FILE_BAD : i32 = -2146893796;
pub const NTE_PROVIDER_DLL_FAIL : i32 = -2146893795;
pub const NTE_PROV_DLL_NOT_FOUND : i32 = -2146893794;
pub const NTE_BAD_KEYSET_PARAM : i32 = -2146893793;
pub const NTE_FAIL : i32 = -2146893792;
pub const NTE_SYS_ERR : i32 = -2146893791;
pub const NTE_SILENT_CONTEXT : i32 = -2146893790;
pub const NTE_TOKEN_KEYSET_STORAGE_FULL : i32 = -2146893789;
pub const NTE_TEMPORARY_PROFILE : i32 = -2146893788;
pub const NTE_FIXEDPARAMETER : i32 = -2146893787;
pub const NTE_INVALID_HANDLE : i32 = -2146893786;
pub const NTE_INVALID_PARAMETER : i32 = -2146893785;
pub const NTE_BUFFER_TOO_SMALL : i32 = -2146893784;
pub const NTE_NOT_SUPPORTED : i32 = -2146893783;
pub const NTE_NO_MORE_ITEMS : i32 = -2146893782;
pub const NTE_BUFFERS_OVERLAP : i32 = -2146893781;
pub const NTE_DECRYPTION_FAILURE : i32 = -2146893780;
pub const NTE_INTERNAL_ERROR : i32 = -2146893779;
pub const NTE_UI_REQUIRED : i32 = -2146893778;
pub const NTE_HMAC_NOT_SUPPORTED : i32 = -2146893777;
pub const NTE_DEVICE_NOT_READY : i32 = -2146893776;
pub const NTE_AUTHENTICATION_IGNORED : i32 = -2146893775;
pub const NTE_VALIDATION_FAILED : i32 = -2146893774;
pub const NTE_INCORRECT_PASSWORD : i32 = -2146893773;
pub const NTE_ENCRYPTION_FAILURE : i32 = -2146893772;
pub const NTE_DEVICE_NOT_FOUND : i32 = -2146893771;
pub const NTE_USER_CANCELLED : i32 = -2146893770;
pub const NTE_PASSWORD_CHANGE_REQUIRED : i32 = -2146893769;
pub const NTE_NOT_ACTIVE_CONSOLE : i32 = -2146893768;
pub const SEC_E_INSUFFICIENT_MEMORY : i32 = -2146893056;
pub const SEC_E_INVALID_HANDLE : i32 = -2146893055;
pub const SEC_E_UNSUPPORTED_FUNCTION : i32 = -2146893054;
pub const SEC_E_TARGET_UNKNOWN : i32 = -2146893053;
pub const SEC_E_INTERNAL_ERROR : i32 = -2146893052;
pub const SEC_E_SECPKG_NOT_FOUND : i32 = -2146893051;
pub const SEC_E_NOT_OWNER : i32 = -2146893050;
pub const SEC_E_CANNOT_INSTALL : i32 = -2146893049;
pub const SEC_E_INVALID_TOKEN : i32 = -2146893048;
pub const SEC_E_CANNOT_PACK : i32 = -2146893047;
pub const SEC_E_QOP_NOT_SUPPORTED : i32 = -2146893046;
pub const SEC_E_NO_IMPERSONATION : i32 = -2146893045;
pub const SEC_E_LOGON_DENIED : i32 = -2146893044;
pub const SEC_E_UNKNOWN_CREDENTIALS : i32 = -2146893043;
pub const SEC_E_NO_CREDENTIALS : i32 = -2146893042;
pub const SEC_E_MESSAGE_ALTERED : i32 = -2146893041;
pub const SEC_E_OUT_OF_SEQUENCE : i32 = -2146893040;
pub const SEC_E_NO_AUTHENTICATING_AUTHORITY : i32 = -2146893039;
pub const SEC_I_CONTINUE_NEEDED : i32 = 590610;
pub const SEC_I_COMPLETE_NEEDED : i32 = 590611;
pub const SEC_I_COMPLETE_AND_CONTINUE : i32 = 590612;
pub const SEC_I_LOCAL_LOGON : i32 = 590613;
pub const SEC_I_GENERIC_EXTENSION_RECEIVED : i32 = 590614;
pub const SEC_E_BAD_PKGID : i32 = -2146893034;
pub const SEC_E_CONTEXT_EXPIRED : i32 = -2146893033;
pub const SEC_I_CONTEXT_EXPIRED : i32 = 590615;
pub const SEC_E_INCOMPLETE_MESSAGE : i32 = -2146893032;
pub const SEC_E_INCOMPLETE_CREDENTIALS : i32 = -2146893024;
pub const SEC_E_BUFFER_TOO_SMALL : i32 = -2146893023;
pub const SEC_I_INCOMPLETE_CREDENTIALS : i32 = 590624;
pub const SEC_I_RENEGOTIATE : i32 = 590625;
pub const SEC_E_WRONG_PRINCIPAL : i32 = -2146893022;
pub const SEC_I_NO_LSA_CONTEXT : i32 = 590627;
pub const SEC_E_TIME_SKEW : i32 = -2146893020;
pub const SEC_E_UNTRUSTED_ROOT : i32 = -2146893019;
pub const SEC_E_ILLEGAL_MESSAGE : i32 = -2146893018;
pub const SEC_E_CERT_UNKNOWN : i32 = -2146893017;
pub const SEC_E_CERT_EXPIRED : i32 = -2146893016;
pub const SEC_E_ENCRYPT_FAILURE : i32 = -2146893015;
pub const SEC_E_DECRYPT_FAILURE : i32 = -2146893008;
pub const SEC_E_ALGORITHM_MISMATCH : i32 = -2146893007;
pub const SEC_E_SECURITY_QOS_FAILED : i32 = -2146893006;
pub const SEC_E_UNFINISHED_CONTEXT_DELETED : i32 = -2146893005;
pub const SEC_E_NO_TGT_REPLY : i32 = -2146893004;
pub const SEC_E_NO_IP_ADDRESSES : i32 = -2146893003;
pub const SEC_E_WRONG_CREDENTIAL_HANDLE : i32 = -2146893002;
pub const SEC_E_CRYPTO_SYSTEM_INVALID : i32 = -2146893001;
pub const SEC_E_MAX_REFERRALS_EXCEEDED : i32 = -2146893000;
pub const SEC_E_MUST_BE_KDC : i32 = -2146892999;
pub const SEC_E_STRONG_CRYPTO_NOT_SUPPORTED : i32 = -2146892998;
pub const SEC_E_TOO_MANY_PRINCIPALS : i32 = -2146892997;
pub const SEC_E_NO_PA_DATA : i32 = -2146892996;
pub const SEC_E_PKINIT_NAME_MISMATCH : i32 = -2146892995;
pub const SEC_E_SMARTCARD_LOGON_REQUIRED : i32 = -2146892994;
pub const SEC_E_SHUTDOWN_IN_PROGRESS : i32 = -2146892993;
pub const SEC_E_KDC_INVALID_REQUEST : i32 = -2146892992;
pub const SEC_E_KDC_UNABLE_TO_REFER : i32 = -2146892991;
pub const SEC_E_KDC_UNKNOWN_ETYPE : i32 = -2146892990;
pub const SEC_E_UNSUPPORTED_PREAUTH : i32 = -2146892989;
pub const SEC_E_DELEGATION_REQUIRED : i32 = -2146892987;
pub const SEC_E_BAD_BINDINGS : i32 = -2146892986;
pub const SEC_E_MULTIPLE_ACCOUNTS : i32 = -2146892985;
pub const SEC_E_NO_KERB_KEY : i32 = -2146892984;
pub const SEC_E_CERT_WRONG_USAGE : i32 = -2146892983;
pub const SEC_E_DOWNGRADE_DETECTED : i32 = -2146892976;
pub const SEC_E_SMARTCARD_CERT_REVOKED : i32 = -2146892975;
pub const SEC_E_ISSUING_CA_UNTRUSTED : i32 = -2146892974;
pub const SEC_E_REVOCATION_OFFLINE_C : i32 = -2146892973;
pub const SEC_E_PKINIT_CLIENT_FAILURE : i32 = -2146892972;
pub const SEC_E_SMARTCARD_CERT_EXPIRED : i32 = -2146892971;
pub const SEC_E_NO_S4U_PROT_SUPPORT : i32 = -2146892970;
pub const SEC_E_CROSSREALM_DELEGATION_FAILURE : i32 = -2146892969;
pub const SEC_E_REVOCATION_OFFLINE_KDC : i32 = -2146892968;
pub const SEC_E_ISSUING_CA_UNTRUSTED_KDC : i32 = -2146892967;
pub const SEC_E_KDC_CERT_EXPIRED : i32 = -2146892966;
pub const SEC_E_KDC_CERT_REVOKED : i32 = -2146892965;
pub const SEC_I_SIGNATURE_NEEDED : i32 = 590684;
pub const SEC_E_INVALID_PARAMETER : i32 = -2146892963;
pub const SEC_E_DELEGATION_POLICY : i32 = -2146892962;
pub const SEC_E_POLICY_NLTM_ONLY : i32 = -2146892961;
pub const SEC_I_NO_RENEGOTIATION : i32 = 590688;
pub const SEC_E_NO_CONTEXT : i32 = -2146892959;
pub const SEC_E_PKU2U_CERT_FAILURE : i32 = -2146892958;
pub const SEC_E_MUTUAL_AUTH_FAILED : i32 = -2146892957;
pub const SEC_I_MESSAGE_FRAGMENT : i32 = 590692;
pub const SEC_E_ONLY_HTTPS_ALLOWED : i32 = -2146892955;
pub const SEC_I_CONTINUE_NEEDED_MESSAGE_OK : i32 = 590694;
pub const SEC_E_APPLICATION_PROTOCOL_MISMATCH : i32 = -2146892953;
pub const SEC_I_ASYNC_CALL_PENDING : i32 = 590696;
pub const SEC_E_INVALID_UPN_NAME : i32 = -2146892951;
pub const SEC_E_EXT_BUFFER_TOO_SMALL : i32 = -2146892950;
pub const SEC_E_INSUFFICIENT_BUFFERS : i32 = -2146892949;
pub const CRYPT_E_MSG_ERROR : i32 = -2146889727;
pub const CRYPT_E_UNKNOWN_ALGO : i32 = -2146889726;
pub const CRYPT_E_OID_FORMAT : i32 = -2146889725;
pub const CRYPT_E_INVALID_MSG_TYPE : i32 = -2146889724;
pub const CRYPT_E_UNEXPECTED_ENCODING : i32 = -2146889723;
pub const CRYPT_E_AUTH_ATTR_MISSING : i32 = -2146889722;
pub const CRYPT_E_HASH_VALUE : i32 = -2146889721;
pub const CRYPT_E_INVALID_INDEX : i32 = -2146889720;
pub const CRYPT_E_ALREADY_DECRYPTED : i32 = -2146889719;
pub const CRYPT_E_NOT_DECRYPTED : i32 = -2146889718;
pub const CRYPT_E_RECIPIENT_NOT_FOUND : i32 = -2146889717;
pub const CRYPT_E_CONTROL_TYPE : i32 = -2146889716;
pub const CRYPT_E_ISSUER_SERIALNUMBER : i32 = -2146889715;
pub const CRYPT_E_SIGNER_NOT_FOUND : i32 = -2146889714;
pub const CRYPT_E_ATTRIBUTES_MISSING : i32 = -2146889713;
pub const CRYPT_E_STREAM_MSG_NOT_READY : i32 = -2146889712;
pub const CRYPT_E_STREAM_INSUFFICIENT_DATA : i32 = -2146889711;
pub const CRYPT_I_NEW_PROTECTION_REQUIRED : i32 = 593938;
pub const CRYPT_E_BAD_LEN : i32 = -2146885631;
pub const CRYPT_E_BAD_ENCODE : i32 = -2146885630;
pub const CRYPT_E_FILE_ERROR : i32 = -2146885629;
pub const CRYPT_E_NOT_FOUND : i32 = -2146885628;
pub const CRYPT_E_EXISTS : i32 = -2146885627;
pub const CRYPT_E_NO_PROVIDER : i32 = -2146885626;
pub const CRYPT_E_SELF_SIGNED : i32 = -2146885625;
pub const CRYPT_E_DELETED_PREV : i32 = -2146885624;
pub const CRYPT_E_NO_MATCH : i32 = -2146885623;
pub const CRYPT_E_UNEXPECTED_MSG_TYPE : i32 = -2146885622;
pub const CRYPT_E_NO_KEY_PROPERTY : i32 = -2146885621;
pub const CRYPT_E_NO_DECRYPT_CERT : i32 = -2146885620;
pub const CRYPT_E_BAD_MSG : i32 = -2146885619;
pub const CRYPT_E_NO_SIGNER : i32 = -2146885618;
pub const CRYPT_E_PENDING_CLOSE : i32 = -2146885617;
pub const CRYPT_E_REVOKED : i32 = -2146885616;
pub const CRYPT_E_NO_REVOCATION_DLL : i32 = -2146885615;
pub const CRYPT_E_NO_REVOCATION_CHECK : i32 = -2146885614;
pub const CRYPT_E_REVOCATION_OFFLINE : i32 = -2146885613;
pub const CRYPT_E_NOT_IN_REVOCATION_DATABASE : i32 = -2146885612;
pub const CRYPT_E_INVALID_NUMERIC_STRING : i32 = -2146885600;
pub const CRYPT_E_INVALID_PRINTABLE_STRING : i32 = -2146885599;
pub const CRYPT_E_INVALID_IA5_STRING : i32 = -2146885598;
pub const CRYPT_E_INVALID_X500_STRING : i32 = -2146885597;
pub const CRYPT_E_NOT_CHAR_STRING : i32 = -2146885596;
pub const CRYPT_E_FILERESIZED : i32 = -2146885595;
pub const CRYPT_E_SECURITY_SETTINGS : i32 = -2146885594;
pub const CRYPT_E_NO_VERIFY_USAGE_DLL : i32 = -2146885593;
pub const CRYPT_E_NO_VERIFY_USAGE_CHECK : i32 = -2146885592;
pub const CRYPT_E_VERIFY_USAGE_OFFLINE : i32 = -2146885591;
pub const CRYPT_E_NOT_IN_CTL : i32 = -2146885590;
pub const CRYPT_E_NO_TRUSTED_SIGNER : i32 = -2146885589;
pub const CRYPT_E_MISSING_PUBKEY_PARA : i32 = -2146885588;
pub const CRYPT_E_OBJECT_LOCATOR_OBJECT_NOT_FOUND : i32 = -2146885587;
pub const CRYPT_E_OSS_ERROR : i32 = -2146881536;
pub const OSS_MORE_BUF : i32 = -2146881535;
pub const OSS_NEGATIVE_UINTEGER : i32 = -2146881534;
pub const OSS_PDU_RANGE : i32 = -2146881533;
pub const OSS_MORE_INPUT : i32 = -2146881532;
pub const OSS_DATA_ERROR : i32 = -2146881531;
pub const OSS_BAD_ARG : i32 = -2146881530;
pub const OSS_BAD_VERSION : i32 = -2146881529;
pub const OSS_OUT_MEMORY : i32 = -2146881528;
pub const OSS_PDU_MISMATCH : i32 = -2146881527;
pub const OSS_LIMITED : i32 = -2146881526;
pub const OSS_BAD_PTR : i32 = -2146881525;
pub const OSS_BAD_TIME : i32 = -2146881524;
pub const OSS_INDEFINITE_NOT_SUPPORTED : i32 = -2146881523;
pub const OSS_MEM_ERROR : i32 = -2146881522;
pub const OSS_BAD_TABLE : i32 = -2146881521;
pub const OSS_TOO_LONG : i32 = -2146881520;
pub const OSS_CONSTRAINT_VIOLATED : i32 = -2146881519;
pub const OSS_FATAL_ERROR : i32 = -2146881518;
pub const OSS_ACCESS_SERIALIZATION_ERROR : i32 = -2146881517;
pub const OSS_NULL_TBL : i32 = -2146881516;
pub const OSS_NULL_FCN : i32 = -2146881515;
pub const OSS_BAD_ENCRULES : i32 = -2146881514;
pub const OSS_UNAVAIL_ENCRULES : i32 = -2146881513;
pub const OSS_CANT_OPEN_TRACE_WINDOW : i32 = -2146881512;
pub const OSS_UNIMPLEMENTED : i32 = -2146881511;
pub const OSS_OID_DLL_NOT_LINKED : i32 = -2146881510;
pub const OSS_CANT_OPEN_TRACE_FILE : i32 = -2146881509;
pub const OSS_TRACE_FILE_ALREADY_OPEN : i32 = -2146881508;
pub const OSS_TABLE_MISMATCH : i32 = -2146881507;
pub const OSS_TYPE_NOT_SUPPORTED : i32 = -2146881506;
pub const OSS_REAL_DLL_NOT_LINKED : i32 = -2146881505;
pub const OSS_REAL_CODE_NOT_LINKED : i32 = -2146881504;
pub const OSS_OUT_OF_RANGE : i32 = -2146881503;
pub const OSS_COPIER_DLL_NOT_LINKED : i32 = -2146881502;
pub const OSS_CONSTRAINT_DLL_NOT_LINKED : i32 = -2146881501;
pub const OSS_COMPARATOR_DLL_NOT_LINKED : i32 = -2146881500;
pub const OSS_COMPARATOR_CODE_NOT_LINKED : i32 = -2146881499;
pub const OSS_MEM_MGR_DLL_NOT_LINKED : i32 = -2146881498;
pub const OSS_PDV_DLL_NOT_LINKED : i32 = -2146881497;
pub const OSS_PDV_CODE_NOT_LINKED : i32 = -2146881496;
pub const OSS_API_DLL_NOT_LINKED : i32 = -2146881495;
pub const OSS_BERDER_DLL_NOT_LINKED : i32 = -2146881494;
pub const OSS_PER_DLL_NOT_LINKED : i32 = -2146881493;
pub const OSS_OPEN_TYPE_ERROR : i32 = -2146881492;
pub const OSS_MUTEX_NOT_CREATED : i32 = -2146881491;
pub const OSS_CANT_CLOSE_TRACE_FILE : i32 = -2146881490;
pub const CRYPT_E_ASN1_ERROR : i32 = -2146881280;
pub const CRYPT_E_ASN1_INTERNAL : i32 = -2146881279;
pub const CRYPT_E_ASN1_EOD : i32 = -2146881278;
pub const CRYPT_E_ASN1_CORRUPT : i32 = -2146881277;
pub const CRYPT_E_ASN1_LARGE : i32 = -2146881276;
pub const CRYPT_E_ASN1_CONSTRAINT : i32 = -2146881275;
pub const CRYPT_E_ASN1_MEMORY : i32 = -2146881274;
pub const CRYPT_E_ASN1_OVERFLOW : i32 = -2146881273;
pub const CRYPT_E_ASN1_BADPDU : i32 = -2146881272;
pub const CRYPT_E_ASN1_BADARGS : i32 = -2146881271;
pub const CRYPT_E_ASN1_BADREAL : i32 = -2146881270;
pub const CRYPT_E_ASN1_BADTAG : i32 = -2146881269;
pub const CRYPT_E_ASN1_CHOICE : i32 = -2146881268;
pub const CRYPT_E_ASN1_RULE : i32 = -2146881267;
pub const CRYPT_E_ASN1_UTF8 : i32 = -2146881266;
pub const CRYPT_E_ASN1_PDU_TYPE : i32 = -2146881229;
pub const CRYPT_E_ASN1_NYI : i32 = -2146881228;
pub const CRYPT_E_ASN1_EXTENDED : i32 = -2146881023;
pub const CRYPT_E_ASN1_NOEOD : i32 = -2146881022;
pub const CERTSRV_E_BAD_REQUESTSUBJECT : i32 = -2146877439;
pub const CERTSRV_E_NO_REQUEST : i32 = -2146877438;
pub const CERTSRV_E_BAD_REQUESTSTATUS : i32 = -2146877437;
pub const CERTSRV_E_PROPERTY_EMPTY : i32 = -2146877436;
pub const CERTSRV_E_INVALID_CA_CERTIFICATE : i32 = -2146877435;
pub const CERTSRV_E_SERVER_SUSPENDED : i32 = -2146877434;
pub const CERTSRV_E_ENCODING_LENGTH : i32 = -2146877433;
pub const CERTSRV_E_ROLECONFLICT : i32 = -2146877432;
pub const CERTSRV_E_RESTRICTEDOFFICER : i32 = -2146877431;
pub const CERTSRV_E_KEY_ARCHIVAL_NOT_CONFIGURED : i32 = -2146877430;
pub const CERTSRV_E_NO_VALID_KRA : i32 = -2146877429;
pub const CERTSRV_E_BAD_REQUEST_KEY_ARCHIVAL : i32 = -2146877428;
pub const CERTSRV_E_NO_CAADMIN_DEFINED : i32 = -2146877427;
pub const CERTSRV_E_BAD_RENEWAL_CERT_ATTRIBUTE : i32 = -2146877426;
pub const CERTSRV_E_NO_DB_SESSIONS : i32 = -2146877425;
pub const CERTSRV_E_ALIGNMENT_FAULT : i32 = -2146877424;
pub const CERTSRV_E_ENROLL_DENIED : i32 = -2146877423;
pub const CERTSRV_E_TEMPLATE_DENIED : i32 = -2146877422;
pub const CERTSRV_E_DOWNLEVEL_DC_SSL_OR_UPGRADE : i32 = -2146877421;
pub const CERTSRV_E_ADMIN_DENIED_REQUEST : i32 = -2146877420;
pub const CERTSRV_E_NO_POLICY_SERVER : i32 = -2146877419;
pub const CERTSRV_E_WEAK_SIGNATURE_OR_KEY : i32 = -2146877418;
pub const CERTSRV_E_KEY_ATTESTATION_NOT_SUPPORTED : i32 = -2146877417;
pub const CERTSRV_E_ENCRYPTION_CERT_REQUIRED : i32 = -2146877416;
pub const CERTSRV_E_UNSUPPORTED_CERT_TYPE : i32 = -2146875392;
pub const CERTSRV_E_NO_CERT_TYPE : i32 = -2146875391;
pub const CERTSRV_E_TEMPLATE_CONFLICT : i32 = -2146875390;
pub const CERTSRV_E_SUBJECT_ALT_NAME_REQUIRED : i32 = -2146875389;
pub const CERTSRV_E_ARCHIVED_KEY_REQUIRED : i32 = -2146875388;
pub const CERTSRV_E_SMIME_REQUIRED : i32 = -2146875387;
pub const CERTSRV_E_BAD_RENEWAL_SUBJECT : i32 = -2146875386;
pub const CERTSRV_E_BAD_TEMPLATE_VERSION : i32 = -2146875385;
pub const CERTSRV_E_TEMPLATE_POLICY_REQUIRED : i32 = -2146875384;
pub const CERTSRV_E_SIGNATURE_POLICY_REQUIRED : i32 = -2146875383;
pub const CERTSRV_E_SIGNATURE_COUNT : i32 = -2146875382;
pub const CERTSRV_E_SIGNATURE_REJECTED : i32 = -2146875381;
pub const CERTSRV_E_ISSUANCE_POLICY_REQUIRED : i32 = -2146875380;
pub const CERTSRV_E_SUBJECT_UPN_REQUIRED : i32 = -2146875379;
pub const CERTSRV_E_SUBJECT_DIRECTORY_GUID_REQUIRED : i32 = -2146875378;
pub const CERTSRV_E_SUBJECT_DNS_REQUIRED : i32 = -2146875377;
pub const CERTSRV_E_ARCHIVED_KEY_UNEXPECTED : i32 = -2146875376;
pub const CERTSRV_E_KEY_LENGTH : i32 = -2146875375;
pub const CERTSRV_E_SUBJECT_EMAIL_REQUIRED : i32 = -2146875374;
pub const CERTSRV_E_UNKNOWN_CERT_TYPE : i32 = -2146875373;
pub const CERTSRV_E_CERT_TYPE_OVERLAP : i32 = -2146875372;
pub const CERTSRV_E_TOO_MANY_SIGNATURES : i32 = -2146875371;
pub const CERTSRV_E_RENEWAL_BAD_PUBLIC_KEY : i32 = -2146875370;
pub const CERTSRV_E_INVALID_EK : i32 = -2146875369;
pub const CERTSRV_E_INVALID_IDBINDING : i32 = -2146875368;
pub const CERTSRV_E_INVALID_ATTESTATION : i32 = -2146875367;
pub const CERTSRV_E_KEY_ATTESTATION : i32 = -2146875366;
pub const CERTSRV_E_CORRUPT_KEY_ATTESTATION : i32 = -2146875365;
pub const CERTSRV_E_EXPIRED_CHALLENGE : i32 = -2146875364;
pub const CERTSRV_E_INVALID_RESPONSE : i32 = -2146875363;
pub const CERTSRV_E_INVALID_REQUESTID : i32 = -2146875362;
pub const CERTSRV_E_REQUEST_PRECERTIFICATE_MISMATCH : i32 = -2146875361;
pub const CERTSRV_E_PENDING_CLIENT_RESPONSE : i32 = -2146875360;
pub const XENROLL_E_KEY_NOT_EXPORTABLE : i32 = -2146873344;
pub const XENROLL_E_CANNOT_ADD_ROOT_CERT : i32 = -2146873343;
pub const XENROLL_E_RESPONSE_KA_HASH_NOT_FOUND : i32 = -2146873342;
pub const XENROLL_E_RESPONSE_UNEXPECTED_KA_HASH : i32 = -2146873341;
pub const XENROLL_E_RESPONSE_KA_HASH_MISMATCH : i32 = -2146873340;
pub const XENROLL_E_KEYSPEC_SMIME_MISMATCH : i32 = -2146873339;
pub const TRUST_E_SYSTEM_ERROR : i32 = -2146869247;
pub const TRUST_E_NO_SIGNER_CERT : i32 = -2146869246;
pub const TRUST_E_COUNTER_SIGNER : i32 = -2146869245;
pub const TRUST_E_CERT_SIGNATURE : i32 = -2146869244;
pub const TRUST_E_TIME_STAMP : i32 = -2146869243;
pub const TRUST_E_BAD_DIGEST : i32 = -2146869232;
pub const TRUST_E_MALFORMED_SIGNATURE : i32 = -2146869231;
pub const TRUST_E_BASIC_CONSTRAINTS : i32 = -2146869223;
pub const TRUST_E_FINANCIAL_CRITERIA : i32 = -2146869218;
pub const MSSIPOTF_E_OUTOFMEMRANGE : i32 = -2146865151;
pub const MSSIPOTF_E_CANTGETOBJECT : i32 = -2146865150;
pub const MSSIPOTF_E_NOHEADTABLE : i32 = -2146865149;
pub const MSSIPOTF_E_BAD_MAGICNUMBER : i32 = -2146865148;
pub const MSSIPOTF_E_BAD_OFFSET_TABLE : i32 = -2146865147;
pub const MSSIPOTF_E_TABLE_TAGORDER : i32 = -2146865146;
pub const MSSIPOTF_E_TABLE_LONGWORD : i32 = -2146865145;
pub const MSSIPOTF_E_BAD_FIRST_TABLE_PLACEMENT : i32 = -2146865144;
pub const MSSIPOTF_E_TABLES_OVERLAP : i32 = -2146865143;
pub const MSSIPOTF_E_TABLE_PADBYTES : i32 = -2146865142;
pub const MSSIPOTF_E_FILETOOSMALL : i32 = -2146865141;
pub const MSSIPOTF_E_TABLE_CHECKSUM : i32 = -2146865140;
pub const MSSIPOTF_E_FILE_CHECKSUM : i32 = -2146865139;
pub const MSSIPOTF_E_FAILED_POLICY : i32 = -2146865136;
pub const MSSIPOTF_E_FAILED_HINTS_CHECK : i32 = -2146865135;
pub const MSSIPOTF_E_NOT_OPENTYPE : i32 = -2146865134;
pub const MSSIPOTF_E_FILE : i32 = -2146865133;
pub const MSSIPOTF_E_CRYPT : i32 = -2146865132;
pub const MSSIPOTF_E_BADVERSION : i32 = -2146865131;
pub const MSSIPOTF_E_DSIG_STRUCTURE : i32 = -2146865130;
pub const MSSIPOTF_E_PCONST_CHECK : i32 = -2146865129;
pub const MSSIPOTF_E_STRUCTURE : i32 = -2146865128;
pub const ERROR_CRED_REQUIRES_CONFIRMATION : i32 = -2146865127;
pub const NTE_OP_OK : i32 = 0;
pub const TRUST_E_PROVIDER_UNKNOWN : i32 = -2146762751;
pub const TRUST_E_ACTION_UNKNOWN : i32 = -2146762750;
pub const TRUST_E_SUBJECT_FORM_UNKNOWN : i32 = -2146762749;
pub const TRUST_E_SUBJECT_NOT_TRUSTED : i32 = -2146762748;
pub const DIGSIG_E_ENCODE : i32 = -2146762747;
pub const DIGSIG_E_DECODE : i32 = -2146762746;
pub const DIGSIG_E_EXTENSIBILITY : i32 = -2146762745;
pub const DIGSIG_E_CRYPTO : i32 = -2146762744;
pub const PERSIST_E_SIZEDEFINITE : i32 = -2146762743;
pub const PERSIST_E_SIZEINDEFINITE : i32 = -2146762742;
pub const PERSIST_E_NOTSELFSIZING : i32 = -2146762741;
pub const TRUST_E_NOSIGNATURE : i32 = -2146762496;
pub const CERT_E_EXPIRED : i32 = -2146762495;
pub const CERT_E_VALIDITYPERIODNESTING : i32 = -2146762494;
pub const CERT_E_ROLE : i32 = -2146762493;
pub const CERT_E_PATHLENCONST : i32 = -2146762492;
pub const CERT_E_CRITICAL : i32 = -2146762491;
pub const CERT_E_PURPOSE : i32 = -2146762490;
pub const CERT_E_ISSUERCHAINING : i32 = -2146762489;
pub const CERT_E_MALFORMED : i32 = -2146762488;
pub const CERT_E_UNTRUSTEDROOT : i32 = -2146762487;
pub const CERT_E_CHAINING : i32 = -2146762486;
pub const TRUST_E_FAIL : i32 = -2146762485;
pub const CERT_E_REVOKED : i32 = -2146762484;
pub const CERT_E_UNTRUSTEDTESTROOT : i32 = -2146762483;
pub const CERT_E_REVOCATION_FAILURE : i32 = -2146762482;
pub const CERT_E_CN_NO_MATCH : i32 = -2146762481;
pub const CERT_E_WRONG_USAGE : i32 = -2146762480;
pub const TRUST_E_EXPLICIT_DISTRUST : i32 = -2146762479;
pub const CERT_E_UNTRUSTEDCA : i32 = -2146762478;
pub const CERT_E_INVALID_POLICY : i32 = -2146762477;
pub const CERT_E_INVALID_NAME : i32 = -2146762476;
pub const SPAPI_E_EXPECTED_SECTION_NAME : i32 = -2146500608;
pub const SPAPI_E_BAD_SECTION_NAME_LINE : i32 = -2146500607;
pub const SPAPI_E_SECTION_NAME_TOO_LONG : i32 = -2146500606;
pub const SPAPI_E_GENERAL_SYNTAX : i32 = -2146500605;
pub const SPAPI_E_WRONG_INF_STYLE : i32 = -2146500352;
pub const SPAPI_E_SECTION_NOT_FOUND : i32 = -2146500351;
pub const SPAPI_E_LINE_NOT_FOUND : i32 = -2146500350;
pub const SPAPI_E_NO_BACKUP : i32 = -2146500349;
pub const SPAPI_E_NO_ASSOCIATED_CLASS : i32 = -2146500096;
pub const SPAPI_E_CLASS_MISMATCH : i32 = -2146500095;
pub const SPAPI_E_DUPLICATE_FOUND : i32 = -2146500094;
pub const SPAPI_E_NO_DRIVER_SELECTED : i32 = -2146500093;
pub const SPAPI_E_KEY_DOES_NOT_EXIST : i32 = -2146500092;
pub const SPAPI_E_INVALID_DEVINST_NAME : i32 = -2146500091;
pub const SPAPI_E_INVALID_CLASS : i32 = -2146500090;
pub const SPAPI_E_DEVINST_ALREADY_EXISTS : i32 = -2146500089;
pub const SPAPI_E_DEVINFO_NOT_REGISTERED : i32 = -2146500088;
pub const SPAPI_E_INVALID_REG_PROPERTY : i32 = -2146500087;
pub const SPAPI_E_NO_INF : i32 = -2146500086;
pub const SPAPI_E_NO_SUCH_DEVINST : i32 = -2146500085;
pub const SPAPI_E_CANT_LOAD_CLASS_ICON : i32 = -2146500084;
pub const SPAPI_E_INVALID_CLASS_INSTALLER : i32 = -2146500083;
pub const SPAPI_E_DI_DO_DEFAULT : i32 = -2146500082;
pub const SPAPI_E_DI_NOFILECOPY : i32 = -2146500081;
pub const SPAPI_E_INVALID_HWPROFILE : i32 = -2146500080;
pub const SPAPI_E_NO_DEVICE_SELECTED : i32 = -2146500079;
pub const SPAPI_E_DEVINFO_LIST_LOCKED : i32 = -2146500078;
pub const SPAPI_E_DEVINFO_DATA_LOCKED : i32 = -2146500077;
pub const SPAPI_E_DI_BAD_PATH : i32 = -2146500076;
pub const SPAPI_E_NO_CLASSINSTALL_PARAMS : i32 = -2146500075;
pub const SPAPI_E_FILEQUEUE_LOCKED : i32 = -2146500074;
pub const SPAPI_E_BAD_SERVICE_INSTALLSECT : i32 = -2146500073;
pub const SPAPI_E_NO_CLASS_DRIVER_LIST : i32 = -2146500072;
pub const SPAPI_E_NO_ASSOCIATED_SERVICE : i32 = -2146500071;
pub const SPAPI_E_NO_DEFAULT_DEVICE_INTERFACE : i32 = -2146500070;
pub const SPAPI_E_DEVICE_INTERFACE_ACTIVE : i32 = -2146500069;
pub const SPAPI_E_DEVICE_INTERFACE_REMOVED : i32 = -2146500068;
pub const SPAPI_E_BAD_INTERFACE_INSTALLSECT : i32 = -2146500067;
pub const SPAPI_E_NO_SUCH_INTERFACE_CLASS : i32 = -2146500066;
pub const SPAPI_E_INVALID_REFERENCE_STRING : i32 = -2146500065;
pub const SPAPI_E_INVALID_MACHINENAME : i32 = -2146500064;
pub const SPAPI_E_REMOTE_COMM_FAILURE : i32 = -2146500063;
pub const SPAPI_E_MACHINE_UNAVAILABLE : i32 = -2146500062;
pub const SPAPI_E_NO_CONFIGMGR_SERVICES : i32 = -2146500061;
pub const SPAPI_E_INVALID_PROPPAGE_PROVIDER : i32 = -2146500060;
pub const SPAPI_E_NO_SUCH_DEVICE_INTERFACE : i32 = -2146500059;
pub const SPAPI_E_DI_POSTPROCESSING_REQUIRED : i32 = -2146500058;
pub const SPAPI_E_INVALID_COINSTALLER : i32 = -2146500057;
pub const SPAPI_E_NO_COMPAT_DRIVERS : i32 = -2146500056;
pub const SPAPI_E_NO_DEVICE_ICON : i32 = -2146500055;
pub const SPAPI_E_INVALID_INF_LOGCONFIG : i32 = -2146500054;
pub const SPAPI_E_DI_DONT_INSTALL : i32 = -2146500053;
pub const SPAPI_E_INVALID_FILTER_DRIVER : i32 = -2146500052;
pub const SPAPI_E_NON_WINDOWS_NT_DRIVER : i32 = -2146500051;
pub const SPAPI_E_NON_WINDOWS_DRIVER : i32 = -2146500050;
pub const SPAPI_E_NO_CATALOG_FOR_OEM_INF : i32 = -2146500049;
pub const SPAPI_E_DEVINSTALL_QUEUE_NONNATIVE : i32 = -2146500048;
pub const SPAPI_E_NOT_DISABLEABLE : i32 = -2146500047;
pub const SPAPI_E_CANT_REMOVE_DEVINST : i32 = -2146500046;
pub const SPAPI_E_INVALID_TARGET : i32 = -2146500045;
pub const SPAPI_E_DRIVER_NONNATIVE : i32 = -2146500044;
pub const SPAPI_E_IN_WOW64 : i32 = -2146500043;
pub const SPAPI_E_SET_SYSTEM_RESTORE_POINT : i32 = -2146500042;
pub const SPAPI_E_INCORRECTLY_COPIED_INF : i32 = -2146500041;
pub const SPAPI_E_SCE_DISABLED : i32 = -2146500040;
pub const SPAPI_E_UNKNOWN_EXCEPTION : i32 = -2146500039;
pub const SPAPI_E_PNP_REGISTRY_ERROR : i32 = -2146500038;
pub const SPAPI_E_REMOTE_REQUEST_UNSUPPORTED : i32 = -2146500037;
pub const SPAPI_E_NOT_AN_INSTALLED_OEM_INF : i32 = -2146500036;
pub const SPAPI_E_INF_IN_USE_BY_DEVICES : i32 = -2146500035;
pub const SPAPI_E_DI_FUNCTION_OBSOLETE : i32 = -2146500034;
pub const SPAPI_E_NO_AUTHENTICODE_CATALOG : i32 = -2146500033;
pub const SPAPI_E_AUTHENTICODE_DISALLOWED : i32 = -2146500032;
pub const SPAPI_E_AUTHENTICODE_TRUSTED_PUBLISHER : i32 = -2146500031;
pub const SPAPI_E_AUTHENTICODE_TRUST_NOT_ESTABLISHED : i32 = -2146500030;
pub const SPAPI_E_AUTHENTICODE_PUBLISHER_NOT_TRUSTED : i32 = -2146500029;
pub const SPAPI_E_SIGNATURE_OSATTRIBUTE_MISMATCH : i32 = -2146500028;
pub const SPAPI_E_ONLY_VALIDATE_VIA_AUTHENTICODE : i32 = -2146500027;
pub const SPAPI_E_DEVICE_INSTALLER_NOT_READY : i32 = -2146500026;
pub const SPAPI_E_DRIVER_STORE_ADD_FAILED : i32 = -2146500025;
pub const SPAPI_E_DEVICE_INSTALL_BLOCKED : i32 = -2146500024;
pub const SPAPI_E_DRIVER_INSTALL_BLOCKED : i32 = -2146500023;
pub const SPAPI_E_WRONG_INF_TYPE : i32 = -2146500022;
pub const SPAPI_E_FILE_HASH_NOT_IN_CATALOG : i32 = -2146500021;
pub const SPAPI_E_DRIVER_STORE_DELETE_FAILED : i32 = -2146500020;
pub const SPAPI_E_UNRECOVERABLE_STACK_OVERFLOW : i32 = -2146499840;
pub const SPAPI_E_ERROR_NOT_INSTALLED : i32 = -2146496512;
pub const SCARD_F_INTERNAL_ERROR : i32 = -2146435071;
pub const SCARD_E_CANCELLED : i32 = -2146435070;
pub const SCARD_E_INVALID_HANDLE : i32 = -2146435069;
pub const SCARD_E_INVALID_PARAMETER : i32 = -2146435068;
pub const SCARD_E_INVALID_TARGET : i32 = -2146435067;
pub const SCARD_E_NO_MEMORY : i32 = -2146435066;
pub const SCARD_F_WAITED_TOO_LONG : i32 = -2146435065;
pub const SCARD_E_INSUFFICIENT_BUFFER : i32 = -2146435064;
pub const SCARD_E_UNKNOWN_READER : i32 = -2146435063;
pub const SCARD_E_TIMEOUT : i32 = -2146435062;
pub const SCARD_E_SHARING_VIOLATION : i32 = -2146435061;
pub const SCARD_E_NO_SMARTCARD : i32 = -2146435060;
pub const SCARD_E_UNKNOWN_CARD : i32 = -2146435059;
pub const SCARD_E_CANT_DISPOSE : i32 = -2146435058;
pub const SCARD_E_PROTO_MISMATCH : i32 = -2146435057;
pub const SCARD_E_NOT_READY : i32 = -2146435056;
pub const SCARD_E_INVALID_VALUE : i32 = -2146435055;
pub const SCARD_E_SYSTEM_CANCELLED : i32 = -2146435054;
pub const SCARD_F_COMM_ERROR : i32 = -2146435053;
pub const SCARD_F_UNKNOWN_ERROR : i32 = -2146435052;
pub const SCARD_E_INVALID_ATR : i32 = -2146435051;
pub const SCARD_E_NOT_TRANSACTED : i32 = -2146435050;
pub const SCARD_E_READER_UNAVAILABLE : i32 = -2146435049;
pub const SCARD_P_SHUTDOWN : i32 = -2146435048;
pub const SCARD_E_PCI_TOO_SMALL : i32 = -2146435047;
pub const SCARD_E_READER_UNSUPPORTED : i32 = -2146435046;
pub const SCARD_E_DUPLICATE_READER : i32 = -2146435045;
pub const SCARD_E_CARD_UNSUPPORTED : i32 = -2146435044;
pub const SCARD_E_NO_SERVICE : i32 = -2146435043;
pub const SCARD_E_SERVICE_STOPPED : i32 = -2146435042;
pub const SCARD_E_UNEXPECTED : i32 = -2146435041;
pub const SCARD_E_ICC_INSTALLATION : i32 = -2146435040;
pub const SCARD_E_ICC_CREATEORDER : i32 = -2146435039;
pub const SCARD_E_UNSUPPORTED_FEATURE : i32 = -2146435038;
pub const SCARD_E_DIR_NOT_FOUND : i32 = -2146435037;
pub const SCARD_E_FILE_NOT_FOUND : i32 = -2146435036;
pub const SCARD_E_NO_DIR : i32 = -2146435035;
pub const SCARD_E_NO_FILE : i32 = -2146435034;
pub const SCARD_E_NO_ACCESS : i32 = -2146435033;
pub const SCARD_E_WRITE_TOO_MANY : i32 = -2146435032;
pub const SCARD_E_BAD_SEEK : i32 = -2146435031;
pub const SCARD_E_INVALID_CHV : i32 = -2146435030;
pub const SCARD_E_UNKNOWN_RES_MNG : i32 = -2146435029;
pub const SCARD_E_NO_SUCH_CERTIFICATE : i32 = -2146435028;
pub const SCARD_E_CERTIFICATE_UNAVAILABLE : i32 = -2146435027;
pub const SCARD_E_NO_READERS_AVAILABLE : i32 = -2146435026;
pub const SCARD_E_COMM_DATA_LOST : i32 = -2146435025;
pub const SCARD_E_NO_KEY_CONTAINER : i32 = -2146435024;
pub const SCARD_E_SERVER_TOO_BUSY : i32 = -2146435023;
pub const SCARD_E_PIN_CACHE_EXPIRED : i32 = -2146435022;
pub const SCARD_E_NO_PIN_CACHE : i32 = -2146435021;
pub const SCARD_E_READ_ONLY_CARD : i32 = -2146435020;
pub const SCARD_W_UNSUPPORTED_CARD : i32 = -2146434971;
pub const SCARD_W_UNRESPONSIVE_CARD : i32 = -2146434970;
pub const SCARD_W_UNPOWERED_CARD : i32 = -2146434969;
pub const SCARD_W_RESET_CARD : i32 = -2146434968;
pub const SCARD_W_REMOVED_CARD : i32 = -2146434967;
pub const SCARD_W_SECURITY_VIOLATION : i32 = -2146434966;
pub const SCARD_W_WRONG_CHV : i32 = -2146434965;
pub const SCARD_W_CHV_BLOCKED : i32 = -2146434964;
pub const SCARD_W_EOF : i32 = -2146434963;
pub const SCARD_W_CANCELLED_BY_USER : i32 = -2146434962;
pub const SCARD_W_CARD_NOT_AUTHENTICATED : i32 = -2146434961;
pub const SCARD_W_CACHE_ITEM_NOT_FOUND : i32 = -2146434960;
pub const SCARD_W_CACHE_ITEM_STALE : i32 = -2146434959;
pub const SCARD_W_CACHE_ITEM_TOO_BIG : i32 = -2146434958;
pub const COMADMIN_E_OBJECTERRORS : i32 = -2146368511;
pub const COMADMIN_E_OBJECTINVALID : i32 = -2146368510;
pub const COMADMIN_E_KEYMISSING : i32 = -2146368509;
pub const COMADMIN_E_ALREADYINSTALLED : i32 = -2146368508;
pub const COMADMIN_E_APP_FILE_WRITEFAIL : i32 = -2146368505;
pub const COMADMIN_E_APP_FILE_READFAIL : i32 = -2146368504;
pub const COMADMIN_E_APP_FILE_VERSION : i32 = -2146368503;
pub const COMADMIN_E_BADPATH : i32 = -2146368502;
pub const COMADMIN_E_APPLICATIONEXISTS : i32 = -2146368501;
pub const COMADMIN_E_ROLEEXISTS : i32 = -2146368500;
pub const COMADMIN_E_CANTCOPYFILE : i32 = -2146368499;
pub const COMADMIN_E_NOUSER : i32 = -2146368497;
pub const COMADMIN_E_INVALIDUSERIDS : i32 = -2146368496;
pub const COMADMIN_E_NOREGISTRYCLSID : i32 = -2146368495;
pub const COMADMIN_E_BADREGISTRYPROGID : i32 = -2146368494;
pub const COMADMIN_E_AUTHENTICATIONLEVEL : i32 = -2146368493;
pub const COMADMIN_E_USERPASSWDNOTVALID : i32 = -2146368492;
pub const COMADMIN_E_CLSIDORIIDMISMATCH : i32 = -2146368488;
pub const COMADMIN_E_REMOTEINTERFACE : i32 = -2146368487;
pub const COMADMIN_E_DLLREGISTERSERVER : i32 = -2146368486;
pub const COMADMIN_E_NOSERVERSHARE : i32 = -2146368485;
pub const COMADMIN_E_DLLLOADFAILED : i32 = -2146368483;
pub const COMADMIN_E_BADREGISTRYLIBID : i32 = -2146368482;
pub const COMADMIN_E_APPDIRNOTFOUND : i32 = -2146368481;
pub const COMADMIN_E_REGISTRARFAILED : i32 = -2146368477;
pub const COMADMIN_E_COMPFILE_DOESNOTEXIST : i32 = -2146368476;
pub const COMADMIN_E_COMPFILE_LOADDLLFAIL : i32 = -2146368475;
pub const COMADMIN_E_COMPFILE_GETCLASSOBJ : i32 = -2146368474;
pub const COMADMIN_E_COMPFILE_CLASSNOTAVAIL : i32 = -2146368473;
pub const COMADMIN_E_COMPFILE_BADTLB : i32 = -2146368472;
pub const COMADMIN_E_COMPFILE_NOTINSTALLABLE : i32 = -2146368471;
pub const COMADMIN_E_NOTCHANGEABLE : i32 = -2146368470;
pub const COMADMIN_E_NOTDELETEABLE : i32 = -2146368469;
pub const COMADMIN_E_SESSION : i32 = -2146368468;
pub const COMADMIN_E_COMP_MOVE_LOCKED : i32 = -2146368467;
pub const COMADMIN_E_COMP_MOVE_BAD_DEST : i32 = -2146368466;
pub const COMADMIN_E_REGISTERTLB : i32 = -2146368464;
pub const COMADMIN_E_SYSTEMAPP : i32 = -2146368461;
pub const COMADMIN_E_COMPFILE_NOREGISTRAR : i32 = -2146368460;
pub const COMADMIN_E_COREQCOMPINSTALLED : i32 = -2146368459;
pub const COMADMIN_E_SERVICENOTINSTALLED : i32 = -2146368458;
pub const COMADMIN_E_PROPERTYSAVEFAILED : i32 = -2146368457;
pub const COMADMIN_E_OBJECTEXISTS : i32 = -2146368456;
pub const COMADMIN_E_COMPONENTEXISTS : i32 = -2146368455;
pub const COMADMIN_E_REGFILE_CORRUPT : i32 = -2146368453;
pub const COMADMIN_E_PROPERTY_OVERFLOW : i32 = -2146368452;
pub const COMADMIN_E_NOTINREGISTRY : i32 = -2146368450;
pub const COMADMIN_E_OBJECTNOTPOOLABLE : i32 = -2146368449;
pub const COMADMIN_E_APPLID_MATCHES_CLSID : i32 = -2146368442;
pub const COMADMIN_E_ROLE_DOES_NOT_EXIST : i32 = -2146368441;
pub const COMADMIN_E_START_APP_NEEDS_COMPONENTS : i32 = -2146368440;
pub const COMADMIN_E_REQUIRES_DIFFERENT_PLATFORM : i32 = -2146368439;
pub const COMADMIN_E_CAN_NOT_EXPORT_APP_PROXY : i32 = -2146368438;
pub const COMADMIN_E_CAN_NOT_START_APP : i32 = -2146368437;
pub const COMADMIN_E_CAN_NOT_EXPORT_SYS_APP : i32 = -2146368436;
pub const COMADMIN_E_CANT_SUBSCRIBE_TO_COMPONENT : i32 = -2146368435;
pub const COMADMIN_E_EVENTCLASS_CANT_BE_SUBSCRIBER : i32 = -2146368434;
pub const COMADMIN_E_LIB_APP_PROXY_INCOMPATIBLE : i32 = -2146368433;
pub const COMADMIN_E_BASE_PARTITION_ONLY : i32 = -2146368432;
pub const COMADMIN_E_START_APP_DISABLED : i32 = -2146368431;
pub const COMADMIN_E_CAT_DUPLICATE_PARTITION_NAME : i32 = -2146368425;
pub const COMADMIN_E_CAT_INVALID_PARTITION_NAME : i32 = -2146368424;
pub const COMADMIN_E_CAT_PARTITION_IN_USE : i32 = -2146368423;
pub const COMADMIN_E_FILE_PARTITION_DUPLICATE_FILES : i32 = -2146368422;
pub const COMADMIN_E_CAT_IMPORTED_COMPONENTS_NOT_ALLOWED : i32 = -2146368421;
pub const COMADMIN_E_AMBIGUOUS_APPLICATION_NAME : i32 = -2146368420;
pub const COMADMIN_E_AMBIGUOUS_PARTITION_NAME : i32 = -2146368419;
pub const COMADMIN_E_REGDB_NOTINITIALIZED : i32 = -2146368398;
pub const COMADMIN_E_REGDB_NOTOPEN : i32 = -2146368397;
pub const COMADMIN_E_REGDB_SYSTEMERR : i32 = -2146368396;
pub const COMADMIN_E_REGDB_ALREADYRUNNING : i32 = -2146368395;
pub const COMADMIN_E_MIG_VERSIONNOTSUPPORTED : i32 = -2146368384;
pub const COMADMIN_E_MIG_SCHEMANOTFOUND : i32 = -2146368383;
pub const COMADMIN_E_CAT_BITNESSMISMATCH : i32 = -2146368382;
pub const COMADMIN_E_CAT_UNACCEPTABLEBITNESS : i32 = -2146368381;
pub const COMADMIN_E_CAT_WRONGAPPBITNESS : i32 = -2146368380;
pub const COMADMIN_E_CAT_PAUSE_RESUME_NOT_SUPPORTED : i32 = -2146368379;
pub const COMADMIN_E_CAT_SERVERFAULT : i32 = -2146368378;
pub const COMQC_E_APPLICATION_NOT_QUEUED : i32 = -2146368000;
pub const COMQC_E_NO_QUEUEABLE_INTERFACES : i32 = -2146367999;
pub const COMQC_E_QUEUING_SERVICE_NOT_AVAILABLE : i32 = -2146367998;
pub const COMQC_E_NO_IPERSISTSTREAM : i32 = -2146367997;
pub const COMQC_E_BAD_MESSAGE : i32 = -2146367996;
pub const COMQC_E_UNAUTHENTICATED : i32 = -2146367995;
pub const COMQC_E_UNTRUSTED_ENQUEUER : i32 = -2146367994;
pub const MSDTC_E_DUPLICATE_RESOURCE : i32 = -2146367743;
pub const COMADMIN_E_OBJECT_PARENT_MISSING : i32 = -2146367480;
pub const COMADMIN_E_OBJECT_DOES_NOT_EXIST : i32 = -2146367479;
pub const COMADMIN_E_APP_NOT_RUNNING : i32 = -2146367478;
pub const COMADMIN_E_INVALID_PARTITION : i32 = -2146367477;
pub const COMADMIN_E_SVCAPP_NOT_POOLABLE_OR_RECYCLABLE : i32 = -2146367475;
pub const COMADMIN_E_USER_IN_SET : i32 = -2146367474;
pub const COMADMIN_E_CANTRECYCLELIBRARYAPPS : i32 = -2146367473;
pub const COMADMIN_E_CANTRECYCLESERVICEAPPS : i32 = -2146367471;
pub const COMADMIN_E_PROCESSALREADYRECYCLED : i32 = -2146367470;
pub const COMADMIN_E_PAUSEDPROCESSMAYNOTBERECYCLED : i32 = -2146367469;
pub const COMADMIN_E_CANTMAKEINPROCSERVICE : i32 = -2146367468;
pub const COMADMIN_E_PROGIDINUSEBYCLSID : i32 = -2146367467;
pub const COMADMIN_E_DEFAULT_PARTITION_NOT_IN_SET : i32 = -2146367466;
pub const COMADMIN_E_RECYCLEDPROCESSMAYNOTBEPAUSED : i32 = -2146367465;
pub const COMADMIN_E_PARTITION_ACCESSDENIED : i32 = -2146367464;
pub const COMADMIN_E_PARTITION_MSI_ONLY : i32 = -2146367463;
pub const COMADMIN_E_LEGACYCOMPS_NOT_ALLOWED_IN_1_0_FORMAT : i32 = -2146367462;
pub const COMADMIN_E_LEGACYCOMPS_NOT_ALLOWED_IN_NONBASE_PARTITIONS : i32 = -2146367461;
pub const COMADMIN_E_COMP_MOVE_SOURCE : i32 = -2146367460;
pub const COMADMIN_E_COMP_MOVE_DEST : i32 = -2146367459;
pub const COMADMIN_E_COMP_MOVE_PRIVATE : i32 = -2146367458;
pub const COMADMIN_E_BASEPARTITION_REQUIRED_IN_SET : i32 = -2146367457;
pub const COMADMIN_E_CANNOT_ALIAS_EVENTCLASS : i32 = -2146367456;
pub const COMADMIN_E_PRIVATE_ACCESSDENIED : i32 = -2146367455;
pub const COMADMIN_E_SAFERINVALID : i32 = -2146367454;
pub const COMADMIN_E_REGISTRY_ACCESSDENIED : i32 = -2146367453;
pub const COMADMIN_E_PARTITIONS_DISABLED : i32 = -2146367452;
pub const WER_S_REPORT_DEBUG : i32 = 1769472;
pub const WER_S_REPORT_UPLOADED : i32 = 1769473;
pub const WER_S_REPORT_QUEUED : i32 = 1769474;
pub const WER_S_DISABLED : i32 = 1769475;
pub const WER_S_SUSPENDED_UPLOAD : i32 = 1769476;
pub const WER_S_DISABLED_QUEUE : i32 = 1769477;
pub const WER_S_DISABLED_ARCHIVE : i32 = 1769478;
pub const WER_S_REPORT_ASYNC : i32 = 1769479;
pub const WER_S_IGNORE_ASSERT_INSTANCE : i32 = 1769480;
pub const WER_S_IGNORE_ALL_ASSERTS : i32 = 1769481;
pub const WER_S_ASSERT_CONTINUE : i32 = 1769482;
pub const WER_S_THROTTLED : i32 = 1769483;
pub const WER_S_REPORT_UPLOADED_CAB : i32 = 1769484;
pub const WER_E_CRASH_FAILURE : i32 = -2145681408;
pub const WER_E_CANCELED : i32 = -2145681407;
pub const WER_E_NETWORK_FAILURE : i32 = -2145681406;
pub const WER_E_NOT_INITIALIZED : i32 = -2145681405;
pub const WER_E_ALREADY_REPORTING : i32 = -2145681404;
pub const WER_E_DUMP_THROTTLED : i32 = -2145681403;
pub const WER_E_INSUFFICIENT_CONSENT : i32 = -2145681402;
pub const WER_E_TOO_HEAVY : i32 = -2145681401;
pub const ERROR_FLT_IO_COMPLETE : i32 = 2031617;
pub const ERROR_FLT_NO_HANDLER_DEFINED : i32 = -2145452031;
pub const ERROR_FLT_CONTEXT_ALREADY_DEFINED : i32 = -2145452030;
pub const ERROR_FLT_INVALID_ASYNCHRONOUS_REQUEST : i32 = -2145452029;
pub const ERROR_FLT_DISALLOW_FAST_IO : i32 = -2145452028;
pub const ERROR_FLT_INVALID_NAME_REQUEST : i32 = -2145452027;
pub const ERROR_FLT_NOT_SAFE_TO_POST_OPERATION : i32 = -2145452026;
pub const ERROR_FLT_NOT_INITIALIZED : i32 = -2145452025;
pub const ERROR_FLT_FILTER_NOT_READY : i32 = -2145452024;
pub const ERROR_FLT_POST_OPERATION_CLEANUP : i32 = -2145452023;
pub const ERROR_FLT_INTERNAL_ERROR : i32 = -2145452022;
pub const ERROR_FLT_DELETING_OBJECT : i32 = -2145452021;
pub const ERROR_FLT_MUST_BE_NONPAGED_POOL : i32 = -2145452020;
pub const ERROR_FLT_DUPLICATE_ENTRY : i32 = -2145452019;
pub const ERROR_FLT_CBDQ_DISABLED : i32 = -2145452018;
pub const ERROR_FLT_DO_NOT_ATTACH : i32 = -2145452017;
pub const ERROR_FLT_DO_NOT_DETACH : i32 = -2145452016;
pub const ERROR_FLT_INSTANCE_ALTITUDE_COLLISION : i32 = -2145452015;
pub const ERROR_FLT_INSTANCE_NAME_COLLISION : i32 = -2145452014;
pub const ERROR_FLT_FILTER_NOT_FOUND : i32 = -2145452013;
pub const ERROR_FLT_VOLUME_NOT_FOUND : i32 = -2145452012;
pub const ERROR_FLT_INSTANCE_NOT_FOUND : i32 = -2145452011;
pub const ERROR_FLT_CONTEXT_ALLOCATION_NOT_FOUND : i32 = -2145452010;
pub const ERROR_FLT_INVALID_CONTEXT_REGISTRATION : i32 = -2145452009;
pub const ERROR_FLT_NAME_CACHE_MISS : i32 = -2145452008;
pub const ERROR_FLT_NO_DEVICE_OBJECT : i32 = -2145452007;
pub const ERROR_FLT_VOLUME_ALREADY_MOUNTED : i32 = -2145452006;
pub const ERROR_FLT_ALREADY_ENLISTED : i32 = -2145452005;
pub const ERROR_FLT_CONTEXT_ALREADY_LINKED : i32 = -2145452004;
pub const ERROR_FLT_NO_WAITER_FOR_REPLY : i32 = -2145452000;
pub const ERROR_FLT_REGISTRATION_BUSY : i32 = -2145451997;
pub const ERROR_HUNG_DISPLAY_DRIVER_THREAD : i32 = -2144993279;
pub const DWM_E_COMPOSITIONDISABLED : i32 = -2144980991;
pub const DWM_E_REMOTING_NOT_SUPPORTED : i32 = -2144980990;
pub const DWM_E_NO_REDIRECTION_SURFACE_AVAILABLE : i32 = -2144980989;
pub const DWM_E_NOT_QUEUING_PRESENTS : i32 = -2144980988;
pub const DWM_E_ADAPTER_NOT_FOUND : i32 = -2144980987;
pub const DWM_S_GDI_REDIRECTION_SURFACE : i32 = 2502661;
pub const DWM_E_TEXTURE_TOO_LARGE : i32 = -2144980985;
pub const DWM_S_GDI_REDIRECTION_SURFACE_BLT_VIA_GDI : i32 = 2502664;
pub const ERROR_MONITOR_NO_DESCRIPTOR : i32 = 2494465;
pub const ERROR_MONITOR_UNKNOWN_DESCRIPTOR_FORMAT : i32 = 2494466;
pub const ERROR_MONITOR_INVALID_DESCRIPTOR_CHECKSUM : i32 = -1071247357;
pub const ERROR_MONITOR_INVALID_STANDARD_TIMING_BLOCK : i32 = -1071247356;
pub const ERROR_MONITOR_WMI_DATABLOCK_REGISTRATION_FAILED : i32 = -1071247355;
pub const ERROR_MONITOR_INVALID_SERIAL_NUMBER_MONDSC_BLOCK : i32 = -1071247354;
pub const ERROR_MONITOR_INVALID_USER_FRIENDLY_MONDSC_BLOCK : i32 = -1071247353;
pub const ERROR_MONITOR_NO_MORE_DESCRIPTOR_DATA : i32 = -1071247352;
pub const ERROR_MONITOR_INVALID_DETAILED_TIMING_BLOCK : i32 = -1071247351;
pub const ERROR_MONITOR_INVALID_MANUFACTURE_DATE : i32 = -1071247350;
pub const ERROR_GRAPHICS_NOT_EXCLUSIVE_MODE_OWNER : i32 = -1071243264;
pub const ERROR_GRAPHICS_INSUFFICIENT_DMA_BUFFER : i32 = -1071243263;
pub const ERROR_GRAPHICS_INVALID_DISPLAY_ADAPTER : i32 = -1071243262;
pub const ERROR_GRAPHICS_ADAPTER_WAS_RESET : i32 = -1071243261;
pub const ERROR_GRAPHICS_INVALID_DRIVER_MODEL : i32 = -1071243260;
pub const ERROR_GRAPHICS_PRESENT_MODE_CHANGED : i32 = -1071243259;
pub const ERROR_GRAPHICS_PRESENT_OCCLUDED : i32 = -1071243258;
pub const ERROR_GRAPHICS_PRESENT_DENIED : i32 = -1071243257;
pub const ERROR_GRAPHICS_CANNOTCOLORCONVERT : i32 = -1071243256;
pub const ERROR_GRAPHICS_DRIVER_MISMATCH : i32 = -1071243255;
pub const ERROR_GRAPHICS_PARTIAL_DATA_POPULATED : i32 = 1076240394;
pub const ERROR_GRAPHICS_PRESENT_REDIRECTION_DISABLED : i32 = -1071243253;
pub const ERROR_GRAPHICS_PRESENT_UNOCCLUDED : i32 = -1071243252;
pub const ERROR_GRAPHICS_WINDOWDC_NOT_AVAILABLE : i32 = -1071243251;
pub const ERROR_GRAPHICS_WINDOWLESS_PRESENT_DISABLED : i32 = -1071243250;
pub const ERROR_GRAPHICS_PRESENT_INVALID_WINDOW : i32 = -1071243249;
pub const ERROR_GRAPHICS_PRESENT_BUFFER_NOT_BOUND : i32 = -1071243248;
pub const ERROR_GRAPHICS_VAIL_STATE_CHANGED : i32 = -1071243247;
pub const ERROR_GRAPHICS_INDIRECT_DISPLAY_ABANDON_SWAPCHAIN : i32 = -1071243246;
pub const ERROR_GRAPHICS_INDIRECT_DISPLAY_DEVICE_STOPPED : i32 = -1071243245;
pub const ERROR_GRAPHICS_VAIL_FAILED_TO_SEND_CREATE_SUPERWETINK_MESSAGE : i32 = -1071243244;
pub const ERROR_GRAPHICS_VAIL_FAILED_TO_SEND_DESTROY_SUPERWETINK_MESSAGE : i32 = -1071243243;
pub const ERROR_GRAPHICS_NO_VIDEO_MEMORY : i32 = -1071243008;
pub const ERROR_GRAPHICS_CANT_LOCK_MEMORY : i32 = -1071243007;
pub const ERROR_GRAPHICS_ALLOCATION_BUSY : i32 = -1071243006;
pub const ERROR_GRAPHICS_TOO_MANY_REFERENCES : i32 = -1071243005;
pub const ERROR_GRAPHICS_TRY_AGAIN_LATER : i32 = -1071243004;
pub const ERROR_GRAPHICS_TRY_AGAIN_NOW : i32 = -1071243003;
pub const ERROR_GRAPHICS_ALLOCATION_INVALID : i32 = -1071243002;
pub const ERROR_GRAPHICS_UNSWIZZLING_APERTURE_UNAVAILABLE : i32 = -1071243001;
pub const ERROR_GRAPHICS_UNSWIZZLING_APERTURE_UNSUPPORTED : i32 = -1071243000;
pub const ERROR_GRAPHICS_CANT_EVICT_PINNED_ALLOCATION : i32 = -1071242999;
pub const ERROR_GRAPHICS_INVALID_ALLOCATION_USAGE : i32 = -1071242992;
pub const ERROR_GRAPHICS_CANT_RENDER_LOCKED_ALLOCATION : i32 = -1071242991;
pub const ERROR_GRAPHICS_ALLOCATION_CLOSED : i32 = -1071242990;
pub const ERROR_GRAPHICS_INVALID_ALLOCATION_INSTANCE : i32 = -1071242989;
pub const ERROR_GRAPHICS_INVALID_ALLOCATION_HANDLE : i32 = -1071242988;
pub const ERROR_GRAPHICS_WRONG_ALLOCATION_DEVICE : i32 = -1071242987;
pub const ERROR_GRAPHICS_ALLOCATION_CONTENT_LOST : i32 = -1071242986;
pub const ERROR_GRAPHICS_GPU_EXCEPTION_ON_DEVICE : i32 = -1071242752;
pub const ERROR_GRAPHICS_SKIP_ALLOCATION_PREPARATION : i32 = 1076240897;
pub const ERROR_GRAPHICS_INVALID_VIDPN_TOPOLOGY : i32 = -1071242496;
pub const ERROR_GRAPHICS_VIDPN_TOPOLOGY_NOT_SUPPORTED : i32 = -1071242495;
pub const ERROR_GRAPHICS_VIDPN_TOPOLOGY_CURRENTLY_NOT_SUPPORTED : i32 = -1071242494;
pub const ERROR_GRAPHICS_INVALID_VIDPN : i32 = -1071242493;
pub const ERROR_GRAPHICS_INVALID_VIDEO_PRESENT_SOURCE : i32 = -1071242492;
pub const ERROR_GRAPHICS_INVALID_VIDEO_PRESENT_TARGET : i32 = -1071242491;
pub const ERROR_GRAPHICS_VIDPN_MODALITY_NOT_SUPPORTED : i32 = -1071242490;
pub const ERROR_GRAPHICS_MODE_NOT_PINNED : i32 = 2499335;
pub const ERROR_GRAPHICS_INVALID_VIDPN_SOURCEMODESET : i32 = -1071242488;
pub const ERROR_GRAPHICS_INVALID_VIDPN_TARGETMODESET : i32 = -1071242487;
pub const ERROR_GRAPHICS_INVALID_FREQUENCY : i32 = -1071242486;
pub const ERROR_GRAPHICS_INVALID_ACTIVE_REGION : i32 = -1071242485;
pub const ERROR_GRAPHICS_INVALID_TOTAL_REGION : i32 = -1071242484;
pub const ERROR_GRAPHICS_INVALID_VIDEO_PRESENT_SOURCE_MODE : i32 = -1071242480;
pub const ERROR_GRAPHICS_INVALID_VIDEO_PRESENT_TARGET_MODE : i32 = -1071242479;
pub const ERROR_GRAPHICS_PINNED_MODE_MUST_REMAIN_IN_SET : i32 = -1071242478;
pub const ERROR_GRAPHICS_PATH_ALREADY_IN_TOPOLOGY : i32 = -1071242477;
pub const ERROR_GRAPHICS_MODE_ALREADY_IN_MODESET : i32 = -1071242476;
pub const ERROR_GRAPHICS_INVALID_VIDEOPRESENTSOURCESET : i32 = -1071242475;
pub const ERROR_GRAPHICS_INVALID_VIDEOPRESENTTARGETSET : i32 = -1071242474;
pub const ERROR_GRAPHICS_SOURCE_ALREADY_IN_SET : i32 = -1071242473;
pub const ERROR_GRAPHICS_TARGET_ALREADY_IN_SET : i32 = -1071242472;
pub const ERROR_GRAPHICS_INVALID_VIDPN_PRESENT_PATH : i32 = -1071242471;
pub const ERROR_GRAPHICS_NO_RECOMMENDED_VIDPN_TOPOLOGY : i32 = -1071242470;
pub const ERROR_GRAPHICS_INVALID_MONITOR_FREQUENCYRANGESET : i32 = -1071242469;
pub const ERROR_GRAPHICS_INVALID_MONITOR_FREQUENCYRANGE : i32 = -1071242468;
pub const ERROR_GRAPHICS_FREQUENCYRANGE_NOT_IN_SET : i32 = -1071242467;
pub const ERROR_GRAPHICS_NO_PREFERRED_MODE : i32 = 2499358;
pub const ERROR_GRAPHICS_FREQUENCYRANGE_ALREADY_IN_SET : i32 = -1071242465;
pub const ERROR_GRAPHICS_STALE_MODESET : i32 = -1071242464;
pub const ERROR_GRAPHICS_INVALID_MONITOR_SOURCEMODESET : i32 = -1071242463;
pub const ERROR_GRAPHICS_INVALID_MONITOR_SOURCE_MODE : i32 = -1071242462;
pub const ERROR_GRAPHICS_NO_RECOMMENDED_FUNCTIONAL_VIDPN : i32 = -1071242461;
pub const ERROR_GRAPHICS_MODE_ID_MUST_BE_UNIQUE : i32 = -1071242460;
pub const ERROR_GRAPHICS_EMPTY_ADAPTER_MONITOR_MODE_SUPPORT_INTERSECTION : i32 = -1071242459;
pub const ERROR_GRAPHICS_VIDEO_PRESENT_TARGETS_LESS_THAN_SOURCES : i32 = -1071242458;
pub const ERROR_GRAPHICS_PATH_NOT_IN_TOPOLOGY : i32 = -1071242457;
pub const ERROR_GRAPHICS_ADAPTER_MUST_HAVE_AT_LEAST_ONE_SOURCE : i32 = -1071242456;
pub const ERROR_GRAPHICS_ADAPTER_MUST_HAVE_AT_LEAST_ONE_TARGET : i32 = -1071242455;
pub const ERROR_GRAPHICS_INVALID_MONITORDESCRIPTORSET : i32 = -1071242454;
pub const ERROR_GRAPHICS_INVALID_MONITORDESCRIPTOR : i32 = -1071242453;
pub const ERROR_GRAPHICS_MONITORDESCRIPTOR_NOT_IN_SET : i32 = -1071242452;
pub const ERROR_GRAPHICS_MONITORDESCRIPTOR_ALREADY_IN_SET : i32 = -1071242451;
pub const ERROR_GRAPHICS_MONITORDESCRIPTOR_ID_MUST_BE_UNIQUE : i32 = -1071242450;
pub const ERROR_GRAPHICS_INVALID_VIDPN_TARGET_SUBSET_TYPE : i32 = -1071242449;
pub const ERROR_GRAPHICS_RESOURCES_NOT_RELATED : i32 = -1071242448;
pub const ERROR_GRAPHICS_SOURCE_ID_MUST_BE_UNIQUE : i32 = -1071242447;
pub const ERROR_GRAPHICS_TARGET_ID_MUST_BE_UNIQUE : i32 = -1071242446;
pub const ERROR_GRAPHICS_NO_AVAILABLE_VIDPN_TARGET : i32 = -1071242445;
pub const ERROR_GRAPHICS_MONITOR_COULD_NOT_BE_ASSOCIATED_WITH_ADAPTER : i32 = -1071242444;
pub const ERROR_GRAPHICS_NO_VIDPNMGR : i32 = -1071242443;
pub const ERROR_GRAPHICS_NO_ACTIVE_VIDPN : i32 = -1071242442;
pub const ERROR_GRAPHICS_STALE_VIDPN_TOPOLOGY : i32 = -1071242441;
pub const ERROR_GRAPHICS_MONITOR_NOT_CONNECTED : i32 = -1071242440;
pub const ERROR_GRAPHICS_SOURCE_NOT_IN_TOPOLOGY : i32 = -1071242439;
pub const ERROR_GRAPHICS_INVALID_PRIMARYSURFACE_SIZE : i32 = -1071242438;
pub const ERROR_GRAPHICS_INVALID_VISIBLEREGION_SIZE : i32 = -1071242437;
pub const ERROR_GRAPHICS_INVALID_STRIDE : i32 = -1071242436;
pub const ERROR_GRAPHICS_INVALID_PIXELFORMAT : i32 = -1071242435;
pub const ERROR_GRAPHICS_INVALID_COLORBASIS : i32 = -1071242434;
pub const ERROR_GRAPHICS_INVALID_PIXELVALUEACCESSMODE : i32 = -1071242433;
pub const ERROR_GRAPHICS_TARGET_NOT_IN_TOPOLOGY : i32 = -1071242432;
pub const ERROR_GRAPHICS_NO_DISPLAY_MODE_MANAGEMENT_SUPPORT : i32 = -1071242431;
pub const ERROR_GRAPHICS_VIDPN_SOURCE_IN_USE : i32 = -1071242430;
pub const ERROR_GRAPHICS_CANT_ACCESS_ACTIVE_VIDPN : i32 = -1071242429;
pub const ERROR_GRAPHICS_INVALID_PATH_IMPORTANCE_ORDINAL : i32 = -1071242428;
pub const ERROR_GRAPHICS_INVALID_PATH_CONTENT_GEOMETRY_TRANSFORMATION : i32 = -1071242427;
pub const ERROR_GRAPHICS_PATH_CONTENT_GEOMETRY_TRANSFORMATION_NOT_SUPPORTED : i32 = -1071242426;
pub const ERROR_GRAPHICS_INVALID_GAMMA_RAMP : i32 = -1071242425;
pub const ERROR_GRAPHICS_GAMMA_RAMP_NOT_SUPPORTED : i32 = -1071242424;
pub const ERROR_GRAPHICS_MULTISAMPLING_NOT_SUPPORTED : i32 = -1071242423;
pub const ERROR_GRAPHICS_MODE_NOT_IN_MODESET : i32 = -1071242422;
pub const ERROR_GRAPHICS_DATASET_IS_EMPTY : i32 = 2499403;
pub const ERROR_GRAPHICS_NO_MORE_ELEMENTS_IN_DATASET : i32 = 2499404;
pub const ERROR_GRAPHICS_INVALID_VIDPN_TOPOLOGY_RECOMMENDATION_REASON : i32 = -1071242419;
pub const ERROR_GRAPHICS_INVALID_PATH_CONTENT_TYPE : i32 = -1071242418;
pub const ERROR_GRAPHICS_INVALID_COPYPROTECTION_TYPE : i32 = -1071242417;
pub const ERROR_GRAPHICS_UNASSIGNED_MODESET_ALREADY_EXISTS : i32 = -1071242416;
pub const ERROR_GRAPHICS_PATH_CONTENT_GEOMETRY_TRANSFORMATION_NOT_PINNED : i32 = 2499409;
pub const ERROR_GRAPHICS_INVALID_SCANLINE_ORDERING : i32 = -1071242414;
pub const ERROR_GRAPHICS_TOPOLOGY_CHANGES_NOT_ALLOWED : i32 = -1071242413;
pub const ERROR_GRAPHICS_NO_AVAILABLE_IMPORTANCE_ORDINALS : i32 = -1071242412;
pub const ERROR_GRAPHICS_INCOMPATIBLE_PRIVATE_FORMAT : i32 = -1071242411;
pub const ERROR_GRAPHICS_INVALID_MODE_PRUNING_ALGORITHM : i32 = -1071242410;
pub const ERROR_GRAPHICS_INVALID_MONITOR_CAPABILITY_ORIGIN : i32 = -1071242409;
pub const ERROR_GRAPHICS_INVALID_MONITOR_FREQUENCYRANGE_CONSTRAINT : i32 = -1071242408;
pub const ERROR_GRAPHICS_MAX_NUM_PATHS_REACHED : i32 = -1071242407;
pub const ERROR_GRAPHICS_CANCEL_VIDPN_TOPOLOGY_AUGMENTATION : i32 = -1071242406;
pub const ERROR_GRAPHICS_INVALID_CLIENT_TYPE : i32 = -1071242405;
pub const ERROR_GRAPHICS_CLIENTVIDPN_NOT_SET : i32 = -1071242404;
pub const ERROR_GRAPHICS_SPECIFIED_CHILD_ALREADY_CONNECTED : i32 = -1071242240;
pub const ERROR_GRAPHICS_CHILD_DESCRIPTOR_NOT_SUPPORTED : i32 = -1071242239;
pub const ERROR_GRAPHICS_UNKNOWN_CHILD_STATUS : i32 = 1076241455;
pub const ERROR_GRAPHICS_NOT_A_LINKED_ADAPTER : i32 = -1071242192;
pub const ERROR_GRAPHICS_LEADLINK_NOT_ENUMERATED : i32 = -1071242191;
pub const ERROR_GRAPHICS_CHAINLINKS_NOT_ENUMERATED : i32 = -1071242190;
pub const ERROR_GRAPHICS_ADAPTER_CHAIN_NOT_READY : i32 = -1071242189;
pub const ERROR_GRAPHICS_CHAINLINKS_NOT_STARTED : i32 = -1071242188;
pub const ERROR_GRAPHICS_CHAINLINKS_NOT_POWERED_ON : i32 = -1071242187;
pub const ERROR_GRAPHICS_INCONSISTENT_DEVICE_LINK_STATE : i32 = -1071242186;
pub const ERROR_GRAPHICS_LEADLINK_START_DEFERRED : i32 = 1076241463;
pub const ERROR_GRAPHICS_NOT_POST_DEVICE_DRIVER : i32 = -1071242184;
pub const ERROR_GRAPHICS_POLLING_TOO_FREQUENTLY : i32 = 1076241465;
pub const ERROR_GRAPHICS_START_DEFERRED : i32 = 1076241466;
pub const ERROR_GRAPHICS_ADAPTER_ACCESS_NOT_EXCLUDED : i32 = -1071242181;
pub const ERROR_GRAPHICS_DEPENDABLE_CHILD_STATUS : i32 = 1076241468;
pub const ERROR_GRAPHICS_OPM_NOT_SUPPORTED : i32 = -1071241984;
pub const ERROR_GRAPHICS_COPP_NOT_SUPPORTED : i32 = -1071241983;
pub const ERROR_GRAPHICS_UAB_NOT_SUPPORTED : i32 = -1071241982;
pub const ERROR_GRAPHICS_OPM_INVALID_ENCRYPTED_PARAMETERS : i32 = -1071241981;
pub const ERROR_GRAPHICS_OPM_NO_VIDEO_OUTPUTS_EXIST : i32 = -1071241979;
pub const ERROR_GRAPHICS_OPM_INTERNAL_ERROR : i32 = -1071241973;
pub const ERROR_GRAPHICS_OPM_INVALID_HANDLE : i32 = -1071241972;
pub const ERROR_GRAPHICS_PVP_INVALID_CERTIFICATE_LENGTH : i32 = -1071241970;
pub const ERROR_GRAPHICS_OPM_SPANNING_MODE_ENABLED : i32 = -1071241969;
pub const ERROR_GRAPHICS_OPM_THEATER_MODE_ENABLED : i32 = -1071241968;
pub const ERROR_GRAPHICS_PVP_HFS_FAILED : i32 = -1071241967;
pub const ERROR_GRAPHICS_OPM_INVALID_SRM : i32 = -1071241966;
pub const ERROR_GRAPHICS_OPM_OUTPUT_DOES_NOT_SUPPORT_HDCP : i32 = -1071241965;
pub const ERROR_GRAPHICS_OPM_OUTPUT_DOES_NOT_SUPPORT_ACP : i32 = -1071241964;
pub const ERROR_GRAPHICS_OPM_OUTPUT_DOES_NOT_SUPPORT_CGMSA : i32 = -1071241963;
pub const ERROR_GRAPHICS_OPM_HDCP_SRM_NEVER_SET : i32 = -1071241962;
pub const ERROR_GRAPHICS_OPM_RESOLUTION_TOO_HIGH : i32 = -1071241961;
pub const ERROR_GRAPHICS_OPM_ALL_HDCP_HARDWARE_ALREADY_IN_USE : i32 = -1071241960;
pub const ERROR_GRAPHICS_OPM_VIDEO_OUTPUT_NO_LONGER_EXISTS : i32 = -1071241958;
pub const ERROR_GRAPHICS_OPM_SESSION_TYPE_CHANGE_IN_PROGRESS : i32 = -1071241957;
pub const ERROR_GRAPHICS_OPM_VIDEO_OUTPUT_DOES_NOT_HAVE_COPP_SEMANTICS : i32 = -1071241956;
pub const ERROR_GRAPHICS_OPM_INVALID_INFORMATION_REQUEST : i32 = -1071241955;
pub const ERROR_GRAPHICS_OPM_DRIVER_INTERNAL_ERROR : i32 = -1071241954;
pub const ERROR_GRAPHICS_OPM_VIDEO_OUTPUT_DOES_NOT_HAVE_OPM_SEMANTICS : i32 = -1071241953;
pub const ERROR_GRAPHICS_OPM_SIGNALING_NOT_SUPPORTED : i32 = -1071241952;
pub const ERROR_GRAPHICS_OPM_INVALID_CONFIGURATION_REQUEST : i32 = -1071241951;
pub const ERROR_GRAPHICS_I2C_NOT_SUPPORTED : i32 = -1071241856;
pub const ERROR_GRAPHICS_I2C_DEVICE_DOES_NOT_EXIST : i32 = -1071241855;
pub const ERROR_GRAPHICS_I2C_ERROR_TRANSMITTING_DATA : i32 = -1071241854;
pub const ERROR_GRAPHICS_I2C_ERROR_RECEIVING_DATA : i32 = -1071241853;
pub const ERROR_GRAPHICS_DDCCI_VCP_NOT_SUPPORTED : i32 = -1071241852;
pub const ERROR_GRAPHICS_DDCCI_INVALID_DATA : i32 = -1071241851;
pub const ERROR_GRAPHICS_DDCCI_MONITOR_RETURNED_INVALID_TIMING_STATUS_BYTE : i32 = -1071241850;
pub const ERROR_GRAPHICS_MCA_INVALID_CAPABILITIES_STRING : i32 = -1071241849;
pub const ERROR_GRAPHICS_MCA_INTERNAL_ERROR : i32 = -1071241848;
pub const ERROR_GRAPHICS_DDCCI_INVALID_MESSAGE_COMMAND : i32 = -1071241847;
pub const ERROR_GRAPHICS_DDCCI_INVALID_MESSAGE_LENGTH : i32 = -1071241846;
pub const ERROR_GRAPHICS_DDCCI_INVALID_MESSAGE_CHECKSUM : i32 = -1071241845;
pub const ERROR_GRAPHICS_INVALID_PHYSICAL_MONITOR_HANDLE : i32 = -1071241844;
pub const ERROR_GRAPHICS_MONITOR_NO_LONGER_EXISTS : i32 = -1071241843;
pub const ERROR_GRAPHICS_DDCCI_CURRENT_CURRENT_VALUE_GREATER_THAN_MAXIMUM_VALUE : i32 = -1071241768;
pub const ERROR_GRAPHICS_MCA_INVALID_VCP_VERSION : i32 = -1071241767;
pub const ERROR_GRAPHICS_MCA_MONITOR_VIOLATES_MCCS_SPECIFICATION : i32 = -1071241766;
pub const ERROR_GRAPHICS_MCA_MCCS_VERSION_MISMATCH : i32 = -1071241765;
pub const ERROR_GRAPHICS_MCA_UNSUPPORTED_MCCS_VERSION : i32 = -1071241764;
pub const ERROR_GRAPHICS_MCA_INVALID_TECHNOLOGY_TYPE_RETURNED : i32 = -1071241762;
pub const ERROR_GRAPHICS_MCA_UNSUPPORTED_COLOR_TEMPERATURE : i32 = -1071241761;
pub const ERROR_GRAPHICS_ONLY_CONSOLE_SESSION_SUPPORTED : i32 = -1071241760;
pub const ERROR_GRAPHICS_NO_DISPLAY_DEVICE_CORRESPONDS_TO_NAME : i32 = -1071241759;
pub const ERROR_GRAPHICS_DISPLAY_DEVICE_NOT_ATTACHED_TO_DESKTOP : i32 = -1071241758;
pub const ERROR_GRAPHICS_MIRRORING_DEVICES_NOT_SUPPORTED : i32 = -1071241757;
pub const ERROR_GRAPHICS_INVALID_POINTER : i32 = -1071241756;
pub const ERROR_GRAPHICS_NO_MONITORS_CORRESPOND_TO_DISPLAY_DEVICE : i32 = -1071241755;
pub const ERROR_GRAPHICS_PARAMETER_ARRAY_TOO_SMALL : i32 = -1071241754;
pub const ERROR_GRAPHICS_INTERNAL_ERROR : i32 = -1071241753;
pub const ERROR_GRAPHICS_SESSION_TYPE_CHANGE_IN_PROGRESS : i32 = -1071249944;
pub const NAP_E_INVALID_PACKET : i32 = -2144927743;
pub const NAP_E_MISSING_SOH : i32 = -2144927742;
pub const NAP_E_CONFLICTING_ID : i32 = -2144927741;
pub const NAP_E_NO_CACHED_SOH : i32 = -2144927740;
pub const NAP_E_STILL_BOUND : i32 = -2144927739;
pub const NAP_E_NOT_REGISTERED : i32 = -2144927738;
pub const NAP_E_NOT_INITIALIZED : i32 = -2144927737;
pub const NAP_E_MISMATCHED_ID : i32 = -2144927736;
pub const NAP_E_NOT_PENDING : i32 = -2144927735;
pub const NAP_E_ID_NOT_FOUND : i32 = -2144927734;
pub const NAP_E_MAXSIZE_TOO_SMALL : i32 = -2144927733;
pub const NAP_E_SERVICE_NOT_RUNNING : i32 = -2144927732;
pub const NAP_S_CERT_ALREADY_PRESENT : i32 = 2555917;
pub const NAP_E_ENTITY_DISABLED : i32 = -2144927730;
pub const NAP_E_NETSH_GROUPPOLICY_ERROR : i32 = -2144927729;
pub const NAP_E_TOO_MANY_CALLS : i32 = -2144927728;
pub const NAP_E_SHV_CONFIG_EXISTED : i32 = -2144927727;
pub const NAP_E_SHV_CONFIG_NOT_FOUND : i32 = -2144927726;
pub const NAP_E_SHV_TIMEOUT : i32 = -2144927725;
pub const TPM_E_ERROR_MASK : i32 = -2144862208;
pub const TPM_E_AUTHFAIL : i32 = -2144862207;
pub const TPM_E_BADINDEX : i32 = -2144862206;
pub const TPM_E_BAD_PARAMETER : i32 = -2144862205;
pub const TPM_E_AUDITFAILURE : i32 = -2144862204;
pub const TPM_E_CLEAR_DISABLED : i32 = -2144862203;
pub const TPM_E_DEACTIVATED : i32 = -2144862202;
pub const TPM_E_DISABLED : i32 = -2144862201;
pub const TPM_E_DISABLED_CMD : i32 = -2144862200;
pub const TPM_E_FAIL : i32 = -2144862199;
pub const TPM_E_BAD_ORDINAL : i32 = -2144862198;
pub const TPM_E_INSTALL_DISABLED : i32 = -2144862197;
pub const TPM_E_INVALID_KEYHANDLE : i32 = -2144862196;
pub const TPM_E_KEYNOTFOUND : i32 = -2144862195;
pub const TPM_E_INAPPROPRIATE_ENC : i32 = -2144862194;
pub const TPM_E_MIGRATEFAIL : i32 = -2144862193;
pub const TPM_E_INVALID_PCR_INFO : i32 = -2144862192;
pub const TPM_E_NOSPACE : i32 = -2144862191;
pub const TPM_E_NOSRK : i32 = -2144862190;
pub const TPM_E_NOTSEALED_BLOB : i32 = -2144862189;
pub const TPM_E_OWNER_SET : i32 = -2144862188;
pub const TPM_E_RESOURCES : i32 = -2144862187;
pub const TPM_E_SHORTRANDOM : i32 = -2144862186;
pub const TPM_E_SIZE : i32 = -2144862185;
pub const TPM_E_WRONGPCRVAL : i32 = -2144862184;
pub const TPM_E_BAD_PARAM_SIZE : i32 = -2144862183;
pub const TPM_E_SHA_THREAD : i32 = -2144862182;
pub const TPM_E_SHA_ERROR : i32 = -2144862181;
pub const TPM_E_FAILEDSELFTEST : i32 = -2144862180;
pub const TPM_E_AUTH2FAIL : i32 = -2144862179;
pub const TPM_E_BADTAG : i32 = -2144862178;
pub const TPM_E_IOERROR : i32 = -2144862177;
pub const TPM_E_ENCRYPT_ERROR : i32 = -2144862176;
pub const TPM_E_DECRYPT_ERROR : i32 = -2144862175;
pub const TPM_E_INVALID_AUTHHANDLE : i32 = -2144862174;
pub const TPM_E_NO_ENDORSEMENT : i32 = -2144862173;
pub const TPM_E_INVALID_KEYUSAGE : i32 = -2144862172;
pub const TPM_E_WRONG_ENTITYTYPE : i32 = -2144862171;
pub const TPM_E_INVALID_POSTINIT : i32 = -2144862170;
pub const TPM_E_INAPPROPRIATE_SIG : i32 = -2144862169;
pub const TPM_E_BAD_KEY_PROPERTY : i32 = -2144862168;
pub const TPM_E_BAD_MIGRATION : i32 = -2144862167;
pub const TPM_E_BAD_SCHEME : i32 = -2144862166;
pub const TPM_E_BAD_DATASIZE : i32 = -2144862165;
pub const TPM_E_BAD_MODE : i32 = -2144862164;
pub const TPM_E_BAD_PRESENCE : i32 = -2144862163;
pub const TPM_E_BAD_VERSION : i32 = -2144862162;
pub const TPM_E_NO_WRAP_TRANSPORT : i32 = -2144862161;
pub const TPM_E_AUDITFAIL_UNSUCCESSFUL : i32 = -2144862160;
pub const TPM_E_AUDITFAIL_SUCCESSFUL : i32 = -2144862159;
pub const TPM_E_NOTRESETABLE : i32 = -2144862158;
pub const TPM_E_NOTLOCAL : i32 = -2144862157;
pub const TPM_E_BAD_TYPE : i32 = -2144862156;
pub const TPM_E_INVALID_RESOURCE : i32 = -2144862155;
pub const TPM_E_NOTFIPS : i32 = -2144862154;
pub const TPM_E_INVALID_FAMILY : i32 = -2144862153;
pub const TPM_E_NO_NV_PERMISSION : i32 = -2144862152;
pub const TPM_E_REQUIRES_SIGN : i32 = -2144862151;
pub const TPM_E_KEY_NOTSUPPORTED : i32 = -2144862150;
pub const TPM_E_AUTH_CONFLICT : i32 = -2144862149;
pub const TPM_E_AREA_LOCKED : i32 = -2144862148;
pub const TPM_E_BAD_LOCALITY : i32 = -2144862147;
pub const TPM_E_READ_ONLY : i32 = -2144862146;
pub const TPM_E_PER_NOWRITE : i32 = -2144862145;
pub const TPM_E_FAMILYCOUNT : i32 = -2144862144;
pub const TPM_E_WRITE_LOCKED : i32 = -2144862143;
pub const TPM_E_BAD_ATTRIBUTES : i32 = -2144862142;
pub const TPM_E_INVALID_STRUCTURE : i32 = -2144862141;
pub const TPM_E_KEY_OWNER_CONTROL : i32 = -2144862140;
pub const TPM_E_BAD_COUNTER : i32 = -2144862139;
pub const TPM_E_NOT_FULLWRITE : i32 = -2144862138;
pub const TPM_E_CONTEXT_GAP : i32 = -2144862137;
pub const TPM_E_MAXNVWRITES : i32 = -2144862136;
pub const TPM_E_NOOPERATOR : i32 = -2144862135;
pub const TPM_E_RESOURCEMISSING : i32 = -2144862134;
pub const TPM_E_DELEGATE_LOCK : i32 = -2144862133;
pub const TPM_E_DELEGATE_FAMILY : i32 = -2144862132;
pub const TPM_E_DELEGATE_ADMIN : i32 = -2144862131;
pub const TPM_E_TRANSPORT_NOTEXCLUSIVE : i32 = -2144862130;
pub const TPM_E_OWNER_CONTROL : i32 = -2144862129;
pub const TPM_E_DAA_RESOURCES : i32 = -2144862128;
pub const TPM_E_DAA_INPUT_DATA0 : i32 = -2144862127;
pub const TPM_E_DAA_INPUT_DATA1 : i32 = -2144862126;
pub const TPM_E_DAA_ISSUER_SETTINGS : i32 = -2144862125;
pub const TPM_E_DAA_TPM_SETTINGS : i32 = -2144862124;
pub const TPM_E_DAA_STAGE : i32 = -2144862123;
pub const TPM_E_DAA_ISSUER_VALIDITY : i32 = -2144862122;
pub const TPM_E_DAA_WRONG_W : i32 = -2144862121;
pub const TPM_E_BAD_HANDLE : i32 = -2144862120;
pub const TPM_E_BAD_DELEGATE : i32 = -2144862119;
pub const TPM_E_BADCONTEXT : i32 = -2144862118;
pub const TPM_E_TOOMANYCONTEXTS : i32 = -2144862117;
pub const TPM_E_MA_TICKET_SIGNATURE : i32 = -2144862116;
pub const TPM_E_MA_DESTINATION : i32 = -2144862115;
pub const TPM_E_MA_SOURCE : i32 = -2144862114;
pub const TPM_E_MA_AUTHORITY : i32 = -2144862113;
pub const TPM_E_PERMANENTEK : i32 = -2144862111;
pub const TPM_E_BAD_SIGNATURE : i32 = -2144862110;
pub const TPM_E_NOCONTEXTSPACE : i32 = -2144862109;
pub const TPM_20_E_ASYMMETRIC : i32 = -2144862079;
pub const TPM_20_E_ATTRIBUTES : i32 = -2144862078;
pub const TPM_20_E_HASH : i32 = -2144862077;
pub const TPM_20_E_VALUE : i32 = -2144862076;
pub const TPM_20_E_HIERARCHY : i32 = -2144862075;
pub const TPM_20_E_KEY_SIZE : i32 = -2144862073;
pub const TPM_20_E_MGF : i32 = -2144862072;
pub const TPM_20_E_MODE : i32 = -2144862071;
pub const TPM_20_E_TYPE : i32 = -2144862070;
pub const TPM_20_E_HANDLE : i32 = -2144862069;
pub const TPM_20_E_KDF : i32 = -2144862068;
pub const TPM_20_E_RANGE : i32 = -2144862067;
pub const TPM_20_E_AUTH_FAIL : i32 = -2144862066;
pub const TPM_20_E_NONCE : i32 = -2144862065;
pub const TPM_20_E_PP : i32 = -2144862064;
pub const TPM_20_E_SCHEME : i32 = -2144862062;
pub const TPM_20_E_SIZE : i32 = -2144862059;
pub const TPM_20_E_SYMMETRIC : i32 = -2144862058;
pub const TPM_20_E_TAG : i32 = -2144862057;
pub const TPM_20_E_SELECTOR : i32 = -2144862056;
pub const TPM_20_E_INSUFFICIENT : i32 = -2144862054;
pub const TPM_20_E_SIGNATURE : i32 = -2144862053;
pub const TPM_20_E_KEY : i32 = -2144862052;
pub const TPM_20_E_POLICY_FAIL : i32 = -2144862051;
pub const TPM_20_E_INTEGRITY : i32 = -2144862049;
pub const TPM_20_E_TICKET : i32 = -2144862048;
pub const TPM_20_E_RESERVED_BITS : i32 = -2144862047;
pub const TPM_20_E_BAD_AUTH : i32 = -2144862046;
pub const TPM_20_E_EXPIRED : i32 = -2144862045;
pub const TPM_20_E_POLICY_CC : i32 = -2144862044;
pub const TPM_20_E_BINDING : i32 = -2144862043;
pub const TPM_20_E_CURVE : i32 = -2144862042;
pub const TPM_20_E_ECC_POINT : i32 = -2144862041;
pub const TPM_20_E_INITIALIZE : i32 = -2144861952;
pub const TPM_20_E_FAILURE : i32 = -2144861951;
pub const TPM_20_E_SEQUENCE : i32 = -2144861949;
pub const TPM_20_E_PRIVATE : i32 = -2144861941;
pub const TPM_20_E_HMAC : i32 = -2144861927;
pub const TPM_20_E_DISABLED : i32 = -2144861920;
pub const TPM_20_E_EXCLUSIVE : i32 = -2144861919;
pub const TPM_20_E_ECC_CURVE : i32 = -2144861917;
pub const TPM_20_E_AUTH_TYPE : i32 = -2144861916;
pub const TPM_20_E_AUTH_MISSING : i32 = -2144861915;
pub const TPM_20_E_POLICY : i32 = -2144861914;
pub const TPM_20_E_PCR : i32 = -2144861913;
pub const TPM_20_E_PCR_CHANGED : i32 = -2144861912;
pub const TPM_20_E_UPGRADE : i32 = -2144861907;
pub const TPM_20_E_TOO_MANY_CONTEXTS : i32 = -2144861906;
pub const TPM_20_E_AUTH_UNAVAILABLE : i32 = -2144861905;
pub const TPM_20_E_REBOOT : i32 = -2144861904;
pub const TPM_20_E_UNBALANCED : i32 = -2144861903;
pub const TPM_20_E_COMMAND_SIZE : i32 = -2144861886;
pub const TPM_20_E_COMMAND_CODE : i32 = -2144861885;
pub const TPM_20_E_AUTHSIZE : i32 = -2144861884;
pub const TPM_20_E_AUTH_CONTEXT : i32 = -2144861883;
pub const TPM_20_E_NV_RANGE : i32 = -2144861882;
pub const TPM_20_E_NV_SIZE : i32 = -2144861881;
pub const TPM_20_E_NV_LOCKED : i32 = -2144861880;
pub const TPM_20_E_NV_AUTHORIZATION : i32 = -2144861879;
pub const TPM_20_E_NV_UNINITIALIZED : i32 = -2144861878;
pub const TPM_20_E_NV_SPACE : i32 = -2144861877;
pub const TPM_20_E_NV_DEFINED : i32 = -2144861876;
pub const TPM_20_E_BAD_CONTEXT : i32 = -2144861872;
pub const TPM_20_E_CPHASH : i32 = -2144861871;
pub const TPM_20_E_PARENT : i32 = -2144861870;
pub const TPM_20_E_NEEDS_TEST : i32 = -2144861869;
pub const TPM_20_E_NO_RESULT : i32 = -2144861868;
pub const TPM_20_E_SENSITIVE : i32 = -2144861867;
pub const TPM_E_COMMAND_BLOCKED : i32 = -2144861184;
pub const TPM_E_INVALID_HANDLE : i32 = -2144861183;
pub const TPM_E_DUPLICATE_VHANDLE : i32 = -2144861182;
pub const TPM_E_EMBEDDED_COMMAND_BLOCKED : i32 = -2144861181;
pub const TPM_E_EMBEDDED_COMMAND_UNSUPPORTED : i32 = -2144861180;
pub const TPM_E_RETRY : i32 = -2144860160;
pub const TPM_E_NEEDS_SELFTEST : i32 = -2144860159;
pub const TPM_E_DOING_SELFTEST : i32 = -2144860158;
pub const TPM_E_DEFEND_LOCK_RUNNING : i32 = -2144860157;
pub const TPM_20_E_CONTEXT_GAP : i32 = -2144859903;
pub const TPM_20_E_OBJECT_MEMORY : i32 = -2144859902;
pub const TPM_20_E_SESSION_MEMORY : i32 = -2144859901;
pub const TPM_20_E_MEMORY : i32 = -2144859900;
pub const TPM_20_E_SESSION_HANDLES : i32 = -2144859899;
pub const TPM_20_E_OBJECT_HANDLES : i32 = -2144859898;
pub const TPM_20_E_LOCALITY : i32 = -2144859897;
pub const TPM_20_E_YIELDED : i32 = -2144859896;
pub const TPM_20_E_CANCELED : i32 = -2144859895;
pub const TPM_20_E_TESTING : i32 = -2144859894;
pub const TPM_20_E_NV_RATE : i32 = -2144859872;
pub const TPM_20_E_LOCKOUT : i32 = -2144859871;
pub const TPM_20_E_RETRY : i32 = -2144859870;
pub const TPM_20_E_NV_UNAVAILABLE : i32 = -2144859869;
pub const TBS_E_INTERNAL_ERROR : i32 = -2144845823;
pub const TBS_E_BAD_PARAMETER : i32 = -2144845822;
pub const TBS_E_INVALID_OUTPUT_POINTER : i32 = -2144845821;
pub const TBS_E_INVALID_CONTEXT : i32 = -2144845820;
pub const TBS_E_INSUFFICIENT_BUFFER : i32 = -2144845819;
pub const TBS_E_IOERROR : i32 = -2144845818;
pub const TBS_E_INVALID_CONTEXT_PARAM : i32 = -2144845817;
pub const TBS_E_SERVICE_NOT_RUNNING : i32 = -2144845816;
pub const TBS_E_TOO_MANY_TBS_CONTEXTS : i32 = -2144845815;
pub const TBS_E_TOO_MANY_RESOURCES : i32 = -2144845814;
pub const TBS_E_SERVICE_START_PENDING : i32 = -2144845813;
pub const TBS_E_PPI_NOT_SUPPORTED : i32 = -2144845812;
pub const TBS_E_COMMAND_CANCELED : i32 = -2144845811;
pub const TBS_E_BUFFER_TOO_LARGE : i32 = -2144845810;
pub const TBS_E_TPM_NOT_FOUND : i32 = -2144845809;
pub const TBS_E_SERVICE_DISABLED : i32 = -2144845808;
pub const TBS_E_NO_EVENT_LOG : i32 = -2144845807;
pub const TBS_E_ACCESS_DENIED : i32 = -2144845806;
pub const TBS_E_PROVISIONING_NOT_ALLOWED : i32 = -2144845805;
pub const TBS_E_PPI_FUNCTION_UNSUPPORTED : i32 = -2144845804;
pub const TBS_E_OWNERAUTH_NOT_FOUND : i32 = -2144845803;
pub const TBS_E_PROVISIONING_INCOMPLETE : i32 = -2144845802;
pub const TPMAPI_E_INVALID_STATE : i32 = -2144796416;
pub const TPMAPI_E_NOT_ENOUGH_DATA : i32 = -2144796415;
pub const TPMAPI_E_TOO_MUCH_DATA : i32 = -2144796414;
pub const TPMAPI_E_INVALID_OUTPUT_POINTER : i32 = -2144796413;
pub const TPMAPI_E_INVALID_PARAMETER : i32 = -2144796412;
pub const TPMAPI_E_OUT_OF_MEMORY : i32 = -2144796411;
pub const TPMAPI_E_BUFFER_TOO_SMALL : i32 = -2144796410;
pub const TPMAPI_E_INTERNAL_ERROR : i32 = -2144796409;
pub const TPMAPI_E_ACCESS_DENIED : i32 = -2144796408;
pub const TPMAPI_E_AUTHORIZATION_FAILED : i32 = -2144796407;
pub const TPMAPI_E_INVALID_CONTEXT_HANDLE : i32 = -2144796406;
pub const TPMAPI_E_TBS_COMMUNICATION_ERROR : i32 = -2144796405;
pub const TPMAPI_E_TPM_COMMAND_ERROR : i32 = -2144796404;
pub const TPMAPI_E_MESSAGE_TOO_LARGE : i32 = -2144796403;
pub const TPMAPI_E_INVALID_ENCODING : i32 = -2144796402;
pub const TPMAPI_E_INVALID_KEY_SIZE : i32 = -2144796401;
pub const TPMAPI_E_ENCRYPTION_FAILED : i32 = -2144796400;
pub const TPMAPI_E_INVALID_KEY_PARAMS : i32 = -2144796399;
pub const TPMAPI_E_INVALID_MIGRATION_AUTHORIZATION_BLOB : i32 = -2144796398;
pub const TPMAPI_E_INVALID_PCR_INDEX : i32 = -2144796397;
pub const TPMAPI_E_INVALID_DELEGATE_BLOB : i32 = -2144796396;
pub const TPMAPI_E_INVALID_CONTEXT_PARAMS : i32 = -2144796395;
pub const TPMAPI_E_INVALID_KEY_BLOB : i32 = -2144796394;
pub const TPMAPI_E_INVALID_PCR_DATA : i32 = -2144796393;
pub const TPMAPI_E_INVALID_OWNER_AUTH : i32 = -2144796392;
pub const TPMAPI_E_FIPS_RNG_CHECK_FAILED : i32 = -2144796391;
pub const TPMAPI_E_EMPTY_TCG_LOG : i32 = -2144796390;
pub const TPMAPI_E_INVALID_TCG_LOG_ENTRY : i32 = -2144796389;
pub const TPMAPI_E_TCG_SEPARATOR_ABSENT : i32 = -2144796388;
pub const TPMAPI_E_TCG_INVALID_DIGEST_ENTRY : i32 = -2144796387;
pub const TPMAPI_E_POLICY_DENIES_OPERATION : i32 = -2144796386;
pub const TPMAPI_E_NV_BITS_NOT_DEFINED : i32 = -2144796385;
pub const TPMAPI_E_NV_BITS_NOT_READY : i32 = -2144796384;
pub const TPMAPI_E_SEALING_KEY_NOT_AVAILABLE : i32 = -2144796383;
pub const TPMAPI_E_NO_AUTHORIZATION_CHAIN_FOUND : i32 = -2144796382;
pub const TPMAPI_E_SVN_COUNTER_NOT_AVAILABLE : i32 = -2144796381;
pub const TPMAPI_E_OWNER_AUTH_NOT_NULL : i32 = -2144796380;
pub const TPMAPI_E_ENDORSEMENT_AUTH_NOT_NULL : i32 = -2144796379;
pub const TPMAPI_E_AUTHORIZATION_REVOKED : i32 = -2144796378;
pub const TPMAPI_E_MALFORMED_AUTHORIZATION_KEY : i32 = -2144796377;
pub const TPMAPI_E_AUTHORIZING_KEY_NOT_SUPPORTED : i32 = -2144796376;
pub const TPMAPI_E_INVALID_AUTHORIZATION_SIGNATURE : i32 = -2144796375;
pub const TPMAPI_E_MALFORMED_AUTHORIZATION_POLICY : i32 = -2144796374;
pub const TPMAPI_E_MALFORMED_AUTHORIZATION_OTHER : i32 = -2144796373;
pub const TPMAPI_E_SEALING_KEY_CHANGED : i32 = -2144796372;
pub const TPMAPI_E_INVALID_TPM_VERSION : i32 = -2144796371;
pub const TPMAPI_E_INVALID_POLICYAUTH_BLOB_TYPE : i32 = -2144796370;
pub const TBSIMP_E_BUFFER_TOO_SMALL : i32 = -2144796160;
pub const TBSIMP_E_CLEANUP_FAILED : i32 = -2144796159;
pub const TBSIMP_E_INVALID_CONTEXT_HANDLE : i32 = -2144796158;
pub const TBSIMP_E_INVALID_CONTEXT_PARAM : i32 = -2144796157;
pub const TBSIMP_E_TPM_ERROR : i32 = -2144796156;
pub const TBSIMP_E_HASH_BAD_KEY : i32 = -2144796155;
pub const TBSIMP_E_DUPLICATE_VHANDLE : i32 = -2144796154;
pub const TBSIMP_E_INVALID_OUTPUT_POINTER : i32 = -2144796153;
pub const TBSIMP_E_INVALID_PARAMETER : i32 = -2144796152;
pub const TBSIMP_E_RPC_INIT_FAILED : i32 = -2144796151;
pub const TBSIMP_E_SCHEDULER_NOT_RUNNING : i32 = -2144796150;
pub const TBSIMP_E_COMMAND_CANCELED : i32 = -2144796149;
pub const TBSIMP_E_OUT_OF_MEMORY : i32 = -2144796148;
pub const TBSIMP_E_LIST_NO_MORE_ITEMS : i32 = -2144796147;
pub const TBSIMP_E_LIST_NOT_FOUND : i32 = -2144796146;
pub const TBSIMP_E_NOT_ENOUGH_SPACE : i32 = -2144796145;
pub const TBSIMP_E_NOT_ENOUGH_TPM_CONTEXTS : i32 = -2144796144;
pub const TBSIMP_E_COMMAND_FAILED : i32 = -2144796143;
pub const TBSIMP_E_UNKNOWN_ORDINAL : i32 = -2144796142;
pub const TBSIMP_E_RESOURCE_EXPIRED : i32 = -2144796141;
pub const TBSIMP_E_INVALID_RESOURCE : i32 = -2144796140;
pub const TBSIMP_E_NOTHING_TO_UNLOAD : i32 = -2144796139;
pub const TBSIMP_E_HASH_TABLE_FULL : i32 = -2144796138;
pub const TBSIMP_E_TOO_MANY_TBS_CONTEXTS : i32 = -2144796137;
pub const TBSIMP_E_TOO_MANY_RESOURCES : i32 = -2144796136;
pub const TBSIMP_E_PPI_NOT_SUPPORTED : i32 = -2144796135;
pub const TBSIMP_E_TPM_INCOMPATIBLE : i32 = -2144796134;
pub const TBSIMP_E_NO_EVENT_LOG : i32 = -2144796133;
pub const TPM_E_PPI_ACPI_FAILURE : i32 = -2144795904;
pub const TPM_E_PPI_USER_ABORT : i32 = -2144795903;
pub const TPM_E_PPI_BIOS_FAILURE : i32 = -2144795902;
pub const TPM_E_PPI_NOT_SUPPORTED : i32 = -2144795901;
pub const TPM_E_PPI_BLOCKED_IN_BIOS : i32 = -2144795900;
pub const TPM_E_PCP_ERROR_MASK : i32 = -2144795648;
pub const TPM_E_PCP_DEVICE_NOT_READY : i32 = -2144795647;
pub const TPM_E_PCP_INVALID_HANDLE : i32 = -2144795646;
pub const TPM_E_PCP_INVALID_PARAMETER : i32 = -2144795645;
pub const TPM_E_PCP_FLAG_NOT_SUPPORTED : i32 = -2144795644;
pub const TPM_E_PCP_NOT_SUPPORTED : i32 = -2144795643;
pub const TPM_E_PCP_BUFFER_TOO_SMALL : i32 = -2144795642;
pub const TPM_E_PCP_INTERNAL_ERROR : i32 = -2144795641;
pub const TPM_E_PCP_AUTHENTICATION_FAILED : i32 = -2144795640;
pub const TPM_E_PCP_AUTHENTICATION_IGNORED : i32 = -2144795639;
pub const TPM_E_PCP_POLICY_NOT_FOUND : i32 = -2144795638;
pub const TPM_E_PCP_PROFILE_NOT_FOUND : i32 = -2144795637;
pub const TPM_E_PCP_VALIDATION_FAILED : i32 = -2144795636;
pub const TPM_E_PCP_WRONG_PARENT : i32 = -2144795634;
pub const TPM_E_KEY_NOT_LOADED : i32 = -2144795633;
pub const TPM_E_NO_KEY_CERTIFICATION : i32 = -2144795632;
pub const TPM_E_KEY_NOT_FINALIZED : i32 = -2144795631;
pub const TPM_E_ATTESTATION_CHALLENGE_NOT_SET : i32 = -2144795630;
pub const TPM_E_NOT_PCR_BOUND : i32 = -2144795629;
pub const TPM_E_KEY_ALREADY_FINALIZED : i32 = -2144795628;
pub const TPM_E_KEY_USAGE_POLICY_NOT_SUPPORTED : i32 = -2144795627;
pub const TPM_E_KEY_USAGE_POLICY_INVALID : i32 = -2144795626;
pub const TPM_E_SOFT_KEY_ERROR : i32 = -2144795625;
pub const TPM_E_KEY_NOT_AUTHENTICATED : i32 = -2144795624;
pub const TPM_E_PCP_KEY_NOT_AIK : i32 = -2144795623;
pub const TPM_E_KEY_NOT_SIGNING_KEY : i32 = -2144795622;
pub const TPM_E_LOCKED_OUT : i32 = -2144795621;
pub const TPM_E_CLAIM_TYPE_NOT_SUPPORTED : i32 = -2144795620;
pub const TPM_E_VERSION_NOT_SUPPORTED : i32 = -2144795619;
pub const TPM_E_BUFFER_LENGTH_MISMATCH : i32 = -2144795618;
pub const TPM_E_PCP_IFX_RSA_KEY_CREATION_BLOCKED : i32 = -2144795617;
pub const TPM_E_PCP_TICKET_MISSING : i32 = -2144795616;
pub const TPM_E_PCP_RAW_POLICY_NOT_SUPPORTED : i32 = -2144795615;
pub const TPM_E_PCP_KEY_HANDLE_INVALIDATED : i32 = -2144795614;
pub const TPM_E_PCP_UNSUPPORTED_PSS_SALT : i32 = 1076429859;
pub const TPM_E_PCP_PLATFORM_CLAIM_MAY_BE_OUTDATED : i32 = 1076429860;
pub const TPM_E_PCP_PLATFORM_CLAIM_OUTDATED : i32 = 1076429861;
pub const TPM_E_PCP_PLATFORM_CLAIM_REBOOT : i32 = 1076429862;
pub const TPM_E_ZERO_EXHAUST_ENABLED : i32 = -2144795392;
pub const TPM_E_PROVISIONING_INCOMPLETE : i32 = -2144795136;
pub const TPM_E_INVALID_OWNER_AUTH : i32 = -2144795135;
pub const TPM_E_TOO_MUCH_DATA : i32 = -2144795134;
pub const PLA_E_DCS_NOT_FOUND : i32 = -2144337918;
pub const PLA_E_DCS_IN_USE : i32 = -2144337750;
pub const PLA_E_TOO_MANY_FOLDERS : i32 = -2144337851;
pub const PLA_E_NO_MIN_DISK : i32 = -2144337808;
pub const PLA_E_DCS_ALREADY_EXISTS : i32 = -2144337737;
pub const PLA_S_PROPERTY_IGNORED : i32 = 3145984;
pub const PLA_E_PROPERTY_CONFLICT : i32 = -2144337663;
pub const PLA_E_DCS_SINGLETON_REQUIRED : i32 = -2144337662;
pub const PLA_E_CREDENTIALS_REQUIRED : i32 = -2144337661;
pub const PLA_E_DCS_NOT_RUNNING : i32 = -2144337660;
pub const PLA_E_CONFLICT_INCL_EXCL_API : i32 = -2144337659;
pub const PLA_E_NETWORK_EXE_NOT_VALID : i32 = -2144337658;
pub const PLA_E_EXE_ALREADY_CONFIGURED : i32 = -2144337657;
pub const PLA_E_EXE_PATH_NOT_VALID : i32 = -2144337656;
pub const PLA_E_DC_ALREADY_EXISTS : i32 = -2144337655;
pub const PLA_E_DCS_START_WAIT_TIMEOUT : i32 = -2144337654;
pub const PLA_E_DC_START_WAIT_TIMEOUT : i32 = -2144337653;
pub const PLA_E_REPORT_WAIT_TIMEOUT : i32 = -2144337652;
pub const PLA_E_NO_DUPLICATES : i32 = -2144337651;
pub const PLA_E_EXE_FULL_PATH_REQUIRED : i32 = -2144337650;
pub const PLA_E_INVALID_SESSION_NAME : i32 = -2144337649;
pub const PLA_E_PLA_CHANNEL_NOT_ENABLED : i32 = -2144337648;
pub const PLA_E_TASKSCHED_CHANNEL_NOT_ENABLED : i32 = -2144337647;
pub const PLA_E_RULES_MANAGER_FAILED : i32 = -2144337646;
pub const PLA_E_CABAPI_FAILURE : i32 = -2144337645;
pub const FVE_E_LOCKED_VOLUME : i32 = -2144272384;
pub const FVE_E_NOT_ENCRYPTED : i32 = -2144272383;
pub const FVE_E_NO_TPM_BIOS : i32 = -2144272382;
pub const FVE_E_NO_MBR_METRIC : i32 = -2144272381;
pub const FVE_E_NO_BOOTSECTOR_METRIC : i32 = -2144272380;
pub const FVE_E_NO_BOOTMGR_METRIC : i32 = -2144272379;
pub const FVE_E_WRONG_BOOTMGR : i32 = -2144272378;
pub const FVE_E_SECURE_KEY_REQUIRED : i32 = -2144272377;
pub const FVE_E_NOT_ACTIVATED : i32 = -2144272376;
pub const FVE_E_ACTION_NOT_ALLOWED : i32 = -2144272375;
pub const FVE_E_AD_SCHEMA_NOT_INSTALLED : i32 = -2144272374;
pub const FVE_E_AD_INVALID_DATATYPE : i32 = -2144272373;
pub const FVE_E_AD_INVALID_DATASIZE : i32 = -2144272372;
pub const FVE_E_AD_NO_VALUES : i32 = -2144272371;
pub const FVE_E_AD_ATTR_NOT_SET : i32 = -2144272370;
pub const FVE_E_AD_GUID_NOT_FOUND : i32 = -2144272369;
pub const FVE_E_BAD_INFORMATION : i32 = -2144272368;
pub const FVE_E_TOO_SMALL : i32 = -2144272367;
pub const FVE_E_SYSTEM_VOLUME : i32 = -2144272366;
pub const FVE_E_FAILED_WRONG_FS : i32 = -2144272365;
pub const FVE_E_BAD_PARTITION_SIZE : i32 = -2144272364;
pub const FVE_E_NOT_SUPPORTED : i32 = -2144272363;
pub const FVE_E_BAD_DATA : i32 = -2144272362;
pub const FVE_E_VOLUME_NOT_BOUND : i32 = -2144272361;
pub const FVE_E_TPM_NOT_OWNED : i32 = -2144272360;
pub const FVE_E_NOT_DATA_VOLUME : i32 = -2144272359;
pub const FVE_E_AD_INSUFFICIENT_BUFFER : i32 = -2144272358;
pub const FVE_E_CONV_READ : i32 = -2144272357;
pub const FVE_E_CONV_WRITE : i32 = -2144272356;
pub const FVE_E_KEY_REQUIRED : i32 = -2144272355;
pub const FVE_E_CLUSTERING_NOT_SUPPORTED : i32 = -2144272354;
pub const FVE_E_VOLUME_BOUND_ALREADY : i32 = -2144272353;
pub const FVE_E_OS_NOT_PROTECTED : i32 = -2144272352;
pub const FVE_E_PROTECTION_DISABLED : i32 = -2144272351;
pub const FVE_E_RECOVERY_KEY_REQUIRED : i32 = -2144272350;
pub const FVE_E_FOREIGN_VOLUME : i32 = -2144272349;
pub const FVE_E_OVERLAPPED_UPDATE : i32 = -2144272348;
pub const FVE_E_TPM_SRK_AUTH_NOT_ZERO : i32 = -2144272347;
pub const FVE_E_FAILED_SECTOR_SIZE : i32 = -2144272346;
pub const FVE_E_FAILED_AUTHENTICATION : i32 = -2144272345;
pub const FVE_E_NOT_OS_VOLUME : i32 = -2144272344;
pub const FVE_E_AUTOUNLOCK_ENABLED : i32 = -2144272343;
pub const FVE_E_WRONG_BOOTSECTOR : i32 = -2144272342;
pub const FVE_E_WRONG_SYSTEM_FS : i32 = -2144272341;
pub const FVE_E_POLICY_PASSWORD_REQUIRED : i32 = -2144272340;
pub const FVE_E_CANNOT_SET_FVEK_ENCRYPTED : i32 = -2144272339;
pub const FVE_E_CANNOT_ENCRYPT_NO_KEY : i32 = -2144272338;
pub const FVE_E_BOOTABLE_CDDVD : i32 = -2144272336;
pub const FVE_E_PROTECTOR_EXISTS : i32 = -2144272335;
pub const FVE_E_RELATIVE_PATH : i32 = -2144272334;
pub const FVE_E_PROTECTOR_NOT_FOUND : i32 = -2144272333;
pub const FVE_E_INVALID_KEY_FORMAT : i32 = -2144272332;
pub const FVE_E_INVALID_PASSWORD_FORMAT : i32 = -2144272331;
pub const FVE_E_FIPS_RNG_CHECK_FAILED : i32 = -2144272330;
pub const FVE_E_FIPS_PREVENTS_RECOVERY_PASSWORD : i32 = -2144272329;
pub const FVE_E_FIPS_PREVENTS_EXTERNAL_KEY_EXPORT : i32 = -2144272328;
pub const FVE_E_NOT_DECRYPTED : i32 = -2144272327;
pub const FVE_E_INVALID_PROTECTOR_TYPE : i32 = -2144272326;
pub const FVE_E_NO_PROTECTORS_TO_TEST : i32 = -2144272325;
pub const FVE_E_KEYFILE_NOT_FOUND : i32 = -2144272324;
pub const FVE_E_KEYFILE_INVALID : i32 = -2144272323;
pub const FVE_E_KEYFILE_NO_VMK : i32 = -2144272322;
pub const FVE_E_TPM_DISABLED : i32 = -2144272321;
pub const FVE_E_NOT_ALLOWED_IN_SAFE_MODE : i32 = -2144272320;
pub const FVE_E_TPM_INVALID_PCR : i32 = -2144272319;
pub const FVE_E_TPM_NO_VMK : i32 = -2144272318;
pub const FVE_E_PIN_INVALID : i32 = -2144272317;
pub const FVE_E_AUTH_INVALID_APPLICATION : i32 = -2144272316;
pub const FVE_E_AUTH_INVALID_CONFIG : i32 = -2144272315;
pub const FVE_E_FIPS_DISABLE_PROTECTION_NOT_ALLOWED : i32 = -2144272314;
pub const FVE_E_FS_NOT_EXTENDED : i32 = -2144272313;
pub const FVE_E_FIRMWARE_TYPE_NOT_SUPPORTED : i32 = -2144272312;
pub const FVE_E_NO_LICENSE : i32 = -2144272311;
pub const FVE_E_NOT_ON_STACK : i32 = -2144272310;
pub const FVE_E_FS_MOUNTED : i32 = -2144272309;
pub const FVE_E_TOKEN_NOT_IMPERSONATED : i32 = -2144272308;
pub const FVE_E_DRY_RUN_FAILED : i32 = -2144272307;
pub const FVE_E_REBOOT_REQUIRED : i32 = -2144272306;
pub const FVE_E_DEBUGGER_ENABLED : i32 = -2144272305;
pub const FVE_E_RAW_ACCESS : i32 = -2144272304;
pub const FVE_E_RAW_BLOCKED : i32 = -2144272303;
pub const FVE_E_BCD_APPLICATIONS_PATH_INCORRECT : i32 = -2144272302;
pub const FVE_E_NOT_ALLOWED_IN_VERSION : i32 = -2144272301;
pub const FVE_E_NO_AUTOUNLOCK_MASTER_KEY : i32 = -2144272300;
pub const FVE_E_MOR_FAILED : i32 = -2144272299;
pub const FVE_E_HIDDEN_VOLUME : i32 = -2144272298;
pub const FVE_E_TRANSIENT_STATE : i32 = -2144272297;
pub const FVE_E_PUBKEY_NOT_ALLOWED : i32 = -2144272296;
pub const FVE_E_VOLUME_HANDLE_OPEN : i32 = -2144272295;
pub const FVE_E_NO_FEATURE_LICENSE : i32 = -2144272294;
pub const FVE_E_INVALID_STARTUP_OPTIONS : i32 = -2144272293;
pub const FVE_E_POLICY_RECOVERY_PASSWORD_NOT_ALLOWED : i32 = -2144272292;
pub const FVE_E_POLICY_RECOVERY_PASSWORD_REQUIRED : i32 = -2144272291;
pub const FVE_E_POLICY_RECOVERY_KEY_NOT_ALLOWED : i32 = -2144272290;
pub const FVE_E_POLICY_RECOVERY_KEY_REQUIRED : i32 = -2144272289;
pub const FVE_E_POLICY_STARTUP_PIN_NOT_ALLOWED : i32 = -2144272288;
pub const FVE_E_POLICY_STARTUP_PIN_REQUIRED : i32 = -2144272287;
pub const FVE_E_POLICY_STARTUP_KEY_NOT_ALLOWED : i32 = -2144272286;
pub const FVE_E_POLICY_STARTUP_KEY_REQUIRED : i32 = -2144272285;
pub const FVE_E_POLICY_STARTUP_PIN_KEY_NOT_ALLOWED : i32 = -2144272284;
pub const FVE_E_POLICY_STARTUP_PIN_KEY_REQUIRED : i32 = -2144272283;
pub const FVE_E_POLICY_STARTUP_TPM_NOT_ALLOWED : i32 = -2144272282;
pub const FVE_E_POLICY_STARTUP_TPM_REQUIRED : i32 = -2144272281;
pub const FVE_E_POLICY_INVALID_PIN_LENGTH : i32 = -2144272280;
pub const FVE_E_KEY_PROTECTOR_NOT_SUPPORTED : i32 = -2144272279;
pub const FVE_E_POLICY_PASSPHRASE_NOT_ALLOWED : i32 = -2144272278;
pub const FVE_E_POLICY_PASSPHRASE_REQUIRED : i32 = -2144272277;
pub const FVE_E_FIPS_PREVENTS_PASSPHRASE : i32 = -2144272276;
pub const FVE_E_OS_VOLUME_PASSPHRASE_NOT_ALLOWED : i32 = -2144272275;
pub const FVE_E_INVALID_BITLOCKER_OID : i32 = -2144272274;
pub const FVE_E_VOLUME_TOO_SMALL : i32 = -2144272273;
pub const FVE_E_DV_NOT_SUPPORTED_ON_FS : i32 = -2144272272;
pub const FVE_E_DV_NOT_ALLOWED_BY_GP : i32 = -2144272271;
pub const FVE_E_POLICY_USER_CERTIFICATE_NOT_ALLOWED : i32 = -2144272270;
pub const FVE_E_POLICY_USER_CERTIFICATE_REQUIRED : i32 = -2144272269;
pub const FVE_E_POLICY_USER_CERT_MUST_BE_HW : i32 = -2144272268;
pub const FVE_E_POLICY_USER_CONFIGURE_FDV_AUTOUNLOCK_NOT_ALLOWED : i32 = -2144272267;
pub const FVE_E_POLICY_USER_CONFIGURE_RDV_AUTOUNLOCK_NOT_ALLOWED : i32 = -2144272266;
pub const FVE_E_POLICY_USER_CONFIGURE_RDV_NOT_ALLOWED : i32 = -2144272265;
pub const FVE_E_POLICY_USER_ENABLE_RDV_NOT_ALLOWED : i32 = -2144272264;
pub const FVE_E_POLICY_USER_DISABLE_RDV_NOT_ALLOWED : i32 = -2144272263;
pub const FVE_E_POLICY_INVALID_PASSPHRASE_LENGTH : i32 = -2144272256;
pub const FVE_E_POLICY_PASSPHRASE_TOO_SIMPLE : i32 = -2144272255;
pub const FVE_E_RECOVERY_PARTITION : i32 = -2144272254;
pub const FVE_E_POLICY_CONFLICT_FDV_RK_OFF_AUK_ON : i32 = -2144272253;
pub const FVE_E_POLICY_CONFLICT_RDV_RK_OFF_AUK_ON : i32 = -2144272252;
pub const FVE_E_NON_BITLOCKER_OID : i32 = -2144272251;
pub const FVE_E_POLICY_PROHIBITS_SELFSIGNED : i32 = -2144272250;
pub const FVE_E_POLICY_CONFLICT_RO_AND_STARTUP_KEY_REQUIRED : i32 = -2144272249;
pub const FVE_E_CONV_RECOVERY_FAILED : i32 = -2144272248;
pub const FVE_E_VIRTUALIZED_SPACE_TOO_BIG : i32 = -2144272247;
pub const FVE_E_POLICY_CONFLICT_OSV_RP_OFF_ADB_ON : i32 = -2144272240;
pub const FVE_E_POLICY_CONFLICT_FDV_RP_OFF_ADB_ON : i32 = -2144272239;
pub const FVE_E_POLICY_CONFLICT_RDV_RP_OFF_ADB_ON : i32 = -2144272238;
pub const FVE_E_NON_BITLOCKER_KU : i32 = -2144272237;
pub const FVE_E_PRIVATEKEY_AUTH_FAILED : i32 = -2144272236;
pub const FVE_E_REMOVAL_OF_DRA_FAILED : i32 = -2144272235;
pub const FVE_E_OPERATION_NOT_SUPPORTED_ON_VISTA_VOLUME : i32 = -2144272234;
pub const FVE_E_CANT_LOCK_AUTOUNLOCK_ENABLED_VOLUME : i32 = -2144272233;
pub const FVE_E_FIPS_HASH_KDF_NOT_ALLOWED : i32 = -2144272232;
pub const FVE_E_ENH_PIN_INVALID : i32 = -2144272231;
pub const FVE_E_INVALID_PIN_CHARS : i32 = -2144272230;
pub const FVE_E_INVALID_DATUM_TYPE : i32 = -2144272229;
pub const FVE_E_EFI_ONLY : i32 = -2144272228;
pub const FVE_E_MULTIPLE_NKP_CERTS : i32 = -2144272227;
pub const FVE_E_REMOVAL_OF_NKP_FAILED : i32 = -2144272226;
pub const FVE_E_INVALID_NKP_CERT : i32 = -2144272225;
pub const FVE_E_NO_EXISTING_PIN : i32 = -2144272224;
pub const FVE_E_PROTECTOR_CHANGE_PIN_MISMATCH : i32 = -2144272223;
pub const FVE_E_PIN_PROTECTOR_CHANGE_BY_STD_USER_DISALLOWED : i32 = -2144272222;
pub const FVE_E_PROTECTOR_CHANGE_MAX_PIN_CHANGE_ATTEMPTS_REACHED : i32 = -2144272221;
pub const FVE_E_POLICY_PASSPHRASE_REQUIRES_ASCII : i32 = -2144272220;
pub const FVE_E_FULL_ENCRYPTION_NOT_ALLOWED_ON_TP_STORAGE : i32 = -2144272219;
pub const FVE_E_WIPE_NOT_ALLOWED_ON_TP_STORAGE : i32 = -2144272218;
pub const FVE_E_KEY_LENGTH_NOT_SUPPORTED_BY_EDRIVE : i32 = -2144272217;
pub const FVE_E_NO_EXISTING_PASSPHRASE : i32 = -2144272216;
pub const FVE_E_PROTECTOR_CHANGE_PASSPHRASE_MISMATCH : i32 = -2144272215;
pub const FVE_E_PASSPHRASE_TOO_LONG : i32 = -2144272214;
pub const FVE_E_NO_PASSPHRASE_WITH_TPM : i32 = -2144272213;
pub const FVE_E_NO_TPM_WITH_PASSPHRASE : i32 = -2144272212;
pub const FVE_E_NOT_ALLOWED_ON_CSV_STACK : i32 = -2144272211;
pub const FVE_E_NOT_ALLOWED_ON_CLUSTER : i32 = -2144272210;
pub const FVE_E_EDRIVE_NO_FAILOVER_TO_SW : i32 = -2144272209;
pub const FVE_E_EDRIVE_BAND_IN_USE : i32 = -2144272208;
pub const FVE_E_EDRIVE_DISALLOWED_BY_GP : i32 = -2144272207;
pub const FVE_E_EDRIVE_INCOMPATIBLE_VOLUME : i32 = -2144272206;
pub const FVE_E_NOT_ALLOWED_TO_UPGRADE_WHILE_CONVERTING : i32 = -2144272205;
pub const FVE_E_EDRIVE_DV_NOT_SUPPORTED : i32 = -2144272204;
pub const FVE_E_NO_PREBOOT_KEYBOARD_DETECTED : i32 = -2144272203;
pub const FVE_E_NO_PREBOOT_KEYBOARD_OR_WINRE_DETECTED : i32 = -2144272202;
pub const FVE_E_POLICY_REQUIRES_STARTUP_PIN_ON_TOUCH_DEVICE : i32 = -2144272201;
pub const FVE_E_POLICY_REQUIRES_RECOVERY_PASSWORD_ON_TOUCH_DEVICE : i32 = -2144272200;
pub const FVE_E_WIPE_CANCEL_NOT_APPLICABLE : i32 = -2144272199;
pub const FVE_E_SECUREBOOT_DISABLED : i32 = -2144272198;
pub const FVE_E_SECUREBOOT_CONFIGURATION_INVALID : i32 = -2144272197;
pub const FVE_E_EDRIVE_DRY_RUN_FAILED : i32 = -2144272196;
pub const FVE_E_SHADOW_COPY_PRESENT : i32 = -2144272195;
pub const FVE_E_POLICY_INVALID_ENHANCED_BCD_SETTINGS : i32 = -2144272194;
pub const FVE_E_EDRIVE_INCOMPATIBLE_FIRMWARE : i32 = -2144272193;
pub const FVE_E_PROTECTOR_CHANGE_MAX_PASSPHRASE_CHANGE_ATTEMPTS_REACHED : i32 = -2144272192;
pub const FVE_E_PASSPHRASE_PROTECTOR_CHANGE_BY_STD_USER_DISALLOWED : i32 = -2144272191;
pub const FVE_E_LIVEID_ACCOUNT_SUSPENDED : i32 = -2144272190;
pub const FVE_E_LIVEID_ACCOUNT_BLOCKED : i32 = -2144272189;
pub const FVE_E_NOT_PROVISIONED_ON_ALL_VOLUMES : i32 = -2144272188;
pub const FVE_E_DE_FIXED_DATA_NOT_SUPPORTED : i32 = -2144272187;
pub const FVE_E_DE_HARDWARE_NOT_COMPLIANT : i32 = -2144272186;
pub const FVE_E_DE_WINRE_NOT_CONFIGURED : i32 = -2144272185;
pub const FVE_E_DE_PROTECTION_SUSPENDED : i32 = -2144272184;
pub const FVE_E_DE_OS_VOLUME_NOT_PROTECTED : i32 = -2144272183;
pub const FVE_E_DE_DEVICE_LOCKEDOUT : i32 = -2144272182;
pub const FVE_E_DE_PROTECTION_NOT_YET_ENABLED : i32 = -2144272181;
pub const FVE_E_INVALID_PIN_CHARS_DETAILED : i32 = -2144272180;
pub const FVE_E_DEVICE_LOCKOUT_COUNTER_UNAVAILABLE : i32 = -2144272179;
pub const FVE_E_DEVICELOCKOUT_COUNTER_MISMATCH : i32 = -2144272178;
pub const FVE_E_BUFFER_TOO_LARGE : i32 = -2144272177;
pub const FVE_E_NO_SUCH_CAPABILITY_ON_TARGET : i32 = -2144272176;
pub const FVE_E_DE_PREVENTED_FOR_OS : i32 = -2144272175;
pub const FVE_E_DE_VOLUME_OPTED_OUT : i32 = -2144272174;
pub const FVE_E_DE_VOLUME_NOT_SUPPORTED : i32 = -2144272173;
pub const FVE_E_EOW_NOT_SUPPORTED_IN_VERSION : i32 = -2144272172;
pub const FVE_E_ADBACKUP_NOT_ENABLED : i32 = -2144272171;
pub const FVE_E_VOLUME_EXTEND_PREVENTS_EOW_DECRYPT : i32 = -2144272170;
pub const FVE_E_NOT_DE_VOLUME : i32 = -2144272169;
pub const FVE_E_PROTECTION_CANNOT_BE_DISABLED : i32 = -2144272168;
pub const FVE_E_OSV_KSR_NOT_ALLOWED : i32 = -2144272167;
pub const FVE_E_AD_BACKUP_REQUIRED_POLICY_NOT_SET_OS_DRIVE : i32 = -2144272166;
pub const FVE_E_AD_BACKUP_REQUIRED_POLICY_NOT_SET_FIXED_DRIVE : i32 = -2144272165;
pub const FVE_E_AD_BACKUP_REQUIRED_POLICY_NOT_SET_REMOVABLE_DRIVE : i32 = -2144272164;
pub const FVE_E_KEY_ROTATION_NOT_SUPPORTED : i32 = -2144272163;
pub const FVE_E_EXECUTE_REQUEST_SENT_TOO_SOON : i32 = -2144272162;
pub const FVE_E_KEY_ROTATION_NOT_ENABLED : i32 = -2144272161;
pub const FVE_E_DEVICE_NOT_JOINED : i32 = -2144272160;
pub const FVE_E_AAD_ENDPOINT_BUSY : i32 = -2144272159;
pub const FWP_E_CALLOUT_NOT_FOUND : i32 = -2144206847;
pub const FWP_E_CONDITION_NOT_FOUND : i32 = -2144206846;
pub const FWP_E_FILTER_NOT_FOUND : i32 = -2144206845;
pub const FWP_E_LAYER_NOT_FOUND : i32 = -2144206844;
pub const FWP_E_PROVIDER_NOT_FOUND : i32 = -2144206843;
pub const FWP_E_PROVIDER_CONTEXT_NOT_FOUND : i32 = -2144206842;
pub const FWP_E_SUBLAYER_NOT_FOUND : i32 = -2144206841;
pub const FWP_E_NOT_FOUND : i32 = -2144206840;
pub const FWP_E_ALREADY_EXISTS : i32 = -2144206839;
pub const FWP_E_IN_USE : i32 = -2144206838;
pub const FWP_E_DYNAMIC_SESSION_IN_PROGRESS : i32 = -2144206837;
pub const FWP_E_WRONG_SESSION : i32 = -2144206836;
pub const FWP_E_NO_TXN_IN_PROGRESS : i32 = -2144206835;
pub const FWP_E_TXN_IN_PROGRESS : i32 = -2144206834;
pub const FWP_E_TXN_ABORTED : i32 = -2144206833;
pub const FWP_E_SESSION_ABORTED : i32 = -2144206832;
pub const FWP_E_INCOMPATIBLE_TXN : i32 = -2144206831;
pub const FWP_E_TIMEOUT : i32 = -2144206830;
pub const FWP_E_NET_EVENTS_DISABLED : i32 = -2144206829;
pub const FWP_E_INCOMPATIBLE_LAYER : i32 = -2144206828;
pub const FWP_E_KM_CLIENTS_ONLY : i32 = -2144206827;
pub const FWP_E_LIFETIME_MISMATCH : i32 = -2144206826;
pub const FWP_E_BUILTIN_OBJECT : i32 = -2144206825;
pub const FWP_E_TOO_MANY_CALLOUTS : i32 = -2144206824;
pub const FWP_E_NOTIFICATION_DROPPED : i32 = -2144206823;
pub const FWP_E_TRAFFIC_MISMATCH : i32 = -2144206822;
pub const FWP_E_INCOMPATIBLE_SA_STATE : i32 = -2144206821;
pub const FWP_E_NULL_POINTER : i32 = -2144206820;
pub const FWP_E_INVALID_ENUMERATOR : i32 = -2144206819;
pub const FWP_E_INVALID_FLAGS : i32 = -2144206818;
pub const FWP_E_INVALID_NET_MASK : i32 = -2144206817;
pub const FWP_E_INVALID_RANGE : i32 = -2144206816;
pub const FWP_E_INVALID_INTERVAL : i32 = -2144206815;
pub const FWP_E_ZERO_LENGTH_ARRAY : i32 = -2144206814;
pub const FWP_E_NULL_DISPLAY_NAME : i32 = -2144206813;
pub const FWP_E_INVALID_ACTION_TYPE : i32 = -2144206812;
pub const FWP_E_INVALID_WEIGHT : i32 = -2144206811;
pub const FWP_E_MATCH_TYPE_MISMATCH : i32 = -2144206810;
pub const FWP_E_TYPE_MISMATCH : i32 = -2144206809;
pub const FWP_E_OUT_OF_BOUNDS : i32 = -2144206808;
pub const FWP_E_RESERVED : i32 = -2144206807;
pub const FWP_E_DUPLICATE_CONDITION : i32 = -2144206806;
pub const FWP_E_DUPLICATE_KEYMOD : i32 = -2144206805;
pub const FWP_E_ACTION_INCOMPATIBLE_WITH_LAYER : i32 = -2144206804;
pub const FWP_E_ACTION_INCOMPATIBLE_WITH_SUBLAYER : i32 = -2144206803;
pub const FWP_E_CONTEXT_INCOMPATIBLE_WITH_LAYER : i32 = -2144206802;
pub const FWP_E_CONTEXT_INCOMPATIBLE_WITH_CALLOUT : i32 = -2144206801;
pub const FWP_E_INCOMPATIBLE_AUTH_METHOD : i32 = -2144206800;
pub const FWP_E_INCOMPATIBLE_DH_GROUP : i32 = -2144206799;
pub const FWP_E_EM_NOT_SUPPORTED : i32 = -2144206798;
pub const FWP_E_NEVER_MATCH : i32 = -2144206797;
pub const FWP_E_PROVIDER_CONTEXT_MISMATCH : i32 = -2144206796;
pub const FWP_E_INVALID_PARAMETER : i32 = -2144206795;
pub const FWP_E_TOO_MANY_SUBLAYERS : i32 = -2144206794;
pub const FWP_E_CALLOUT_NOTIFICATION_FAILED : i32 = -2144206793;
pub const FWP_E_INVALID_AUTH_TRANSFORM : i32 = -2144206792;
pub const FWP_E_INVALID_CIPHER_TRANSFORM : i32 = -2144206791;
pub const FWP_E_INCOMPATIBLE_CIPHER_TRANSFORM : i32 = -2144206790;
pub const FWP_E_INVALID_TRANSFORM_COMBINATION : i32 = -2144206789;
pub const FWP_E_DUPLICATE_AUTH_METHOD : i32 = -2144206788;
pub const FWP_E_INVALID_TUNNEL_ENDPOINT : i32 = -2144206787;
pub const FWP_E_L2_DRIVER_NOT_READY : i32 = -2144206786;
pub const FWP_E_KEY_DICTATOR_ALREADY_REGISTERED : i32 = -2144206785;
pub const FWP_E_KEY_DICTATION_INVALID_KEYING_MATERIAL : i32 = -2144206784;
pub const FWP_E_CONNECTIONS_DISABLED : i32 = -2144206783;
pub const FWP_E_INVALID_DNS_NAME : i32 = -2144206782;
pub const FWP_E_STILL_ON : i32 = -2144206781;
pub const FWP_E_IKEEXT_NOT_RUNNING : i32 = -2144206780;
pub const FWP_E_DROP_NOICMP : i32 = -2144206588;
pub const WS_S_ASYNC : i32 = 3997696;
pub const WS_S_END : i32 = 3997697;
pub const WS_E_INVALID_FORMAT : i32 = -2143485952;
pub const WS_E_OBJECT_FAULTED : i32 = -2143485951;
pub const WS_E_NUMERIC_OVERFLOW : i32 = -2143485950;
pub const WS_E_INVALID_OPERATION : i32 = -2143485949;
pub const WS_E_OPERATION_ABORTED : i32 = -2143485948;
pub const WS_E_ENDPOINT_ACCESS_DENIED : i32 = -2143485947;
pub const WS_E_OPERATION_TIMED_OUT : i32 = -2143485946;
pub const WS_E_OPERATION_ABANDONED : i32 = -2143485945;
pub const WS_E_QUOTA_EXCEEDED : i32 = -2143485944;
pub const WS_E_NO_TRANSLATION_AVAILABLE : i32 = -2143485943;
pub const WS_E_SECURITY_VERIFICATION_FAILURE : i32 = -2143485942;
pub const WS_E_ADDRESS_IN_USE : i32 = -2143485941;
pub const WS_E_ADDRESS_NOT_AVAILABLE : i32 = -2143485940;
pub const WS_E_ENDPOINT_NOT_FOUND : i32 = -2143485939;
pub const WS_E_ENDPOINT_NOT_AVAILABLE : i32 = -2143485938;
pub const WS_E_ENDPOINT_FAILURE : i32 = -2143485937;
pub const WS_E_ENDPOINT_UNREACHABLE : i32 = -2143485936;
pub const WS_E_ENDPOINT_ACTION_NOT_SUPPORTED : i32 = -2143485935;
pub const WS_E_ENDPOINT_TOO_BUSY : i32 = -2143485934;
pub const WS_E_ENDPOINT_FAULT_RECEIVED : i32 = -2143485933;
pub const WS_E_ENDPOINT_DISCONNECTED : i32 = -2143485932;
pub const WS_E_PROXY_FAILURE : i32 = -2143485931;
pub const WS_E_PROXY_ACCESS_DENIED : i32 = -2143485930;
pub const WS_E_NOT_SUPPORTED : i32 = -2143485929;
pub const WS_E_PROXY_REQUIRES_BASIC_AUTH : i32 = -2143485928;
pub const WS_E_PROXY_REQUIRES_DIGEST_AUTH : i32 = -2143485927;
pub const WS_E_PROXY_REQUIRES_NTLM_AUTH : i32 = -2143485926;
pub const WS_E_PROXY_REQUIRES_NEGOTIATE_AUTH : i32 = -2143485925;
pub const WS_E_SERVER_REQUIRES_BASIC_AUTH : i32 = -2143485924;
pub const WS_E_SERVER_REQUIRES_DIGEST_AUTH : i32 = -2143485923;
pub const WS_E_SERVER_REQUIRES_NTLM_AUTH : i32 = -2143485922;
pub const WS_E_SERVER_REQUIRES_NEGOTIATE_AUTH : i32 = -2143485921;
pub const WS_E_INVALID_ENDPOINT_URL : i32 = -2143485920;
pub const WS_E_OTHER : i32 = -2143485919;
pub const WS_E_SECURITY_TOKEN_EXPIRED : i32 = -2143485918;
pub const WS_E_SECURITY_SYSTEM_FAILURE : i32 = -2143485917;
pub const ERROR_NDIS_INTERFACE_CLOSING : u32 = 2150891522;
pub const ERROR_NDIS_BAD_VERSION : u32 = 2150891524;
pub const ERROR_NDIS_BAD_CHARACTERISTICS : u32 = 2150891525;
pub const ERROR_NDIS_ADAPTER_NOT_FOUND : u32 = 2150891526;
pub const ERROR_NDIS_OPEN_FAILED : u32 = 2150891527;
pub const ERROR_NDIS_DEVICE_FAILED : u32 = 2150891528;
pub const ERROR_NDIS_MULTICAST_FULL : u32 = 2150891529;
pub const ERROR_NDIS_MULTICAST_EXISTS : u32 = 2150891530;
pub const ERROR_NDIS_MULTICAST_NOT_FOUND : u32 = 2150891531;
pub const ERROR_NDIS_REQUEST_ABORTED : u32 = 2150891532;
pub const ERROR_NDIS_RESET_IN_PROGRESS : u32 = 2150891533;
pub const ERROR_NDIS_NOT_SUPPORTED : u32 = 2150891707;
pub const ERROR_NDIS_INVALID_PACKET : u32 = 2150891535;
pub const ERROR_NDIS_ADAPTER_NOT_READY : u32 = 2150891537;
pub const ERROR_NDIS_INVALID_LENGTH : u32 = 2150891540;
pub const ERROR_NDIS_INVALID_DATA : u32 = 2150891541;
pub const ERROR_NDIS_BUFFER_TOO_SHORT : u32 = 2150891542;
pub const ERROR_NDIS_INVALID_OID : u32 = 2150891543;
pub const ERROR_NDIS_ADAPTER_REMOVED : u32 = 2150891544;
pub const ERROR_NDIS_UNSUPPORTED_MEDIA : u32 = 2150891545;
pub const ERROR_NDIS_GROUP_ADDRESS_IN_USE : u32 = 2150891546;
pub const ERROR_NDIS_FILE_NOT_FOUND : u32 = 2150891547;
pub const ERROR_NDIS_ERROR_READING_FILE : u32 = 2150891548;
pub const ERROR_NDIS_ALREADY_MAPPED : u32 = 2150891549;
pub const ERROR_NDIS_RESOURCE_CONFLICT : u32 = 2150891550;
pub const ERROR_NDIS_MEDIA_DISCONNECTED : u32 = 2150891551;
pub const ERROR_NDIS_INVALID_ADDRESS : u32 = 2150891554;
pub const ERROR_NDIS_INVALID_DEVICE_REQUEST : u32 = 2150891536;
pub const ERROR_NDIS_PAUSED : u32 = 2150891562;
pub const ERROR_NDIS_INTERFACE_NOT_FOUND : u32 = 2150891563;
pub const ERROR_NDIS_UNSUPPORTED_REVISION : u32 = 2150891564;
pub const ERROR_NDIS_INVALID_PORT : u32 = 2150891565;
pub const ERROR_NDIS_INVALID_PORT_STATE : u32 = 2150891566;
pub const ERROR_NDIS_LOW_POWER_STATE : u32 = 2150891567;
pub const ERROR_NDIS_REINIT_REQUIRED : u32 = 2150891568;
pub const ERROR_NDIS_NO_QUEUES : u32 = 2150891569;
pub const ERROR_NDIS_DOT11_AUTO_CONFIG_ENABLED : u32 = 2150899712;
pub const ERROR_NDIS_DOT11_MEDIA_IN_USE : u32 = 2150899713;
pub const ERROR_NDIS_DOT11_POWER_STATE_INVALID : u32 = 2150899714;
pub const ERROR_NDIS_PM_WOL_PATTERN_LIST_FULL : u32 = 2150899715;
pub const ERROR_NDIS_PM_PROTOCOL_OFFLOAD_LIST_FULL : u32 = 2150899716;
pub const ERROR_NDIS_DOT11_AP_CHANNEL_CURRENTLY_NOT_AVAILABLE : u32 = 2150899717;
pub const ERROR_NDIS_DOT11_AP_BAND_CURRENTLY_NOT_AVAILABLE : u32 = 2150899718;
pub const ERROR_NDIS_DOT11_AP_CHANNEL_NOT_ALLOWED : u32 = 2150899719;
pub const ERROR_NDIS_DOT11_AP_BAND_NOT_ALLOWED : u32 = 2150899720;
pub const ERROR_NDIS_INDICATION_REQUIRED : u32 = 3407873;
pub const ERROR_NDIS_OFFLOAD_POLICY : u32 = 3224637455;
pub const ERROR_NDIS_OFFLOAD_CONNECTION_REJECTED : u32 = 3224637458;
pub const ERROR_NDIS_OFFLOAD_PATH_REJECTED : u32 = 3224637459;
pub const ERROR_HV_INVALID_HYPERCALL_CODE : u32 = 3224698882;
pub const ERROR_HV_INVALID_HYPERCALL_INPUT : u32 = 3224698883;
pub const ERROR_HV_INVALID_ALIGNMENT : u32 = 3224698884;
pub const ERROR_HV_INVALID_PARAMETER : u32 = 3224698885;
pub const ERROR_HV_ACCESS_DENIED : u32 = 3224698886;
pub const ERROR_HV_INVALID_PARTITION_STATE : u32 = 3224698887;
pub const ERROR_HV_OPERATION_DENIED : u32 = 3224698888;
pub const ERROR_HV_UNKNOWN_PROPERTY : u32 = 3224698889;
pub const ERROR_HV_PROPERTY_VALUE_OUT_OF_RANGE : u32 = 3224698890;
pub const ERROR_HV_INSUFFICIENT_MEMORY : u32 = 3224698891;
pub const ERROR_HV_PARTITION_TOO_DEEP : u32 = 3224698892;
pub const ERROR_HV_INVALID_PARTITION_ID : u32 = 3224698893;
pub const ERROR_HV_INVALID_VP_INDEX : u32 = 3224698894;
pub const ERROR_HV_INVALID_PORT_ID : u32 = 3224698897;
pub const ERROR_HV_INVALID_CONNECTION_ID : u32 = 3224698898;
pub const ERROR_HV_INSUFFICIENT_BUFFERS : u32 = 3224698899;
pub const ERROR_HV_NOT_ACKNOWLEDGED : u32 = 3224698900;
pub const ERROR_HV_INVALID_VP_STATE : u32 = 3224698901;
pub const ERROR_HV_ACKNOWLEDGED : u32 = 3224698902;
pub const ERROR_HV_INVALID_SAVE_RESTORE_STATE : u32 = 3224698903;
pub const ERROR_HV_INVALID_SYNIC_STATE : u32 = 3224698904;
pub const ERROR_HV_OBJECT_IN_USE : u32 = 3224698905;
pub const ERROR_HV_INVALID_PROXIMITY_DOMAIN_INFO : u32 = 3224698906;
pub const ERROR_HV_NO_DATA : u32 = 3224698907;
pub const ERROR_HV_INACTIVE : u32 = 3224698908;
pub const ERROR_HV_NO_RESOURCES : u32 = 3224698909;
pub const ERROR_HV_FEATURE_UNAVAILABLE : u32 = 3224698910;
pub const ERROR_HV_INSUFFICIENT_BUFFER : u32 = 3224698931;
pub const ERROR_HV_INSUFFICIENT_DEVICE_DOMAINS : u32 = 3224698936;
pub const ERROR_HV_CPUID_FEATURE_VALIDATION : u32 = 3224698940;
pub const ERROR_HV_CPUID_XSAVE_FEATURE_VALIDATION : u32 = 3224698941;
pub const ERROR_HV_PROCESSOR_STARTUP_TIMEOUT : u32 = 3224698942;
pub const ERROR_HV_SMX_ENABLED : u32 = 3224698943;
pub const ERROR_HV_INVALID_LP_INDEX : u32 = 3224698945;
pub const ERROR_HV_INVALID_REGISTER_VALUE : u32 = 3224698960;
pub const ERROR_HV_INVALID_VTL_STATE : u32 = 3224698961;
pub const ERROR_HV_NX_NOT_DETECTED : u32 = 3224698965;
pub const ERROR_HV_INVALID_DEVICE_ID : u32 = 3224698967;
pub const ERROR_HV_INVALID_DEVICE_STATE : u32 = 3224698968;
pub const ERROR_HV_PENDING_PAGE_REQUESTS : u32 = 3473497;
pub const ERROR_HV_PAGE_REQUEST_INVALID : u32 = 3224698976;
pub const ERROR_HV_INVALID_CPU_GROUP_ID : u32 = 3224698991;
pub const ERROR_HV_INVALID_CPU_GROUP_STATE : u32 = 3224698992;
pub const ERROR_HV_OPERATION_FAILED : u32 = 3224698993;
pub const ERROR_HV_NOT_ALLOWED_WITH_NESTED_VIRT_ACTIVE : u32 = 3224698994;
pub const ERROR_HV_INSUFFICIENT_ROOT_MEMORY : u32 = 3224698995;
pub const ERROR_HV_EVENT_BUFFER_ALREADY_FREED : u32 = 3224698996;
pub const ERROR_HV_INSUFFICIENT_CONTIGUOUS_MEMORY : u32 = 3224698997;
pub const ERROR_HV_NOT_PRESENT : u32 = 3224702976;
pub const ERROR_VID_DUPLICATE_HANDLER : u32 = 3224829953;
pub const ERROR_VID_TOO_MANY_HANDLERS : u32 = 3224829954;
pub const ERROR_VID_QUEUE_FULL : u32 = 3224829955;
pub const ERROR_VID_HANDLER_NOT_PRESENT : u32 = 3224829956;
pub const ERROR_VID_INVALID_OBJECT_NAME : u32 = 3224829957;
pub const ERROR_VID_PARTITION_NAME_TOO_LONG : u32 = 3224829958;
pub const ERROR_VID_MESSAGE_QUEUE_NAME_TOO_LONG : u32 = 3224829959;
pub const ERROR_VID_PARTITION_ALREADY_EXISTS : u32 = 3224829960;
pub const ERROR_VID_PARTITION_DOES_NOT_EXIST : u32 = 3224829961;
pub const ERROR_VID_PARTITION_NAME_NOT_FOUND : u32 = 3224829962;
pub const ERROR_VID_MESSAGE_QUEUE_ALREADY_EXISTS : u32 = 3224829963;
pub const ERROR_VID_EXCEEDED_MBP_ENTRY_MAP_LIMIT : u32 = 3224829964;
pub const ERROR_VID_MB_STILL_REFERENCED : u32 = 3224829965;
pub const ERROR_VID_CHILD_GPA_PAGE_SET_CORRUPTED : u32 = 3224829966;
pub const ERROR_VID_INVALID_NUMA_SETTINGS : u32 = 3224829967;
pub const ERROR_VID_INVALID_NUMA_NODE_INDEX : u32 = 3224829968;
pub const ERROR_VID_NOTIFICATION_QUEUE_ALREADY_ASSOCIATED : u32 = 3224829969;
pub const ERROR_VID_INVALID_MEMORY_BLOCK_HANDLE : u32 = 3224829970;
pub const ERROR_VID_PAGE_RANGE_OVERFLOW : u32 = 3224829971;
pub const ERROR_VID_INVALID_MESSAGE_QUEUE_HANDLE : u32 = 3224829972;
pub const ERROR_VID_INVALID_GPA_RANGE_HANDLE : u32 = 3224829973;
pub const ERROR_VID_NO_MEMORY_BLOCK_NOTIFICATION_QUEUE : u32 = 3224829974;
pub const ERROR_VID_MEMORY_BLOCK_LOCK_COUNT_EXCEEDED : u32 = 3224829975;
pub const ERROR_VID_INVALID_PPM_HANDLE : u32 = 3224829976;
pub const ERROR_VID_MBPS_ARE_LOCKED : u32 = 3224829977;
pub const ERROR_VID_MESSAGE_QUEUE_CLOSED : u32 = 3224829978;
pub const ERROR_VID_VIRTUAL_PROCESSOR_LIMIT_EXCEEDED : u32 = 3224829979;
pub const ERROR_VID_STOP_PENDING : u32 = 3224829980;
pub const ERROR_VID_INVALID_PROCESSOR_STATE : u32 = 3224829981;
pub const ERROR_VID_EXCEEDED_KM_CONTEXT_COUNT_LIMIT : u32 = 3224829982;
pub const ERROR_VID_KM_INTERFACE_ALREADY_INITIALIZED : u32 = 3224829983;
pub const ERROR_VID_MB_PROPERTY_ALREADY_SET_RESET : u32 = 3224829984;
pub const ERROR_VID_MMIO_RANGE_DESTROYED : u32 = 3224829985;
pub const ERROR_VID_INVALID_CHILD_GPA_PAGE_SET : u32 = 3224829986;
pub const ERROR_VID_RESERVE_PAGE_SET_IS_BEING_USED : u32 = 3224829987;
pub const ERROR_VID_RESERVE_PAGE_SET_TOO_SMALL : u32 = 3224829988;
pub const ERROR_VID_MBP_ALREADY_LOCKED_USING_RESERVED_PAGE : u32 = 3224829989;
pub const ERROR_VID_MBP_COUNT_EXCEEDED_LIMIT : u32 = 3224829990;
pub const ERROR_VID_SAVED_STATE_CORRUPT : u32 = 3224829991;
pub const ERROR_VID_SAVED_STATE_UNRECOGNIZED_ITEM : u32 = 3224829992;
pub const ERROR_VID_SAVED_STATE_INCOMPATIBLE : u32 = 3224829993;
pub const ERROR_VID_VTL_ACCESS_DENIED : u32 = 3224829994;
pub const ERROR_VMCOMPUTE_TERMINATED_DURING_START : u32 = 3224830208;
pub const ERROR_VMCOMPUTE_IMAGE_MISMATCH : u32 = 3224830209;
pub const ERROR_VMCOMPUTE_HYPERV_NOT_INSTALLED : u32 = 3224830210;
pub const ERROR_VMCOMPUTE_OPERATION_PENDING : u32 = 3224830211;
pub const ERROR_VMCOMPUTE_TOO_MANY_NOTIFICATIONS : u32 = 3224830212;
pub const ERROR_VMCOMPUTE_INVALID_STATE : u32 = 3224830213;
pub const ERROR_VMCOMPUTE_UNEXPECTED_EXIT : u32 = 3224830214;
pub const ERROR_VMCOMPUTE_TERMINATED : u32 = 3224830215;
pub const ERROR_VMCOMPUTE_CONNECT_FAILED : u32 = 3224830216;
pub const ERROR_VMCOMPUTE_TIMEOUT : u32 = 3224830217;
pub const ERROR_VMCOMPUTE_CONNECTION_CLOSED : u32 = 3224830218;
pub const ERROR_VMCOMPUTE_UNKNOWN_MESSAGE : u32 = 3224830219;
pub const ERROR_VMCOMPUTE_UNSUPPORTED_PROTOCOL_VERSION : u32 = 3224830220;
pub const ERROR_VMCOMPUTE_INVALID_JSON : u32 = 3224830221;
pub const ERROR_VMCOMPUTE_SYSTEM_NOT_FOUND : u32 = 3224830222;
pub const ERROR_VMCOMPUTE_SYSTEM_ALREADY_EXISTS : u32 = 3224830223;
pub const ERROR_VMCOMPUTE_SYSTEM_ALREADY_STOPPED : u32 = 3224830224;
pub const ERROR_VMCOMPUTE_PROTOCOL_ERROR : u32 = 3224830225;
pub const ERROR_VMCOMPUTE_INVALID_LAYER : u32 = 3224830226;
pub const ERROR_VMCOMPUTE_WINDOWS_INSIDER_REQUIRED : u32 = 3224830227;
pub const HCS_E_TERMINATED_DURING_START : i32 = -2143878912;
pub const HCS_E_IMAGE_MISMATCH : i32 = -2143878911;
pub const HCS_E_HYPERV_NOT_INSTALLED : i32 = -2143878910;
pub const HCS_E_INVALID_STATE : i32 = -2143878907;
pub const HCS_E_UNEXPECTED_EXIT : i32 = -2143878906;
pub const HCS_E_TERMINATED : i32 = -2143878905;
pub const HCS_E_CONNECT_FAILED : i32 = -2143878904;
pub const HCS_E_CONNECTION_TIMEOUT : i32 = -2143878903;
pub const HCS_E_CONNECTION_CLOSED : i32 = -2143878902;
pub const HCS_E_UNKNOWN_MESSAGE : i32 = -2143878901;
pub const HCS_E_UNSUPPORTED_PROTOCOL_VERSION : i32 = -2143878900;
pub const HCS_E_INVALID_JSON : i32 = -2143878899;
pub const HCS_E_SYSTEM_NOT_FOUND : i32 = -2143878898;
pub const HCS_E_SYSTEM_ALREADY_EXISTS : i32 = -2143878897;
pub const HCS_E_SYSTEM_ALREADY_STOPPED : i32 = -2143878896;
pub const HCS_E_PROTOCOL_ERROR : i32 = -2143878895;
pub const HCS_E_INVALID_LAYER : i32 = -2143878894;
pub const HCS_E_WINDOWS_INSIDER_REQUIRED : i32 = -2143878893;
pub const HCS_E_SERVICE_NOT_AVAILABLE : i32 = -2143878892;
pub const HCS_E_OPERATION_NOT_STARTED : i32 = -2143878891;
pub const HCS_E_OPERATION_ALREADY_STARTED : i32 = -2143878890;
pub const HCS_E_OPERATION_PENDING : i32 = -2143878889;
pub const HCS_E_OPERATION_TIMEOUT : i32 = -2143878888;
pub const HCS_E_OPERATION_SYSTEM_CALLBACK_ALREADY_SET : i32 = -2143878887;
pub const HCS_E_OPERATION_RESULT_ALLOCATION_FAILED : i32 = -2143878886;
pub const HCS_E_ACCESS_DENIED : i32 = -2143878885;
pub const HCS_E_GUEST_CRITICAL_ERROR : i32 = -2143878884;
pub const HCS_E_PROCESS_INFO_NOT_AVAILABLE : i32 = -2143878883;
pub const HCS_E_SERVICE_DISCONNECT : i32 = -2143878882;
pub const HCS_E_PROCESS_ALREADY_STOPPED : i32 = -2143878881;
pub const ERROR_VNET_VIRTUAL_SWITCH_NAME_NOT_FOUND : u32 = 3224830464;
pub const ERROR_VID_REMOTE_NODE_PARENT_GPA_PAGES_USED : u32 = 2151088129;
pub const WHV_E_UNKNOWN_CAPABILITY : i32 = -2143878400;
pub const WHV_E_INSUFFICIENT_BUFFER : i32 = -2143878399;
pub const WHV_E_UNKNOWN_PROPERTY : i32 = -2143878398;
pub const WHV_E_UNSUPPORTED_HYPERVISOR_CONFIG : i32 = -2143878397;
pub const WHV_E_INVALID_PARTITION_CONFIG : i32 = -2143878396;
pub const WHV_E_GPA_RANGE_NOT_FOUND : i32 = -2143878395;
pub const WHV_E_VP_ALREADY_EXISTS : i32 = -2143878394;
pub const WHV_E_VP_DOES_NOT_EXIST : i32 = -2143878393;
pub const WHV_E_INVALID_VP_STATE : i32 = -2143878392;
pub const WHV_E_INVALID_VP_REGISTER_NAME : i32 = -2143878391;
pub const WHV_E_UNSUPPORTED_PROCESSOR_CONFIG : i32 = -2143878384;
pub const ERROR_VSMB_SAVED_STATE_FILE_NOT_FOUND : u32 = 3224830976;
pub const ERROR_VSMB_SAVED_STATE_CORRUPT : u32 = 3224830977;
pub const VM_SAVED_STATE_DUMP_E_PARTITION_STATE_NOT_FOUND : i32 = -1070136064;
pub const VM_SAVED_STATE_DUMP_E_GUEST_MEMORY_NOT_FOUND : i32 = -1070136063;
pub const VM_SAVED_STATE_DUMP_E_NO_VP_FOUND_IN_PARTITION_STATE : i32 = -1070136062;
pub const VM_SAVED_STATE_DUMP_E_NESTED_VIRTUALIZATION_NOT_SUPPORTED : i32 = -1070136061;
pub const VM_SAVED_STATE_DUMP_E_WINDOWS_KERNEL_IMAGE_NOT_FOUND : i32 = -1070136060;
pub const VM_SAVED_STATE_DUMP_E_PXE_NOT_PRESENT : i32 = -1070136059;
pub const VM_SAVED_STATE_DUMP_E_PDPTE_NOT_PRESENT : i32 = -1070136058;
pub const VM_SAVED_STATE_DUMP_E_PDE_NOT_PRESENT : i32 = -1070136057;
pub const VM_SAVED_STATE_DUMP_E_PTE_NOT_PRESENT : i32 = -1070136056;
pub const ERROR_VOLMGR_INCOMPLETE_REGENERATION : u32 = 2151153665;
pub const ERROR_VOLMGR_INCOMPLETE_DISK_MIGRATION : u32 = 2151153666;
pub const ERROR_VOLMGR_DATABASE_FULL : u32 = 3224895489;
pub const ERROR_VOLMGR_DISK_CONFIGURATION_CORRUPTED : u32 = 3224895490;
pub const ERROR_VOLMGR_DISK_CONFIGURATION_NOT_IN_SYNC : u32 = 3224895491;
pub const ERROR_VOLMGR_PACK_CONFIG_UPDATE_FAILED : u32 = 3224895492;
pub const ERROR_VOLMGR_DISK_CONTAINS_NON_SIMPLE_VOLUME : u32 = 3224895493;
pub const ERROR_VOLMGR_DISK_DUPLICATE : u32 = 3224895494;
pub const ERROR_VOLMGR_DISK_DYNAMIC : u32 = 3224895495;
pub const ERROR_VOLMGR_DISK_ID_INVALID : u32 = 3224895496;
pub const ERROR_VOLMGR_DISK_INVALID : u32 = 3224895497;
pub const ERROR_VOLMGR_DISK_LAST_VOTER : u32 = 3224895498;
pub const ERROR_VOLMGR_DISK_LAYOUT_INVALID : u32 = 3224895499;
pub const ERROR_VOLMGR_DISK_LAYOUT_NON_BASIC_BETWEEN_BASIC_PARTITIONS : u32 = 3224895500;
pub const ERROR_VOLMGR_DISK_LAYOUT_NOT_CYLINDER_ALIGNED : u32 = 3224895501;
pub const ERROR_VOLMGR_DISK_LAYOUT_PARTITIONS_TOO_SMALL : u32 = 3224895502;
pub const ERROR_VOLMGR_DISK_LAYOUT_PRIMARY_BETWEEN_LOGICAL_PARTITIONS : u32 = 3224895503;
pub const ERROR_VOLMGR_DISK_LAYOUT_TOO_MANY_PARTITIONS : u32 = 3224895504;
pub const ERROR_VOLMGR_DISK_MISSING : u32 = 3224895505;
pub const ERROR_VOLMGR_DISK_NOT_EMPTY : u32 = 3224895506;
pub const ERROR_VOLMGR_DISK_NOT_ENOUGH_SPACE : u32 = 3224895507;
pub const ERROR_VOLMGR_DISK_REVECTORING_FAILED : u32 = 3224895508;
pub const ERROR_VOLMGR_DISK_SECTOR_SIZE_INVALID : u32 = 3224895509;
pub const ERROR_VOLMGR_DISK_SET_NOT_CONTAINED : u32 = 3224895510;
pub const ERROR_VOLMGR_DISK_USED_BY_MULTIPLE_MEMBERS : u32 = 3224895511;
pub const ERROR_VOLMGR_DISK_USED_BY_MULTIPLE_PLEXES : u32 = 3224895512;
pub const ERROR_VOLMGR_DYNAMIC_DISK_NOT_SUPPORTED : u32 = 3224895513;
pub const ERROR_VOLMGR_EXTENT_ALREADY_USED : u32 = 3224895514;
pub const ERROR_VOLMGR_EXTENT_NOT_CONTIGUOUS : u32 = 3224895515;
pub const ERROR_VOLMGR_EXTENT_NOT_IN_PUBLIC_REGION : u32 = 3224895516;
pub const ERROR_VOLMGR_EXTENT_NOT_SECTOR_ALIGNED : u32 = 3224895517;
pub const ERROR_VOLMGR_EXTENT_OVERLAPS_EBR_PARTITION : u32 = 3224895518;
pub const ERROR_VOLMGR_EXTENT_VOLUME_LENGTHS_DO_NOT_MATCH : u32 = 3224895519;
pub const ERROR_VOLMGR_FAULT_TOLERANT_NOT_SUPPORTED : u32 = 3224895520;
pub const ERROR_VOLMGR_INTERLEAVE_LENGTH_INVALID : u32 = 3224895521;
pub const ERROR_VOLMGR_MAXIMUM_REGISTERED_USERS : u32 = 3224895522;
pub const ERROR_VOLMGR_MEMBER_IN_SYNC : u32 = 3224895523;
pub const ERROR_VOLMGR_MEMBER_INDEX_DUPLICATE : u32 = 3224895524;
pub const ERROR_VOLMGR_MEMBER_INDEX_INVALID : u32 = 3224895525;
pub const ERROR_VOLMGR_MEMBER_MISSING : u32 = 3224895526;
pub const ERROR_VOLMGR_MEMBER_NOT_DETACHED : u32 = 3224895527;
pub const ERROR_VOLMGR_MEMBER_REGENERATING : u32 = 3224895528;
pub const ERROR_VOLMGR_ALL_DISKS_FAILED : u32 = 3224895529;
pub const ERROR_VOLMGR_NO_REGISTERED_USERS : u32 = 3224895530;
pub const ERROR_VOLMGR_NO_SUCH_USER : u32 = 3224895531;
pub const ERROR_VOLMGR_NOTIFICATION_RESET : u32 = 3224895532;
pub const ERROR_VOLMGR_NUMBER_OF_MEMBERS_INVALID : u32 = 3224895533;
pub const ERROR_VOLMGR_NUMBER_OF_PLEXES_INVALID : u32 = 3224895534;
pub const ERROR_VOLMGR_PACK_DUPLICATE : u32 = 3224895535;
pub const ERROR_VOLMGR_PACK_ID_INVALID : u32 = 3224895536;
pub const ERROR_VOLMGR_PACK_INVALID : u32 = 3224895537;
pub const ERROR_VOLMGR_PACK_NAME_INVALID : u32 = 3224895538;
pub const ERROR_VOLMGR_PACK_OFFLINE : u32 = 3224895539;
pub const ERROR_VOLMGR_PACK_HAS_QUORUM : u32 = 3224895540;
pub const ERROR_VOLMGR_PACK_WITHOUT_QUORUM : u32 = 3224895541;
pub const ERROR_VOLMGR_PARTITION_STYLE_INVALID : u32 = 3224895542;
pub const ERROR_VOLMGR_PARTITION_UPDATE_FAILED : u32 = 3224895543;
pub const ERROR_VOLMGR_PLEX_IN_SYNC : u32 = 3224895544;
pub const ERROR_VOLMGR_PLEX_INDEX_DUPLICATE : u32 = 3224895545;
pub const ERROR_VOLMGR_PLEX_INDEX_INVALID : u32 = 3224895546;
pub const ERROR_VOLMGR_PLEX_LAST_ACTIVE : u32 = 3224895547;
pub const ERROR_VOLMGR_PLEX_MISSING : u32 = 3224895548;
pub const ERROR_VOLMGR_PLEX_REGENERATING : u32 = 3224895549;
pub const ERROR_VOLMGR_PLEX_TYPE_INVALID : u32 = 3224895550;
pub const ERROR_VOLMGR_PLEX_NOT_RAID5 : u32 = 3224895551;
pub const ERROR_VOLMGR_PLEX_NOT_SIMPLE : u32 = 3224895552;
pub const ERROR_VOLMGR_STRUCTURE_SIZE_INVALID : u32 = 3224895553;
pub const ERROR_VOLMGR_TOO_MANY_NOTIFICATION_REQUESTS : u32 = 3224895554;
pub const ERROR_VOLMGR_TRANSACTION_IN_PROGRESS : u32 = 3224895555;
pub const ERROR_VOLMGR_UNEXPECTED_DISK_LAYOUT_CHANGE : u32 = 3224895556;
pub const ERROR_VOLMGR_VOLUME_CONTAINS_MISSING_DISK : u32 = 3224895557;
pub const ERROR_VOLMGR_VOLUME_ID_INVALID : u32 = 3224895558;
pub const ERROR_VOLMGR_VOLUME_LENGTH_INVALID : u32 = 3224895559;
pub const ERROR_VOLMGR_VOLUME_LENGTH_NOT_SECTOR_SIZE_MULTIPLE : u32 = 3224895560;
pub const ERROR_VOLMGR_VOLUME_NOT_MIRRORED : u32 = 3224895561;
pub const ERROR_VOLMGR_VOLUME_NOT_RETAINED : u32 = 3224895562;
pub const ERROR_VOLMGR_VOLUME_OFFLINE : u32 = 3224895563;
pub const ERROR_VOLMGR_VOLUME_RETAINED : u32 = 3224895564;
pub const ERROR_VOLMGR_NUMBER_OF_EXTENTS_INVALID : u32 = 3224895565;
pub const ERROR_VOLMGR_DIFFERENT_SECTOR_SIZE : u32 = 3224895566;
pub const ERROR_VOLMGR_BAD_BOOT_DISK : u32 = 3224895567;
pub const ERROR_VOLMGR_PACK_CONFIG_OFFLINE : u32 = 3224895568;
pub const ERROR_VOLMGR_PACK_CONFIG_ONLINE : u32 = 3224895569;
pub const ERROR_VOLMGR_NOT_PRIMARY_PACK : u32 = 3224895570;
pub const ERROR_VOLMGR_PACK_LOG_UPDATE_FAILED : u32 = 3224895571;
pub const ERROR_VOLMGR_NUMBER_OF_DISKS_IN_PLEX_INVALID : u32 = 3224895572;
pub const ERROR_VOLMGR_NUMBER_OF_DISKS_IN_MEMBER_INVALID : u32 = 3224895573;
pub const ERROR_VOLMGR_VOLUME_MIRRORED : u32 = 3224895574;
pub const ERROR_VOLMGR_PLEX_NOT_SIMPLE_SPANNED : u32 = 3224895575;
pub const ERROR_VOLMGR_NO_VALID_LOG_COPIES : u32 = 3224895576;
pub const ERROR_VOLMGR_PRIMARY_PACK_PRESENT : u32 = 3224895577;
pub const ERROR_VOLMGR_NUMBER_OF_DISKS_INVALID : u32 = 3224895578;
pub const ERROR_VOLMGR_MIRROR_NOT_SUPPORTED : u32 = 3224895579;
pub const ERROR_VOLMGR_RAID5_NOT_SUPPORTED : u32 = 3224895580;
pub const ERROR_BCD_NOT_ALL_ENTRIES_IMPORTED : u32 = 2151219201;
pub const ERROR_BCD_TOO_MANY_ELEMENTS : u32 = 3224961026;
pub const ERROR_BCD_NOT_ALL_ENTRIES_SYNCHRONIZED : u32 = 2151219203;
pub const ERROR_VHD_DRIVE_FOOTER_MISSING : u32 = 3225026561;
pub const ERROR_VHD_DRIVE_FOOTER_CHECKSUM_MISMATCH : u32 = 3225026562;
pub const ERROR_VHD_DRIVE_FOOTER_CORRUPT : u32 = 3225026563;
pub const ERROR_VHD_FORMAT_UNKNOWN : u32 = 3225026564;
pub const ERROR_VHD_FORMAT_UNSUPPORTED_VERSION : u32 = 3225026565;
pub const ERROR_VHD_SPARSE_HEADER_CHECKSUM_MISMATCH : u32 = 3225026566;
pub const ERROR_VHD_SPARSE_HEADER_UNSUPPORTED_VERSION : u32 = 3225026567;
pub const ERROR_VHD_SPARSE_HEADER_CORRUPT : u32 = 3225026568;
pub const ERROR_VHD_BLOCK_ALLOCATION_FAILURE : u32 = 3225026569;
pub const ERROR_VHD_BLOCK_ALLOCATION_TABLE_CORRUPT : u32 = 3225026570;
pub const ERROR_VHD_INVALID_BLOCK_SIZE : u32 = 3225026571;
pub const ERROR_VHD_BITMAP_MISMATCH : u32 = 3225026572;
pub const ERROR_VHD_PARENT_VHD_NOT_FOUND : u32 = 3225026573;
pub const ERROR_VHD_CHILD_PARENT_ID_MISMATCH : u32 = 3225026574;
pub const ERROR_VHD_CHILD_PARENT_TIMESTAMP_MISMATCH : u32 = 3225026575;
pub const ERROR_VHD_METADATA_READ_FAILURE : u32 = 3225026576;
pub const ERROR_VHD_METADATA_WRITE_FAILURE : u32 = 3225026577;
pub const ERROR_VHD_INVALID_SIZE : u32 = 3225026578;
pub const ERROR_VHD_INVALID_FILE_SIZE : u32 = 3225026579;
pub const ERROR_VIRTDISK_PROVIDER_NOT_FOUND : u32 = 3225026580;
pub const ERROR_VIRTDISK_NOT_VIRTUAL_DISK : u32 = 3225026581;
pub const ERROR_VHD_PARENT_VHD_ACCESS_DENIED : u32 = 3225026582;
pub const ERROR_VHD_CHILD_PARENT_SIZE_MISMATCH : u32 = 3225026583;
pub const ERROR_VHD_DIFFERENCING_CHAIN_CYCLE_DETECTED : u32 = 3225026584;
pub const ERROR_VHD_DIFFERENCING_CHAIN_ERROR_IN_PARENT : u32 = 3225026585;
pub const ERROR_VIRTUAL_DISK_LIMITATION : u32 = 3225026586;
pub const ERROR_VHD_INVALID_TYPE : u32 = 3225026587;
pub const ERROR_VHD_INVALID_STATE : u32 = 3225026588;
pub const ERROR_VIRTDISK_UNSUPPORTED_DISK_SECTOR_SIZE : u32 = 3225026589;
pub const ERROR_VIRTDISK_DISK_ALREADY_OWNED : u32 = 3225026590;
pub const ERROR_VIRTDISK_DISK_ONLINE_AND_WRITABLE : u32 = 3225026591;
pub const ERROR_CTLOG_TRACKING_NOT_INITIALIZED : u32 = 3225026592;
pub const ERROR_CTLOG_LOGFILE_SIZE_EXCEEDED_MAXSIZE : u32 = 3225026593;
pub const ERROR_CTLOG_VHD_CHANGED_OFFLINE : u32 = 3225026594;
pub const ERROR_CTLOG_INVALID_TRACKING_STATE : u32 = 3225026595;
pub const ERROR_CTLOG_INCONSISTENT_TRACKING_FILE : u32 = 3225026596;
pub const ERROR_VHD_RESIZE_WOULD_TRUNCATE_DATA : u32 = 3225026597;
pub const ERROR_VHD_COULD_NOT_COMPUTE_MINIMUM_VIRTUAL_SIZE : u32 = 3225026598;
pub const ERROR_VHD_ALREADY_AT_OR_BELOW_MINIMUM_VIRTUAL_SIZE : u32 = 3225026599;
pub const ERROR_VHD_METADATA_FULL : u32 = 3225026600;
pub const ERROR_VHD_INVALID_CHANGE_TRACKING_ID : u32 = 3225026601;
pub const ERROR_VHD_CHANGE_TRACKING_DISABLED : u32 = 3225026602;
pub const ERROR_VHD_MISSING_CHANGE_TRACKING_INFORMATION : u32 = 3225026608;
pub const ERROR_QUERY_STORAGE_ERROR : u32 = 2151284737;
pub const HCN_E_NETWORK_NOT_FOUND : i32 = -2143617023;
pub const HCN_E_ENDPOINT_NOT_FOUND : i32 = -2143617022;
pub const HCN_E_LAYER_NOT_FOUND : i32 = -2143617021;
pub const HCN_E_SWITCH_NOT_FOUND : i32 = -2143617020;
pub const HCN_E_SUBNET_NOT_FOUND : i32 = -2143617019;
pub const HCN_E_ADAPTER_NOT_FOUND : i32 = -2143617018;
pub const HCN_E_PORT_NOT_FOUND : i32 = -2143617017;
pub const HCN_E_POLICY_NOT_FOUND : i32 = -2143617016;
pub const HCN_E_VFP_PORTSETTING_NOT_FOUND : i32 = -2143617015;
pub const HCN_E_INVALID_NETWORK : i32 = -2143617014;
pub const HCN_E_INVALID_NETWORK_TYPE : i32 = -2143617013;
pub const HCN_E_INVALID_ENDPOINT : i32 = -2143617012;
pub const HCN_E_INVALID_POLICY : i32 = -2143617011;
pub const HCN_E_INVALID_POLICY_TYPE : i32 = -2143617010;
pub const HCN_E_INVALID_REMOTE_ENDPOINT_OPERATION : i32 = -2143617009;
pub const HCN_E_NETWORK_ALREADY_EXISTS : i32 = -2143617008;
pub const HCN_E_LAYER_ALREADY_EXISTS : i32 = -2143617007;
pub const HCN_E_POLICY_ALREADY_EXISTS : i32 = -2143617006;
pub const HCN_E_PORT_ALREADY_EXISTS : i32 = -2143617005;
pub const HCN_E_ENDPOINT_ALREADY_ATTACHED : i32 = -2143617004;
pub const HCN_E_REQUEST_UNSUPPORTED : i32 = -2143617003;
pub const HCN_E_MAPPING_NOT_SUPPORTED : i32 = -2143617002;
pub const HCN_E_DEGRADED_OPERATION : i32 = -2143617001;
pub const HCN_E_SHARED_SWITCH_MODIFICATION : i32 = -2143617000;
pub const HCN_E_GUID_CONVERSION_FAILURE : i32 = -2143616999;
pub const HCN_E_REGKEY_FAILURE : i32 = -2143616998;
pub const HCN_E_INVALID_JSON : i32 = -2143616997;
pub const HCN_E_INVALID_JSON_REFERENCE : i32 = -2143616996;
pub const HCN_E_ENDPOINT_SHARING_DISABLED : i32 = -2143616995;
pub const HCN_E_INVALID_IP : i32 = -2143616994;
pub const HCN_E_SWITCH_EXTENSION_NOT_FOUND : i32 = -2143616993;
pub const HCN_E_MANAGER_STOPPED : i32 = -2143616992;
pub const GCN_E_MODULE_NOT_FOUND : i32 = -2143616991;
pub const GCN_E_NO_REQUEST_HANDLERS : i32 = -2143616990;
pub const GCN_E_REQUEST_UNSUPPORTED : i32 = -2143616989;
pub const GCN_E_RUNTIMEKEYS_FAILED : i32 = -2143616988;
pub const GCN_E_NETADAPTER_TIMEOUT : i32 = -2143616987;
pub const GCN_E_NETADAPTER_NOT_FOUND : i32 = -2143616986;
pub const GCN_E_NETCOMPARTMENT_NOT_FOUND : i32 = -2143616985;
pub const GCN_E_NETINTERFACE_NOT_FOUND : i32 = -2143616984;
pub const GCN_E_DEFAULTNAMESPACE_EXISTS : i32 = -2143616983;
pub const HCN_E_ICS_DISABLED : i32 = -2143616982;
pub const HCN_E_ENDPOINT_NAMESPACE_ALREADY_EXISTS : i32 = -2143616981;
pub const HCN_E_ENTITY_HAS_REFERENCES : i32 = -2143616980;
pub const HCN_E_INVALID_INTERNAL_PORT : i32 = -2143616979;
pub const HCN_E_NAMESPACE_ATTACH_FAILED : i32 = -2143616978;
pub const HCN_E_ADDR_INVALID_OR_RESERVED : i32 = -2143616977;
pub const HCN_E_INVALID_PREFIX : i32 = -2143616976;
pub const HCN_E_OBJECT_USED_AFTER_UNLOAD : i32 = -2143616975;
pub const HCN_E_INVALID_SUBNET : i32 = -2143616974;
pub const HCN_E_INVALID_IP_SUBNET : i32 = -2143616973;
pub const HCN_E_ENDPOINT_NOT_ATTACHED : i32 = -2143616972;
pub const HCN_E_ENDPOINT_NOT_LOCAL : i32 = -2143616971;
pub const HCN_INTERFACEPARAMETERS_ALREADY_APPLIED : i32 = -2143616970;
pub const SDIAG_E_CANCELLED : u32 = 2151416064;
pub const SDIAG_E_SCRIPT : u32 = 2151416065;
pub const SDIAG_E_POWERSHELL : u32 = 2151416066;
pub const SDIAG_E_MANAGEDHOST : u32 = 2151416067;
pub const SDIAG_E_NOVERIFIER : u32 = 2151416068;
pub const SDIAG_S_CANNOTRUN : u32 = 3932421;
pub const SDIAG_E_DISABLED : u32 = 2151416070;
pub const SDIAG_E_TRUST : u32 = 2151416071;
pub const SDIAG_E_CANNOTRUN : u32 = 2151416072;
pub const SDIAG_E_VERSION : u32 = 2151416073;
pub const SDIAG_E_RESOURCE : u32 = 2151416074;
pub const SDIAG_E_ROOTCAUSE : u32 = 2151416075;
pub const WPN_E_CHANNEL_CLOSED : i32 = -2143420160;
pub const WPN_E_CHANNEL_REQUEST_NOT_COMPLETE : i32 = -2143420159;
pub const WPN_E_INVALID_APP : i32 = -2143420158;
pub const WPN_E_OUTSTANDING_CHANNEL_REQUEST : i32 = -2143420157;
pub const WPN_E_DUPLICATE_CHANNEL : i32 = -2143420156;
pub const WPN_E_PLATFORM_UNAVAILABLE : i32 = -2143420155;
pub const WPN_E_NOTIFICATION_POSTED : i32 = -2143420154;
pub const WPN_E_NOTIFICATION_HIDDEN : i32 = -2143420153;
pub const WPN_E_NOTIFICATION_NOT_POSTED : i32 = -2143420152;
pub const WPN_E_CLOUD_DISABLED : i32 = -2143420151;
pub const WPN_E_CLOUD_INCAPABLE : i32 = -2143420144;
pub const WPN_E_CLOUD_AUTH_UNAVAILABLE : i32 = -2143420134;
pub const WPN_E_CLOUD_SERVICE_UNAVAILABLE : i32 = -2143420133;
pub const WPN_E_FAILED_LOCK_SCREEN_UPDATE_INTIALIZATION : i32 = -2143420132;
pub const WPN_E_NOTIFICATION_DISABLED : i32 = -2143420143;
pub const WPN_E_NOTIFICATION_INCAPABLE : i32 = -2143420142;
pub const WPN_E_INTERNET_INCAPABLE : i32 = -2143420141;
pub const WPN_E_NOTIFICATION_TYPE_DISABLED : i32 = -2143420140;
pub const WPN_E_NOTIFICATION_SIZE : i32 = -2143420139;
pub const WPN_E_TAG_SIZE : i32 = -2143420138;
pub const WPN_E_ACCESS_DENIED : i32 = -2143420137;
pub const WPN_E_DUPLICATE_REGISTRATION : i32 = -2143420136;
pub const WPN_E_PUSH_NOTIFICATION_INCAPABLE : i32 = -2143420135;
pub const WPN_E_DEV_ID_SIZE : i32 = -2143420128;
pub const WPN_E_TAG_ALPHANUMERIC : i32 = -2143420118;
pub const WPN_E_INVALID_HTTP_STATUS_CODE : i32 = -2143420117;
pub const WPN_E_OUT_OF_SESSION : i32 = -2143419904;
pub const WPN_E_POWER_SAVE : i32 = -2143419903;
pub const WPN_E_IMAGE_NOT_FOUND_IN_CACHE : i32 = -2143419902;
pub const WPN_E_ALL_URL_NOT_COMPLETED : i32 = -2143419901;
pub const WPN_E_INVALID_CLOUD_IMAGE : i32 = -2143419900;
pub const WPN_E_NOTIFICATION_ID_MATCHED : i32 = -2143419899;
pub const WPN_E_CALLBACK_ALREADY_REGISTERED : i32 = -2143419898;
pub const WPN_E_TOAST_NOTIFICATION_DROPPED : i32 = -2143419897;
pub const WPN_E_STORAGE_LOCKED : i32 = -2143419896;
pub const WPN_E_GROUP_SIZE : i32 = -2143419895;
pub const WPN_E_GROUP_ALPHANUMERIC : i32 = -2143419894;
pub const WPN_E_CLOUD_DISABLED_FOR_APP : i32 = -2143419893;
pub const E_MBN_CONTEXT_NOT_ACTIVATED : i32 = -2141945343;
pub const E_MBN_BAD_SIM : i32 = -2141945342;
pub const E_MBN_DATA_CLASS_NOT_AVAILABLE : i32 = -2141945341;
pub const E_MBN_INVALID_ACCESS_STRING : i32 = -2141945340;
pub const E_MBN_MAX_ACTIVATED_CONTEXTS : i32 = -2141945339;
pub const E_MBN_PACKET_SVC_DETACHED : i32 = -2141945338;
pub const E_MBN_PROVIDER_NOT_VISIBLE : i32 = -2141945337;
pub const E_MBN_RADIO_POWER_OFF : i32 = -2141945336;
pub const E_MBN_SERVICE_NOT_ACTIVATED : i32 = -2141945335;
pub const E_MBN_SIM_NOT_INSERTED : i32 = -2141945334;
pub const E_MBN_VOICE_CALL_IN_PROGRESS : i32 = -2141945333;
pub const E_MBN_INVALID_CACHE : i32 = -2141945332;
pub const E_MBN_NOT_REGISTERED : i32 = -2141945331;
pub const E_MBN_PROVIDERS_NOT_FOUND : i32 = -2141945330;
pub const E_MBN_PIN_NOT_SUPPORTED : i32 = -2141945329;
pub const E_MBN_PIN_REQUIRED : i32 = -2141945328;
pub const E_MBN_PIN_DISABLED : i32 = -2141945327;
pub const E_MBN_FAILURE : i32 = -2141945326;
pub const E_MBN_INVALID_PROFILE : i32 = -2141945320;
pub const E_MBN_DEFAULT_PROFILE_EXIST : i32 = -2141945319;
pub const E_MBN_SMS_ENCODING_NOT_SUPPORTED : i32 = -2141945312;
pub const E_MBN_SMS_FILTER_NOT_SUPPORTED : i32 = -2141945311;
pub const E_MBN_SMS_INVALID_MEMORY_INDEX : i32 = -2141945310;
pub const E_MBN_SMS_LANG_NOT_SUPPORTED : i32 = -2141945309;
pub const E_MBN_SMS_MEMORY_FAILURE : i32 = -2141945308;
pub const E_MBN_SMS_NETWORK_TIMEOUT : i32 = -2141945307;
pub const E_MBN_SMS_UNKNOWN_SMSC_ADDRESS : i32 = -2141945306;
pub const E_MBN_SMS_FORMAT_NOT_SUPPORTED : i32 = -2141945305;
pub const E_MBN_SMS_OPERATION_NOT_ALLOWED : i32 = -2141945304;
pub const E_MBN_SMS_MEMORY_FULL : i32 = -2141945303;
pub const PEER_E_IPV6_NOT_INSTALLED : i32 = -2140995583;
pub const PEER_E_NOT_INITIALIZED : i32 = -2140995582;
pub const PEER_E_CANNOT_START_SERVICE : i32 = -2140995581;
pub const PEER_E_NOT_LICENSED : i32 = -2140995580;
pub const PEER_E_INVALID_GRAPH : i32 = -2140995568;
pub const PEER_E_DBNAME_CHANGED : i32 = -2140995567;
pub const PEER_E_DUPLICATE_GRAPH : i32 = -2140995566;
pub const PEER_E_GRAPH_NOT_READY : i32 = -2140995565;
pub const PEER_E_GRAPH_SHUTTING_DOWN : i32 = -2140995564;
pub const PEER_E_GRAPH_IN_USE : i32 = -2140995563;
pub const PEER_E_INVALID_DATABASE : i32 = -2140995562;
pub const PEER_E_TOO_MANY_ATTRIBUTES : i32 = -2140995561;
pub const PEER_E_CONNECTION_NOT_FOUND : i32 = -2140995325;
pub const PEER_E_CONNECT_SELF : i32 = -2140995322;
pub const PEER_E_ALREADY_LISTENING : i32 = -2140995321;
pub const PEER_E_NODE_NOT_FOUND : i32 = -2140995320;
pub const PEER_E_CONNECTION_FAILED : i32 = -2140995319;
pub const PEER_E_CONNECTION_NOT_AUTHENTICATED : i32 = -2140995318;
pub const PEER_E_CONNECTION_REFUSED : i32 = -2140995317;
pub const PEER_E_CLASSIFIER_TOO_LONG : i32 = -2140995071;
pub const PEER_E_TOO_MANY_IDENTITIES : i32 = -2140995070;
pub const PEER_E_NO_KEY_ACCESS : i32 = -2140995069;
pub const PEER_E_GROUPS_EXIST : i32 = -2140995068;
pub const PEER_E_RECORD_NOT_FOUND : i32 = -2140994815;
pub const PEER_E_DATABASE_ACCESSDENIED : i32 = -2140994814;
pub const PEER_E_DBINITIALIZATION_FAILED : i32 = -2140994813;
pub const PEER_E_MAX_RECORD_SIZE_EXCEEDED : i32 = -2140994812;
pub const PEER_E_DATABASE_ALREADY_PRESENT : i32 = -2140994811;
pub const PEER_E_DATABASE_NOT_PRESENT : i32 = -2140994810;
pub const PEER_E_IDENTITY_NOT_FOUND : i32 = -2140994559;
pub const PEER_E_EVENT_HANDLE_NOT_FOUND : i32 = -2140994303;
pub const PEER_E_INVALID_SEARCH : i32 = -2140994047;
pub const PEER_E_INVALID_ATTRIBUTES : i32 = -2140994046;
pub const PEER_E_INVITATION_NOT_TRUSTED : i32 = -2140993791;
pub const PEER_E_CHAIN_TOO_LONG : i32 = -2140993789;
pub const PEER_E_INVALID_TIME_PERIOD : i32 = -2140993787;
pub const PEER_E_CIRCULAR_CHAIN_DETECTED : i32 = -2140993786;
pub const PEER_E_CERT_STORE_CORRUPTED : i32 = -2140993535;
pub const PEER_E_NO_CLOUD : i32 = -2140991487;
pub const PEER_E_CLOUD_NAME_AMBIGUOUS : i32 = -2140991483;
pub const PEER_E_INVALID_RECORD : i32 = -2140987376;
pub const PEER_E_NOT_AUTHORIZED : i32 = -2140987360;
pub const PEER_E_PASSWORD_DOES_NOT_MEET_POLICY : i32 = -2140987359;
pub const PEER_E_DEFERRED_VALIDATION : i32 = -2140987344;
pub const PEER_E_INVALID_GROUP_PROPERTIES : i32 = -2140987328;
pub const PEER_E_INVALID_PEER_NAME : i32 = -2140987312;
pub const PEER_E_INVALID_CLASSIFIER : i32 = -2140987296;
pub const PEER_E_INVALID_FRIENDLY_NAME : i32 = -2140987280;
pub const PEER_E_INVALID_ROLE_PROPERTY : i32 = -2140987279;
pub const PEER_E_INVALID_CLASSIFIER_PROPERTY : i32 = -2140987278;
pub const PEER_E_INVALID_RECORD_EXPIRATION : i32 = -2140987264;
pub const PEER_E_INVALID_CREDENTIAL_INFO : i32 = -2140987263;
pub const PEER_E_INVALID_CREDENTIAL : i32 = -2140987262;
pub const PEER_E_INVALID_RECORD_SIZE : i32 = -2140987261;
pub const PEER_E_UNSUPPORTED_VERSION : i32 = -2140987248;
pub const PEER_E_GROUP_NOT_READY : i32 = -2140987247;
pub const PEER_E_GROUP_IN_USE : i32 = -2140987246;
pub const PEER_E_INVALID_GROUP : i32 = -2140987245;
pub const PEER_E_NO_MEMBERS_FOUND : i32 = -2140987244;
pub const PEER_E_NO_MEMBER_CONNECTIONS : i32 = -2140987243;
pub const PEER_E_UNABLE_TO_LISTEN : i32 = -2140987242;
pub const PEER_E_IDENTITY_DELETED : i32 = -2140987232;
pub const PEER_E_SERVICE_NOT_AVAILABLE : i32 = -2140987231;
pub const PEER_E_CONTACT_NOT_FOUND : i32 = -2140971007;
pub const PEER_S_GRAPH_DATA_CREATED : i32 = 6488065;
pub const PEER_S_NO_EVENT_DATA : i32 = 6488066;
pub const PEER_S_ALREADY_CONNECTED : i32 = 6496256;
pub const PEER_S_SUBSCRIPTION_EXISTS : i32 = 6512640;
pub const PEER_S_NO_CONNECTIVITY : i32 = 6488069;
pub const PEER_S_ALREADY_A_MEMBER : i32 = 6488070;
pub const PEER_E_CANNOT_CONVERT_PEER_NAME : i32 = -2140979199;
pub const PEER_E_INVALID_PEER_HOST_NAME : i32 = -2140979198;
pub const PEER_E_NO_MORE : i32 = -2140979197;
pub const PEER_E_PNRP_DUPLICATE_PEER_NAME : i32 = -2140979195;
pub const PEER_E_INVITE_CANCELLED : i32 = -2140966912;
pub const PEER_E_INVITE_RESPONSE_NOT_AVAILABLE : i32 = -2140966911;
pub const PEER_E_NOT_SIGNED_IN : i32 = -2140966909;
pub const PEER_E_PRIVACY_DECLINED : i32 = -2140966908;
pub const PEER_E_TIMEOUT : i32 = -2140966907;
pub const PEER_E_INVALID_ADDRESS : i32 = -2140966905;
pub const PEER_E_FW_EXCEPTION_DISABLED : i32 = -2140966904;
pub const PEER_E_FW_BLOCKED_BY_POLICY : i32 = -2140966903;
pub const PEER_E_FW_BLOCKED_BY_SHIELDS_UP : i32 = -2140966902;
pub const PEER_E_FW_DECLINED : i32 = -2140966901;
pub const UI_E_CREATE_FAILED : i32 = -2144731135;
pub const UI_E_SHUTDOWN_CALLED : i32 = -2144731134;
pub const UI_E_ILLEGAL_REENTRANCY : i32 = -2144731133;
pub const UI_E_OBJECT_SEALED : i32 = -2144731132;
pub const UI_E_VALUE_NOT_SET : i32 = -2144731131;
pub const UI_E_VALUE_NOT_DETERMINED : i32 = -2144731130;
pub const UI_E_INVALID_OUTPUT : i32 = -2144731129;
pub const UI_E_BOOLEAN_EXPECTED : i32 = -2144731128;
pub const UI_E_DIFFERENT_OWNER : i32 = -2144731127;
pub const UI_E_AMBIGUOUS_MATCH : i32 = -2144731126;
pub const UI_E_FP_OVERFLOW : i32 = -2144731125;
pub const UI_E_WRONG_THREAD : i32 = -2144731124;
pub const UI_E_STORYBOARD_ACTIVE : i32 = -2144730879;
pub const UI_E_STORYBOARD_NOT_PLAYING : i32 = -2144730878;
pub const UI_E_START_KEYFRAME_AFTER_END : i32 = -2144730877;
pub const UI_E_END_KEYFRAME_NOT_DETERMINED : i32 = -2144730876;
pub const UI_E_LOOPS_OVERLAP : i32 = -2144730875;
pub const UI_E_TRANSITION_ALREADY_USED : i32 = -2144730874;
pub const UI_E_TRANSITION_NOT_IN_STORYBOARD : i32 = -2144730873;
pub const UI_E_TRANSITION_ECLIPSED : i32 = -2144730872;
pub const UI_E_TIME_BEFORE_LAST_UPDATE : i32 = -2144730871;
pub const UI_E_TIMER_CLIENT_ALREADY_CONNECTED : i32 = -2144730870;
pub const UI_E_INVALID_DIMENSION : i32 = -2144730869;
pub const UI_E_PRIMITIVE_OUT_OF_BOUNDS : i32 = -2144730868;
pub const UI_E_WINDOW_CLOSED : i32 = -2144730623;
pub const E_BLUETOOTH_ATT_INVALID_HANDLE : i32 = -2140864511;
pub const E_BLUETOOTH_ATT_READ_NOT_PERMITTED : i32 = -2140864510;
pub const E_BLUETOOTH_ATT_WRITE_NOT_PERMITTED : i32 = -2140864509;
pub const E_BLUETOOTH_ATT_INVALID_PDU : i32 = -2140864508;
pub const E_BLUETOOTH_ATT_INSUFFICIENT_AUTHENTICATION : i32 = -2140864507;
pub const E_BLUETOOTH_ATT_REQUEST_NOT_SUPPORTED : i32 = -2140864506;
pub const E_BLUETOOTH_ATT_INVALID_OFFSET : i32 = -2140864505;
pub const E_BLUETOOTH_ATT_INSUFFICIENT_AUTHORIZATION : i32 = -2140864504;
pub const E_BLUETOOTH_ATT_PREPARE_QUEUE_FULL : i32 = -2140864503;
pub const E_BLUETOOTH_ATT_ATTRIBUTE_NOT_FOUND : i32 = -2140864502;
pub const E_BLUETOOTH_ATT_ATTRIBUTE_NOT_LONG : i32 = -2140864501;
pub const E_BLUETOOTH_ATT_INSUFFICIENT_ENCRYPTION_KEY_SIZE : i32 = -2140864500;
pub const E_BLUETOOTH_ATT_INVALID_ATTRIBUTE_VALUE_LENGTH : i32 = -2140864499;
pub const E_BLUETOOTH_ATT_UNLIKELY : i32 = -2140864498;
pub const E_BLUETOOTH_ATT_INSUFFICIENT_ENCRYPTION : i32 = -2140864497;
pub const E_BLUETOOTH_ATT_UNSUPPORTED_GROUP_TYPE : i32 = -2140864496;
pub const E_BLUETOOTH_ATT_INSUFFICIENT_RESOURCES : i32 = -2140864495;
pub const E_BLUETOOTH_ATT_UNKNOWN_ERROR : i32 = -2140860416;
pub const E_AUDIO_ENGINE_NODE_NOT_FOUND : i32 = -2140798975;
pub const E_HDAUDIO_EMPTY_CONNECTION_LIST : i32 = -2140798974;
pub const E_HDAUDIO_CONNECTION_LIST_NOT_SUPPORTED : i32 = -2140798973;
pub const E_HDAUDIO_NO_LOGICAL_DEVICES_CREATED : i32 = -2140798972;
pub const E_HDAUDIO_NULL_LINKED_LIST_ENTRY : i32 = -2140798971;
pub const STATEREPOSITORY_E_CONCURRENCY_LOCKING_FAILURE : i32 = -2140733439;
pub const STATEREPOSITORY_E_STATEMENT_INPROGRESS : i32 = -2140733438;
pub const STATEREPOSITORY_E_CONFIGURATION_INVALID : i32 = -2140733437;
pub const STATEREPOSITORY_E_UNKNOWN_SCHEMA_VERSION : i32 = -2140733436;
pub const STATEREPOSITORY_ERROR_DICTIONARY_CORRUPTED : i32 = -2140733435;
pub const STATEREPOSITORY_E_BLOCKED : i32 = -2140733434;
pub const STATEREPOSITORY_E_BUSY_RETRY : i32 = -2140733433;
pub const STATEREPOSITORY_E_BUSY_RECOVERY_RETRY : i32 = -2140733432;
pub const STATEREPOSITORY_E_LOCKED_RETRY : i32 = -2140733431;
pub const STATEREPOSITORY_E_LOCKED_SHAREDCACHE_RETRY : i32 = -2140733430;
pub const STATEREPOSITORY_E_TRANSACTION_REQUIRED : i32 = -2140733429;
pub const STATEREPOSITORY_E_BUSY_TIMEOUT_EXCEEDED : i32 = -2140733428;
pub const STATEREPOSITORY_E_BUSY_RECOVERY_TIMEOUT_EXCEEDED : i32 = -2140733427;
pub const STATEREPOSITORY_E_LOCKED_TIMEOUT_EXCEEDED : i32 = -2140733426;
pub const STATEREPOSITORY_E_LOCKED_SHAREDCACHE_TIMEOUT_EXCEEDED : i32 = -2140733425;
pub const STATEREPOSITORY_E_SERVICE_STOP_IN_PROGRESS : i32 = -2140733424;
pub const STATEREPOSTORY_E_NESTED_TRANSACTION_NOT_SUPPORTED : i32 = -2140733423;
pub const STATEREPOSITORY_ERROR_CACHE_CORRUPTED : i32 = -2140733422;
pub const STATEREPOSITORY_TRANSACTION_CALLER_ID_CHANGED : i32 = 6750227;
pub const STATEREPOSITORY_TRANSACTION_IN_PROGRESS : i32 = 6750228;
pub const ERROR_SPACES_POOL_WAS_DELETED : i32 = 15138817;
pub const ERROR_SPACES_FAULT_DOMAIN_TYPE_INVALID : i32 = -2132344831;
pub const ERROR_SPACES_INTERNAL_ERROR : i32 = -2132344830;
pub const ERROR_SPACES_RESILIENCY_TYPE_INVALID : i32 = -2132344829;
pub const ERROR_SPACES_DRIVE_SECTOR_SIZE_INVALID : i32 = -2132344828;
pub const ERROR_SPACES_DRIVE_REDUNDANCY_INVALID : i32 = -2132344826;
pub const ERROR_SPACES_NUMBER_OF_DATA_COPIES_INVALID : i32 = -2132344825;
pub const ERROR_SPACES_PARITY_LAYOUT_INVALID : i32 = -2132344824;
pub const ERROR_SPACES_INTERLEAVE_LENGTH_INVALID : i32 = -2132344823;
pub const ERROR_SPACES_NUMBER_OF_COLUMNS_INVALID : i32 = -2132344822;
pub const ERROR_SPACES_NOT_ENOUGH_DRIVES : i32 = -2132344821;
pub const ERROR_SPACES_EXTENDED_ERROR : i32 = -2132344820;
pub const ERROR_SPACES_PROVISIONING_TYPE_INVALID : i32 = -2132344819;
pub const ERROR_SPACES_ALLOCATION_SIZE_INVALID : i32 = -2132344818;
pub const ERROR_SPACES_ENCLOSURE_AWARE_INVALID : i32 = -2132344817;
pub const ERROR_SPACES_WRITE_CACHE_SIZE_INVALID : i32 = -2132344816;
pub const ERROR_SPACES_NUMBER_OF_GROUPS_INVALID : i32 = -2132344815;
pub const ERROR_SPACES_DRIVE_OPERATIONAL_STATE_INVALID : i32 = -2132344814;
pub const ERROR_SPACES_ENTRY_INCOMPLETE : i32 = -2132344813;
pub const ERROR_SPACES_ENTRY_INVALID : i32 = -2132344812;
pub const ERROR_VOLSNAP_BOOTFILE_NOT_VALID : i32 = -2138963967;
pub const ERROR_VOLSNAP_ACTIVATION_TIMEOUT : i32 = -2138963966;
pub const ERROR_TIERING_NOT_SUPPORTED_ON_VOLUME : i32 = -2138898431;
pub const ERROR_TIERING_VOLUME_DISMOUNT_IN_PROGRESS : i32 = -2138898430;
pub const ERROR_TIERING_STORAGE_TIER_NOT_FOUND : i32 = -2138898429;
pub const ERROR_TIERING_INVALID_FILE_ID : i32 = -2138898428;
pub const ERROR_TIERING_WRONG_CLUSTER_NODE : i32 = -2138898427;
pub const ERROR_TIERING_ALREADY_PROCESSING : i32 = -2138898426;
pub const ERROR_TIERING_CANNOT_PIN_OBJECT : i32 = -2138898425;
pub const ERROR_TIERING_FILE_IS_NOT_PINNED : i32 = -2138898424;
pub const ERROR_NOT_A_TIERED_VOLUME : i32 = -2138898423;
pub const ERROR_ATTRIBUTE_NOT_PRESENT : i32 = -2138898422;
pub const ERROR_SECCORE_INVALID_COMMAND : i32 = -1058537472;
pub const ERROR_NO_APPLICABLE_APP_LICENSES_FOUND : i32 = -1058406399;
pub const ERROR_CLIP_LICENSE_NOT_FOUND : i32 = -1058406398;
pub const ERROR_CLIP_DEVICE_LICENSE_MISSING : i32 = -1058406397;
pub const ERROR_CLIP_LICENSE_INVALID_SIGNATURE : i32 = -1058406396;
pub const ERROR_CLIP_KEYHOLDER_LICENSE_MISSING_OR_INVALID : i32 = -1058406395;
pub const ERROR_CLIP_LICENSE_EXPIRED : i32 = -1058406394;
pub const ERROR_CLIP_LICENSE_SIGNED_BY_UNKNOWN_SOURCE : i32 = -1058406393;
pub const ERROR_CLIP_LICENSE_NOT_SIGNED : i32 = -1058406392;
pub const ERROR_CLIP_LICENSE_HARDWARE_ID_OUT_OF_TOLERANCE : i32 = -1058406391;
pub const ERROR_CLIP_LICENSE_DEVICE_ID_MISMATCH : i32 = -1058406390;
pub const DXGI_STATUS_OCCLUDED : i32 = 142213121;
pub const DXGI_STATUS_CLIPPED : i32 = 142213122;
pub const DXGI_STATUS_NO_REDIRECTION : i32 = 142213124;
pub const DXGI_STATUS_NO_DESKTOP_ACCESS : i32 = 142213125;
pub const DXGI_STATUS_GRAPHICS_VIDPN_SOURCE_IN_USE : i32 = 142213126;
pub const DXGI_STATUS_MODE_CHANGED : i32 = 142213127;
pub const DXGI_STATUS_MODE_CHANGE_IN_PROGRESS : i32 = 142213128;
pub const DXGI_ERROR_INVALID_CALL : i32 = -2005270527;
pub const DXGI_ERROR_NOT_FOUND : i32 = -2005270526;
pub const DXGI_ERROR_MORE_DATA : i32 = -2005270525;
pub const DXGI_ERROR_UNSUPPORTED : i32 = -2005270524;
pub const DXGI_ERROR_DEVICE_REMOVED : i32 = -2005270523;
pub const DXGI_ERROR_DEVICE_HUNG : i32 = -2005270522;
pub const DXGI_ERROR_DEVICE_RESET : i32 = -2005270521;
pub const DXGI_ERROR_WAS_STILL_DRAWING : i32 = -2005270518;
pub const DXGI_ERROR_FRAME_STATISTICS_DISJOINT : i32 = -2005270517;
pub const DXGI_ERROR_GRAPHICS_VIDPN_SOURCE_IN_USE : i32 = -2005270516;
pub const DXGI_ERROR_DRIVER_INTERNAL_ERROR : i32 = -2005270496;
pub const DXGI_ERROR_NONEXCLUSIVE : i32 = -2005270495;
pub const DXGI_ERROR_NOT_CURRENTLY_AVAILABLE : i32 = -2005270494;
pub const DXGI_ERROR_REMOTE_CLIENT_DISCONNECTED : i32 = -2005270493;
pub const DXGI_ERROR_REMOTE_OUTOFMEMORY : i32 = -2005270492;
pub const DXGI_ERROR_ACCESS_LOST : i32 = -2005270490;
pub const DXGI_ERROR_WAIT_TIMEOUT : i32 = -2005270489;
pub const DXGI_ERROR_SESSION_DISCONNECTED : i32 = -2005270488;
pub const DXGI_ERROR_RESTRICT_TO_OUTPUT_STALE : i32 = -2005270487;
pub const DXGI_ERROR_CANNOT_PROTECT_CONTENT : i32 = -2005270486;
pub const DXGI_ERROR_ACCESS_DENIED : i32 = -2005270485;
pub const DXGI_ERROR_NAME_ALREADY_EXISTS : i32 = -2005270484;
pub const DXGI_ERROR_SDK_COMPONENT_MISSING : i32 = -2005270483;
pub const DXGI_ERROR_NOT_CURRENT : i32 = -2005270482;
pub const DXGI_ERROR_HW_PROTECTION_OUTOFMEMORY : i32 = -2005270480;
pub const DXGI_ERROR_DYNAMIC_CODE_POLICY_VIOLATION : i32 = -2005270479;
pub const DXGI_ERROR_NON_COMPOSITED_UI : i32 = -2005270478;
pub const DXCORE_ERROR_EVENT_NOT_UNREGISTERED : i32 = -2004877311;
pub const DXGI_STATUS_UNOCCLUDED : i32 = 142213129;
pub const DXGI_STATUS_DDA_WAS_STILL_DRAWING : i32 = 142213130;
pub const DXGI_ERROR_MODE_CHANGE_IN_PROGRESS : i32 = -2005270491;
pub const DXGI_STATUS_PRESENT_REQUIRED : i32 = 142213167;
pub const DXGI_ERROR_CACHE_CORRUPT : i32 = -2005270477;
pub const DXGI_ERROR_CACHE_FULL : i32 = -2005270476;
pub const DXGI_ERROR_CACHE_HASH_COLLISION : i32 = -2005270475;
pub const DXGI_ERROR_ALREADY_EXISTS : i32 = -2005270474;
pub const DXGI_DDI_ERR_WASSTILLDRAWING : i32 = -2005204991;
pub const DXGI_DDI_ERR_UNSUPPORTED : i32 = -2005204990;
pub const DXGI_DDI_ERR_NONEXCLUSIVE : i32 = -2005204989;
pub const D3D10_ERROR_TOO_MANY_UNIQUE_STATE_OBJECTS : i32 = -2005336063;
pub const D3D10_ERROR_FILE_NOT_FOUND : i32 = -2005336062;
pub const D3D11_ERROR_TOO_MANY_UNIQUE_STATE_OBJECTS : i32 = -2005139455;
pub const D3D11_ERROR_FILE_NOT_FOUND : i32 = -2005139454;
pub const D3D11_ERROR_TOO_MANY_UNIQUE_VIEW_OBJECTS : i32 = -2005139453;
pub const D3D11_ERROR_DEFERRED_CONTEXT_MAP_WITHOUT_INITIAL_DISCARD : i32 = -2005139452;
pub const D3D12_ERROR_ADAPTER_NOT_FOUND : i32 = -2005008383;
pub const D3D12_ERROR_DRIVER_VERSION_MISMATCH : i32 = -2005008382;
pub const D2DERR_WRONG_STATE : i32 = -2003238911;
pub const D2DERR_NOT_INITIALIZED : i32 = -2003238910;
pub const D2DERR_UNSUPPORTED_OPERATION : i32 = -2003238909;
pub const D2DERR_SCANNER_FAILED : i32 = -2003238908;
pub const D2DERR_SCREEN_ACCESS_DENIED : i32 = -2003238907;
pub const D2DERR_DISPLAY_STATE_INVALID : i32 = -2003238906;
pub const D2DERR_ZERO_VECTOR : i32 = -2003238905;
pub const D2DERR_INTERNAL_ERROR : i32 = -2003238904;
pub const D2DERR_DISPLAY_FORMAT_NOT_SUPPORTED : i32 = -2003238903;
pub const D2DERR_INVALID_CALL : i32 = -2003238902;
pub const D2DERR_NO_HARDWARE_DEVICE : i32 = -2003238901;
pub const D2DERR_RECREATE_TARGET : i32 = -2003238900;
pub const D2DERR_TOO_MANY_SHADER_ELEMENTS : i32 = -2003238899;
pub const D2DERR_SHADER_COMPILE_FAILED : i32 = -2003238898;
pub const D2DERR_MAX_TEXTURE_SIZE_EXCEEDED : i32 = -2003238897;
pub const D2DERR_UNSUPPORTED_VERSION : i32 = -2003238896;
pub const D2DERR_BAD_NUMBER : i32 = -2003238895;
pub const D2DERR_WRONG_FACTORY : i32 = -2003238894;
pub const D2DERR_LAYER_ALREADY_IN_USE : i32 = -2003238893;
pub const D2DERR_POP_CALL_DID_NOT_MATCH_PUSH : i32 = -2003238892;
pub const D2DERR_WRONG_RESOURCE_DOMAIN : i32 = -2003238891;
pub const D2DERR_PUSH_POP_UNBALANCED : i32 = -2003238890;
pub const D2DERR_RENDER_TARGET_HAS_LAYER_OR_CLIPRECT : i32 = -2003238889;
pub const D2DERR_INCOMPATIBLE_BRUSH_TYPES : i32 = -2003238888;
pub const D2DERR_WIN32_ERROR : i32 = -2003238887;
pub const D2DERR_TARGET_NOT_GDI_COMPATIBLE : i32 = -2003238886;
pub const D2DERR_TEXT_EFFECT_IS_WRONG_TYPE : i32 = -2003238885;
pub const D2DERR_TEXT_RENDERER_NOT_RELEASED : i32 = -2003238884;
pub const D2DERR_EXCEEDS_MAX_BITMAP_SIZE : i32 = -2003238883;
pub const D2DERR_INVALID_GRAPH_CONFIGURATION : i32 = -2003238882;
pub const D2DERR_INVALID_INTERNAL_GRAPH_CONFIGURATION : i32 = -2003238881;
pub const D2DERR_CYCLIC_GRAPH : i32 = -2003238880;
pub const D2DERR_BITMAP_CANNOT_DRAW : i32 = -2003238879;
pub const D2DERR_OUTSTANDING_BITMAP_REFERENCES : i32 = -2003238878;
pub const D2DERR_ORIGINAL_TARGET_NOT_BOUND : i32 = -2003238877;
pub const D2DERR_INVALID_TARGET : i32 = -2003238876;
pub const D2DERR_BITMAP_BOUND_AS_TARGET : i32 = -2003238875;
pub const D2DERR_INSUFFICIENT_DEVICE_CAPABILITIES : i32 = -2003238874;
pub const D2DERR_INTERMEDIATE_TOO_LARGE : i32 = -2003238873;
pub const D2DERR_EFFECT_IS_NOT_REGISTERED : i32 = -2003238872;
pub const D2DERR_INVALID_PROPERTY : i32 = -2003238871;
pub const D2DERR_NO_SUBPROPERTIES : i32 = -2003238870;
pub const D2DERR_PRINT_JOB_CLOSED : i32 = -2003238869;
pub const D2DERR_PRINT_FORMAT_NOT_SUPPORTED : i32 = -2003238868;
pub const D2DERR_TOO_MANY_TRANSFORM_INPUTS : i32 = -2003238867;
pub const D2DERR_INVALID_GLYPH_IMAGE : i32 = -2003238866;
pub const DWRITE_E_FILEFORMAT : i32 = -2003283968;
pub const DWRITE_E_UNEXPECTED : i32 = -2003283967;
pub const DWRITE_E_NOFONT : i32 = -2003283966;
pub const DWRITE_E_FILENOTFOUND : i32 = -2003283965;
pub const DWRITE_E_FILEACCESS : i32 = -2003283964;
pub const DWRITE_E_FONTCOLLECTIONOBSOLETE : i32 = -2003283963;
pub const DWRITE_E_ALREADYREGISTERED : i32 = -2003283962;
pub const DWRITE_E_CACHEFORMAT : i32 = -2003283961;
pub const DWRITE_E_CACHEVERSION : i32 = -2003283960;
pub const DWRITE_E_UNSUPPORTEDOPERATION : i32 = -2003283959;
pub const DWRITE_E_TEXTRENDERERINCOMPATIBLE : i32 = -2003283958;
pub const DWRITE_E_FLOWDIRECTIONCONFLICTS : i32 = -2003283957;
pub const DWRITE_E_NOCOLOR : i32 = -2003283956;
pub const DWRITE_E_REMOTEFONT : i32 = -2003283955;
pub const DWRITE_E_DOWNLOADCANCELLED : i32 = -2003283954;
pub const DWRITE_E_DOWNLOADFAILED : i32 = -2003283953;
pub const DWRITE_E_TOOMANYDOWNLOADS : i32 = -2003283952;
pub const WINCODEC_ERR_WRONGSTATE : i32 = -2003292412;
pub const WINCODEC_ERR_VALUEOUTOFRANGE : i32 = -2003292411;
pub const WINCODEC_ERR_UNKNOWNIMAGEFORMAT : i32 = -2003292409;
pub const WINCODEC_ERR_UNSUPPORTEDVERSION : i32 = -2003292405;
pub const WINCODEC_ERR_NOTINITIALIZED : i32 = -2003292404;
pub const WINCODEC_ERR_ALREADYLOCKED : i32 = -2003292403;
pub const WINCODEC_ERR_PROPERTYNOTFOUND : i32 = -2003292352;
pub const WINCODEC_ERR_PROPERTYNOTSUPPORTED : i32 = -2003292351;
pub const WINCODEC_ERR_PROPERTYSIZE : i32 = -2003292350;
pub const WINCODEC_ERR_CODECPRESENT : i32 = -2003292349;
pub const WINCODEC_ERR_CODECNOTHUMBNAIL : i32 = -2003292348;
pub const WINCODEC_ERR_PALETTEUNAVAILABLE : i32 = -2003292347;
pub const WINCODEC_ERR_CODECTOOMANYSCANLINES : i32 = -2003292346;
pub const WINCODEC_ERR_INTERNALERROR : i32 = -2003292344;
pub const WINCODEC_ERR_SOURCERECTDOESNOTMATCHDIMENSIONS : i32 = -2003292343;
pub const WINCODEC_ERR_COMPONENTNOTFOUND : i32 = -2003292336;
pub const WINCODEC_ERR_IMAGESIZEOUTOFRANGE : i32 = -2003292335;
pub const WINCODEC_ERR_TOOMUCHMETADATA : i32 = -2003292334;
pub const WINCODEC_ERR_BADIMAGE : i32 = -2003292320;
pub const WINCODEC_ERR_BADHEADER : i32 = -2003292319;
pub const WINCODEC_ERR_FRAMEMISSING : i32 = -2003292318;
pub const WINCODEC_ERR_BADMETADATAHEADER : i32 = -2003292317;
pub const WINCODEC_ERR_BADSTREAMDATA : i32 = -2003292304;
pub const WINCODEC_ERR_STREAMWRITE : i32 = -2003292303;
pub const WINCODEC_ERR_STREAMREAD : i32 = -2003292302;
pub const WINCODEC_ERR_STREAMNOTAVAILABLE : i32 = -2003292301;
pub const WINCODEC_ERR_UNSUPPORTEDPIXELFORMAT : i32 = -2003292288;
pub const WINCODEC_ERR_UNSUPPORTEDOPERATION : i32 = -2003292287;
pub const WINCODEC_ERR_INVALIDREGISTRATION : i32 = -2003292278;
pub const WINCODEC_ERR_COMPONENTINITIALIZEFAILURE : i32 = -2003292277;
pub const WINCODEC_ERR_INSUFFICIENTBUFFER : i32 = -2003292276;
pub const WINCODEC_ERR_DUPLICATEMETADATAPRESENT : i32 = -2003292275;
pub const WINCODEC_ERR_PROPERTYUNEXPECTEDTYPE : i32 = -2003292274;
pub const WINCODEC_ERR_UNEXPECTEDSIZE : i32 = -2003292273;
pub const WINCODEC_ERR_INVALIDQUERYREQUEST : i32 = -2003292272;
pub const WINCODEC_ERR_UNEXPECTEDMETADATATYPE : i32 = -2003292271;
pub const WINCODEC_ERR_REQUESTONLYVALIDATMETADATAROOT : i32 = -2003292270;
pub const WINCODEC_ERR_INVALIDQUERYCHARACTER : i32 = -2003292269;
pub const WINCODEC_ERR_WIN32ERROR : i32 = -2003292268;
pub const WINCODEC_ERR_INVALIDPROGRESSIVELEVEL : i32 = -2003292267;
pub const WINCODEC_ERR_INVALIDJPEGSCANINDEX : i32 = -2003292266;
pub const MILERR_OBJECTBUSY : i32 = -2003304447;
pub const MILERR_INSUFFICIENTBUFFER : i32 = -2003304446;
pub const MILERR_WIN32ERROR : i32 = -2003304445;
pub const MILERR_SCANNER_FAILED : i32 = -2003304444;
pub const MILERR_SCREENACCESSDENIED : i32 = -2003304443;
pub const MILERR_DISPLAYSTATEINVALID : i32 = -2003304442;
pub const MILERR_NONINVERTIBLEMATRIX : i32 = -2003304441;
pub const MILERR_ZEROVECTOR : i32 = -2003304440;
pub const MILERR_TERMINATED : i32 = -2003304439;
pub const MILERR_BADNUMBER : i32 = -2003304438;
pub const MILERR_INTERNALERROR : i32 = -2003304320;
pub const MILERR_DISPLAYFORMATNOTSUPPORTED : i32 = -2003304316;
pub const MILERR_INVALIDCALL : i32 = -2003304315;
pub const MILERR_ALREADYLOCKED : i32 = -2003304314;
pub const MILERR_NOTLOCKED : i32 = -2003304313;
pub const MILERR_DEVICECANNOTRENDERTEXT : i32 = -2003304312;
pub const MILERR_GLYPHBITMAPMISSED : i32 = -2003304311;
pub const MILERR_MALFORMEDGLYPHCACHE : i32 = -2003304310;
pub const MILERR_GENERIC_IGNORE : i32 = -2003304309;
pub const MILERR_MALFORMED_GUIDELINE_DATA : i32 = -2003304308;
pub const MILERR_NO_HARDWARE_DEVICE : i32 = -2003304307;
pub const MILERR_NEED_RECREATE_AND_PRESENT : i32 = -2003304306;
pub const MILERR_ALREADY_INITIALIZED : i32 = -2003304305;
pub const MILERR_MISMATCHED_SIZE : i32 = -2003304304;
pub const MILERR_NO_REDIRECTION_SURFACE_AVAILABLE : i32 = -2003304303;
pub const MILERR_REMOTING_NOT_SUPPORTED : i32 = -2003304302;
pub const MILERR_QUEUED_PRESENT_NOT_SUPPORTED : i32 = -2003304301;
pub const MILERR_NOT_QUEUING_PRESENTS : i32 = -2003304300;
pub const MILERR_NO_REDIRECTION_SURFACE_RETRY_LATER : i32 = -2003304299;
pub const MILERR_TOOMANYSHADERELEMNTS : i32 = -2003304298;
pub const MILERR_MROW_READLOCK_FAILED : i32 = -2003304297;
pub const MILERR_MROW_UPDATE_FAILED : i32 = -2003304296;
pub const MILERR_SHADER_COMPILE_FAILED : i32 = -2003304295;
pub const MILERR_MAX_TEXTURE_SIZE_EXCEEDED : i32 = -2003304294;
pub const MILERR_QPC_TIME_WENT_BACKWARD : i32 = -2003304293;
pub const MILERR_DXGI_ENUMERATION_OUT_OF_SYNC : i32 = -2003304291;
pub const MILERR_ADAPTER_NOT_FOUND : i32 = -2003304290;
pub const MILERR_COLORSPACE_NOT_SUPPORTED : i32 = -2003304289;
pub const MILERR_PREFILTER_NOT_SUPPORTED : i32 = -2003304288;
pub const MILERR_DISPLAYID_ACCESS_DENIED : i32 = -2003304287;
pub const UCEERR_INVALIDPACKETHEADER : i32 = -2003303424;
pub const UCEERR_UNKNOWNPACKET : i32 = -2003303423;
pub const UCEERR_ILLEGALPACKET : i32 = -2003303422;
pub const UCEERR_MALFORMEDPACKET : i32 = -2003303421;
pub const UCEERR_ILLEGALHANDLE : i32 = -2003303420;
pub const UCEERR_HANDLELOOKUPFAILED : i32 = -2003303419;
pub const UCEERR_RENDERTHREADFAILURE : i32 = -2003303418;
pub const UCEERR_CTXSTACKFRSTTARGETNULL : i32 = -2003303417;
pub const UCEERR_CONNECTIONIDLOOKUPFAILED : i32 = -2003303416;
pub const UCEERR_BLOCKSFULL : i32 = -2003303415;
pub const UCEERR_MEMORYFAILURE : i32 = -2003303414;
pub const UCEERR_PACKETRECORDOUTOFRANGE : i32 = -2003303413;
pub const UCEERR_ILLEGALRECORDTYPE : i32 = -2003303412;
pub const UCEERR_OUTOFHANDLES : i32 = -2003303411;
pub const UCEERR_UNCHANGABLE_UPDATE_ATTEMPTED : i32 = -2003303410;
pub const UCEERR_NO_MULTIPLE_WORKER_THREADS : i32 = -2003303409;
pub const UCEERR_REMOTINGNOTSUPPORTED : i32 = -2003303408;
pub const UCEERR_MISSINGENDCOMMAND : i32 = -2003303407;
pub const UCEERR_MISSINGBEGINCOMMAND : i32 = -2003303406;
pub const UCEERR_CHANNELSYNCTIMEDOUT : i32 = -2003303405;
pub const UCEERR_CHANNELSYNCABANDONED : i32 = -2003303404;
pub const UCEERR_UNSUPPORTEDTRANSPORTVERSION : i32 = -2003303403;
pub const UCEERR_TRANSPORTUNAVAILABLE : i32 = -2003303402;
pub const UCEERR_FEEDBACK_UNSUPPORTED : i32 = -2003303401;
pub const UCEERR_COMMANDTRANSPORTDENIED : i32 = -2003303400;
pub const UCEERR_GRAPHICSSTREAMUNAVAILABLE : i32 = -2003303399;
pub const UCEERR_GRAPHICSSTREAMALREADYOPEN : i32 = -2003303392;
pub const UCEERR_TRANSPORTDISCONNECTED : i32 = -2003303391;
pub const UCEERR_TRANSPORTOVERLOADED : i32 = -2003303390;
pub const UCEERR_PARTITION_ZOMBIED : i32 = -2003303389;
pub const MILAVERR_NOCLOCK : i32 = -2003303168;
pub const MILAVERR_NOMEDIATYPE : i32 = -2003303167;
pub const MILAVERR_NOVIDEOMIXER : i32 = -2003303166;
pub const MILAVERR_NOVIDEOPRESENTER : i32 = -2003303165;
pub const MILAVERR_NOREADYFRAMES : i32 = -2003303164;
pub const MILAVERR_MODULENOTLOADED : i32 = -2003303163;
pub const MILAVERR_WMPFACTORYNOTREGISTERED : i32 = -2003303162;
pub const MILAVERR_INVALIDWMPVERSION : i32 = -2003303161;
pub const MILAVERR_INSUFFICIENTVIDEORESOURCES : i32 = -2003303160;
pub const MILAVERR_VIDEOACCELERATIONNOTAVAILABLE : i32 = -2003303159;
pub const MILAVERR_REQUESTEDTEXTURETOOBIG : i32 = -2003303158;
pub const MILAVERR_SEEKFAILED : i32 = -2003303157;
pub const MILAVERR_UNEXPECTEDWMPFAILURE : i32 = -2003303156;
pub const MILAVERR_MEDIAPLAYERCLOSED : i32 = -2003303155;
pub const MILAVERR_UNKNOWNHARDWAREERROR : i32 = -2003303154;
pub const MILEFFECTSERR_UNKNOWNPROPERTY : i32 = -2003302898;
pub const MILEFFECTSERR_EFFECTNOTPARTOFGROUP : i32 = -2003302897;
pub const MILEFFECTSERR_NOINPUTSOURCEATTACHED : i32 = -2003302896;
pub const MILEFFECTSERR_CONNECTORNOTCONNECTED : i32 = -2003302895;
pub const MILEFFECTSERR_CONNECTORNOTASSOCIATEDWITHEFFECT : i32 = -2003302894;
pub const MILEFFECTSERR_RESERVED : i32 = -2003302893;
pub const MILEFFECTSERR_CYCLEDETECTED : i32 = -2003302892;
pub const MILEFFECTSERR_EFFECTINMORETHANONEGRAPH : i32 = -2003302891;
pub const MILEFFECTSERR_EFFECTALREADYINAGRAPH : i32 = -2003302890;
pub const MILEFFECTSERR_EFFECTHASNOCHILDREN : i32 = -2003302889;
pub const MILEFFECTSERR_ALREADYATTACHEDTOLISTENER : i32 = -2003302888;
pub const MILEFFECTSERR_NOTAFFINETRANSFORM : i32 = -2003302887;
pub const MILEFFECTSERR_EMPTYBOUNDS : i32 = -2003302886;
pub const MILEFFECTSERR_OUTPUTSIZETOOLARGE : i32 = -2003302885;
pub const DWMERR_STATE_TRANSITION_FAILED : i32 = -2003302656;
pub const DWMERR_THEME_FAILED : i32 = -2003302655;
pub const DWMERR_CATASTROPHIC_FAILURE : i32 = -2003302654;
pub const DCOMPOSITION_ERROR_WINDOW_ALREADY_COMPOSED : i32 = -2003302400;
pub const DCOMPOSITION_ERROR_SURFACE_BEING_RENDERED : i32 = -2003302399;
pub const DCOMPOSITION_ERROR_SURFACE_NOT_BEING_RENDERED : i32 = -2003302398;
pub const ONL_E_INVALID_AUTHENTICATION_TARGET : i32 = -2138701823;
pub const ONL_E_ACCESS_DENIED_BY_TOU : i32 = -2138701822;
pub const ONL_E_INVALID_APPLICATION : i32 = -2138701821;
pub const ONL_E_PASSWORD_UPDATE_REQUIRED : i32 = -2138701820;
pub const ONL_E_ACCOUNT_UPDATE_REQUIRED : i32 = -2138701819;
pub const ONL_E_FORCESIGNIN : i32 = -2138701818;
pub const ONL_E_ACCOUNT_LOCKED : i32 = -2138701817;
pub const ONL_E_PARENTAL_CONSENT_REQUIRED : i32 = -2138701816;
pub const ONL_E_EMAIL_VERIFICATION_REQUIRED : i32 = -2138701815;
pub const ONL_E_ACCOUNT_SUSPENDED_COMPROIMISE : i32 = -2138701814;
pub const ONL_E_ACCOUNT_SUSPENDED_ABUSE : i32 = -2138701813;
pub const ONL_E_ACTION_REQUIRED : i32 = -2138701812;
pub const ONL_CONNECTION_COUNT_LIMIT : i32 = -2138701811;
pub const ONL_E_CONNECTED_ACCOUNT_CAN_NOT_SIGNOUT : i32 = -2138701810;
pub const ONL_E_USER_AUTHENTICATION_REQUIRED : i32 = -2138701809;
pub const ONL_E_REQUEST_THROTTLED : i32 = -2138701808;
pub const FA_E_MAX_PERSISTED_ITEMS_REACHED : i32 = -2144927200;
pub const FA_E_HOMEGROUP_NOT_AVAILABLE : i32 = -2144927198;
pub const E_MONITOR_RESOLUTION_TOO_LOW : i32 = -2144927152;
pub const E_ELEVATED_ACTIVATION_NOT_SUPPORTED : i32 = -2144927151;
pub const E_UAC_DISABLED : i32 = -2144927150;
pub const E_FULL_ADMIN_NOT_SUPPORTED : i32 = -2144927149;
pub const E_APPLICATION_NOT_REGISTERED : i32 = -2144927148;
pub const E_MULTIPLE_EXTENSIONS_FOR_APPLICATION : i32 = -2144927147;
pub const E_MULTIPLE_PACKAGES_FOR_FAMILY : i32 = -2144927146;
pub const E_APPLICATION_MANAGER_NOT_RUNNING : i32 = -2144927145;
pub const S_STORE_LAUNCHED_FOR_REMEDIATION : i32 = 2556504;
pub const S_APPLICATION_ACTIVATION_ERROR_HANDLED_BY_DIALOG : i32 = 2556505;
pub const E_APPLICATION_ACTIVATION_TIMED_OUT : i32 = -2144927142;
pub const E_APPLICATION_ACTIVATION_EXEC_FAILURE : i32 = -2144927141;
pub const E_APPLICATION_TEMPORARY_LICENSE_ERROR : i32 = -2144927140;
pub const E_APPLICATION_TRIAL_LICENSE_EXPIRED : i32 = -2144927139;
pub const E_SKYDRIVE_ROOT_TARGET_FILE_SYSTEM_NOT_SUPPORTED : i32 = -2144927136;
pub const E_SKYDRIVE_ROOT_TARGET_OVERLAP : i32 = -2144927135;
pub const E_SKYDRIVE_ROOT_TARGET_CANNOT_INDEX : i32 = -2144927134;
pub const E_SKYDRIVE_FILE_NOT_UPLOADED : i32 = -2144927133;
pub const E_SKYDRIVE_UPDATE_AVAILABILITY_FAIL : i32 = -2144927132;
pub const E_SKYDRIVE_ROOT_TARGET_VOLUME_ROOT_NOT_SUPPORTED : i32 = -2144927131;
pub const E_SYNCENGINE_FILE_SIZE_OVER_LIMIT : i32 = -2013089791;
pub const E_SYNCENGINE_FILE_SIZE_EXCEEDS_REMAINING_QUOTA : i32 = -2013089790;
pub const E_SYNCENGINE_UNSUPPORTED_FILE_NAME : i32 = -2013089789;
pub const E_SYNCENGINE_FOLDER_ITEM_COUNT_LIMIT_EXCEEDED : i32 = -2013089788;
pub const E_SYNCENGINE_FILE_SYNC_PARTNER_ERROR : i32 = -2013089787;
pub const E_SYNCENGINE_SYNC_PAUSED_BY_SERVICE : i32 = -2013089786;
pub const E_SYNCENGINE_FILE_IDENTIFIER_UNKNOWN : i32 = -2013085694;
pub const E_SYNCENGINE_SERVICE_AUTHENTICATION_FAILED : i32 = -2013085693;
pub const E_SYNCENGINE_UNKNOWN_SERVICE_ERROR : i32 = -2013085692;
pub const E_SYNCENGINE_SERVICE_RETURNED_UNEXPECTED_SIZE : i32 = -2013085691;
pub const E_SYNCENGINE_REQUEST_BLOCKED_BY_SERVICE : i32 = -2013085690;
pub const E_SYNCENGINE_REQUEST_BLOCKED_DUE_TO_CLIENT_ERROR : i32 = -2013085689;
pub const E_SYNCENGINE_FOLDER_INACCESSIBLE : i32 = -2013081599;
pub const E_SYNCENGINE_UNSUPPORTED_FOLDER_NAME : i32 = -2013081598;
pub const E_SYNCENGINE_UNSUPPORTED_MARKET : i32 = -2013081597;
pub const E_SYNCENGINE_PATH_LENGTH_LIMIT_EXCEEDED : i32 = -2013081596;
pub const E_SYNCENGINE_REMOTE_PATH_LENGTH_LIMIT_EXCEEDED : i32 = -2013081595;
pub const E_SYNCENGINE_CLIENT_UPDATE_NEEDED : i32 = -2013081594;
pub const E_SYNCENGINE_PROXY_AUTHENTICATION_REQUIRED : i32 = -2013081593;
pub const E_SYNCENGINE_STORAGE_SERVICE_PROVISIONING_FAILED : i32 = -2013081592;
pub const E_SYNCENGINE_UNSUPPORTED_REPARSE_POINT : i32 = -2013081591;
pub const E_SYNCENGINE_STORAGE_SERVICE_BLOCKED : i32 = -2013081590;
pub const E_SYNCENGINE_FOLDER_IN_REDIRECTION : i32 = -2013081589;
pub const EAS_E_POLICY_NOT_MANAGED_BY_OS : i32 = -2141913087;
pub const EAS_E_POLICY_COMPLIANT_WITH_ACTIONS : i32 = -2141913086;
pub const EAS_E_REQUESTED_POLICY_NOT_ENFORCEABLE : i32 = -2141913085;
pub const EAS_E_CURRENT_USER_HAS_BLANK_PASSWORD : i32 = -2141913084;
pub const EAS_E_REQUESTED_POLICY_PASSWORD_EXPIRATION_INCOMPATIBLE : i32 = -2141913083;
pub const EAS_E_USER_CANNOT_CHANGE_PASSWORD : i32 = -2141913082;
pub const EAS_E_ADMINS_HAVE_BLANK_PASSWORD : i32 = -2141913081;
pub const EAS_E_ADMINS_CANNOT_CHANGE_PASSWORD : i32 = -2141913080;
pub const EAS_E_LOCAL_CONTROLLED_USERS_CANNOT_CHANGE_PASSWORD : i32 = -2141913079;
pub const EAS_E_PASSWORD_POLICY_NOT_ENFORCEABLE_FOR_CONNECTED_ADMINS : i32 = -2141913078;
pub const EAS_E_CONNECTED_ADMINS_NEED_TO_CHANGE_PASSWORD : i32 = -2141913077;
pub const EAS_E_PASSWORD_POLICY_NOT_ENFORCEABLE_FOR_CURRENT_CONNECTED_USER : i32 = -2141913076;
pub const EAS_E_CURRENT_CONNECTED_USER_NEED_TO_CHANGE_PASSWORD : i32 = -2141913075;
pub const WEB_E_UNSUPPORTED_FORMAT : i32 = -2089484287;
pub const WEB_E_INVALID_XML : i32 = -2089484286;
pub const WEB_E_MISSING_REQUIRED_ELEMENT : i32 = -2089484285;
pub const WEB_E_MISSING_REQUIRED_ATTRIBUTE : i32 = -2089484284;
pub const WEB_E_UNEXPECTED_CONTENT : i32 = -2089484283;
pub const WEB_E_RESOURCE_TOO_LARGE : i32 = -2089484282;
pub const WEB_E_INVALID_JSON_STRING : i32 = -2089484281;
pub const WEB_E_INVALID_JSON_NUMBER : i32 = -2089484280;
pub const WEB_E_JSON_VALUE_NOT_FOUND : i32 = -2089484279;
pub const HTTP_E_STATUS_UNEXPECTED : i32 = -2145845247;
pub const HTTP_E_STATUS_UNEXPECTED_REDIRECTION : i32 = -2145845245;
pub const HTTP_E_STATUS_UNEXPECTED_CLIENT_ERROR : i32 = -2145845244;
pub const HTTP_E_STATUS_UNEXPECTED_SERVER_ERROR : i32 = -2145845243;
pub const HTTP_E_STATUS_AMBIGUOUS : i32 = -2145844948;
pub const HTTP_E_STATUS_MOVED : i32 = -2145844947;
pub const HTTP_E_STATUS_REDIRECT : i32 = -2145844946;
pub const HTTP_E_STATUS_REDIRECT_METHOD : i32 = -2145844945;
pub const HTTP_E_STATUS_NOT_MODIFIED : i32 = -2145844944;
pub const HTTP_E_STATUS_USE_PROXY : i32 = -2145844943;
pub const HTTP_E_STATUS_REDIRECT_KEEP_VERB : i32 = -2145844941;
pub const HTTP_E_STATUS_BAD_REQUEST : i32 = -2145844848;
pub const HTTP_E_STATUS_DENIED : i32 = -2145844847;
pub const HTTP_E_STATUS_PAYMENT_REQ : i32 = -2145844846;
pub const HTTP_E_STATUS_FORBIDDEN : i32 = -2145844845;
pub const HTTP_E_STATUS_NOT_FOUND : i32 = -2145844844;
pub const HTTP_E_STATUS_BAD_METHOD : i32 = -2145844843;
pub const HTTP_E_STATUS_NONE_ACCEPTABLE : i32 = -2145844842;
pub const HTTP_E_STATUS_PROXY_AUTH_REQ : i32 = -2145844841;
pub const HTTP_E_STATUS_REQUEST_TIMEOUT : i32 = -2145844840;
pub const HTTP_E_STATUS_CONFLICT : i32 = -2145844839;
pub const HTTP_E_STATUS_GONE : i32 = -2145844838;
pub const HTTP_E_STATUS_LENGTH_REQUIRED : i32 = -2145844837;
pub const HTTP_E_STATUS_PRECOND_FAILED : i32 = -2145844836;
pub const HTTP_E_STATUS_REQUEST_TOO_LARGE : i32 = -2145844835;
pub const HTTP_E_STATUS_URI_TOO_LONG : i32 = -2145844834;
pub const HTTP_E_STATUS_UNSUPPORTED_MEDIA : i32 = -2145844833;
pub const HTTP_E_STATUS_RANGE_NOT_SATISFIABLE : i32 = -2145844832;
pub const HTTP_E_STATUS_EXPECTATION_FAILED : i32 = -2145844831;
pub const HTTP_E_STATUS_SERVER_ERROR : i32 = -2145844748;
pub const HTTP_E_STATUS_NOT_SUPPORTED : i32 = -2145844747;
pub const HTTP_E_STATUS_BAD_GATEWAY : i32 = -2145844746;
pub const HTTP_E_STATUS_SERVICE_UNAVAIL : i32 = -2145844745;
pub const HTTP_E_STATUS_GATEWAY_TIMEOUT : i32 = -2145844744;
pub const HTTP_E_STATUS_VERSION_NOT_SUP : i32 = -2145844743;
pub const E_INVALID_PROTOCOL_OPERATION : i32 = -2089418751;
pub const E_INVALID_PROTOCOL_FORMAT : i32 = -2089418750;
pub const E_PROTOCOL_EXTENSIONS_NOT_SUPPORTED : i32 = -2089418749;
pub const E_SUBPROTOCOL_NOT_SUPPORTED : i32 = -2089418748;
pub const E_PROTOCOL_VERSION_NOT_SUPPORTED : i32 = -2089418747;
pub const INPUT_E_OUT_OF_ORDER : i32 = -2143289344;
pub const INPUT_E_REENTRANCY : i32 = -2143289343;
pub const INPUT_E_MULTIMODAL : i32 = -2143289342;
pub const INPUT_E_PACKET : i32 = -2143289341;
pub const INPUT_E_FRAME : i32 = -2143289340;
pub const INPUT_E_HISTORY : i32 = -2143289339;
pub const INPUT_E_DEVICE_INFO : i32 = -2143289338;
pub const INPUT_E_TRANSFORM : i32 = -2143289337;
pub const INPUT_E_DEVICE_PROPERTY : i32 = -2143289336;
pub const INET_E_INVALID_URL : i32 = -2146697214;
pub const INET_E_NO_SESSION : i32 = -2146697213;
pub const INET_E_CANNOT_CONNECT : i32 = -2146697212;
pub const INET_E_RESOURCE_NOT_FOUND : i32 = -2146697211;
pub const INET_E_OBJECT_NOT_FOUND : i32 = -2146697210;
pub const INET_E_DATA_NOT_AVAILABLE : i32 = -2146697209;
pub const INET_E_DOWNLOAD_FAILURE : i32 = -2146697208;
pub const INET_E_AUTHENTICATION_REQUIRED : i32 = -2146697207;
pub const INET_E_NO_VALID_MEDIA : i32 = -2146697206;
pub const INET_E_CONNECTION_TIMEOUT : i32 = -2146697205;
pub const INET_E_INVALID_REQUEST : i32 = -2146697204;
pub const INET_E_UNKNOWN_PROTOCOL : i32 = -2146697203;
pub const INET_E_SECURITY_PROBLEM : i32 = -2146697202;
pub const INET_E_CANNOT_LOAD_DATA : i32 = -2146697201;
pub const INET_E_CANNOT_INSTANTIATE_OBJECT : i32 = -2146697200;
pub const INET_E_INVALID_CERTIFICATE : i32 = -2146697191;
pub const INET_E_REDIRECT_FAILED : i32 = -2146697196;
pub const INET_E_REDIRECT_TO_DIR : i32 = -2146697195;
pub const ERROR_DBG_CREATE_PROCESS_FAILURE_LOCKDOWN : i32 = -2135949311;
pub const ERROR_DBG_ATTACH_PROCESS_FAILURE_LOCKDOWN : i32 = -2135949310;
pub const ERROR_DBG_CONNECT_SERVER_FAILURE_LOCKDOWN : i32 = -2135949309;
pub const ERROR_DBG_START_SERVER_FAILURE_LOCKDOWN : i32 = -2135949308;
pub const ERROR_IO_PREEMPTED : i32 = -1996423167;
pub const JSCRIPT_E_CANTEXECUTE : i32 = -1996357631;
pub const WEP_E_NOT_PROVISIONED_ON_ALL_VOLUMES : i32 = -2013200383;
pub const WEP_E_FIXED_DATA_NOT_SUPPORTED : i32 = -2013200382;
pub const WEP_E_HARDWARE_NOT_COMPLIANT : i32 = -2013200381;
pub const WEP_E_LOCK_NOT_CONFIGURED : i32 = -2013200380;
pub const WEP_E_PROTECTION_SUSPENDED : i32 = -2013200379;
pub const WEP_E_NO_LICENSE : i32 = -2013200378;
pub const WEP_E_OS_NOT_PROTECTED : i32 = -2013200377;
pub const WEP_E_UNEXPECTED_FAIL : i32 = -2013200376;
pub const WEP_E_BUFFER_TOO_LARGE : i32 = -2013200375;
pub const ERROR_SVHDX_ERROR_STORED : i32 = -1067712512;
pub const ERROR_SVHDX_ERROR_NOT_AVAILABLE : i32 = -1067647232;
pub const ERROR_SVHDX_UNIT_ATTENTION_AVAILABLE : i32 = -1067647231;
pub const ERROR_SVHDX_UNIT_ATTENTION_CAPACITY_DATA_CHANGED : i32 = -1067647230;
pub const ERROR_SVHDX_UNIT_ATTENTION_RESERVATIONS_PREEMPTED : i32 = -1067647229;
pub const ERROR_SVHDX_UNIT_ATTENTION_RESERVATIONS_RELEASED : i32 = -1067647228;
pub const ERROR_SVHDX_UNIT_ATTENTION_REGISTRATIONS_PREEMPTED : i32 = -1067647227;
pub const ERROR_SVHDX_UNIT_ATTENTION_OPERATING_DEFINITION_CHANGED : i32 = -1067647226;
pub const ERROR_SVHDX_RESERVATION_CONFLICT : i32 = -1067647225;
pub const ERROR_SVHDX_WRONG_FILE_TYPE : i32 = -1067647224;
pub const ERROR_SVHDX_VERSION_MISMATCH : i32 = -1067647223;
pub const ERROR_VHD_SHARED : i32 = -1067647222;
pub const ERROR_SVHDX_NO_INITIATOR : i32 = -1067647221;
pub const ERROR_VHDSET_BACKING_STORAGE_NOT_FOUND : i32 = -1067647220;
pub const ERROR_SMB_NO_PREAUTH_INTEGRITY_HASH_OVERLAP : i32 = -1067646976;
pub const ERROR_SMB_BAD_CLUSTER_DIALECT : i32 = -1067646975;
pub const WININET_E_OUT_OF_HANDLES : i32 = -2147012895;
pub const WININET_E_TIMEOUT : i32 = -2147012894;
pub const WININET_E_EXTENDED_ERROR : i32 = -2147012893;
pub const WININET_E_INTERNAL_ERROR : i32 = -2147012892;
pub const WININET_E_INVALID_URL : i32 = -2147012891;
pub const WININET_E_UNRECOGNIZED_SCHEME : i32 = -2147012890;
pub const WININET_E_NAME_NOT_RESOLVED : i32 = -2147012889;
pub const WININET_E_PROTOCOL_NOT_FOUND : i32 = -2147012888;
pub const WININET_E_INVALID_OPTION : i32 = -2147012887;
pub const WININET_E_BAD_OPTION_LENGTH : i32 = -2147012886;
pub const WININET_E_OPTION_NOT_SETTABLE : i32 = -2147012885;
pub const WININET_E_SHUTDOWN : i32 = -2147012884;
pub const WININET_E_INCORRECT_USER_NAME : i32 = -2147012883;
pub const WININET_E_INCORRECT_PASSWORD : i32 = -2147012882;
pub const WININET_E_LOGIN_FAILURE : i32 = -2147012881;
pub const WININET_E_INVALID_OPERATION : i32 = -2147012880;
pub const WININET_E_OPERATION_CANCELLED : i32 = -2147012879;
pub const WININET_E_INCORRECT_HANDLE_TYPE : i32 = -2147012878;
pub const WININET_E_INCORRECT_HANDLE_STATE : i32 = -2147012877;
pub const WININET_E_NOT_PROXY_REQUEST : i32 = -2147012876;
pub const WININET_E_REGISTRY_VALUE_NOT_FOUND : i32 = -2147012875;
pub const WININET_E_BAD_REGISTRY_PARAMETER : i32 = -2147012874;
pub const WININET_E_NO_DIRECT_ACCESS : i32 = -2147012873;
pub const WININET_E_NO_CONTEXT : i32 = -2147012872;
pub const WININET_E_NO_CALLBACK : i32 = -2147012871;
pub const WININET_E_REQUEST_PENDING : i32 = -2147012870;
pub const WININET_E_INCORRECT_FORMAT : i32 = -2147012869;
pub const WININET_E_ITEM_NOT_FOUND : i32 = -2147012868;
pub const WININET_E_CANNOT_CONNECT : i32 = -2147012867;
pub const WININET_E_CONNECTION_ABORTED : i32 = -2147012866;
pub const WININET_E_CONNECTION_RESET : i32 = -2147012865;
pub const WININET_E_FORCE_RETRY : i32 = -2147012864;
pub const WININET_E_INVALID_PROXY_REQUEST : i32 = -2147012863;
pub const WININET_E_NEED_UI : i32 = -2147012862;
pub const WININET_E_HANDLE_EXISTS : i32 = -2147012860;
pub const WININET_E_SEC_CERT_DATE_INVALID : i32 = -2147012859;
pub const WININET_E_SEC_CERT_CN_INVALID : i32 = -2147012858;
pub const WININET_E_HTTP_TO_HTTPS_ON_REDIR : i32 = -2147012857;
pub const WININET_E_HTTPS_TO_HTTP_ON_REDIR : i32 = -2147012856;
pub const WININET_E_MIXED_SECURITY : i32 = -2147012855;
pub const WININET_E_CHG_POST_IS_NON_SECURE : i32 = -2147012854;
pub const WININET_E_POST_IS_NON_SECURE : i32 = -2147012853;
pub const WININET_E_CLIENT_AUTH_CERT_NEEDED : i32 = -2147012852;
pub const WININET_E_INVALID_CA : i32 = -2147012851;
pub const WININET_E_CLIENT_AUTH_NOT_SETUP : i32 = -2147012850;
pub const WININET_E_ASYNC_THREAD_FAILED : i32 = -2147012849;
pub const WININET_E_REDIRECT_SCHEME_CHANGE : i32 = -2147012848;
pub const WININET_E_DIALOG_PENDING : i32 = -2147012847;
pub const WININET_E_RETRY_DIALOG : i32 = -2147012846;
pub const WININET_E_NO_NEW_CONTAINERS : i32 = -2147012845;
pub const WININET_E_HTTPS_HTTP_SUBMIT_REDIR : i32 = -2147012844;
pub const WININET_E_SEC_CERT_ERRORS : i32 = -2147012841;
pub const WININET_E_SEC_CERT_REV_FAILED : i32 = -2147012839;
pub const WININET_E_HEADER_NOT_FOUND : i32 = -2147012746;
pub const WININET_E_DOWNLEVEL_SERVER : i32 = -2147012745;
pub const WININET_E_INVALID_SERVER_RESPONSE : i32 = -2147012744;
pub const WININET_E_INVALID_HEADER : i32 = -2147012743;
pub const WININET_E_INVALID_QUERY_REQUEST : i32 = -2147012742;
pub const WININET_E_HEADER_ALREADY_EXISTS : i32 = -2147012741;
pub const WININET_E_REDIRECT_FAILED : i32 = -2147012740;
pub const WININET_E_SECURITY_CHANNEL_ERROR : i32 = -2147012739;
pub const WININET_E_UNABLE_TO_CACHE_FILE : i32 = -2147012738;
pub const WININET_E_TCPIP_NOT_INSTALLED : i32 = -2147012737;
pub const WININET_E_DISCONNECTED : i32 = -2147012733;
pub const WININET_E_SERVER_UNREACHABLE : i32 = -2147012732;
pub const WININET_E_PROXY_SERVER_UNREACHABLE : i32 = -2147012731;
pub const WININET_E_BAD_AUTO_PROXY_SCRIPT : i32 = -2147012730;
pub const WININET_E_UNABLE_TO_DOWNLOAD_SCRIPT : i32 = -2147012729;
pub const WININET_E_SEC_INVALID_CERT : i32 = -2147012727;
pub const WININET_E_SEC_CERT_REVOKED : i32 = -2147012726;
pub const WININET_E_FAILED_DUETOSECURITYCHECK : i32 = -2147012725;
pub const WININET_E_NOT_INITIALIZED : i32 = -2147012724;
pub const WININET_E_LOGIN_FAILURE_DISPLAY_ENTITY_BODY : i32 = -2147012722;
pub const WININET_E_DECODING_FAILED : i32 = -2147012721;
pub const WININET_E_NOT_REDIRECTED : i32 = -2147012736;
pub const WININET_E_COOKIE_NEEDS_CONFIRMATION : i32 = -2147012735;
pub const WININET_E_COOKIE_DECLINED : i32 = -2147012734;
pub const WININET_E_REDIRECT_NEEDS_CONFIRMATION : i32 = -2147012728;
pub const SQLITE_E_ERROR : i32 = -2018574335;
pub const SQLITE_E_INTERNAL : i32 = -2018574334;
pub const SQLITE_E_PERM : i32 = -2018574333;
pub const SQLITE_E_ABORT : i32 = -2018574332;
pub const SQLITE_E_BUSY : i32 = -2018574331;
pub const SQLITE_E_LOCKED : i32 = -2018574330;
pub const SQLITE_E_NOMEM : i32 = -2018574329;
pub const SQLITE_E_READONLY : i32 = -2018574328;
pub const SQLITE_E_INTERRUPT : i32 = -2018574327;
pub const SQLITE_E_IOERR : i32 = -2018574326;
pub const SQLITE_E_CORRUPT : i32 = -2018574325;
pub const SQLITE_E_NOTFOUND : i32 = -2018574324;
pub const SQLITE_E_FULL : i32 = -2018574323;
pub const SQLITE_E_CANTOPEN : i32 = -2018574322;
pub const SQLITE_E_PROTOCOL : i32 = -2018574321;
pub const SQLITE_E_EMPTY : i32 = -2018574320;
pub const SQLITE_E_SCHEMA : i32 = -2018574319;
pub const SQLITE_E_TOOBIG : i32 = -2018574318;
pub const SQLITE_E_CONSTRAINT : i32 = -2018574317;
pub const SQLITE_E_MISMATCH : i32 = -2018574316;
pub const SQLITE_E_MISUSE : i32 = -2018574315;
pub const SQLITE_E_NOLFS : i32 = -2018574314;
pub const SQLITE_E_AUTH : i32 = -2018574313;
pub const SQLITE_E_FORMAT : i32 = -2018574312;
pub const SQLITE_E_RANGE : i32 = -2018574311;
pub const SQLITE_E_NOTADB : i32 = -2018574310;
pub const SQLITE_E_NOTICE : i32 = -2018574309;
pub const SQLITE_E_WARNING : i32 = -2018574308;
pub const SQLITE_E_ROW : i32 = -2018574236;
pub const SQLITE_E_DONE : i32 = -2018574235;
pub const SQLITE_E_IOERR_READ : i32 = -2018574070;
pub const SQLITE_E_IOERR_SHORT_READ : i32 = -2018573814;
pub const SQLITE_E_IOERR_WRITE : i32 = -2018573558;
pub const SQLITE_E_IOERR_FSYNC : i32 = -2018573302;
pub const SQLITE_E_IOERR_DIR_FSYNC : i32 = -2018573046;
pub const SQLITE_E_IOERR_TRUNCATE : i32 = -2018572790;
pub const SQLITE_E_IOERR_FSTAT : i32 = -2018572534;
pub const SQLITE_E_IOERR_UNLOCK : i32 = -2018572278;
pub const SQLITE_E_IOERR_RDLOCK : i32 = -2018572022;
pub const SQLITE_E_IOERR_DELETE : i32 = -2018571766;
pub const SQLITE_E_IOERR_BLOCKED : i32 = -2018571510;
pub const SQLITE_E_IOERR_NOMEM : i32 = -2018571254;
pub const SQLITE_E_IOERR_ACCESS : i32 = -2018570998;
pub const SQLITE_E_IOERR_CHECKRESERVEDLOCK : i32 = -2018570742;
pub const SQLITE_E_IOERR_LOCK : i32 = -2018570486;
pub const SQLITE_E_IOERR_CLOSE : i32 = -2018570230;
pub const SQLITE_E_IOERR_DIR_CLOSE : i32 = -2018569974;
pub const SQLITE_E_IOERR_SHMOPEN : i32 = -2018569718;
pub const SQLITE_E_IOERR_SHMSIZE : i32 = -2018569462;
pub const SQLITE_E_IOERR_SHMLOCK : i32 = -2018569206;
pub const SQLITE_E_IOERR_SHMMAP : i32 = -2018568950;
pub const SQLITE_E_IOERR_SEEK : i32 = -2018568694;
pub const SQLITE_E_IOERR_DELETE_NOENT : i32 = -2018568438;
pub const SQLITE_E_IOERR_MMAP : i32 = -2018568182;
pub const SQLITE_E_IOERR_GETTEMPPATH : i32 = -2018567926;
pub const SQLITE_E_IOERR_CONVPATH : i32 = -2018567670;
pub const SQLITE_E_IOERR_VNODE : i32 = -2018567678;
pub const SQLITE_E_IOERR_AUTH : i32 = -2018567677;
pub const SQLITE_E_LOCKED_SHAREDCACHE : i32 = -2018574074;
pub const SQLITE_E_BUSY_RECOVERY : i32 = -2018574075;
pub const SQLITE_E_BUSY_SNAPSHOT : i32 = -2018573819;
pub const SQLITE_E_CANTOPEN_NOTEMPDIR : i32 = -2018574066;
pub const SQLITE_E_CANTOPEN_ISDIR : i32 = -2018573810;
pub const SQLITE_E_CANTOPEN_FULLPATH : i32 = -2018573554;
pub const SQLITE_E_CANTOPEN_CONVPATH : i32 = -2018573298;
pub const SQLITE_E_CORRUPT_VTAB : i32 = -2018574069;
pub const SQLITE_E_READONLY_RECOVERY : i32 = -2018574072;
pub const SQLITE_E_READONLY_CANTLOCK : i32 = -2018573816;
pub const SQLITE_E_READONLY_ROLLBACK : i32 = -2018573560;
pub const SQLITE_E_READONLY_DBMOVED : i32 = -2018573304;
pub const SQLITE_E_ABORT_ROLLBACK : i32 = -2018573820;
pub const SQLITE_E_CONSTRAINT_CHECK : i32 = -2018574061;
pub const SQLITE_E_CONSTRAINT_COMMITHOOK : i32 = -2018573805;
pub const SQLITE_E_CONSTRAINT_FOREIGNKEY : i32 = -2018573549;
pub const SQLITE_E_CONSTRAINT_FUNCTION : i32 = -2018573293;
pub const SQLITE_E_CONSTRAINT_NOTNULL : i32 = -2018573037;
pub const SQLITE_E_CONSTRAINT_PRIMARYKEY : i32 = -2018572781;
pub const SQLITE_E_CONSTRAINT_TRIGGER : i32 = -2018572525;
pub const SQLITE_E_CONSTRAINT_UNIQUE : i32 = -2018572269;
pub const SQLITE_E_CONSTRAINT_VTAB : i32 = -2018572013;
pub const SQLITE_E_CONSTRAINT_ROWID : i32 = -2018571757;
pub const SQLITE_E_NOTICE_RECOVER_WAL : i32 = -2018574053;
pub const SQLITE_E_NOTICE_RECOVER_ROLLBACK : i32 = -2018573797;
pub const SQLITE_E_WARNING_AUTOINDEX : i32 = -2018574052;
pub const UTC_E_TOGGLE_TRACE_STARTED : i32 = -2017128447;
pub const UTC_E_ALTERNATIVE_TRACE_CANNOT_PREEMPT : i32 = -2017128446;
pub const UTC_E_AOT_NOT_RUNNING : i32 = -2017128445;
pub const UTC_E_SCRIPT_TYPE_INVALID : i32 = -2017128444;
pub const UTC_E_SCENARIODEF_NOT_FOUND : i32 = -2017128443;
pub const UTC_E_TRACEPROFILE_NOT_FOUND : i32 = -2017128442;
pub const UTC_E_FORWARDER_ALREADY_ENABLED : i32 = -2017128441;
pub const UTC_E_FORWARDER_ALREADY_DISABLED : i32 = -2017128440;
pub const UTC_E_EVENTLOG_ENTRY_MALFORMED : i32 = -2017128439;
pub const UTC_E_DIAGRULES_SCHEMAVERSION_MISMATCH : i32 = -2017128438;
pub const UTC_E_SCRIPT_TERMINATED : i32 = -2017128437;
pub const UTC_E_INVALID_CUSTOM_FILTER : i32 = -2017128436;
pub const UTC_E_TRACE_NOT_RUNNING : i32 = -2017128435;
pub const UTC_E_REESCALATED_TOO_QUICKLY : i32 = -2017128434;
pub const UTC_E_ESCALATION_ALREADY_RUNNING : i32 = -2017128433;
pub const UTC_E_PERFTRACK_ALREADY_TRACING : i32 = -2017128432;
pub const UTC_E_REACHED_MAX_ESCALATIONS : i32 = -2017128431;
pub const UTC_E_FORWARDER_PRODUCER_MISMATCH : i32 = -2017128430;
pub const UTC_E_INTENTIONAL_SCRIPT_FAILURE : i32 = -2017128429;
pub const UTC_E_SQM_INIT_FAILED : i32 = -2017128428;
pub const UTC_E_NO_WER_LOGGER_SUPPORTED : i32 = -2017128427;
pub const UTC_E_TRACERS_DONT_EXIST : i32 = -2017128426;
pub const UTC_E_WINRT_INIT_FAILED : i32 = -2017128425;
pub const UTC_E_SCENARIODEF_SCHEMAVERSION_MISMATCH : i32 = -2017128424;
pub const UTC_E_INVALID_FILTER : i32 = -2017128423;
pub const UTC_E_EXE_TERMINATED : i32 = -2017128422;
pub const UTC_E_ESCALATION_NOT_AUTHORIZED : i32 = -2017128421;
pub const UTC_E_SETUP_NOT_AUTHORIZED : i32 = -2017128420;
pub const UTC_E_CHILD_PROCESS_FAILED : i32 = -2017128419;
pub const UTC_E_COMMAND_LINE_NOT_AUTHORIZED : i32 = -2017128418;
pub const UTC_E_CANNOT_LOAD_SCENARIO_EDITOR_XML : i32 = -2017128417;
pub const UTC_E_ESCALATION_TIMED_OUT : i32 = -2017128416;
pub const UTC_E_SETUP_TIMED_OUT : i32 = -2017128415;
pub const UTC_E_TRIGGER_MISMATCH : i32 = -2017128414;
pub const UTC_E_TRIGGER_NOT_FOUND : i32 = -2017128413;
pub const UTC_E_SIF_NOT_SUPPORTED : i32 = -2017128412;
pub const UTC_E_DELAY_TERMINATED : i32 = -2017128411;
pub const UTC_E_DEVICE_TICKET_ERROR : i32 = -2017128410;
pub const UTC_E_TRACE_BUFFER_LIMIT_EXCEEDED : i32 = -2017128409;
pub const UTC_E_API_RESULT_UNAVAILABLE : i32 = -2017128408;
pub const UTC_E_RPC_TIMEOUT : i32 = -2017128407;
pub const UTC_E_RPC_WAIT_FAILED : i32 = -2017128406;
pub const UTC_E_API_BUSY : i32 = -2017128405;
pub const UTC_E_TRACE_MIN_DURATION_REQUIREMENT_NOT_MET : i32 = -2017128404;
pub const UTC_E_EXCLUSIVITY_NOT_AVAILABLE : i32 = -2017128403;
pub const UTC_E_GETFILE_FILE_PATH_NOT_APPROVED : i32 = -2017128402;
pub const UTC_E_ESCALATION_DIRECTORY_ALREADY_EXISTS : i32 = -2017128401;
pub const UTC_E_TIME_TRIGGER_ON_START_INVALID : i32 = -2017128400;
pub const UTC_E_TIME_TRIGGER_ONLY_VALID_ON_SINGLE_TRANSITION : i32 = -2017128399;
pub const UTC_E_TIME_TRIGGER_INVALID_TIME_RANGE : i32 = -2017128398;
pub const UTC_E_MULTIPLE_TIME_TRIGGER_ON_SINGLE_STATE : i32 = -2017128397;
pub const UTC_E_BINARY_MISSING : i32 = -2017128396;
pub const UTC_E_FAILED_TO_RESOLVE_CONTAINER_ID : i32 = -2017128394;
pub const UTC_E_UNABLE_TO_RESOLVE_SESSION : i32 = -2017128393;
pub const UTC_E_THROTTLED : i32 = -2017128392;
pub const UTC_E_UNAPPROVED_SCRIPT : i32 = -2017128391;
pub const UTC_E_SCRIPT_MISSING : i32 = -2017128390;
pub const UTC_E_SCENARIO_THROTTLED : i32 = -2017128389;
pub const UTC_E_API_NOT_SUPPORTED : i32 = -2017128388;
pub const UTC_E_GETFILE_EXTERNAL_PATH_NOT_APPROVED : i32 = -2017128387;
pub const UTC_E_TRY_GET_SCENARIO_TIMEOUT_EXCEEDED : i32 = -2017128386;
pub const UTC_E_CERT_REV_FAILED : i32 = -2017128385;
pub const UTC_E_FAILED_TO_START_NDISCAP : i32 = -2017128384;
pub const UTC_E_KERNELDUMP_LIMIT_REACHED : i32 = -2017128383;
pub const UTC_E_MISSING_AGGREGATE_EVENT_TAG : i32 = -2017128382;
pub const UTC_E_INVALID_AGGREGATION_STRUCT : i32 = -2017128381;
pub const UTC_E_ACTION_NOT_SUPPORTED_IN_DESTINATION : i32 = -2017128380;
pub const UTC_E_FILTER_MISSING_ATTRIBUTE : i32 = -2017128379;
pub const UTC_E_FILTER_INVALID_TYPE : i32 = -2017128378;
pub const UTC_E_FILTER_VARIABLE_NOT_FOUND : i32 = -2017128377;
pub const UTC_E_FILTER_FUNCTION_RESTRICTED : i32 = -2017128376;
pub const UTC_E_FILTER_VERSION_MISMATCH : i32 = -2017128375;
pub const UTC_E_FILTER_INVALID_FUNCTION : i32 = -2017128368;
pub const UTC_E_FILTER_INVALID_FUNCTION_PARAMS : i32 = -2017128367;
pub const UTC_E_FILTER_INVALID_COMMAND : i32 = -2017128366;
pub const UTC_E_FILTER_ILLEGAL_EVAL : i32 = -2017128365;
pub const UTC_E_TTTRACER_RETURNED_ERROR : i32 = -2017128364;
pub const UTC_E_AGENT_DIAGNOSTICS_TOO_LARGE : i32 = -2017128363;
pub const UTC_E_FAILED_TO_RECEIVE_AGENT_DIAGNOSTICS : i32 = -2017128362;
pub const UTC_E_SCENARIO_HAS_NO_ACTIONS : i32 = -2017128361;
pub const UTC_E_TTTRACER_STORAGE_FULL : i32 = -2017128360;
pub const UTC_E_INSUFFICIENT_SPACE_TO_START_TRACE : i32 = -2017128359;
pub const UTC_E_ESCALATION_CANCELLED_AT_SHUTDOWN : i32 = -2017128358;
pub const UTC_E_GETFILEINFOACTION_FILE_NOT_APPROVED : i32 = -2017128357;
pub const UTC_E_SETREGKEYACTION_TYPE_NOT_APPROVED : i32 = -2017128356;
pub const WINML_ERR_INVALID_DEVICE : i32 = -2003828735;
pub const WINML_ERR_INVALID_BINDING : i32 = -2003828734;
pub const WINML_ERR_VALUE_NOTFOUND : i32 = -2003828733;
pub const WINML_ERR_SIZE_MISMATCH : i32 = -2003828732;
pub const ERROR_QUIC_HANDSHAKE_FAILURE : i32 = -2143223808;
pub const ERROR_QUIC_VER_NEG_FAILURE : i32 = -2143223807;
pub const DS_S_SUCCESS : i32 = 0;
pub const DNS_ERROR_RCODE_NO_ERROR : i32 = 0;
pub const DNS_ERROR_RCODE_LAST : i32 = 9018;
pub const DNS_STATUS_PACKET_UNSECURE : i32 = 9505;
pub const DNS_ERROR_NO_MEMORY : i32 = 14;
pub const DNS_ERROR_INVALID_NAME : i32 = 123;
pub const DNS_ERROR_INVALID_DATA : i32 = 13;
pub const SEC_E_NO_SPM : i32 = -2146893052;
pub const SEC_E_NOT_SUPPORTED : i32 = -2146893054;
pub const SCARD_S_SUCCESS : i32 = 0;
pub const PWM_IOCTL_ID_CONTROLLER_GET_INFO : i32 = 0;
pub const PWM_IOCTL_ID_CONTROLLER_GET_ACTUAL_PERIOD : i32 = 1;
pub const PWM_IOCTL_ID_CONTROLLER_SET_DESIRED_PERIOD : i32 = 2;
pub const PWM_IOCTL_ID_PIN_GET_ACTIVE_DUTY_CYCLE_PERCENTAGE : i32 = 100;
pub const PWM_IOCTL_ID_PIN_SET_ACTIVE_DUTY_CYCLE_PERCENTAGE : i32 = 101;
pub const PWM_IOCTL_ID_PIN_GET_POLARITY : i32 = 102;
pub const PWM_IOCTL_ID_PIN_SET_POLARITY : i32 = 103;
pub const PWM_IOCTL_ID_PIN_START : i32 = 104;
pub const PWM_IOCTL_ID_PIN_STOP : i32 = 105;
pub const PWM_IOCTL_ID_PIN_IS_STARTED : i32 = 106;

//
// types
//
// --------------------------------------------------------
// Type: POWERBROADCAST_SETTING
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const POWERBROADCAST_SETTING = extern struct {
    PowerSetting: Guid,
    DataLength: u32,
    Data: ?[*]u8,
};
// --------------------------------------------------------
// Type: AR_STATE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const AR_STATE = *opaque{
};
// --------------------------------------------------------
// Type: ORIENTATION_PREFERENCE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const ORIENTATION_PREFERENCE = *opaque{
};
// --------------------------------------------------------
// Type: BOOL
// TypeLayoutAttr: sequential
pub const BOOL = i32;
// --------------------------------------------------------
// Type: BoundaryDescriptorHandle
// TypeLayoutAttr: sequential
// RAIIFree 'DeleteBoundaryDescriptor' (TODO: can we use this information?)
pub const BoundaryDescriptorHandle = ?*opaque{};
// --------------------------------------------------------
// Type: HANDLE
// TypeLayoutAttr: sequential
// RAIIFree 'CloseHandle' (TODO: can we use this information?)
pub const HANDLE = ?*opaque{};
// --------------------------------------------------------
// Type: HINSTANCE
// TypeLayoutAttr: sequential
// RAIIFree 'FreeLibrary' (TODO: can we use this information?)
pub const HINSTANCE = ?*opaque{};
// --------------------------------------------------------
// Type: LRESULT
// TypeLayoutAttr: sequential
pub const LRESULT = i32;
// --------------------------------------------------------
// Type: LSTATUS
// TypeLayoutAttr: sequential
pub const LSTATUS = i32;
// --------------------------------------------------------
// Type: NamespaceHandle
// TypeLayoutAttr: sequential
// RAIIFree 'ClosePrivateNamespace' (TODO: can we use this information?)
pub const NamespaceHandle = ?*opaque{};
// --------------------------------------------------------
// Type: NTSTATUS
// TypeLayoutAttr: sequential
pub const NTSTATUS = i32;
// --------------------------------------------------------
// Type: PTP_POOL
// TypeLayoutAttr: sequential
// RAIIFree 'CloseThreadpool' (TODO: can we use this information?)
pub const PTP_POOL = ?*opaque{};
// --------------------------------------------------------
// Type: TimerQueueHandle
// TypeLayoutAttr: sequential
// RAIIFree 'DeleteTimerQueueEx' (TODO: can we use this information?)
pub const TimerQueueHandle = ?*opaque{};
// --------------------------------------------------------
// Type: FLOAT128
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const FLOAT128 = extern struct {
    LowPart: i64,
    HighPart: i64,
};
// --------------------------------------------------------
// Type: LARGE_INTEGER
// TypeLayoutAttr: explicit
// not generating the actual code for this type because it has an explicit layout
pub const LARGE_INTEGER = *opaque{
    // --------------------------------------------------------
    // Type: _u_e__Struct
    // TypeLayoutAttr: sequential
    // TODO: I think this is a struct, but not sure at this point, assuming it is for now
    pub const _u_e__Struct = extern struct {
        LowPart: u32,
        HighPart: i32,
    };
    // --------------------------------------------------------
    // Type: _Anonymous_e__Struct
    // TypeLayoutAttr: sequential
    // TODO: I think this is a struct, but not sure at this point, assuming it is for now
    pub const _Anonymous_e__Struct = extern struct {
        LowPart: u32,
        HighPart: i32,
    };
};
// --------------------------------------------------------
// Type: ULARGE_INTEGER
// TypeLayoutAttr: explicit
// not generating the actual code for this type because it has an explicit layout
pub const ULARGE_INTEGER = *opaque{
    // --------------------------------------------------------
    // Type: _u_e__Struct
    // TypeLayoutAttr: sequential
    // TODO: I think this is a struct, but not sure at this point, assuming it is for now
    pub const _u_e__Struct = extern struct {
        LowPart: u32,
        HighPart: u32,
    };
    // --------------------------------------------------------
    // Type: _Anonymous_e__Struct
    // TypeLayoutAttr: sequential
    // TODO: I think this is a struct, but not sure at this point, assuming it is for now
    pub const _Anonymous_e__Struct = extern struct {
        LowPart: u32,
        HighPart: u32,
    };
};
// --------------------------------------------------------
// Type: M128A
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const M128A = extern struct {
    Low: u64,
    High: i64,
};
// --------------------------------------------------------
// Type: XSAVE_FORMAT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const XSAVE_FORMAT = extern struct {
    ControlWord: u16,
    StatusWord: u16,
    TagWord: u8,
    Reserved1: u8,
    ErrorOpcode: u16,
    ErrorOffset: u32,
    ErrorSelector: u16,
    Reserved2: u16,
    DataOffset: u32,
    DataSelector: u16,
    Reserved3: u16,
    MxCsr: u32,
    MxCsr_Mask: u32,
    FloatRegisters: ?[*]M128A,
    XmmRegisters: ?[*]M128A,
    Reserved4: ?[*]u8,
};
// --------------------------------------------------------
// Type: XSAVE_CET_U_FORMAT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const XSAVE_CET_U_FORMAT = extern struct {
    Ia32CetUMsr: u64,
    Ia32Pl3SspMsr: u64,
};
// --------------------------------------------------------
// Type: XSAVE_AREA_HEADER
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const XSAVE_AREA_HEADER = extern struct {
    Mask: u64,
    CompactionMask: u64,
    Reserved2: ?[*]u64,
};
// --------------------------------------------------------
// Type: XSAVE_AREA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const XSAVE_AREA = extern struct {
    LegacyState: XSAVE_FORMAT,
    Header: XSAVE_AREA_HEADER,
};
// --------------------------------------------------------
// Type: XSTATE_CONTEXT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const XSTATE_CONTEXT = extern struct {
    Mask: u64,
    Length: u32,
    Reserved1: u32,
    Area: ?*XSAVE_AREA,
    Reserved2: u32,
    Buffer: ?*opaque{},
    Reserved3: u32,
};
// --------------------------------------------------------
// Type: SCOPE_TABLE_AMD64
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SCOPE_TABLE_AMD64 = extern struct {
    Count: u32,
    ScopeRecord: ?[*]_Anonymous_e__Struct,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Struct
    // TypeLayoutAttr: sequential
    // TODO: I think this is a struct, but not sure at this point, assuming it is for now
    pub const _Anonymous_e__Struct = extern struct {
        BeginAddress: u32,
        EndAddress: u32,
        HandlerAddress: u32,
        JumpTarget: u32,
    };
};
// --------------------------------------------------------
// Type: SCOPE_TABLE_ARM
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SCOPE_TABLE_ARM = extern struct {
    Count: u32,
    ScopeRecord: ?[*]_Anonymous_e__Struct,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Struct
    // TypeLayoutAttr: sequential
    // TODO: I think this is a struct, but not sure at this point, assuming it is for now
    pub const _Anonymous_e__Struct = extern struct {
        BeginAddress: u32,
        EndAddress: u32,
        HandlerAddress: u32,
        JumpTarget: u32,
    };
};
// --------------------------------------------------------
// Type: SCOPE_TABLE_ARM64
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SCOPE_TABLE_ARM64 = extern struct {
    Count: u32,
    ScopeRecord: ?[*]_Anonymous_e__Struct,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Struct
    // TypeLayoutAttr: sequential
    // TODO: I think this is a struct, but not sure at this point, assuming it is for now
    pub const _Anonymous_e__Struct = extern struct {
        BeginAddress: u32,
        EndAddress: u32,
        HandlerAddress: u32,
        JumpTarget: u32,
    };
};
// --------------------------------------------------------
// Type: KNONVOLATILE_CONTEXT_POINTERS_ARM64
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const KNONVOLATILE_CONTEXT_POINTERS_ARM64 = extern struct {
    X19: ?*u64,
    X20: ?*u64,
    X21: ?*u64,
    X22: ?*u64,
    X23: ?*u64,
    X24: ?*u64,
    X25: ?*u64,
    X26: ?*u64,
    X27: ?*u64,
    X28: ?*u64,
    Fp: ?*u64,
    Lr: ?*u64,
    D8: ?*u64,
    D9: ?*u64,
    D10: ?*u64,
    D11: ?*u64,
    D12: ?*u64,
    D13: ?*u64,
    D14: ?*u64,
    D15: ?*u64,
};
// --------------------------------------------------------
// Type: FLOATING_SAVE_AREA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const FLOATING_SAVE_AREA = extern struct {
    ControlWord: u32,
    StatusWord: u32,
    TagWord: u32,
    ErrorOffset: u32,
    ErrorSelector: u32,
    DataOffset: u32,
    DataSelector: u32,
    RegisterArea: ?[*]u8,
    Spare0: u32,
};
// --------------------------------------------------------
// Type: KNONVOLATILE_CONTEXT_POINTERS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const KNONVOLATILE_CONTEXT_POINTERS = extern struct {
    Dummy: u32,
};
// --------------------------------------------------------
// Type: WOW64_DESCRIPTOR_TABLE_ENTRY
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const WOW64_DESCRIPTOR_TABLE_ENTRY = extern struct {
    Selector: u32,
    Descriptor: WOW64_LDT_ENTRY,
};
// --------------------------------------------------------
// Type: EXCEPTION_RECORD32
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const EXCEPTION_RECORD32 = extern struct {
    ExceptionCode: u32,
    ExceptionFlags: u32,
    ExceptionRecord: u32,
    ExceptionAddress: u32,
    NumberParameters: u32,
    ExceptionInformation: ?[*]u32,
};
// --------------------------------------------------------
// Type: SE_SID
// TypeLayoutAttr: explicit
// not generating the actual code for this type because it has an explicit layout
pub const SE_SID = *opaque{
};
// --------------------------------------------------------
// Type: SYSTEM_PROCESS_TRUST_LABEL_ACE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SYSTEM_PROCESS_TRUST_LABEL_ACE = extern struct {
    Header: ACE_HEADER,
    Mask: u32,
    SidStart: u32,
};
// --------------------------------------------------------
// Type: SYSTEM_ACCESS_FILTER_ACE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SYSTEM_ACCESS_FILTER_ACE = extern struct {
    Header: ACE_HEADER,
    Mask: u32,
    SidStart: u32,
};
// --------------------------------------------------------
// Type: SECURITY_DESCRIPTOR_RELATIVE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SECURITY_DESCRIPTOR_RELATIVE = extern struct {
    Revision: u8,
    Sbz1: u8,
    Control: u16,
    Owner: u32,
    Group: u32,
    Sacl: u32,
    Dacl: u32,
};
// --------------------------------------------------------
// Type: SECURITY_OBJECT_AI_PARAMS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SECURITY_OBJECT_AI_PARAMS = extern struct {
    Size: u32,
    ConstraintMask: u32,
};
// --------------------------------------------------------
// Type: ACCESS_REASON_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const ACCESS_REASON_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: ACCESS_REASONS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const ACCESS_REASONS = extern struct {
    Data: ?[*]u32,
};
// --------------------------------------------------------
// Type: SE_SECURITY_DESCRIPTOR
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SE_SECURITY_DESCRIPTOR = extern struct {
    Size: u32,
    Flags: u32,
    SecurityDescriptor: ?*opaque{},
};
// --------------------------------------------------------
// Type: SE_ACCESS_REQUEST
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SE_ACCESS_REQUEST = extern struct {
    Size: u32,
    SeSecurityDescriptor: ?*SE_SECURITY_DESCRIPTOR,
    DesiredAccess: u32,
    PreviouslyGrantedAccess: u32,
    PrincipalSelfSid: ?*opaque{},
    GenericMapping: ?*GENERIC_MAPPING,
    ObjectTypeListCount: u32,
    ObjectTypeList: ?*OBJECT_TYPE_LIST,
};
// --------------------------------------------------------
// Type: SE_ACCESS_REPLY
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SE_ACCESS_REPLY = extern struct {
    Size: u32,
    ResultListCount: u32,
    GrantedAccess: ?*u32,
    AccessStatus: ?*u32,
    AccessReason: ?*ACCESS_REASONS,
    Privileges: ?*?*PRIVILEGE_SET,
};
// --------------------------------------------------------
// Type: SE_TOKEN_USER
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SE_TOKEN_USER = extern struct {
    Anonymous1: _Anonymous1_e__Union,
    Anonymous2: _Anonymous2_e__Union,
    // --------------------------------------------------------
    // Type: _Anonymous1_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous1_e__Union = *opaque{
    };
    // --------------------------------------------------------
    // Type: _Anonymous2_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous2_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: TOKEN_SID_INFORMATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TOKEN_SID_INFORMATION = extern struct {
    Sid: ?*opaque{},
};
// --------------------------------------------------------
// Type: TOKEN_BNO_ISOLATION_INFORMATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TOKEN_BNO_ISOLATION_INFORMATION = extern struct {
    IsolationPrefix: ?*u16,
    IsolationEnabled: u8,
};
// --------------------------------------------------------
// Type: SE_IMPERSONATION_STATE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SE_IMPERSONATION_STATE = extern struct {
    Token: ?*opaque{},
    CopyOnOpen: u8,
    EffectiveOnly: u8,
    Level: SECURITY_IMPERSONATION_LEVEL,
};
// --------------------------------------------------------
// Type: SE_IMAGE_SIGNATURE_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const SE_IMAGE_SIGNATURE_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: SE_LEARNING_MODE_DATA_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const SE_LEARNING_MODE_DATA_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: JOB_SET_ARRAY
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const JOB_SET_ARRAY = extern struct {
    JobHandle: HANDLE,
    MemberLevel: u32,
    Flags: u32,
};
// --------------------------------------------------------
// Type: EXCEPTION_REGISTRATION_RECORD
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const EXCEPTION_REGISTRATION_RECORD = extern struct {
    Next: ?*EXCEPTION_REGISTRATION_RECORD,
    Handler: EXCEPTION_ROUTINE,
};
// --------------------------------------------------------
// Type: NT_TIB
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NT_TIB = extern struct {
    ExceptionList: ?*EXCEPTION_REGISTRATION_RECORD,
    StackBase: ?*opaque{},
    StackLimit: ?*opaque{},
    SubSystemTib: ?*opaque{},
    Anonymous: _Anonymous_e__Union,
    ArbitraryUserPointer: ?*opaque{},
    Self: ?*NT_TIB,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: NT_TIB32
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NT_TIB32 = extern struct {
    ExceptionList: u32,
    StackBase: u32,
    StackLimit: u32,
    SubSystemTib: u32,
    Anonymous: _Anonymous_e__Union,
    ArbitraryUserPointer: u32,
    Self: u32,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: NT_TIB64
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NT_TIB64 = extern struct {
    ExceptionList: u64,
    StackBase: u64,
    StackLimit: u64,
    SubSystemTib: u64,
    Anonymous: _Anonymous_e__Union,
    ArbitraryUserPointer: u64,
    Self: u64,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: UMS_CREATE_THREAD_ATTRIBUTES
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const UMS_CREATE_THREAD_ATTRIBUTES = extern struct {
    UmsVersion: u32,
    UmsContext: ?*opaque{},
    UmsCompletionList: ?*opaque{},
};
// --------------------------------------------------------
// Type: WOW64_ARCHITECTURE_INFORMATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const WOW64_ARCHITECTURE_INFORMATION = extern struct {
    _bitfield: u32,
};
// --------------------------------------------------------
// Type: PROCESS_DYNAMIC_EH_CONTINUATION_TARGET
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PROCESS_DYNAMIC_EH_CONTINUATION_TARGET = extern struct {
    TargetAddress: ?*opaque{},
    Flags: ?*opaque{},
};
// --------------------------------------------------------
// Type: PROCESS_DYNAMIC_EH_CONTINUATION_TARGETS_INFORMATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PROCESS_DYNAMIC_EH_CONTINUATION_TARGETS_INFORMATION = extern struct {
    NumberOfTargets: u16,
    Reserved: u16,
    Reserved2: u32,
    Targets: ?*PROCESS_DYNAMIC_EH_CONTINUATION_TARGET,
};
// --------------------------------------------------------
// Type: RATE_QUOTA_LIMIT
// TypeLayoutAttr: explicit
// not generating the actual code for this type because it has an explicit layout
pub const RATE_QUOTA_LIMIT = *opaque{
    // --------------------------------------------------------
    // Type: _Anonymous_e__Struct
    // TypeLayoutAttr: sequential
    // TODO: I think this is a struct, but not sure at this point, assuming it is for now
    pub const _Anonymous_e__Struct = extern struct {
        _bitfield: u32,
    };
};
// --------------------------------------------------------
// Type: QUOTA_LIMITS_EX
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const QUOTA_LIMITS_EX = extern struct {
    PagedPoolLimit: ?*opaque{},
    NonPagedPoolLimit: ?*opaque{},
    MinimumWorkingSetSize: ?*opaque{},
    MaximumWorkingSetSize: ?*opaque{},
    PagefileLimit: ?*opaque{},
    TimeLimit: LARGE_INTEGER,
    WorkingSetLimit: ?*opaque{},
    Reserved2: ?*opaque{},
    Reserved3: ?*opaque{},
    Reserved4: ?*opaque{},
    Flags: u32,
    CpuRateLimit: RATE_QUOTA_LIMIT,
};
// --------------------------------------------------------
// Type: IO_COUNTERS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const IO_COUNTERS = extern struct {
    ReadOperationCount: u64,
    WriteOperationCount: u64,
    OtherOperationCount: u64,
    ReadTransferCount: u64,
    WriteTransferCount: u64,
    OtherTransferCount: u64,
};
// --------------------------------------------------------
// Type: PROCESS_MITIGATION_POLICY
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PROCESS_MITIGATION_POLICY = *opaque{
};
// --------------------------------------------------------
// Type: PROCESS_MITIGATION_ASLR_POLICY
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PROCESS_MITIGATION_ASLR_POLICY = extern struct {
    Anonymous: _Anonymous_e__Union,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
        // --------------------------------------------------------
        // Type: _Anonymous_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _Anonymous_e__Struct = extern struct {
            _bitfield: u32,
        };
    };
};
// --------------------------------------------------------
// Type: PROCESS_MITIGATION_DEP_POLICY
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PROCESS_MITIGATION_DEP_POLICY = extern struct {
    Anonymous: _Anonymous_e__Union,
    Permanent: u8,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
        // --------------------------------------------------------
        // Type: _Anonymous_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _Anonymous_e__Struct = extern struct {
            _bitfield: u32,
        };
    };
};
// --------------------------------------------------------
// Type: PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY = extern struct {
    Anonymous: _Anonymous_e__Union,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
        // --------------------------------------------------------
        // Type: _Anonymous_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _Anonymous_e__Struct = extern struct {
            _bitfield: u32,
        };
    };
};
// --------------------------------------------------------
// Type: PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY = extern struct {
    Anonymous: _Anonymous_e__Union,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
        // --------------------------------------------------------
        // Type: _Anonymous_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _Anonymous_e__Struct = extern struct {
            _bitfield: u32,
        };
    };
};
// --------------------------------------------------------
// Type: PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY = extern struct {
    Anonymous: _Anonymous_e__Union,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
        // --------------------------------------------------------
        // Type: _Anonymous_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _Anonymous_e__Struct = extern struct {
            _bitfield: u32,
        };
    };
};
// --------------------------------------------------------
// Type: PROCESS_MITIGATION_DYNAMIC_CODE_POLICY
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PROCESS_MITIGATION_DYNAMIC_CODE_POLICY = extern struct {
    Anonymous: _Anonymous_e__Union,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
        // --------------------------------------------------------
        // Type: _Anonymous_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _Anonymous_e__Struct = extern struct {
            _bitfield: u32,
        };
    };
};
// --------------------------------------------------------
// Type: PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY = extern struct {
    Anonymous: _Anonymous_e__Union,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
        // --------------------------------------------------------
        // Type: _Anonymous_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _Anonymous_e__Struct = extern struct {
            _bitfield: u32,
        };
    };
};
// --------------------------------------------------------
// Type: PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY = extern struct {
    Anonymous: _Anonymous_e__Union,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
        // --------------------------------------------------------
        // Type: _Anonymous_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _Anonymous_e__Struct = extern struct {
            _bitfield: u32,
        };
    };
};
// --------------------------------------------------------
// Type: PROCESS_MITIGATION_FONT_DISABLE_POLICY
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PROCESS_MITIGATION_FONT_DISABLE_POLICY = extern struct {
    Anonymous: _Anonymous_e__Union,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
        // --------------------------------------------------------
        // Type: _Anonymous_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _Anonymous_e__Struct = extern struct {
            _bitfield: u32,
        };
    };
};
// --------------------------------------------------------
// Type: PROCESS_MITIGATION_IMAGE_LOAD_POLICY
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PROCESS_MITIGATION_IMAGE_LOAD_POLICY = extern struct {
    Anonymous: _Anonymous_e__Union,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
        // --------------------------------------------------------
        // Type: _Anonymous_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _Anonymous_e__Struct = extern struct {
            _bitfield: u32,
        };
    };
};
// --------------------------------------------------------
// Type: PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY = extern struct {
    Anonymous: _Anonymous_e__Union,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
        // --------------------------------------------------------
        // Type: _Anonymous_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _Anonymous_e__Struct = extern struct {
            _bitfield: u32,
        };
    };
};
// --------------------------------------------------------
// Type: PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY = extern struct {
    Anonymous: _Anonymous_e__Union,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
        // --------------------------------------------------------
        // Type: _Anonymous_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _Anonymous_e__Struct = extern struct {
            _bitfield: u32,
        };
    };
};
// --------------------------------------------------------
// Type: PROCESS_MITIGATION_CHILD_PROCESS_POLICY
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PROCESS_MITIGATION_CHILD_PROCESS_POLICY = extern struct {
    Anonymous: _Anonymous_e__Union,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
        // --------------------------------------------------------
        // Type: _Anonymous_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _Anonymous_e__Struct = extern struct {
            _bitfield: u32,
        };
    };
};
// --------------------------------------------------------
// Type: PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY = extern struct {
    Anonymous: _Anonymous_e__Union,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
        // --------------------------------------------------------
        // Type: _Anonymous_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _Anonymous_e__Struct = extern struct {
            _bitfield: u32,
        };
    };
};
// --------------------------------------------------------
// Type: PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY = extern struct {
    Anonymous: _Anonymous_e__Union,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
        // --------------------------------------------------------
        // Type: _Anonymous_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _Anonymous_e__Struct = extern struct {
            _bitfield: u32,
        };
    };
};
// --------------------------------------------------------
// Type: JOBOBJECT_BASIC_ACCOUNTING_INFORMATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const JOBOBJECT_BASIC_ACCOUNTING_INFORMATION = extern struct {
    TotalUserTime: LARGE_INTEGER,
    TotalKernelTime: LARGE_INTEGER,
    ThisPeriodTotalUserTime: LARGE_INTEGER,
    ThisPeriodTotalKernelTime: LARGE_INTEGER,
    TotalPageFaultCount: u32,
    TotalProcesses: u32,
    ActiveProcesses: u32,
    TotalTerminatedProcesses: u32,
};
// --------------------------------------------------------
// Type: JOBOBJECT_BASIC_LIMIT_INFORMATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const JOBOBJECT_BASIC_LIMIT_INFORMATION = extern struct {
    PerProcessUserTimeLimit: LARGE_INTEGER,
    PerJobUserTimeLimit: LARGE_INTEGER,
    LimitFlags: u32,
    MinimumWorkingSetSize: ?*opaque{},
    MaximumWorkingSetSize: ?*opaque{},
    ActiveProcessLimit: u32,
    Affinity: ?*opaque{},
    PriorityClass: u32,
    SchedulingClass: u32,
};
// --------------------------------------------------------
// Type: JOBOBJECT_EXTENDED_LIMIT_INFORMATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const JOBOBJECT_EXTENDED_LIMIT_INFORMATION = extern struct {
    BasicLimitInformation: JOBOBJECT_BASIC_LIMIT_INFORMATION,
    IoInfo: IO_COUNTERS,
    ProcessMemoryLimit: ?*opaque{},
    JobMemoryLimit: ?*opaque{},
    PeakProcessMemoryUsed: ?*opaque{},
    PeakJobMemoryUsed: ?*opaque{},
};
// --------------------------------------------------------
// Type: JOBOBJECT_BASIC_PROCESS_ID_LIST
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const JOBOBJECT_BASIC_PROCESS_ID_LIST = extern struct {
    NumberOfAssignedProcesses: u32,
    NumberOfProcessIdsInList: u32,
    ProcessIdList: ?[*]?*opaque{},
};
// --------------------------------------------------------
// Type: JOBOBJECT_BASIC_UI_RESTRICTIONS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const JOBOBJECT_BASIC_UI_RESTRICTIONS = extern struct {
    UIRestrictionsClass: u32,
};
// --------------------------------------------------------
// Type: JOBOBJECT_SECURITY_LIMIT_INFORMATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const JOBOBJECT_SECURITY_LIMIT_INFORMATION = extern struct {
    SecurityLimitFlags: u32,
    JobToken: HANDLE,
    SidsToDisable: ?*TOKEN_GROUPS,
    PrivilegesToDelete: ?*TOKEN_PRIVILEGES,
    RestrictedSids: ?*TOKEN_GROUPS,
};
// --------------------------------------------------------
// Type: JOBOBJECT_END_OF_JOB_TIME_INFORMATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const JOBOBJECT_END_OF_JOB_TIME_INFORMATION = extern struct {
    EndOfJobTimeAction: u32,
};
// --------------------------------------------------------
// Type: JOBOBJECT_ASSOCIATE_COMPLETION_PORT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const JOBOBJECT_ASSOCIATE_COMPLETION_PORT = extern struct {
    CompletionKey: ?*opaque{},
    CompletionPort: HANDLE,
};
// --------------------------------------------------------
// Type: JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION = extern struct {
    BasicInfo: JOBOBJECT_BASIC_ACCOUNTING_INFORMATION,
    IoInfo: IO_COUNTERS,
};
// --------------------------------------------------------
// Type: JOBOBJECT_JOBSET_INFORMATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const JOBOBJECT_JOBSET_INFORMATION = extern struct {
    MemberLevel: u32,
};
// --------------------------------------------------------
// Type: JOBOBJECT_RATE_CONTROL_TOLERANCE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const JOBOBJECT_RATE_CONTROL_TOLERANCE = *opaque{
};
// --------------------------------------------------------
// Type: JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL = *opaque{
};
// --------------------------------------------------------
// Type: JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION = extern struct {
    IoReadBytesLimit: u64,
    IoWriteBytesLimit: u64,
    PerJobUserTimeLimit: LARGE_INTEGER,
    JobMemoryLimit: u64,
    RateControlTolerance: JOBOBJECT_RATE_CONTROL_TOLERANCE,
    RateControlToleranceInterval: JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL,
    LimitFlags: u32,
};
// --------------------------------------------------------
// Type: JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2 = extern struct {
    IoReadBytesLimit: u64,
    IoWriteBytesLimit: u64,
    PerJobUserTimeLimit: LARGE_INTEGER,
    Anonymous1: _Anonymous1_e__Union,
    Anonymous2: _Anonymous2_e__Union,
    Anonymous3: _Anonymous3_e__Union,
    LimitFlags: u32,
    IoRateControlTolerance: JOBOBJECT_RATE_CONTROL_TOLERANCE,
    JobLowMemoryLimit: u64,
    IoRateControlToleranceInterval: JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL,
    NetRateControlTolerance: JOBOBJECT_RATE_CONTROL_TOLERANCE,
    NetRateControlToleranceInterval: JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL,
    // --------------------------------------------------------
    // Type: _Anonymous3_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous3_e__Union = *opaque{
    };
    // --------------------------------------------------------
    // Type: _Anonymous1_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous1_e__Union = *opaque{
    };
    // --------------------------------------------------------
    // Type: _Anonymous2_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous2_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: JOBOBJECT_LIMIT_VIOLATION_INFORMATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const JOBOBJECT_LIMIT_VIOLATION_INFORMATION = extern struct {
    LimitFlags: u32,
    ViolationLimitFlags: u32,
    IoReadBytes: u64,
    IoReadBytesLimit: u64,
    IoWriteBytes: u64,
    IoWriteBytesLimit: u64,
    PerJobUserTime: LARGE_INTEGER,
    PerJobUserTimeLimit: LARGE_INTEGER,
    JobMemory: u64,
    JobMemoryLimit: u64,
    RateControlTolerance: JOBOBJECT_RATE_CONTROL_TOLERANCE,
    RateControlToleranceLimit: JOBOBJECT_RATE_CONTROL_TOLERANCE,
};
// --------------------------------------------------------
// Type: JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2 = extern struct {
    LimitFlags: u32,
    ViolationLimitFlags: u32,
    IoReadBytes: u64,
    IoReadBytesLimit: u64,
    IoWriteBytes: u64,
    IoWriteBytesLimit: u64,
    PerJobUserTime: LARGE_INTEGER,
    PerJobUserTimeLimit: LARGE_INTEGER,
    JobMemory: u64,
    Anonymous1: _Anonymous1_e__Union,
    Anonymous2: _Anonymous2_e__Union,
    Anonymous3: _Anonymous3_e__Union,
    JobLowMemoryLimit: u64,
    IoRateControlTolerance: JOBOBJECT_RATE_CONTROL_TOLERANCE,
    IoRateControlToleranceLimit: JOBOBJECT_RATE_CONTROL_TOLERANCE,
    NetRateControlTolerance: JOBOBJECT_RATE_CONTROL_TOLERANCE,
    NetRateControlToleranceLimit: JOBOBJECT_RATE_CONTROL_TOLERANCE,
    // --------------------------------------------------------
    // Type: _Anonymous2_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous2_e__Union = *opaque{
    };
    // --------------------------------------------------------
    // Type: _Anonymous1_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous1_e__Union = *opaque{
    };
    // --------------------------------------------------------
    // Type: _Anonymous3_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous3_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: JOBOBJECT_CPU_RATE_CONTROL_INFORMATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const JOBOBJECT_CPU_RATE_CONTROL_INFORMATION = extern struct {
    ControlFlags: u32,
    Anonymous: _Anonymous_e__Union,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
        // --------------------------------------------------------
        // Type: _Anonymous_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _Anonymous_e__Struct = extern struct {
            MinRate: u16,
            MaxRate: u16,
        };
    };
};
// --------------------------------------------------------
// Type: JOB_OBJECT_NET_RATE_CONTROL_FLAGS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const JOB_OBJECT_NET_RATE_CONTROL_FLAGS = *opaque{
};
// --------------------------------------------------------
// Type: JOBOBJECT_NET_RATE_CONTROL_INFORMATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const JOBOBJECT_NET_RATE_CONTROL_INFORMATION = extern struct {
    MaxBandwidth: u64,
    ControlFlags: JOB_OBJECT_NET_RATE_CONTROL_FLAGS,
    DscpTag: u8,
};
// --------------------------------------------------------
// Type: JOB_OBJECT_IO_RATE_CONTROL_FLAGS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const JOB_OBJECT_IO_RATE_CONTROL_FLAGS = *opaque{
};
// --------------------------------------------------------
// Type: JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE = extern struct {
    MaxIops: i64,
    MaxBandwidth: i64,
    ReservationIops: i64,
    VolumeName: ?*u16,
    BaseIoSize: u32,
    ControlFlags: JOB_OBJECT_IO_RATE_CONTROL_FLAGS,
    VolumeNameLength: u16,
};
// --------------------------------------------------------
// Type: JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V2
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V2 = extern struct {
    MaxIops: i64,
    MaxBandwidth: i64,
    ReservationIops: i64,
    VolumeName: ?*u16,
    BaseIoSize: u32,
    ControlFlags: JOB_OBJECT_IO_RATE_CONTROL_FLAGS,
    VolumeNameLength: u16,
    CriticalReservationIops: i64,
    ReservationBandwidth: i64,
    CriticalReservationBandwidth: i64,
    MaxTimePercent: i64,
    ReservationTimePercent: i64,
    CriticalReservationTimePercent: i64,
};
// --------------------------------------------------------
// Type: JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3 = extern struct {
    MaxIops: i64,
    MaxBandwidth: i64,
    ReservationIops: i64,
    VolumeName: ?*u16,
    BaseIoSize: u32,
    ControlFlags: JOB_OBJECT_IO_RATE_CONTROL_FLAGS,
    VolumeNameLength: u16,
    CriticalReservationIops: i64,
    ReservationBandwidth: i64,
    CriticalReservationBandwidth: i64,
    MaxTimePercent: i64,
    ReservationTimePercent: i64,
    CriticalReservationTimePercent: i64,
    SoftMaxIops: i64,
    SoftMaxBandwidth: i64,
    SoftMaxTimePercent: i64,
    LimitExcessNotifyIops: i64,
    LimitExcessNotifyBandwidth: i64,
    LimitExcessNotifyTimePercent: i64,
};
// --------------------------------------------------------
// Type: JOBOBJECT_IO_ATTRIBUTION_CONTROL_FLAGS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const JOBOBJECT_IO_ATTRIBUTION_CONTROL_FLAGS = *opaque{
};
// --------------------------------------------------------
// Type: JOBOBJECT_IO_ATTRIBUTION_STATS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const JOBOBJECT_IO_ATTRIBUTION_STATS = extern struct {
    IoCount: ?*opaque{},
    TotalNonOverlappedQueueTime: u64,
    TotalNonOverlappedServiceTime: u64,
    TotalSize: u64,
};
// --------------------------------------------------------
// Type: JOBOBJECT_IO_ATTRIBUTION_INFORMATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const JOBOBJECT_IO_ATTRIBUTION_INFORMATION = extern struct {
    ControlFlags: u32,
    ReadStats: JOBOBJECT_IO_ATTRIBUTION_STATS,
    WriteStats: JOBOBJECT_IO_ATTRIBUTION_STATS,
};
// --------------------------------------------------------
// Type: JOBOBJECTINFOCLASS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const JOBOBJECTINFOCLASS = *opaque{
};
// --------------------------------------------------------
// Type: SILOOBJECT_BASIC_INFORMATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SILOOBJECT_BASIC_INFORMATION = extern struct {
    SiloId: u32,
    SiloParentId: u32,
    NumberOfProcesses: u32,
    IsInServerSilo: u8,
    Reserved: ?[*]u8,
};
// --------------------------------------------------------
// Type: SERVERSILO_STATE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const SERVERSILO_STATE = *opaque{
};
// --------------------------------------------------------
// Type: SERVERSILO_BASIC_INFORMATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SERVERSILO_BASIC_INFORMATION = extern struct {
    ServiceSessionId: u32,
    State: SERVERSILO_STATE,
    ExitStatus: u32,
    IsDownlevelContainer: u8,
    ApiSetSchema: ?*opaque{},
    HostApiSetSchema: ?*opaque{},
};
// --------------------------------------------------------
// Type: LOGICAL_PROCESSOR_RELATIONSHIP
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const LOGICAL_PROCESSOR_RELATIONSHIP = *opaque{
};
// --------------------------------------------------------
// Type: PROCESSOR_CACHE_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PROCESSOR_CACHE_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: CACHE_DESCRIPTOR
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CACHE_DESCRIPTOR = extern struct {
    Level: u8,
    Associativity: u8,
    LineSize: u16,
    Size: u32,
    Type: PROCESSOR_CACHE_TYPE,
};
// --------------------------------------------------------
// Type: SYSTEM_LOGICAL_PROCESSOR_INFORMATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SYSTEM_LOGICAL_PROCESSOR_INFORMATION = extern struct {
    ProcessorMask: ?*opaque{},
    Relationship: LOGICAL_PROCESSOR_RELATIONSHIP,
    Anonymous: _Anonymous_e__Union,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
        // --------------------------------------------------------
        // Type: _NumaNode_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _NumaNode_e__Struct = extern struct {
            NodeNumber: u32,
        };
        // --------------------------------------------------------
        // Type: _ProcessorCore_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _ProcessorCore_e__Struct = extern struct {
            Flags: u8,
        };
    };
};
// --------------------------------------------------------
// Type: PROCESSOR_RELATIONSHIP
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PROCESSOR_RELATIONSHIP = extern struct {
    Flags: u8,
    EfficiencyClass: u8,
    Reserved: ?[*]u8,
    GroupCount: u16,
    GroupMask: ?[*]GROUP_AFFINITY,
};
// --------------------------------------------------------
// Type: NUMA_NODE_RELATIONSHIP
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NUMA_NODE_RELATIONSHIP = extern struct {
    NodeNumber: u32,
    Reserved: ?[*]u8,
    GroupMask: GROUP_AFFINITY,
};
// --------------------------------------------------------
// Type: CACHE_RELATIONSHIP
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CACHE_RELATIONSHIP = extern struct {
    Level: u8,
    Associativity: u8,
    LineSize: u16,
    CacheSize: u32,
    Type: PROCESSOR_CACHE_TYPE,
    Reserved: ?[*]u8,
    GroupMask: GROUP_AFFINITY,
};
// --------------------------------------------------------
// Type: PROCESSOR_GROUP_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PROCESSOR_GROUP_INFO = extern struct {
    MaximumProcessorCount: u8,
    ActiveProcessorCount: u8,
    Reserved: ?[*]u8,
    ActiveProcessorMask: ?*opaque{},
};
// --------------------------------------------------------
// Type: GROUP_RELATIONSHIP
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const GROUP_RELATIONSHIP = extern struct {
    MaximumGroupCount: u16,
    ActiveGroupCount: u16,
    Reserved: ?[*]u8,
    GroupInfo: ?[*]PROCESSOR_GROUP_INFO,
};
// --------------------------------------------------------
// Type: SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX = extern struct {
    Relationship: LOGICAL_PROCESSOR_RELATIONSHIP,
    Size: u32,
    Anonymous: _Anonymous_e__Union,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: CPU_SET_INFORMATION_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const CPU_SET_INFORMATION_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: SYSTEM_CPU_SET_INFORMATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SYSTEM_CPU_SET_INFORMATION = extern struct {
    Size: u32,
    Type: CPU_SET_INFORMATION_TYPE,
    Anonymous: _Anonymous_e__Union,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
        // --------------------------------------------------------
        // Type: _CpuSet_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _CpuSet_e__Struct = extern struct {
            Id: u32,
            Group: u16,
            LogicalProcessorIndex: u8,
            CoreIndex: u8,
            LastLevelCacheIndex: u8,
            NumaNodeIndex: u8,
            EfficiencyClass: u8,
            Anonymous1: _Anonymous1_e__Union,
            Anonymous2: _Anonymous2_e__Union,
            AllocationTag: u64,
            // --------------------------------------------------------
            // Type: _Anonymous1_e__Union
            // TypeLayoutAttr: explicit
            // not generating the actual code for this type because it has an explicit layout
            pub const _Anonymous1_e__Union = *opaque{
                // --------------------------------------------------------
                // Type: _Anonymous_e__Struct
                // TypeLayoutAttr: sequential
                // TODO: I think this is a struct, but not sure at this point, assuming it is for now
                pub const _Anonymous_e__Struct = extern struct {
                    _bitfield: u8,
                };
            };
            // --------------------------------------------------------
            // Type: _Anonymous2_e__Union
            // TypeLayoutAttr: explicit
            // not generating the actual code for this type because it has an explicit layout
            pub const _Anonymous2_e__Union = *opaque{
            };
        };
    };
};
// --------------------------------------------------------
// Type: SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION = extern struct {
    CycleTime: u64,
};
// --------------------------------------------------------
// Type: XSTATE_FEATURE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const XSTATE_FEATURE = extern struct {
    Offset: u32,
    Size: u32,
};
// --------------------------------------------------------
// Type: XSTATE_CONFIGURATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const XSTATE_CONFIGURATION = extern struct {
    EnabledFeatures: u64,
    EnabledVolatileFeatures: u64,
    Size: u32,
    Anonymous: _Anonymous_e__Union,
    Features: ?[*]XSTATE_FEATURE,
    EnabledSupervisorFeatures: u64,
    AlignedFeatures: u64,
    AllFeatureSize: u32,
    AllFeatures: ?[*]u32,
    EnabledUserVisibleSupervisorFeatures: u64,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
        // --------------------------------------------------------
        // Type: _Anonymous_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _Anonymous_e__Struct = extern struct {
            _bitfield: u32,
        };
    };
};
// --------------------------------------------------------
// Type: MEMORY_BASIC_INFORMATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const MEMORY_BASIC_INFORMATION = extern struct {
    BaseAddress: ?*opaque{},
    AllocationBase: ?*opaque{},
    AllocationProtect: u32,
    RegionSize: ?*opaque{},
    State: u32,
    Protect: u32,
    Type: u32,
};
// --------------------------------------------------------
// Type: MEMORY_BASIC_INFORMATION32
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const MEMORY_BASIC_INFORMATION32 = extern struct {
    BaseAddress: u32,
    AllocationBase: u32,
    AllocationProtect: u32,
    RegionSize: u32,
    State: u32,
    Protect: u32,
    Type: u32,
};
// --------------------------------------------------------
// Type: MEMORY_BASIC_INFORMATION64
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const MEMORY_BASIC_INFORMATION64 = extern struct {
    BaseAddress: u64,
    AllocationBase: u64,
    AllocationProtect: u32,
    __alignment1: u32,
    RegionSize: u64,
    State: u32,
    Protect: u32,
    Type: u32,
    __alignment2: u32,
};
// --------------------------------------------------------
// Type: CFG_CALL_TARGET_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CFG_CALL_TARGET_INFO = extern struct {
    Offset: ?*opaque{},
    Flags: ?*opaque{},
};
// --------------------------------------------------------
// Type: MEM_ADDRESS_REQUIREMENTS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const MEM_ADDRESS_REQUIREMENTS = extern struct {
    LowestStartingAddress: ?*opaque{},
    HighestEndingAddress: ?*opaque{},
    Alignment: ?*opaque{},
};
// --------------------------------------------------------
// Type: MEM_EXTENDED_PARAMETER_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const MEM_EXTENDED_PARAMETER_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: MEM_EXTENDED_PARAMETER
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const MEM_EXTENDED_PARAMETER = extern struct {
    Anonymous1: _Anonymous1_e__Struct,
    Anonymous2: _Anonymous2_e__Union,
    // --------------------------------------------------------
    // Type: _Anonymous2_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous2_e__Union = *opaque{
    };
    // --------------------------------------------------------
    // Type: _Anonymous1_e__Struct
    // TypeLayoutAttr: sequential
    // TODO: I think this is a struct, but not sure at this point, assuming it is for now
    pub const _Anonymous1_e__Struct = extern struct {
        _bitfield: u64,
    };
};
// --------------------------------------------------------
// Type: MEM_SECTION_EXTENDED_PARAMETER_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const MEM_SECTION_EXTENDED_PARAMETER_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: ENCLAVE_CREATE_INFO_SGX
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const ENCLAVE_CREATE_INFO_SGX = extern struct {
    Secs: ?[*]u8,
};
// --------------------------------------------------------
// Type: ENCLAVE_INIT_INFO_SGX
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const ENCLAVE_INIT_INFO_SGX = extern struct {
    SigStruct: ?[*]u8,
    Reserved1: ?[*]u8,
    EInitToken: ?[*]u8,
    Reserved2: ?[*]u8,
};
// --------------------------------------------------------
// Type: ENCLAVE_CREATE_INFO_VBS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const ENCLAVE_CREATE_INFO_VBS = extern struct {
    Flags: u32,
    OwnerID: ?[*]u8,
};
// --------------------------------------------------------
// Type: ENCLAVE_CREATE_INFO_VBS_BASIC
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const ENCLAVE_CREATE_INFO_VBS_BASIC = extern struct {
    Flags: u32,
    OwnerID: ?[*]u8,
};
// --------------------------------------------------------
// Type: ENCLAVE_LOAD_DATA_VBS_BASIC
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const ENCLAVE_LOAD_DATA_VBS_BASIC = extern struct {
    PageType: u32,
};
// --------------------------------------------------------
// Type: ENCLAVE_INIT_INFO_VBS_BASIC
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const ENCLAVE_INIT_INFO_VBS_BASIC = extern struct {
    FamilyId: ?[*]u8,
    ImageId: ?[*]u8,
    EnclaveSize: u64,
    EnclaveSvn: u32,
    Reserved: u32,
    Anonymous: _Anonymous_e__Union,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: ENCLAVE_INIT_INFO_VBS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const ENCLAVE_INIT_INFO_VBS = extern struct {
    Length: u32,
    ThreadCount: u32,
};
// --------------------------------------------------------
// Type: ENCLAVE_TARGET_FUNCTION
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const ENCLAVE_TARGET_FUNCTION = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PENCLAVE_TARGET_FUNCTION
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PENCLAVE_TARGET_FUNCTION = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: LPENCLAVE_TARGET_FUNCTION
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const LPENCLAVE_TARGET_FUNCTION = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: FILE_SEGMENT_ELEMENT
// TypeLayoutAttr: explicit
// not generating the actual code for this type because it has an explicit layout
pub const FILE_SEGMENT_ELEMENT = *opaque{
};
// --------------------------------------------------------
// Type: SCRUB_DATA_INPUT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SCRUB_DATA_INPUT = extern struct {
    Size: u32,
    Flags: u32,
    MaximumIos: u32,
    ObjectId: ?[*]u32,
    Reserved: ?[*]u32,
    ResumeContext: ?[*]u8,
};
// --------------------------------------------------------
// Type: SCRUB_PARITY_EXTENT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SCRUB_PARITY_EXTENT = extern struct {
    Offset: i64,
    Length: u64,
};
// --------------------------------------------------------
// Type: SCRUB_PARITY_EXTENT_DATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SCRUB_PARITY_EXTENT_DATA = extern struct {
    Size: u16,
    Flags: u16,
    NumberOfParityExtents: u16,
    MaximumNumberOfParityExtents: u16,
    ParityExtents: ?[*]SCRUB_PARITY_EXTENT,
};
// --------------------------------------------------------
// Type: SCRUB_DATA_OUTPUT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SCRUB_DATA_OUTPUT = extern struct {
    Size: u32,
    Flags: u32,
    Status: u32,
    ErrorFileOffset: u64,
    ErrorLength: u64,
    NumberOfBytesRepaired: u64,
    NumberOfBytesFailed: u64,
    InternalFileReference: u64,
    ResumeContextLength: u16,
    ParityExtentDataOffset: u16,
    Reserved: ?[*]u32,
    NumberOfMetadataBytesProcessed: u64,
    NumberOfDataBytesProcessed: u64,
    TotalNumberOfMetadataBytesInUse: u64,
    TotalNumberOfDataBytesInUse: u64,
    ResumeContext: ?[*]u8,
};
// --------------------------------------------------------
// Type: SharedVirtualDiskSupportType
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const SharedVirtualDiskSupportType = *opaque{
};
// --------------------------------------------------------
// Type: SharedVirtualDiskHandleState
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const SharedVirtualDiskHandleState = *opaque{
};
// --------------------------------------------------------
// Type: SHARED_VIRTUAL_DISK_SUPPORT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SHARED_VIRTUAL_DISK_SUPPORT = extern struct {
    SharedVirtualDiskSupport: SharedVirtualDiskSupportType,
    HandleState: SharedVirtualDiskHandleState,
};
// --------------------------------------------------------
// Type: REARRANGE_FILE_DATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const REARRANGE_FILE_DATA = extern struct {
    SourceStartingOffset: u64,
    TargetOffset: u64,
    SourceFileHandle: HANDLE,
    Length: u32,
    Flags: u32,
};
// --------------------------------------------------------
// Type: SHUFFLE_FILE_DATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SHUFFLE_FILE_DATA = extern struct {
    StartingOffset: i64,
    Length: i64,
    Flags: u32,
};
// --------------------------------------------------------
// Type: NETWORK_APP_INSTANCE_EA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NETWORK_APP_INSTANCE_EA = extern struct {
    AppInstanceID: Guid,
    CsvFlags: u32,
};
// --------------------------------------------------------
// Type: SYSTEM_POWER_STATE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const SYSTEM_POWER_STATE = *opaque{
};
// --------------------------------------------------------
// Type: POWER_ACTION
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const POWER_ACTION = *opaque{
};
// --------------------------------------------------------
// Type: DEVICE_POWER_STATE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const DEVICE_POWER_STATE = *opaque{
};
// --------------------------------------------------------
// Type: MONITOR_DISPLAY_STATE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const MONITOR_DISPLAY_STATE = *opaque{
};
// --------------------------------------------------------
// Type: USER_ACTIVITY_PRESENCE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const USER_ACTIVITY_PRESENCE = *opaque{
};
// --------------------------------------------------------
// Type: LATENCY_TIME
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const LATENCY_TIME = *opaque{
};
// --------------------------------------------------------
// Type: POWER_REQUEST_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const POWER_REQUEST_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: CM_Power_Data_s
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CM_Power_Data_s = extern struct {
    PD_Size: u32,
    PD_MostRecentPowerState: DEVICE_POWER_STATE,
    PD_Capabilities: u32,
    PD_D1Latency: u32,
    PD_D2Latency: u32,
    PD_D3Latency: u32,
    PD_PowerStateMapping: ?[*]DEVICE_POWER_STATE,
    PD_DeepestSystemWake: SYSTEM_POWER_STATE,
};
// --------------------------------------------------------
// Type: POWER_INFORMATION_LEVEL
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const POWER_INFORMATION_LEVEL = *opaque{
};
// --------------------------------------------------------
// Type: POWER_USER_PRESENCE_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const POWER_USER_PRESENCE_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: POWER_USER_PRESENCE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const POWER_USER_PRESENCE = extern struct {
    UserPresence: POWER_USER_PRESENCE_TYPE,
};
// --------------------------------------------------------
// Type: POWER_SESSION_CONNECT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const POWER_SESSION_CONNECT = extern struct {
    Connected: u8,
    Console: u8,
};
// --------------------------------------------------------
// Type: POWER_SESSION_TIMEOUTS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const POWER_SESSION_TIMEOUTS = extern struct {
    InputTimeout: u32,
    DisplayTimeout: u32,
};
// --------------------------------------------------------
// Type: POWER_SESSION_RIT_STATE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const POWER_SESSION_RIT_STATE = extern struct {
    Active: u8,
    LastInputTime: u32,
};
// --------------------------------------------------------
// Type: POWER_SESSION_WINLOGON
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const POWER_SESSION_WINLOGON = extern struct {
    SessionId: u32,
    Console: u8,
    Locked: u8,
};
// --------------------------------------------------------
// Type: POWER_SESSION_ALLOW_EXTERNAL_DMA_DEVICES
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const POWER_SESSION_ALLOW_EXTERNAL_DMA_DEVICES = extern struct {
    IsAllowed: u8,
};
// --------------------------------------------------------
// Type: POWER_IDLE_RESILIENCY
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const POWER_IDLE_RESILIENCY = extern struct {
    CoalescingTimeout: u32,
    IdleResiliencyPeriod: u32,
};
// --------------------------------------------------------
// Type: POWER_MONITOR_REQUEST_REASON
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const POWER_MONITOR_REQUEST_REASON = *opaque{
};
// --------------------------------------------------------
// Type: POWER_MONITOR_REQUEST_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const POWER_MONITOR_REQUEST_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: POWER_MONITOR_INVOCATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const POWER_MONITOR_INVOCATION = extern struct {
    Console: u8,
    RequestReason: POWER_MONITOR_REQUEST_REASON,
};
// --------------------------------------------------------
// Type: RESUME_PERFORMANCE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const RESUME_PERFORMANCE = extern struct {
    PostTimeMs: u32,
    TotalResumeTimeMs: u64,
    ResumeCompleteTimestamp: u64,
};
// --------------------------------------------------------
// Type: SYSTEM_POWER_CONDITION
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const SYSTEM_POWER_CONDITION = *opaque{
};
// --------------------------------------------------------
// Type: SET_POWER_SETTING_VALUE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SET_POWER_SETTING_VALUE = extern struct {
    Version: u32,
    Guid: Guid,
    PowerCondition: SYSTEM_POWER_CONDITION,
    DataLength: u32,
    Data: ?[*]u8,
};
// --------------------------------------------------------
// Type: NOTIFY_USER_POWER_SETTING
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NOTIFY_USER_POWER_SETTING = extern struct {
    Guid: Guid,
};
// --------------------------------------------------------
// Type: APPLICATIONLAUNCH_SETTING_VALUE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const APPLICATIONLAUNCH_SETTING_VALUE = extern struct {
    ActivationTime: LARGE_INTEGER,
    Flags: u32,
    ButtonInstanceID: u32,
};
// --------------------------------------------------------
// Type: POWER_PLATFORM_ROLE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const POWER_PLATFORM_ROLE = *opaque{
};
// --------------------------------------------------------
// Type: POWER_PLATFORM_INFORMATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const POWER_PLATFORM_INFORMATION = extern struct {
    AoAc: u8,
};
// --------------------------------------------------------
// Type: BATTERY_REPORTING_SCALE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const BATTERY_REPORTING_SCALE = extern struct {
    Granularity: u32,
    Capacity: u32,
};
// --------------------------------------------------------
// Type: PPM_WMI_LEGACY_PERFSTATE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PPM_WMI_LEGACY_PERFSTATE = extern struct {
    Frequency: u32,
    Flags: u32,
    PercentFrequency: u32,
};
// --------------------------------------------------------
// Type: PPM_WMI_IDLE_STATE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PPM_WMI_IDLE_STATE = extern struct {
    Latency: u32,
    Power: u32,
    TimeCheck: u32,
    PromotePercent: u8,
    DemotePercent: u8,
    StateType: u8,
    Reserved: u8,
    StateFlags: u32,
    Context: u32,
    IdleHandler: u32,
    Reserved1: u32,
};
// --------------------------------------------------------
// Type: PPM_WMI_IDLE_STATES
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PPM_WMI_IDLE_STATES = extern struct {
    Type: u32,
    Count: u32,
    TargetState: u32,
    OldState: u32,
    TargetProcessors: u64,
    State: ?[*]PPM_WMI_IDLE_STATE,
};
// --------------------------------------------------------
// Type: PPM_WMI_IDLE_STATES_EX
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PPM_WMI_IDLE_STATES_EX = extern struct {
    Type: u32,
    Count: u32,
    TargetState: u32,
    OldState: u32,
    TargetProcessors: ?*opaque{},
    State: ?[*]PPM_WMI_IDLE_STATE,
};
// --------------------------------------------------------
// Type: PPM_WMI_PERF_STATE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PPM_WMI_PERF_STATE = extern struct {
    Frequency: u32,
    Power: u32,
    PercentFrequency: u8,
    IncreaseLevel: u8,
    DecreaseLevel: u8,
    Type: u8,
    IncreaseTime: u32,
    DecreaseTime: u32,
    Control: u64,
    Status: u64,
    HitCount: u32,
    Reserved1: u32,
    Reserved2: u64,
    Reserved3: u64,
};
// --------------------------------------------------------
// Type: PPM_WMI_PERF_STATES
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PPM_WMI_PERF_STATES = extern struct {
    Count: u32,
    MaxFrequency: u32,
    CurrentState: u32,
    MaxPerfState: u32,
    MinPerfState: u32,
    LowestPerfState: u32,
    ThermalConstraint: u32,
    BusyAdjThreshold: u8,
    PolicyType: u8,
    Type: u8,
    Reserved: u8,
    TimerInterval: u32,
    TargetProcessors: u64,
    PStateHandler: u32,
    PStateContext: u32,
    TStateHandler: u32,
    TStateContext: u32,
    FeedbackHandler: u32,
    Reserved1: u32,
    Reserved2: u64,
    State: ?[*]PPM_WMI_PERF_STATE,
};
// --------------------------------------------------------
// Type: PPM_WMI_PERF_STATES_EX
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PPM_WMI_PERF_STATES_EX = extern struct {
    Count: u32,
    MaxFrequency: u32,
    CurrentState: u32,
    MaxPerfState: u32,
    MinPerfState: u32,
    LowestPerfState: u32,
    ThermalConstraint: u32,
    BusyAdjThreshold: u8,
    PolicyType: u8,
    Type: u8,
    Reserved: u8,
    TimerInterval: u32,
    TargetProcessors: ?*opaque{},
    PStateHandler: u32,
    PStateContext: u32,
    TStateHandler: u32,
    TStateContext: u32,
    FeedbackHandler: u32,
    Reserved1: u32,
    Reserved2: u64,
    State: ?[*]PPM_WMI_PERF_STATE,
};
// --------------------------------------------------------
// Type: PPM_IDLE_STATE_ACCOUNTING
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PPM_IDLE_STATE_ACCOUNTING = extern struct {
    IdleTransitions: u32,
    FailedTransitions: u32,
    InvalidBucketIndex: u32,
    TotalTime: u64,
    IdleTimeBuckets: ?[*]u32,
};
// --------------------------------------------------------
// Type: PPM_IDLE_ACCOUNTING
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PPM_IDLE_ACCOUNTING = extern struct {
    StateCount: u32,
    TotalTransitions: u32,
    ResetCount: u32,
    StartTime: u64,
    State: ?[*]PPM_IDLE_STATE_ACCOUNTING,
};
// --------------------------------------------------------
// Type: PPM_IDLE_STATE_BUCKET_EX
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PPM_IDLE_STATE_BUCKET_EX = extern struct {
    TotalTimeUs: u64,
    MinTimeUs: u32,
    MaxTimeUs: u32,
    Count: u32,
};
// --------------------------------------------------------
// Type: PPM_IDLE_STATE_ACCOUNTING_EX
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PPM_IDLE_STATE_ACCOUNTING_EX = extern struct {
    TotalTime: u64,
    IdleTransitions: u32,
    FailedTransitions: u32,
    InvalidBucketIndex: u32,
    MinTimeUs: u32,
    MaxTimeUs: u32,
    CancelledTransitions: u32,
    IdleTimeBuckets: ?[*]PPM_IDLE_STATE_BUCKET_EX,
};
// --------------------------------------------------------
// Type: PPM_IDLE_ACCOUNTING_EX
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PPM_IDLE_ACCOUNTING_EX = extern struct {
    StateCount: u32,
    TotalTransitions: u32,
    ResetCount: u32,
    AbortCount: u32,
    StartTime: u64,
    State: ?[*]PPM_IDLE_STATE_ACCOUNTING_EX,
};
// --------------------------------------------------------
// Type: PPM_PERFSTATE_EVENT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PPM_PERFSTATE_EVENT = extern struct {
    State: u32,
    Status: u32,
    Latency: u32,
    Speed: u32,
    Processor: u32,
};
// --------------------------------------------------------
// Type: PPM_PERFSTATE_DOMAIN_EVENT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PPM_PERFSTATE_DOMAIN_EVENT = extern struct {
    State: u32,
    Latency: u32,
    Speed: u32,
    Processors: u64,
};
// --------------------------------------------------------
// Type: PPM_IDLESTATE_EVENT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PPM_IDLESTATE_EVENT = extern struct {
    NewState: u32,
    OldState: u32,
    Processors: u64,
};
// --------------------------------------------------------
// Type: PPM_THERMALCHANGE_EVENT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PPM_THERMALCHANGE_EVENT = extern struct {
    ThermalConstraint: u32,
    Processors: u64,
};
// --------------------------------------------------------
// Type: PPM_THERMAL_POLICY_EVENT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PPM_THERMAL_POLICY_EVENT = extern struct {
    Mode: u8,
    Processors: u64,
};
// --------------------------------------------------------
// Type: POWER_ACTION_POLICY
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const POWER_ACTION_POLICY = extern struct {
    Action: POWER_ACTION,
    Flags: u32,
    EventCode: u32,
};
// --------------------------------------------------------
// Type: SYSTEM_POWER_LEVEL
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SYSTEM_POWER_LEVEL = extern struct {
    Enable: u8,
    Spare: ?[*]u8,
    BatteryLevel: u32,
    PowerPolicy: POWER_ACTION_POLICY,
    MinSystemState: SYSTEM_POWER_STATE,
};
// --------------------------------------------------------
// Type: SYSTEM_POWER_POLICY
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SYSTEM_POWER_POLICY = extern struct {
    Revision: u32,
    PowerButton: POWER_ACTION_POLICY,
    SleepButton: POWER_ACTION_POLICY,
    LidClose: POWER_ACTION_POLICY,
    LidOpenWake: SYSTEM_POWER_STATE,
    Reserved: u32,
    Idle: POWER_ACTION_POLICY,
    IdleTimeout: u32,
    IdleSensitivity: u8,
    DynamicThrottle: u8,
    Spare2: ?[*]u8,
    MinSleep: SYSTEM_POWER_STATE,
    MaxSleep: SYSTEM_POWER_STATE,
    ReducedLatencySleep: SYSTEM_POWER_STATE,
    WinLogonFlags: u32,
    Spare3: u32,
    DozeS4Timeout: u32,
    BroadcastCapacityResolution: u32,
    DischargePolicy: ?[*]SYSTEM_POWER_LEVEL,
    VideoTimeout: u32,
    VideoDimDisplay: u8,
    VideoReserved: ?[*]u32,
    SpindownTimeout: u32,
    OptimizeForPower: u8,
    FanThrottleTolerance: u8,
    ForcedThrottle: u8,
    MinThrottle: u8,
    OverThrottled: POWER_ACTION_POLICY,
};
// --------------------------------------------------------
// Type: PROCESSOR_IDLESTATE_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PROCESSOR_IDLESTATE_INFO = extern struct {
    TimeCheck: u32,
    DemotePercent: u8,
    PromotePercent: u8,
    Spare: ?[*]u8,
};
// --------------------------------------------------------
// Type: PROCESSOR_IDLESTATE_POLICY
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PROCESSOR_IDLESTATE_POLICY = extern struct {
    Revision: u16,
    Flags: _Flags_e__Union,
    PolicyCount: u32,
    Policy: ?[*]PROCESSOR_IDLESTATE_INFO,
    // --------------------------------------------------------
    // Type: _Flags_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Flags_e__Union = *opaque{
        // --------------------------------------------------------
        // Type: _Anonymous_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _Anonymous_e__Struct = extern struct {
            _bitfield: u16,
        };
    };
};
// --------------------------------------------------------
// Type: PROCESSOR_POWER_POLICY_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PROCESSOR_POWER_POLICY_INFO = extern struct {
    TimeCheck: u32,
    DemoteLimit: u32,
    PromoteLimit: u32,
    DemotePercent: u8,
    PromotePercent: u8,
    Spare: ?[*]u8,
    _bitfield: u32,
};
// --------------------------------------------------------
// Type: PROCESSOR_POWER_POLICY
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PROCESSOR_POWER_POLICY = extern struct {
    Revision: u32,
    DynamicThrottle: u8,
    Spare: ?[*]u8,
    _bitfield: u32,
    PolicyCount: u32,
    Policy: ?[*]PROCESSOR_POWER_POLICY_INFO,
};
// --------------------------------------------------------
// Type: PROCESSOR_PERFSTATE_POLICY
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PROCESSOR_PERFSTATE_POLICY = extern struct {
    Revision: u32,
    MaxThrottle: u8,
    MinThrottle: u8,
    BusyAdjThreshold: u8,
    Anonymous: _Anonymous_e__Union,
    TimeCheck: u32,
    IncreaseTime: u32,
    DecreaseTime: u32,
    IncreasePercent: u32,
    DecreasePercent: u32,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
        // --------------------------------------------------------
        // Type: _Flags_e__Union
        // TypeLayoutAttr: explicit
        // not generating the actual code for this type because it has an explicit layout
        pub const _Flags_e__Union = *opaque{
            // --------------------------------------------------------
            // Type: _Anonymous_e__Struct
            // TypeLayoutAttr: sequential
            // TODO: I think this is a struct, but not sure at this point, assuming it is for now
            pub const _Anonymous_e__Struct = extern struct {
                _bitfield: u8,
            };
        };
    };
};
// --------------------------------------------------------
// Type: ADMINISTRATOR_POWER_POLICY
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const ADMINISTRATOR_POWER_POLICY = extern struct {
    MinSleep: SYSTEM_POWER_STATE,
    MaxSleep: SYSTEM_POWER_STATE,
    MinVideoTimeout: u32,
    MaxVideoTimeout: u32,
    MinSpindownTimeout: u32,
    MaxSpindownTimeout: u32,
};
// --------------------------------------------------------
// Type: HIBERFILE_BUCKET_SIZE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const HIBERFILE_BUCKET_SIZE = *opaque{
};
// --------------------------------------------------------
// Type: HIBERFILE_BUCKET
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HIBERFILE_BUCKET = extern struct {
    MaxPhysicalMemory: u64,
    PhysicalMemoryPercent: ?[*]u32,
};
// --------------------------------------------------------
// Type: SYSTEM_POWER_CAPABILITIES
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SYSTEM_POWER_CAPABILITIES = extern struct {
    PowerButtonPresent: u8,
    SleepButtonPresent: u8,
    LidPresent: u8,
    SystemS1: u8,
    SystemS2: u8,
    SystemS3: u8,
    SystemS4: u8,
    SystemS5: u8,
    HiberFilePresent: u8,
    FullWake: u8,
    VideoDimPresent: u8,
    ApmPresent: u8,
    UpsPresent: u8,
    ThermalControl: u8,
    ProcessorThrottle: u8,
    ProcessorMinThrottle: u8,
    ProcessorMaxThrottle: u8,
    FastSystemS4: u8,
    Hiberboot: u8,
    WakeAlarmPresent: u8,
    AoAc: u8,
    DiskSpinDown: u8,
    HiberFileType: u8,
    AoAcConnectivitySupported: u8,
    spare3: ?[*]u8,
    SystemBatteriesPresent: u8,
    BatteriesAreShortTerm: u8,
    BatteryScale: ?[*]BATTERY_REPORTING_SCALE,
    AcOnLineWake: SYSTEM_POWER_STATE,
    SoftLidWake: SYSTEM_POWER_STATE,
    RtcWake: SYSTEM_POWER_STATE,
    MinDeviceWakeState: SYSTEM_POWER_STATE,
    DefaultLowLatencyWake: SYSTEM_POWER_STATE,
};
// --------------------------------------------------------
// Type: SYSTEM_BATTERY_STATE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SYSTEM_BATTERY_STATE = extern struct {
    AcOnLine: u8,
    BatteryPresent: u8,
    Charging: u8,
    Discharging: u8,
    Spare1: ?[*]u8,
    Tag: u8,
    MaxCapacity: u32,
    RemainingCapacity: u32,
    Rate: u32,
    EstimatedTime: u32,
    DefaultAlert1: u32,
    DefaultAlert2: u32,
};
// --------------------------------------------------------
// Type: IMAGE_DOS_HEADER
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=2 Size=0
pub const IMAGE_DOS_HEADER = *opaque{
};
// --------------------------------------------------------
// Type: IMAGE_OS2_HEADER
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=2 Size=0
pub const IMAGE_OS2_HEADER = *opaque{
};
// --------------------------------------------------------
// Type: IMAGE_VXD_HEADER
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=2 Size=0
pub const IMAGE_VXD_HEADER = *opaque{
};
// --------------------------------------------------------
// Type: IMAGE_OPTIONAL_HEADER
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const IMAGE_OPTIONAL_HEADER = extern struct {
    Magic: u16,
    MajorLinkerVersion: u8,
    MinorLinkerVersion: u8,
    SizeOfCode: u32,
    SizeOfInitializedData: u32,
    SizeOfUninitializedData: u32,
    AddressOfEntryPoint: u32,
    BaseOfCode: u32,
    BaseOfData: u32,
    ImageBase: u32,
    SectionAlignment: u32,
    FileAlignment: u32,
    MajorOperatingSystemVersion: u16,
    MinorOperatingSystemVersion: u16,
    MajorImageVersion: u16,
    MinorImageVersion: u16,
    MajorSubsystemVersion: u16,
    MinorSubsystemVersion: u16,
    Win32VersionValue: u32,
    SizeOfImage: u32,
    SizeOfHeaders: u32,
    CheckSum: u32,
    Subsystem: u16,
    DllCharacteristics: u16,
    SizeOfStackReserve: u32,
    SizeOfStackCommit: u32,
    SizeOfHeapReserve: u32,
    SizeOfHeapCommit: u32,
    LoaderFlags: u32,
    NumberOfRvaAndSizes: u32,
    DataDirectory: ?[*]IMAGE_DATA_DIRECTORY,
};
// --------------------------------------------------------
// Type: IMAGE_ROM_OPTIONAL_HEADER
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const IMAGE_ROM_OPTIONAL_HEADER = extern struct {
    Magic: u16,
    MajorLinkerVersion: u8,
    MinorLinkerVersion: u8,
    SizeOfCode: u32,
    SizeOfInitializedData: u32,
    SizeOfUninitializedData: u32,
    AddressOfEntryPoint: u32,
    BaseOfCode: u32,
    BaseOfData: u32,
    BaseOfBss: u32,
    GprMask: u32,
    CprMask: ?[*]u32,
    GpValue: u32,
};
// --------------------------------------------------------
// Type: IMAGE_NT_HEADERS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const IMAGE_NT_HEADERS = extern struct {
    Signature: u32,
    FileHeader: IMAGE_FILE_HEADER,
    OptionalHeader: IMAGE_OPTIONAL_HEADER,
};
// --------------------------------------------------------
// Type: IMAGE_ROM_HEADERS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const IMAGE_ROM_HEADERS = extern struct {
    FileHeader: IMAGE_FILE_HEADER,
    OptionalHeader: IMAGE_ROM_OPTIONAL_HEADER,
};
// --------------------------------------------------------
// Type: ANON_OBJECT_HEADER
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const ANON_OBJECT_HEADER = extern struct {
    Sig1: u16,
    Sig2: u16,
    Version: u16,
    Machine: u16,
    TimeDateStamp: u32,
    ClassID: Guid,
    SizeOfData: u32,
};
// --------------------------------------------------------
// Type: ANON_OBJECT_HEADER_V2
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const ANON_OBJECT_HEADER_V2 = extern struct {
    Sig1: u16,
    Sig2: u16,
    Version: u16,
    Machine: u16,
    TimeDateStamp: u32,
    ClassID: Guid,
    SizeOfData: u32,
    Flags: u32,
    MetaDataSize: u32,
    MetaDataOffset: u32,
};
// --------------------------------------------------------
// Type: ANON_OBJECT_HEADER_BIGOBJ
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const ANON_OBJECT_HEADER_BIGOBJ = extern struct {
    Sig1: u16,
    Sig2: u16,
    Version: u16,
    Machine: u16,
    TimeDateStamp: u32,
    ClassID: Guid,
    SizeOfData: u32,
    Flags: u32,
    MetaDataSize: u32,
    MetaDataOffset: u32,
    NumberOfSections: u32,
    PointerToSymbolTable: u32,
    NumberOfSymbols: u32,
};
// --------------------------------------------------------
// Type: IMAGE_SYMBOL
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=2 Size=0
pub const IMAGE_SYMBOL = *opaque{
    // --------------------------------------------------------
    // Type: _N_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _N_e__Union = *opaque{
        // --------------------------------------------------------
        // Type: _Name_e__Struct
        // TypeLayoutAttr: sequential
        // not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=2 Size=0
        pub const _Name_e__Struct = *opaque{
        };
    };
};
// --------------------------------------------------------
// Type: IMAGE_SYMBOL_EX
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=2 Size=0
pub const IMAGE_SYMBOL_EX = *opaque{
    // --------------------------------------------------------
    // Type: _N_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _N_e__Union = *opaque{
        // --------------------------------------------------------
        // Type: _Name_e__Struct
        // TypeLayoutAttr: sequential
        // not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=2 Size=0
        pub const _Name_e__Struct = *opaque{
        };
    };
};
// --------------------------------------------------------
// Type: IMAGE_AUX_SYMBOL_TOKEN_DEF
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=2 Size=0
pub const IMAGE_AUX_SYMBOL_TOKEN_DEF = *opaque{
};
// --------------------------------------------------------
// Type: IMAGE_AUX_SYMBOL
// TypeLayoutAttr: explicit
// not generating the actual code for this type because it has an explicit layout
pub const IMAGE_AUX_SYMBOL = *opaque{
    // --------------------------------------------------------
    // Type: _CRC_e__Struct
    // TypeLayoutAttr: sequential
    // not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=2 Size=0
    pub const _CRC_e__Struct = *opaque{
    };
    // --------------------------------------------------------
    // Type: _File_e__Struct
    // TypeLayoutAttr: sequential
    // TODO: I think this is a struct, but not sure at this point, assuming it is for now
    pub const _File_e__Struct = extern struct {
        Name: ?[*]u8,
    };
    // --------------------------------------------------------
    // Type: _Sym_e__Struct
    // TypeLayoutAttr: sequential
    // not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=2 Size=0
    pub const _Sym_e__Struct = *opaque{
        // --------------------------------------------------------
        // Type: _FcnAry_e__Union
        // TypeLayoutAttr: explicit
        // not generating the actual code for this type because it has an explicit layout
        pub const _FcnAry_e__Union = *opaque{
            // --------------------------------------------------------
            // Type: _Array_e__Struct
            // TypeLayoutAttr: sequential
            // TODO: I think this is a struct, but not sure at this point, assuming it is for now
            pub const _Array_e__Struct = extern struct {
                Dimension: ?[*]u16,
            };
            // --------------------------------------------------------
            // Type: _Function_e__Struct
            // TypeLayoutAttr: sequential
            // not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=2 Size=0
            pub const _Function_e__Struct = *opaque{
            };
        };
        // --------------------------------------------------------
        // Type: _Misc_e__Union
        // TypeLayoutAttr: explicit
        // not generating the actual code for this type because it has an explicit layout
        pub const _Misc_e__Union = *opaque{
            // --------------------------------------------------------
            // Type: _LnSz_e__Struct
            // TypeLayoutAttr: sequential
            // TODO: I think this is a struct, but not sure at this point, assuming it is for now
            pub const _LnSz_e__Struct = extern struct {
                Linenumber: u16,
                Size: u16,
            };
        };
    };
    // --------------------------------------------------------
    // Type: _Section_e__Struct
    // TypeLayoutAttr: sequential
    // not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=2 Size=0
    pub const _Section_e__Struct = *opaque{
    };
};
// --------------------------------------------------------
// Type: IMAGE_AUX_SYMBOL_EX
// TypeLayoutAttr: explicit
// not generating the actual code for this type because it has an explicit layout
pub const IMAGE_AUX_SYMBOL_EX = *opaque{
    // --------------------------------------------------------
    // Type: _Anonymous_e__Struct
    // TypeLayoutAttr: sequential
    // TODO: I think this is a struct, but not sure at this point, assuming it is for now
    pub const _Anonymous_e__Struct = extern struct {
        TokenDef: IMAGE_AUX_SYMBOL_TOKEN_DEF,
        rgbReserved: ?[*]u8,
    };
    // --------------------------------------------------------
    // Type: _File_e__Struct
    // TypeLayoutAttr: sequential
    // TODO: I think this is a struct, but not sure at this point, assuming it is for now
    pub const _File_e__Struct = extern struct {
        Name: ?[*]u8,
    };
    // --------------------------------------------------------
    // Type: _CRC_e__Struct
    // TypeLayoutAttr: sequential
    // not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=2 Size=0
    pub const _CRC_e__Struct = *opaque{
    };
    // --------------------------------------------------------
    // Type: _Sym_e__Struct
    // TypeLayoutAttr: sequential
    // not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=2 Size=0
    pub const _Sym_e__Struct = *opaque{
    };
    // --------------------------------------------------------
    // Type: _Section_e__Struct
    // TypeLayoutAttr: sequential
    // not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=2 Size=0
    pub const _Section_e__Struct = *opaque{
    };
};
// --------------------------------------------------------
// Type: IMAGE_AUX_SYMBOL_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const IMAGE_AUX_SYMBOL_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: IMAGE_RELOCATION
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=2 Size=0
pub const IMAGE_RELOCATION = *opaque{
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: IMAGE_LINENUMBER
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const IMAGE_LINENUMBER = extern struct {
    Type: _Type_e__Union,
    Linenumber: u16,
    // --------------------------------------------------------
    // Type: _Type_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Type_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: IMAGE_BASE_RELOCATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const IMAGE_BASE_RELOCATION = extern struct {
    VirtualAddress: u32,
    SizeOfBlock: u32,
};
// --------------------------------------------------------
// Type: IMAGE_ARCHIVE_MEMBER_HEADER
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const IMAGE_ARCHIVE_MEMBER_HEADER = extern struct {
    Name: ?[*]u8,
    Date: ?[*]u8,
    UserID: ?[*]u8,
    GroupID: ?[*]u8,
    Mode: ?[*]u8,
    Size: ?[*]u8,
    EndHeader: ?[*]u8,
};
// --------------------------------------------------------
// Type: IMAGE_EXPORT_DIRECTORY
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const IMAGE_EXPORT_DIRECTORY = extern struct {
    Characteristics: u32,
    TimeDateStamp: u32,
    MajorVersion: u16,
    MinorVersion: u16,
    Name: u32,
    Base: u32,
    NumberOfFunctions: u32,
    NumberOfNames: u32,
    AddressOfFunctions: u32,
    AddressOfNames: u32,
    AddressOfNameOrdinals: u32,
};
// --------------------------------------------------------
// Type: IMAGE_IMPORT_BY_NAME
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const IMAGE_IMPORT_BY_NAME = extern struct {
    Hint: u16,
    Name: ?[*]i8,
};
// --------------------------------------------------------
// Type: IMAGE_THUNK_DATA64
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const IMAGE_THUNK_DATA64 = extern struct {
    u1: _u1_e__Union,
    // --------------------------------------------------------
    // Type: _u1_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _u1_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: IMAGE_THUNK_DATA32
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const IMAGE_THUNK_DATA32 = extern struct {
    u1: _u1_e__Union,
    // --------------------------------------------------------
    // Type: _u1_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _u1_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: PIMAGE_TLS_CALLBACK
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PIMAGE_TLS_CALLBACK = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: IMAGE_TLS_DIRECTORY64
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=4 Size=0
pub const IMAGE_TLS_DIRECTORY64 = *opaque{
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
        // --------------------------------------------------------
        // Type: _Anonymous_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _Anonymous_e__Struct = extern struct {
            _bitfield: u32,
        };
    };
};
// --------------------------------------------------------
// Type: IMAGE_TLS_DIRECTORY32
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const IMAGE_TLS_DIRECTORY32 = extern struct {
    StartAddressOfRawData: u32,
    EndAddressOfRawData: u32,
    AddressOfIndex: u32,
    AddressOfCallBacks: u32,
    SizeOfZeroFill: u32,
    Anonymous: _Anonymous_e__Union,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
        // --------------------------------------------------------
        // Type: _Anonymous_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _Anonymous_e__Struct = extern struct {
            _bitfield: u32,
        };
    };
};
// --------------------------------------------------------
// Type: IMAGE_IMPORT_DESCRIPTOR
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const IMAGE_IMPORT_DESCRIPTOR = extern struct {
    Anonymous: _Anonymous_e__Union,
    TimeDateStamp: u32,
    ForwarderChain: u32,
    Name: u32,
    FirstThunk: u32,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: IMAGE_BOUND_IMPORT_DESCRIPTOR
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const IMAGE_BOUND_IMPORT_DESCRIPTOR = extern struct {
    TimeDateStamp: u32,
    OffsetModuleName: u16,
    NumberOfModuleForwarderRefs: u16,
};
// --------------------------------------------------------
// Type: IMAGE_BOUND_FORWARDER_REF
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const IMAGE_BOUND_FORWARDER_REF = extern struct {
    TimeDateStamp: u32,
    OffsetModuleName: u16,
    Reserved: u16,
};
// --------------------------------------------------------
// Type: IMAGE_DELAYLOAD_DESCRIPTOR
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const IMAGE_DELAYLOAD_DESCRIPTOR = extern struct {
    Attributes: _Attributes_e__Union,
    DllNameRVA: u32,
    ModuleHandleRVA: u32,
    ImportAddressTableRVA: u32,
    ImportNameTableRVA: u32,
    BoundImportAddressTableRVA: u32,
    UnloadInformationTableRVA: u32,
    TimeDateStamp: u32,
    // --------------------------------------------------------
    // Type: _Attributes_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Attributes_e__Union = *opaque{
        // --------------------------------------------------------
        // Type: _Anonymous_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _Anonymous_e__Struct = extern struct {
            _bitfield: u32,
        };
    };
};
// --------------------------------------------------------
// Type: IMAGE_RESOURCE_DIRECTORY
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const IMAGE_RESOURCE_DIRECTORY = extern struct {
    Characteristics: u32,
    TimeDateStamp: u32,
    MajorVersion: u16,
    MinorVersion: u16,
    NumberOfNamedEntries: u16,
    NumberOfIdEntries: u16,
};
// --------------------------------------------------------
// Type: IMAGE_RESOURCE_DIRECTORY_ENTRY
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const IMAGE_RESOURCE_DIRECTORY_ENTRY = extern struct {
    Anonymous1: _Anonymous1_e__Union,
    Anonymous2: _Anonymous2_e__Union,
    // --------------------------------------------------------
    // Type: _Anonymous2_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous2_e__Union = *opaque{
        // --------------------------------------------------------
        // Type: _Anonymous_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _Anonymous_e__Struct = extern struct {
            _bitfield: u32,
        };
    };
    // --------------------------------------------------------
    // Type: _Anonymous1_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous1_e__Union = *opaque{
        // --------------------------------------------------------
        // Type: _Anonymous_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _Anonymous_e__Struct = extern struct {
            _bitfield: u32,
        };
    };
};
// --------------------------------------------------------
// Type: IMAGE_RESOURCE_DIRECTORY_STRING
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const IMAGE_RESOURCE_DIRECTORY_STRING = extern struct {
    Length: u16,
    NameString: ?[*]i8,
};
// --------------------------------------------------------
// Type: IMAGE_RESOURCE_DIR_STRING_U
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const IMAGE_RESOURCE_DIR_STRING_U = extern struct {
    Length: u16,
    NameString: ?[*]u16,
};
// --------------------------------------------------------
// Type: IMAGE_RESOURCE_DATA_ENTRY
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const IMAGE_RESOURCE_DATA_ENTRY = extern struct {
    OffsetToData: u32,
    Size: u32,
    CodePage: u32,
    Reserved: u32,
};
// --------------------------------------------------------
// Type: IMAGE_LOAD_CONFIG_CODE_INTEGRITY
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const IMAGE_LOAD_CONFIG_CODE_INTEGRITY = extern struct {
    Flags: u16,
    Catalog: u16,
    CatalogOffset: u32,
    Reserved: u32,
};
// --------------------------------------------------------
// Type: IMAGE_DYNAMIC_RELOCATION_TABLE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const IMAGE_DYNAMIC_RELOCATION_TABLE = extern struct {
    Version: u32,
    Size: u32,
};
// --------------------------------------------------------
// Type: IMAGE_DYNAMIC_RELOCATION32
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const IMAGE_DYNAMIC_RELOCATION32 = *opaque{
};
// --------------------------------------------------------
// Type: IMAGE_DYNAMIC_RELOCATION64
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const IMAGE_DYNAMIC_RELOCATION64 = *opaque{
};
// --------------------------------------------------------
// Type: IMAGE_DYNAMIC_RELOCATION32_V2
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const IMAGE_DYNAMIC_RELOCATION32_V2 = *opaque{
};
// --------------------------------------------------------
// Type: IMAGE_DYNAMIC_RELOCATION64_V2
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const IMAGE_DYNAMIC_RELOCATION64_V2 = *opaque{
};
// --------------------------------------------------------
// Type: IMAGE_PROLOGUE_DYNAMIC_RELOCATION_HEADER
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const IMAGE_PROLOGUE_DYNAMIC_RELOCATION_HEADER = extern struct {
    PrologueByteCount: u8,
};
// --------------------------------------------------------
// Type: IMAGE_EPILOGUE_DYNAMIC_RELOCATION_HEADER
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const IMAGE_EPILOGUE_DYNAMIC_RELOCATION_HEADER = *opaque{
};
// --------------------------------------------------------
// Type: IMAGE_IMPORT_CONTROL_TRANSFER_DYNAMIC_RELOCATION
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const IMAGE_IMPORT_CONTROL_TRANSFER_DYNAMIC_RELOCATION = *opaque{
};
// --------------------------------------------------------
// Type: IMAGE_INDIR_CONTROL_TRANSFER_DYNAMIC_RELOCATION
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const IMAGE_INDIR_CONTROL_TRANSFER_DYNAMIC_RELOCATION = *opaque{
};
// --------------------------------------------------------
// Type: IMAGE_SWITCHTABLE_BRANCH_DYNAMIC_RELOCATION
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const IMAGE_SWITCHTABLE_BRANCH_DYNAMIC_RELOCATION = *opaque{
};
// --------------------------------------------------------
// Type: IMAGE_HOT_PATCH_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const IMAGE_HOT_PATCH_INFO = extern struct {
    Version: u32,
    Size: u32,
    SequenceNumber: u32,
    BaseImageList: u32,
    BaseImageCount: u32,
    BufferOffset: u32,
    ExtraPatchSize: u32,
};
// --------------------------------------------------------
// Type: IMAGE_HOT_PATCH_BASE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const IMAGE_HOT_PATCH_BASE = extern struct {
    SequenceNumber: u32,
    Flags: u32,
    OriginalTimeDateStamp: u32,
    OriginalCheckSum: u32,
    CodeIntegrityInfo: u32,
    CodeIntegritySize: u32,
    PatchTable: u32,
    BufferOffset: u32,
};
// --------------------------------------------------------
// Type: IMAGE_HOT_PATCH_HASHES
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const IMAGE_HOT_PATCH_HASHES = extern struct {
    SHA256: ?[*]u8,
    SHA1: ?[*]u8,
};
// --------------------------------------------------------
// Type: IMAGE_CE_RUNTIME_FUNCTION_ENTRY
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const IMAGE_CE_RUNTIME_FUNCTION_ENTRY = extern struct {
    FuncStart: u32,
    _bitfield: u32,
};
// --------------------------------------------------------
// Type: IMAGE_ARM_RUNTIME_FUNCTION_ENTRY
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const IMAGE_ARM_RUNTIME_FUNCTION_ENTRY = extern struct {
    BeginAddress: u32,
    Anonymous: _Anonymous_e__Union,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
        // --------------------------------------------------------
        // Type: _Anonymous_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _Anonymous_e__Struct = extern struct {
            _bitfield: u32,
        };
    };
};
// --------------------------------------------------------
// Type: ARM64_FNPDATA_FLAGS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const ARM64_FNPDATA_FLAGS = *opaque{
};
// --------------------------------------------------------
// Type: ARM64_FNPDATA_CR
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const ARM64_FNPDATA_CR = *opaque{
};
// --------------------------------------------------------
// Type: IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY = extern struct {
    BeginAddress: u32,
    Anonymous: _Anonymous_e__Union,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
        // --------------------------------------------------------
        // Type: _Anonymous_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _Anonymous_e__Struct = extern struct {
            _bitfield: u32,
        };
    };
};
// --------------------------------------------------------
// Type: IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY_XDATA
// TypeLayoutAttr: explicit
// not generating the actual code for this type because it has an explicit layout
pub const IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY_XDATA = *opaque{
    // --------------------------------------------------------
    // Type: _Anonymous_e__Struct
    // TypeLayoutAttr: sequential
    // TODO: I think this is a struct, but not sure at this point, assuming it is for now
    pub const _Anonymous_e__Struct = extern struct {
        _bitfield: u32,
    };
};
// --------------------------------------------------------
// Type: IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=4 Size=0
pub const IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY = *opaque{
};
// --------------------------------------------------------
// Type: IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY = extern struct {
    BeginAddress: u32,
    EndAddress: u32,
    ExceptionHandler: u32,
    HandlerData: u32,
    PrologEndAddress: u32,
};
// --------------------------------------------------------
// Type: IMAGE_RUNTIME_FUNCTION_ENTRY
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const IMAGE_RUNTIME_FUNCTION_ENTRY = extern struct {
    BeginAddress: u32,
    EndAddress: u32,
    Anonymous: _Anonymous_e__Union,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: IMAGE_ENCLAVE_CONFIG32
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const IMAGE_ENCLAVE_CONFIG32 = extern struct {
    Size: u32,
    MinimumRequiredConfigSize: u32,
    PolicyFlags: u32,
    NumberOfImports: u32,
    ImportList: u32,
    ImportEntrySize: u32,
    FamilyID: ?[*]u8,
    ImageID: ?[*]u8,
    ImageVersion: u32,
    SecurityVersion: u32,
    EnclaveSize: u32,
    NumberOfThreads: u32,
    EnclaveFlags: u32,
};
// --------------------------------------------------------
// Type: IMAGE_ENCLAVE_CONFIG64
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=4 Size=0
pub const IMAGE_ENCLAVE_CONFIG64 = *opaque{
};
// --------------------------------------------------------
// Type: IMAGE_ENCLAVE_IMPORT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const IMAGE_ENCLAVE_IMPORT = extern struct {
    MatchType: u32,
    MinimumSecurityVersion: u32,
    UniqueOrAuthorID: ?[*]u8,
    FamilyID: ?[*]u8,
    ImageID: ?[*]u8,
    ImportName: u32,
    Reserved: u32,
};
// --------------------------------------------------------
// Type: IMAGE_DEBUG_MISC
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const IMAGE_DEBUG_MISC = extern struct {
    DataType: u32,
    Length: u32,
    Unicode: u8,
    Reserved: ?[*]u8,
    Data: ?[*]u8,
};
// --------------------------------------------------------
// Type: IMAGE_SEPARATE_DEBUG_HEADER
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const IMAGE_SEPARATE_DEBUG_HEADER = extern struct {
    Signature: u16,
    Flags: u16,
    Machine: u16,
    Characteristics: u16,
    TimeDateStamp: u32,
    CheckSum: u32,
    ImageBase: u32,
    SizeOfImage: u32,
    NumberOfSections: u32,
    ExportedNamesSize: u32,
    DebugDirectorySize: u32,
    SectionAlignment: u32,
    Reserved: ?[*]u32,
};
// --------------------------------------------------------
// Type: NON_PAGED_DEBUG_INFO
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=4 Size=0
pub const NON_PAGED_DEBUG_INFO = *opaque{
};
// --------------------------------------------------------
// Type: IMAGE_ARCHITECTURE_HEADER
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const IMAGE_ARCHITECTURE_HEADER = extern struct {
    _bitfield: u32,
    FirstEntryRVA: u32,
};
// --------------------------------------------------------
// Type: IMAGE_ARCHITECTURE_ENTRY
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const IMAGE_ARCHITECTURE_ENTRY = extern struct {
    FixupInstRVA: u32,
    NewInst: u32,
};
// --------------------------------------------------------
// Type: IMPORT_OBJECT_HEADER
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const IMPORT_OBJECT_HEADER = extern struct {
    Sig1: u16,
    Sig2: u16,
    Version: u16,
    Machine: u16,
    TimeDateStamp: u32,
    SizeOfData: u32,
    Anonymous: _Anonymous_e__Union,
    _bitfield: u16,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: IMPORT_OBJECT_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const IMPORT_OBJECT_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: IMPORT_OBJECT_NAME_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const IMPORT_OBJECT_NAME_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: ReplacesCorHdrNumericDefines
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const ReplacesCorHdrNumericDefines = *opaque{
};
// --------------------------------------------------------
// Type: IMAGE_COR20_HEADER
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const IMAGE_COR20_HEADER = extern struct {
    cb: u32,
    MajorRuntimeVersion: u16,
    MinorRuntimeVersion: u16,
    MetaData: IMAGE_DATA_DIRECTORY,
    Flags: u32,
    Anonymous: _Anonymous_e__Union,
    Resources: IMAGE_DATA_DIRECTORY,
    StrongNameSignature: IMAGE_DATA_DIRECTORY,
    CodeManagerTable: IMAGE_DATA_DIRECTORY,
    VTableFixups: IMAGE_DATA_DIRECTORY,
    ExportAddressTableJumps: IMAGE_DATA_DIRECTORY,
    ManagedNativeHeader: IMAGE_DATA_DIRECTORY,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: SLIST_HEADER
// TypeLayoutAttr: explicit
// not generating the actual code for this type because it has an explicit layout
pub const SLIST_HEADER = *opaque{
    // --------------------------------------------------------
    // Type: _Anonymous_e__Struct
    // TypeLayoutAttr: sequential
    // TODO: I think this is a struct, but not sure at this point, assuming it is for now
    pub const _Anonymous_e__Struct = extern struct {
        Next: SINGLE_LIST_ENTRY,
        Depth: u16,
        CpuId: u16,
    };
};
// --------------------------------------------------------
// Type: RTL_RUN_ONCE
// TypeLayoutAttr: explicit
// not generating the actual code for this type because it has an explicit layout
pub const RTL_RUN_ONCE = *opaque{
};
// --------------------------------------------------------
// Type: RTL_BARRIER
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const RTL_BARRIER = extern struct {
    Reserved1: u32,
    Reserved2: u32,
    Reserved3: ?[*]?*opaque{},
    Reserved4: u32,
    Reserved5: u32,
};
// --------------------------------------------------------
// Type: RTL_UMS_THREAD_INFO_CLASS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const RTL_UMS_THREAD_INFO_CLASS = *opaque{
};
// --------------------------------------------------------
// Type: RTL_UMS_SCHEDULER_REASON
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const RTL_UMS_SCHEDULER_REASON = *opaque{
};
// --------------------------------------------------------
// Type: RTL_UMS_SCHEDULER_ENTRY_POINT
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const RTL_UMS_SCHEDULER_ENTRY_POINT = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PRTL_UMS_SCHEDULER_ENTRY_POINT
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PRTL_UMS_SCHEDULER_ENTRY_POINT = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: OS_DEPLOYEMENT_STATE_VALUES
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const OS_DEPLOYEMENT_STATE_VALUES = *opaque{
};
// --------------------------------------------------------
// Type: NV_MEMORY_RANGE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NV_MEMORY_RANGE = extern struct {
    BaseAddress: ?*opaque{},
    Length: ?*opaque{},
};
// --------------------------------------------------------
// Type: CORRELATION_VECTOR
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CORRELATION_VECTOR = extern struct {
    Version: i8,
    Vector: ?[*]i8,
};
// --------------------------------------------------------
// Type: CUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG = extern struct {
    Size: u32,
    TriggerId: ?*u16,
};
// --------------------------------------------------------
// Type: IMAGE_POLICY_ENTRY_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const IMAGE_POLICY_ENTRY_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: IMAGE_POLICY_ID
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const IMAGE_POLICY_ID = *opaque{
};
// --------------------------------------------------------
// Type: IMAGE_POLICY_ENTRY
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const IMAGE_POLICY_ENTRY = extern struct {
    Type: IMAGE_POLICY_ENTRY_TYPE,
    PolicyId: IMAGE_POLICY_ID,
    u: _u_e__Union,
    // --------------------------------------------------------
    // Type: _u_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _u_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: IMAGE_POLICY_METADATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const IMAGE_POLICY_METADATA = extern struct {
    Version: u8,
    Reserved0: ?[*]u8,
    ApplicationId: u64,
    Policies: IMAGE_POLICY_ENTRY,
};
// --------------------------------------------------------
// Type: RTL_CRITICAL_SECTION_DEBUG
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const RTL_CRITICAL_SECTION_DEBUG = extern struct {
    Type: u16,
    CreatorBackTraceIndex: u16,
    CriticalSection: ?*RTL_CRITICAL_SECTION,
    ProcessLocksList: LIST_ENTRY,
    EntryCount: u32,
    ContentionCount: u32,
    Flags: u32,
    CreatorBackTraceIndexHigh: u16,
    SpareWORD: u16,
};
// --------------------------------------------------------
// Type: RTL_CRITICAL_SECTION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const RTL_CRITICAL_SECTION = extern struct {
    DebugInfo: ?*RTL_CRITICAL_SECTION_DEBUG,
    LockCount: i32,
    RecursionCount: i32,
    OwningThread: HANDLE,
    LockSemaphore: HANDLE,
    SpinCount: ?*opaque{},
};
// --------------------------------------------------------
// Type: RTL_SRWLOCK
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const RTL_SRWLOCK = extern struct {
    Ptr: ?*opaque{},
};
// --------------------------------------------------------
// Type: RTL_CONDITION_VARIABLE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const RTL_CONDITION_VARIABLE = extern struct {
    Ptr: ?*opaque{},
};
// --------------------------------------------------------
// Type: PAPCFUNC
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PAPCFUNC = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: HEAP_INFORMATION_CLASS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const HEAP_INFORMATION_CLASS = *opaque{
};
// --------------------------------------------------------
// Type: HEAP_OPTIMIZE_RESOURCES_INFORMATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HEAP_OPTIMIZE_RESOURCES_INFORMATION = extern struct {
    Version: u32,
    Flags: u32,
};
// --------------------------------------------------------
// Type: WAITORTIMERCALLBACKFUNC
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const WAITORTIMERCALLBACKFUNC = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: WORKERCALLBACKFUNC
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const WORKERCALLBACKFUNC = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: APC_CALLBACK_FUNCTION
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const APC_CALLBACK_FUNCTION = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: WAITORTIMERCALLBACK
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const WAITORTIMERCALLBACK = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PFLS_CALLBACK_FUNCTION
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFLS_CALLBACK_FUNCTION = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PSECURE_MEMORY_CACHE_CALLBACK
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PSECURE_MEMORY_CACHE_CALLBACK = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: ACTIVATION_CONTEXT_INFO_CLASS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const ACTIVATION_CONTEXT_INFO_CLASS = *opaque{
};
// --------------------------------------------------------
// Type: SUPPORTED_OS_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SUPPORTED_OS_INFO = extern struct {
    MajorVersion: u16,
    MinorVersion: u16,
};
// --------------------------------------------------------
// Type: MAXVERSIONTESTED_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const MAXVERSIONTESTED_INFO = extern struct {
    MaxVersionTested: u64,
};
// --------------------------------------------------------
// Type: EVENTLOGRECORD
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const EVENTLOGRECORD = extern struct {
    Length: u32,
    Reserved: u32,
    RecordNumber: u32,
    TimeGenerated: u32,
    TimeWritten: u32,
    EventID: u32,
    EventType: u16,
    NumStrings: u16,
    EventCategory: u16,
    ReservedFlags: u16,
    ClosingRecordNumber: u32,
    StringOffset: u32,
    UserSidLength: u32,
    UserSidOffset: u32,
    DataLength: u32,
    DataOffset: u32,
};
// --------------------------------------------------------
// Type: EVENTSFORLOGFILE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const EVENTSFORLOGFILE = extern struct {
    ulSize: u32,
    szLogicalLogFile: ?[*]u16,
    ulNumRecords: u32,
    pEventLogRecords: EVENTLOGRECORD,
};
// --------------------------------------------------------
// Type: PACKEDEVENTINFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PACKEDEVENTINFO = extern struct {
    ulSize: u32,
    ulNumEventsForLogFile: u32,
    ulOffsets: u32,
};
// --------------------------------------------------------
// Type: CM_SERVICE_NODE_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const CM_SERVICE_NODE_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: CM_SERVICE_LOAD_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const CM_SERVICE_LOAD_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: CM_ERROR_CONTROL_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const CM_ERROR_CONTROL_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: TAPE_ERASE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TAPE_ERASE = extern struct {
    Type: u32,
    Immediate: u8,
};
// --------------------------------------------------------
// Type: TAPE_PREPARE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TAPE_PREPARE = extern struct {
    Operation: u32,
    Immediate: u8,
};
// --------------------------------------------------------
// Type: TAPE_WRITE_MARKS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TAPE_WRITE_MARKS = extern struct {
    Type: u32,
    Count: u32,
    Immediate: u8,
};
// --------------------------------------------------------
// Type: TAPE_GET_POSITION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TAPE_GET_POSITION = extern struct {
    Type: u32,
    Partition: u32,
    Offset: LARGE_INTEGER,
};
// --------------------------------------------------------
// Type: TAPE_SET_POSITION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TAPE_SET_POSITION = extern struct {
    Method: u32,
    Partition: u32,
    Offset: LARGE_INTEGER,
    Immediate: u8,
};
// --------------------------------------------------------
// Type: TAPE_GET_DRIVE_PARAMETERS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TAPE_GET_DRIVE_PARAMETERS = extern struct {
    ECC: u8,
    Compression: u8,
    DataPadding: u8,
    ReportSetmarks: u8,
    DefaultBlockSize: u32,
    MaximumBlockSize: u32,
    MinimumBlockSize: u32,
    MaximumPartitionCount: u32,
    FeaturesLow: u32,
    FeaturesHigh: u32,
    EOTWarningZoneSize: u32,
};
// --------------------------------------------------------
// Type: TAPE_SET_DRIVE_PARAMETERS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TAPE_SET_DRIVE_PARAMETERS = extern struct {
    ECC: u8,
    Compression: u8,
    DataPadding: u8,
    ReportSetmarks: u8,
    EOTWarningZoneSize: u32,
};
// --------------------------------------------------------
// Type: TAPE_GET_MEDIA_PARAMETERS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TAPE_GET_MEDIA_PARAMETERS = extern struct {
    Capacity: LARGE_INTEGER,
    Remaining: LARGE_INTEGER,
    BlockSize: u32,
    PartitionCount: u32,
    WriteProtected: u8,
};
// --------------------------------------------------------
// Type: TAPE_SET_MEDIA_PARAMETERS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TAPE_SET_MEDIA_PARAMETERS = extern struct {
    BlockSize: u32,
};
// --------------------------------------------------------
// Type: TAPE_CREATE_PARTITION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TAPE_CREATE_PARTITION = extern struct {
    Method: u32,
    Count: u32,
    Size: u32,
};
// --------------------------------------------------------
// Type: TAPE_WMI_OPERATIONS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TAPE_WMI_OPERATIONS = extern struct {
    Method: u32,
    DataBufferSize: u32,
    DataBuffer: ?*opaque{},
};
// --------------------------------------------------------
// Type: TAPE_DRIVE_PROBLEM_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const TAPE_DRIVE_PROBLEM_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: TRANSACTION_STATE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const TRANSACTION_STATE = *opaque{
};
// --------------------------------------------------------
// Type: TRANSACTION_BASIC_INFORMATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TRANSACTION_BASIC_INFORMATION = extern struct {
    TransactionId: Guid,
    State: u32,
    Outcome: u32,
};
// --------------------------------------------------------
// Type: TRANSACTIONMANAGER_BASIC_INFORMATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TRANSACTIONMANAGER_BASIC_INFORMATION = extern struct {
    TmIdentity: Guid,
    VirtualClock: LARGE_INTEGER,
};
// --------------------------------------------------------
// Type: TRANSACTIONMANAGER_LOG_INFORMATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TRANSACTIONMANAGER_LOG_INFORMATION = extern struct {
    LogIdentity: Guid,
};
// --------------------------------------------------------
// Type: TRANSACTIONMANAGER_LOGPATH_INFORMATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TRANSACTIONMANAGER_LOGPATH_INFORMATION = extern struct {
    LogPathLength: u32,
    LogPath: ?[*]u16,
};
// --------------------------------------------------------
// Type: TRANSACTIONMANAGER_RECOVERY_INFORMATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TRANSACTIONMANAGER_RECOVERY_INFORMATION = extern struct {
    LastRecoveredLsn: u64,
};
// --------------------------------------------------------
// Type: TRANSACTIONMANAGER_OLDEST_INFORMATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TRANSACTIONMANAGER_OLDEST_INFORMATION = extern struct {
    OldestTransactionGuid: Guid,
};
// --------------------------------------------------------
// Type: TRANSACTION_PROPERTIES_INFORMATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TRANSACTION_PROPERTIES_INFORMATION = extern struct {
    IsolationLevel: u32,
    IsolationFlags: u32,
    Timeout: LARGE_INTEGER,
    Outcome: u32,
    DescriptionLength: u32,
    Description: ?[*]u16,
};
// --------------------------------------------------------
// Type: TRANSACTION_BIND_INFORMATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TRANSACTION_BIND_INFORMATION = extern struct {
    TmHandle: HANDLE,
};
// --------------------------------------------------------
// Type: TRANSACTION_ENLISTMENT_PAIR
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TRANSACTION_ENLISTMENT_PAIR = extern struct {
    EnlistmentId: Guid,
    ResourceManagerId: Guid,
};
// --------------------------------------------------------
// Type: TRANSACTION_ENLISTMENTS_INFORMATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TRANSACTION_ENLISTMENTS_INFORMATION = extern struct {
    NumberOfEnlistments: u32,
    EnlistmentPair: ?[*]TRANSACTION_ENLISTMENT_PAIR,
};
// --------------------------------------------------------
// Type: TRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION = extern struct {
    SuperiorEnlistmentPair: TRANSACTION_ENLISTMENT_PAIR,
};
// --------------------------------------------------------
// Type: RESOURCEMANAGER_BASIC_INFORMATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const RESOURCEMANAGER_BASIC_INFORMATION = extern struct {
    ResourceManagerId: Guid,
    DescriptionLength: u32,
    Description: ?[*]u16,
};
// --------------------------------------------------------
// Type: RESOURCEMANAGER_COMPLETION_INFORMATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const RESOURCEMANAGER_COMPLETION_INFORMATION = extern struct {
    IoCompletionPortHandle: HANDLE,
    CompletionKey: ?*opaque{},
};
// --------------------------------------------------------
// Type: TRANSACTION_INFORMATION_CLASS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const TRANSACTION_INFORMATION_CLASS = *opaque{
};
// --------------------------------------------------------
// Type: TRANSACTIONMANAGER_INFORMATION_CLASS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const TRANSACTIONMANAGER_INFORMATION_CLASS = *opaque{
};
// --------------------------------------------------------
// Type: RESOURCEMANAGER_INFORMATION_CLASS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const RESOURCEMANAGER_INFORMATION_CLASS = *opaque{
};
// --------------------------------------------------------
// Type: ENLISTMENT_BASIC_INFORMATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const ENLISTMENT_BASIC_INFORMATION = extern struct {
    EnlistmentId: Guid,
    TransactionId: Guid,
    ResourceManagerId: Guid,
};
// --------------------------------------------------------
// Type: ENLISTMENT_CRM_INFORMATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const ENLISTMENT_CRM_INFORMATION = extern struct {
    CrmTransactionManagerId: Guid,
    CrmResourceManagerId: Guid,
    CrmEnlistmentId: Guid,
};
// --------------------------------------------------------
// Type: ENLISTMENT_INFORMATION_CLASS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const ENLISTMENT_INFORMATION_CLASS = *opaque{
};
// --------------------------------------------------------
// Type: TRANSACTION_LIST_ENTRY
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TRANSACTION_LIST_ENTRY = extern struct {
    UOW: Guid,
};
// --------------------------------------------------------
// Type: TRANSACTION_LIST_INFORMATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TRANSACTION_LIST_INFORMATION = extern struct {
    NumberOfTransactions: u32,
    TransactionInformation: ?[*]TRANSACTION_LIST_ENTRY,
};
// --------------------------------------------------------
// Type: KTMOBJECT_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const KTMOBJECT_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: KTMOBJECT_CURSOR
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const KTMOBJECT_CURSOR = extern struct {
    LastQuery: Guid,
    ObjectIdCount: u32,
    ObjectIds: ?[*]Guid,
};
// --------------------------------------------------------
// Type: TP_CALLBACK_INSTANCE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const TP_CALLBACK_INSTANCE = opaque {
};
// --------------------------------------------------------
// Type: PTP_SIMPLE_CALLBACK
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PTP_SIMPLE_CALLBACK = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: TP_POOL
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const TP_POOL = opaque {
};
// --------------------------------------------------------
// Type: TP_CALLBACK_PRIORITY
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const TP_CALLBACK_PRIORITY = *opaque{
};
// --------------------------------------------------------
// Type: TP_POOL_STACK_INFORMATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TP_POOL_STACK_INFORMATION = extern struct {
    StackReserve: ?*opaque{},
    StackCommit: ?*opaque{},
};
// --------------------------------------------------------
// Type: TP_CLEANUP_GROUP
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const TP_CLEANUP_GROUP = opaque {
};
// --------------------------------------------------------
// Type: PTP_CLEANUP_GROUP_CANCEL_CALLBACK
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PTP_CLEANUP_GROUP_CANCEL_CALLBACK = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: TP_CALLBACK_ENVIRON_V3
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TP_CALLBACK_ENVIRON_V3 = extern struct {
    Version: u32,
    Pool: PTP_POOL,
    CleanupGroup: ?*opaque{},
    CleanupGroupCancelCallback: PTP_CLEANUP_GROUP_CANCEL_CALLBACK,
    RaceDll: ?*opaque{},
    ActivationContext: ?*opaque{},
    FinalizationCallback: PTP_SIMPLE_CALLBACK,
    u: _u_e__Union,
    CallbackPriority: TP_CALLBACK_PRIORITY,
    Size: u32,
    // --------------------------------------------------------
    // Type: _u_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _u_e__Union = *opaque{
        // --------------------------------------------------------
        // Type: _s_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _s_e__Struct = extern struct {
            _bitfield: u32,
        };
    };
    // --------------------------------------------------------
    // Type: _ACTIVATION_CONTEXT
    // TypeLayoutAttr: sequential
    // TODO: I think this is a struct, but not sure at this point, assuming it is for now
    // a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
    pub const _ACTIVATION_CONTEXT = opaque {
    };
};
// --------------------------------------------------------
// Type: TP_WORK
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const TP_WORK = opaque {
};
// --------------------------------------------------------
// Type: PTP_WORK_CALLBACK
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PTP_WORK_CALLBACK = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: TP_TIMER
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const TP_TIMER = opaque {
};
// --------------------------------------------------------
// Type: PTP_TIMER_CALLBACK
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PTP_TIMER_CALLBACK = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: TP_WAIT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const TP_WAIT = opaque {
};
// --------------------------------------------------------
// Type: PTP_WAIT_CALLBACK
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PTP_WAIT_CALLBACK = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: TP_IO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const TP_IO = opaque {
};
// --------------------------------------------------------
// Type: TEB
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const TEB = opaque {
};
// --------------------------------------------------------
// Type: FARPROC
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const FARPROC = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: NEARPROC
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const NEARPROC = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PROC
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PROC = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: HKEY__
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HKEY__ = extern struct {
    unused: i32,
};
// --------------------------------------------------------
// Type: HMETAFILE__
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HMETAFILE__ = extern struct {
    unused: i32,
};
// --------------------------------------------------------
// Type: HINSTANCE__
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HINSTANCE__ = extern struct {
    unused: i32,
};
// --------------------------------------------------------
// Type: HRGN__
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HRGN__ = extern struct {
    unused: i32,
};
// --------------------------------------------------------
// Type: HRSRC__
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HRSRC__ = extern struct {
    unused: i32,
};
// --------------------------------------------------------
// Type: HSPRITE__
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HSPRITE__ = extern struct {
    unused: i32,
};
// --------------------------------------------------------
// Type: HLSURF__
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HLSURF__ = extern struct {
    unused: i32,
};
// --------------------------------------------------------
// Type: HSTR__
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HSTR__ = extern struct {
    unused: i32,
};
// --------------------------------------------------------
// Type: HTASK__
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HTASK__ = extern struct {
    unused: i32,
};
// --------------------------------------------------------
// Type: HWINSTA__
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HWINSTA__ = extern struct {
    unused: i32,
};
// --------------------------------------------------------
// Type: HKL__
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HKL__ = extern struct {
    unused: i32,
};
// --------------------------------------------------------
// Type: HWND__
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HWND__ = extern struct {
    unused: i32,
};
// --------------------------------------------------------
// Type: HHOOK__
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HHOOK__ = extern struct {
    unused: i32,
};
// --------------------------------------------------------
// Type: HACCEL__
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HACCEL__ = extern struct {
    unused: i32,
};
// --------------------------------------------------------
// Type: HBITMAP__
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HBITMAP__ = extern struct {
    unused: i32,
};
// --------------------------------------------------------
// Type: HBRUSH__
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HBRUSH__ = extern struct {
    unused: i32,
};
// --------------------------------------------------------
// Type: HCOLORSPACE__
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HCOLORSPACE__ = extern struct {
    unused: i32,
};
// --------------------------------------------------------
// Type: HDC__
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HDC__ = extern struct {
    unused: i32,
};
// --------------------------------------------------------
// Type: HGLRC__
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HGLRC__ = extern struct {
    unused: i32,
};
// --------------------------------------------------------
// Type: HDESK__
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HDESK__ = extern struct {
    unused: i32,
};
// --------------------------------------------------------
// Type: HENHMETAFILE__
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HENHMETAFILE__ = extern struct {
    unused: i32,
};
// --------------------------------------------------------
// Type: HFONT__
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HFONT__ = extern struct {
    unused: i32,
};
// --------------------------------------------------------
// Type: HICON__
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HICON__ = extern struct {
    unused: i32,
};
// --------------------------------------------------------
// Type: HMENU__
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HMENU__ = extern struct {
    unused: i32,
};
// --------------------------------------------------------
// Type: HPALETTE__
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HPALETTE__ = extern struct {
    unused: i32,
};
// --------------------------------------------------------
// Type: HPEN__
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HPEN__ = extern struct {
    unused: i32,
};
// --------------------------------------------------------
// Type: HWINEVENTHOOK__
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HWINEVENTHOOK__ = extern struct {
    unused: i32,
};
// --------------------------------------------------------
// Type: HMONITOR__
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HMONITOR__ = extern struct {
    unused: i32,
};
// --------------------------------------------------------
// Type: HUMPD__
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HUMPD__ = extern struct {
    unused: i32,
};
// --------------------------------------------------------
// Type: APP_LOCAL_DEVICE_ID
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const APP_LOCAL_DEVICE_ID = extern struct {
    value: ?[*]u8,
};
// --------------------------------------------------------
// Type: DPI_AWARENESS_CONTEXT__
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DPI_AWARENESS_CONTEXT__ = extern struct {
    unused: i32,
};
// --------------------------------------------------------
// Type: PINIT_ONCE_FN
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PINIT_ONCE_FN = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PTIMERAPCROUTINE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PTIMERAPCROUTINE = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PTP_WIN32_IO_CALLBACK
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PTP_WIN32_IO_CALLBACK = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: JOBOBJECT_IO_RATE_CONTROL_INFORMATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const JOBOBJECT_IO_RATE_CONTROL_INFORMATION = extern struct {
    MaxIops: i64,
    MaxBandwidth: i64,
    ReservationIops: i64,
    VolumeName: ?*u16,
    BaseIoSize: u32,
    ControlFlags: u32,
};
// --------------------------------------------------------
// Type: SECURITY_ATTRIBUTES
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SECURITY_ATTRIBUTES = extern struct {
    nLength: u32,
    lpSecurityDescriptor: ?*opaque{},
    bInheritHandle: BOOL,
};
// --------------------------------------------------------
// Type: OVERLAPPED
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const OVERLAPPED = extern struct {
    Internal: ?*opaque{},
    InternalHigh: ?*opaque{},
    Anonymous: _Anonymous_e__Union,
    hEvent: HANDLE,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
        // --------------------------------------------------------
        // Type: _Anonymous_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _Anonymous_e__Struct = extern struct {
            Offset: u32,
            OffsetHigh: u32,
        };
    };
};
// --------------------------------------------------------
// Type: PROCESS_HEAP_ENTRY
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PROCESS_HEAP_ENTRY = extern struct {
    lpData: ?*opaque{},
    cbData: u32,
    cbOverhead: u8,
    iRegionIndex: u8,
    wFlags: u16,
    Anonymous: _Anonymous_e__Union,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
        // --------------------------------------------------------
        // Type: _Region_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _Region_e__Struct = extern struct {
            dwCommittedSize: u32,
            dwUnCommittedSize: u32,
            lpFirstBlock: ?*opaque{},
            lpLastBlock: ?*opaque{},
        };
        // --------------------------------------------------------
        // Type: _Block_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _Block_e__Struct = extern struct {
            hMem: HANDLE,
            dwReserved: ?[*]u32,
        };
    };
};
// --------------------------------------------------------
// Type: REASON_CONTEXT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const REASON_CONTEXT = extern struct {
    Version: u32,
    Flags: u32,
    Reason: _Reason_e__Union,
    // --------------------------------------------------------
    // Type: _Reason_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Reason_e__Union = *opaque{
        // --------------------------------------------------------
        // Type: _Detailed_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _Detailed_e__Struct = extern struct {
            LocalizedReasonModule: ?*opaque{},
            LocalizedReasonId: u32,
            ReasonStringCount: u32,
            ReasonStrings: ?*?*u16,
        };
    };
};
// --------------------------------------------------------
// Type: PTHREAD_START_ROUTINE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PTHREAD_START_ROUTINE = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: LPTHREAD_START_ROUTINE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const LPTHREAD_START_ROUTINE = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PENCLAVE_ROUTINE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PENCLAVE_ROUTINE = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: LPENCLAVE_ROUTINE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const LPENCLAVE_ROUTINE = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: HEAP_SUMMARY
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HEAP_SUMMARY = extern struct {
    cb: u32,
    cbAllocated: ?*opaque{},
    cbCommitted: ?*opaque{},
    cbReserved: ?*opaque{},
    cbMaxReserve: ?*opaque{},
};
// --------------------------------------------------------
// Type: MEMORY_RESOURCE_NOTIFICATION_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const MEMORY_RESOURCE_NOTIFICATION_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: WIN32_MEMORY_RANGE_ENTRY
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const WIN32_MEMORY_RANGE_ENTRY = extern struct {
    VirtualAddress: ?*opaque{},
    NumberOfBytes: ?*opaque{},
};
// --------------------------------------------------------
// Type: BAD_MEMORY_CALLBACK_ROUTINE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const BAD_MEMORY_CALLBACK_ROUTINE = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PBAD_MEMORY_CALLBACK_ROUTINE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PBAD_MEMORY_CALLBACK_ROUTINE = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: OFFER_PRIORITY
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const OFFER_PRIORITY = *opaque{
};
// --------------------------------------------------------
// Type: WIN32_MEMORY_INFORMATION_CLASS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const WIN32_MEMORY_INFORMATION_CLASS = *opaque{
};
// --------------------------------------------------------
// Type: WIN32_MEMORY_REGION_INFORMATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const WIN32_MEMORY_REGION_INFORMATION = extern struct {
    AllocationBase: ?*opaque{},
    AllocationProtect: u32,
    Anonymous: _Anonymous_e__Union,
    RegionSize: ?*opaque{},
    CommitSize: ?*opaque{},
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
        // --------------------------------------------------------
        // Type: _Anonymous_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _Anonymous_e__Struct = extern struct {
            _bitfield: u32,
        };
    };
};
// --------------------------------------------------------
// Type: ENUMUILANG
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const ENUMUILANG = extern struct {
    NumOfEnumUILang: u32,
    SizeOfEnumUIBuffer: u32,
    pEnumUIBuffer: ?*u16,
};
// --------------------------------------------------------
// Type: ENUMRESLANGPROCA
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const ENUMRESLANGPROCA = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: ENUMRESLANGPROCW
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const ENUMRESLANGPROCW = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PGET_MODULE_HANDLE_EXA
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PGET_MODULE_HANDLE_EXA = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PGET_MODULE_HANDLE_EXW
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PGET_MODULE_HANDLE_EXW = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: REDIRECTION_FUNCTION_DESCRIPTOR
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const REDIRECTION_FUNCTION_DESCRIPTOR = extern struct {
    DllName: ?*i8,
    FunctionName: ?*i8,
    RedirectionTarget: ?*opaque{},
};
// --------------------------------------------------------
// Type: REDIRECTION_DESCRIPTOR
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const REDIRECTION_DESCRIPTOR = extern struct {
    Version: u32,
    FunctionCount: u32,
    Redirections: ?*REDIRECTION_FUNCTION_DESCRIPTOR,
};
// --------------------------------------------------------
// Type: COORD
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const COORD = extern struct {
    X: i16,
    Y: i16,
};
// --------------------------------------------------------
// Type: SMALL_RECT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SMALL_RECT = extern struct {
    Left: i16,
    Top: i16,
    Right: i16,
    Bottom: i16,
};
// --------------------------------------------------------
// Type: KEY_EVENT_RECORD
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const KEY_EVENT_RECORD = extern struct {
    bKeyDown: BOOL,
    wRepeatCount: u16,
    wVirtualKeyCode: u16,
    wVirtualScanCode: u16,
    uChar: _uChar_e__Union,
    dwControlKeyState: u32,
    // --------------------------------------------------------
    // Type: _uChar_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _uChar_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: MOUSE_EVENT_RECORD
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const MOUSE_EVENT_RECORD = extern struct {
    dwMousePosition: COORD,
    dwButtonState: u32,
    dwControlKeyState: u32,
    dwEventFlags: u32,
};
// --------------------------------------------------------
// Type: WINDOW_BUFFER_SIZE_RECORD
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const WINDOW_BUFFER_SIZE_RECORD = extern struct {
    dwSize: COORD,
};
// --------------------------------------------------------
// Type: MENU_EVENT_RECORD
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const MENU_EVENT_RECORD = extern struct {
    dwCommandId: u32,
};
// --------------------------------------------------------
// Type: FOCUS_EVENT_RECORD
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const FOCUS_EVENT_RECORD = extern struct {
    bSetFocus: BOOL,
};
// --------------------------------------------------------
// Type: INPUT_RECORD
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const INPUT_RECORD = extern struct {
    EventType: u16,
    Event: _Event_e__Union,
    // --------------------------------------------------------
    // Type: _Event_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Event_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: CHAR_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CHAR_INFO = extern struct {
    Char: _Char_e__Union,
    Attributes: u16,
    // --------------------------------------------------------
    // Type: _Char_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Char_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: CONSOLE_FONT_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CONSOLE_FONT_INFO = extern struct {
    nFont: u32,
    dwFontSize: COORD,
};
// --------------------------------------------------------
// Type: CONSOLE_READCONSOLE_CONTROL
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CONSOLE_READCONSOLE_CONTROL = extern struct {
    nLength: u32,
    nInitialChars: u32,
    dwCtrlWakeupMask: u32,
    dwControlKeyState: u32,
};
// --------------------------------------------------------
// Type: PHANDLER_ROUTINE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PHANDLER_ROUTINE = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: CONSOLE_CURSOR_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CONSOLE_CURSOR_INFO = extern struct {
    dwSize: u32,
    bVisible: BOOL,
};
// --------------------------------------------------------
// Type: CONSOLE_SCREEN_BUFFER_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CONSOLE_SCREEN_BUFFER_INFO = extern struct {
    dwSize: COORD,
    dwCursorPosition: COORD,
    wAttributes: u16,
    srWindow: SMALL_RECT,
    dwMaximumWindowSize: COORD,
};
// --------------------------------------------------------
// Type: CONSOLE_SCREEN_BUFFER_INFOEX
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CONSOLE_SCREEN_BUFFER_INFOEX = extern struct {
    cbSize: u32,
    dwSize: COORD,
    dwCursorPosition: COORD,
    wAttributes: u16,
    srWindow: SMALL_RECT,
    dwMaximumWindowSize: COORD,
    wPopupAttributes: u16,
    bFullscreenSupported: BOOL,
    ColorTable: ?[*]u32,
};
// --------------------------------------------------------
// Type: CONSOLE_FONT_INFOEX
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CONSOLE_FONT_INFOEX = extern struct {
    cbSize: u32,
    nFont: u32,
    dwFontSize: COORD,
    FontFamily: u32,
    FontWeight: u32,
    FaceName: ?[*]u16,
};
// --------------------------------------------------------
// Type: CONSOLE_SELECTION_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CONSOLE_SELECTION_INFO = extern struct {
    dwFlags: u32,
    dwSelectionAnchor: COORD,
    srSelection: SMALL_RECT,
};
// --------------------------------------------------------
// Type: CONSOLE_HISTORY_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CONSOLE_HISTORY_INFO = extern struct {
    cbSize: u32,
    HistoryBufferSize: u32,
    NumberOfHistoryBuffers: u32,
    dwFlags: u32,
};
// --------------------------------------------------------
// Type: TIMECALLBACK
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const TIMECALLBACK = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: LPTIMECALLBACK
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const LPTIMECALLBACK = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PM_OPEN_PROC
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PM_OPEN_PROC = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PM_QUERY_PROC
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PM_QUERY_PROC = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: RPC_IMPORT_CONTEXT_P
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const RPC_IMPORT_CONTEXT_P = extern struct {
    LookupContext: ?*opaque{},
    ProposedHandle: ?*opaque{},
    Bindings: ?*RPC_BINDING_VECTOR,
};
// --------------------------------------------------------
// Type: RemHGLOBAL
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const RemHGLOBAL = extern struct {
    fNullHGlobal: i32,
    cbData: u32,
    data: ?[*]u8,
};
// --------------------------------------------------------
// Type: RemHMETAFILEPICT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const RemHMETAFILEPICT = extern struct {
    mm: i32,
    xExt: i32,
    yExt: i32,
    cbData: u32,
    data: ?[*]u8,
};
// --------------------------------------------------------
// Type: RemHENHMETAFILE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const RemHENHMETAFILE = extern struct {
    cbData: u32,
    data: ?[*]u8,
};
// --------------------------------------------------------
// Type: RemHBITMAP
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const RemHBITMAP = extern struct {
    cbData: u32,
    data: ?[*]u8,
};
// --------------------------------------------------------
// Type: RemHPALETTE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const RemHPALETTE = extern struct {
    cbData: u32,
    data: ?[*]u8,
};
// --------------------------------------------------------
// Type: RemBRUSH
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const RemBRUSH = extern struct {
    cbData: u32,
    data: ?[*]u8,
};
// --------------------------------------------------------
// Type: userCLIPFORMAT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const userCLIPFORMAT = extern struct {
    fContext: i32,
    u: _u_e__Struct,
    // --------------------------------------------------------
    // Type: _u_e__Struct
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _u_e__Struct = *opaque{
    };
};
// --------------------------------------------------------
// Type: GDI_NONREMOTE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const GDI_NONREMOTE = extern struct {
    fContext: i32,
    u: _u_e__Struct,
    // --------------------------------------------------------
    // Type: _u_e__Struct
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _u_e__Struct = *opaque{
    };
};
// --------------------------------------------------------
// Type: userHGLOBAL
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const userHGLOBAL = extern struct {
    fContext: i32,
    u: _u_e__Struct,
    // --------------------------------------------------------
    // Type: _u_e__Struct
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _u_e__Struct = *opaque{
    };
};
// --------------------------------------------------------
// Type: userHMETAFILE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const userHMETAFILE = extern struct {
    fContext: i32,
    u: _u_e__Struct,
    // --------------------------------------------------------
    // Type: _u_e__Struct
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _u_e__Struct = *opaque{
    };
};
// --------------------------------------------------------
// Type: remoteMETAFILEPICT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const remoteMETAFILEPICT = extern struct {
    mm: i32,
    xExt: i32,
    yExt: i32,
    hMF: ?*userHMETAFILE,
};
// --------------------------------------------------------
// Type: userHMETAFILEPICT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const userHMETAFILEPICT = extern struct {
    fContext: i32,
    u: _u_e__Struct,
    // --------------------------------------------------------
    // Type: _u_e__Struct
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _u_e__Struct = *opaque{
    };
};
// --------------------------------------------------------
// Type: userHENHMETAFILE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const userHENHMETAFILE = extern struct {
    fContext: i32,
    u: _u_e__Struct,
    // --------------------------------------------------------
    // Type: _u_e__Struct
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _u_e__Struct = *opaque{
    };
};
// --------------------------------------------------------
// Type: userBITMAP
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const userBITMAP = extern struct {
    bmType: i32,
    bmWidth: i32,
    bmHeight: i32,
    bmWidthBytes: i32,
    bmPlanes: u16,
    bmBitsPixel: u16,
    cbSize: u32,
    pBuffer: ?[*]u8,
};
// --------------------------------------------------------
// Type: userHBITMAP
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const userHBITMAP = extern struct {
    fContext: i32,
    u: _u_e__Struct,
    // --------------------------------------------------------
    // Type: _u_e__Struct
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _u_e__Struct = *opaque{
    };
};
// --------------------------------------------------------
// Type: userHPALETTE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const userHPALETTE = extern struct {
    fContext: i32,
    u: _u_e__Struct,
    // --------------------------------------------------------
    // Type: _u_e__Struct
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _u_e__Struct = *opaque{
    };
};
// --------------------------------------------------------
// Type: RemotableHandle
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const RemotableHandle = extern struct {
    fContext: i32,
    u: _u_e__Struct,
    // --------------------------------------------------------
    // Type: _u_e__Struct
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _u_e__Struct = *opaque{
    };
};
// --------------------------------------------------------
// Type: CY
// TypeLayoutAttr: explicit
// not generating the actual code for this type because it has an explicit layout
pub const CY = *opaque{
    // --------------------------------------------------------
    // Type: _Anonymous_e__Struct
    // TypeLayoutAttr: sequential
    // TODO: I think this is a struct, but not sure at this point, assuming it is for now
    pub const _Anonymous_e__Struct = extern struct {
        Lo: u32,
        Hi: i32,
    };
};
// --------------------------------------------------------
// Type: DECIMAL
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DECIMAL = extern struct {
    wReserved: u16,
    Anonymous1: _Anonymous1_e__Union,
    Hi32: u32,
    Anonymous2: _Anonymous2_e__Union,
    // --------------------------------------------------------
    // Type: _Anonymous2_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous2_e__Union = *opaque{
        // --------------------------------------------------------
        // Type: _Anonymous_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _Anonymous_e__Struct = extern struct {
            Lo32: u32,
            Mid32: u32,
        };
    };
    // --------------------------------------------------------
    // Type: _Anonymous1_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous1_e__Union = *opaque{
        // --------------------------------------------------------
        // Type: _Anonymous_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _Anonymous_e__Struct = extern struct {
            scale: u8,
            sign: u8,
        };
    };
};
// --------------------------------------------------------
// Type: BSTRBLOB
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const BSTRBLOB = extern struct {
    cbSize: u32,
    pData: ?*u8,
};
// --------------------------------------------------------
// Type: CLIPDATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CLIPDATA = extern struct {
    cbSize: u32,
    ulClipFmt: i32,
    pClipData: ?*u8,
};
// --------------------------------------------------------
// Type: uCLSSPEC
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const uCLSSPEC = extern struct {
    tyspec: u32,
    tagged_union: _tagged_union_e__Struct,
    // --------------------------------------------------------
    // Type: _tagged_union_e__Struct
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _tagged_union_e__Struct = *opaque{
        // --------------------------------------------------------
        // Type: _ByName_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _ByName_e__Struct = extern struct {
            pPackageName: ?*u16,
            PolicyId: Guid,
        };
        // --------------------------------------------------------
        // Type: _ByObjectId_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _ByObjectId_e__Struct = extern struct {
            ObjectId: Guid,
            PolicyId: Guid,
        };
    };
};
// --------------------------------------------------------
// Type: STORAGE_HOTPLUG_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const STORAGE_HOTPLUG_INFO = extern struct {
    Size: u32,
    MediaRemovable: u8,
    MediaHotplug: u8,
    DeviceHotplug: u8,
    WriteCacheEnableOverride: u8,
};
// --------------------------------------------------------
// Type: STORAGE_DEVICE_NUMBER
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const STORAGE_DEVICE_NUMBER = extern struct {
    DeviceType: u32,
    DeviceNumber: u32,
    PartitionNumber: u32,
};
// --------------------------------------------------------
// Type: STORAGE_DEVICE_NUMBERS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const STORAGE_DEVICE_NUMBERS = extern struct {
    Version: u32,
    Size: u32,
    NumberOfDevices: u32,
    Devices: ?[*]STORAGE_DEVICE_NUMBER,
};
// --------------------------------------------------------
// Type: STORAGE_DEVICE_NUMBER_EX
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const STORAGE_DEVICE_NUMBER_EX = extern struct {
    Version: u32,
    Size: u32,
    Flags: u32,
    DeviceType: u32,
    DeviceNumber: u32,
    DeviceGuid: Guid,
    PartitionNumber: u32,
};
// --------------------------------------------------------
// Type: STORAGE_BUS_RESET_REQUEST
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const STORAGE_BUS_RESET_REQUEST = extern struct {
    PathId: u8,
};
// --------------------------------------------------------
// Type: STORAGE_BREAK_RESERVATION_REQUEST
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const STORAGE_BREAK_RESERVATION_REQUEST = extern struct {
    Length: u32,
    _unused: u8,
    PathId: u8,
    TargetId: u8,
    Lun: u8,
};
// --------------------------------------------------------
// Type: PREVENT_MEDIA_REMOVAL
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PREVENT_MEDIA_REMOVAL = extern struct {
    PreventMediaRemoval: u8,
};
// --------------------------------------------------------
// Type: CLASS_MEDIA_CHANGE_CONTEXT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CLASS_MEDIA_CHANGE_CONTEXT = extern struct {
    MediaChangeCount: u32,
    NewState: u32,
};
// --------------------------------------------------------
// Type: TAPE_STATISTICS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TAPE_STATISTICS = extern struct {
    Version: u32,
    Flags: u32,
    RecoveredWrites: LARGE_INTEGER,
    UnrecoveredWrites: LARGE_INTEGER,
    RecoveredReads: LARGE_INTEGER,
    UnrecoveredReads: LARGE_INTEGER,
    CompressionRatioReads: u8,
    CompressionRatioWrites: u8,
};
// --------------------------------------------------------
// Type: TAPE_GET_STATISTICS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TAPE_GET_STATISTICS = extern struct {
    Operation: u32,
};
// --------------------------------------------------------
// Type: STORAGE_MEDIA_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const STORAGE_MEDIA_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: STORAGE_BUS_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const STORAGE_BUS_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: DEVICE_MEDIA_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DEVICE_MEDIA_INFO = extern struct {
    DeviceSpecific: _DeviceSpecific_e__Union,
    // --------------------------------------------------------
    // Type: _DeviceSpecific_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _DeviceSpecific_e__Union = *opaque{
        // --------------------------------------------------------
        // Type: _TapeInfo_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _TapeInfo_e__Struct = extern struct {
            MediaType: STORAGE_MEDIA_TYPE,
            MediaCharacteristics: u32,
            CurrentBlockSize: u32,
            BusType: STORAGE_BUS_TYPE,
            BusSpecificData: _BusSpecificData_e__Union,
            // --------------------------------------------------------
            // Type: _BusSpecificData_e__Union
            // TypeLayoutAttr: explicit
            // not generating the actual code for this type because it has an explicit layout
            pub const _BusSpecificData_e__Union = *opaque{
                // --------------------------------------------------------
                // Type: _ScsiInformation_e__Struct
                // TypeLayoutAttr: sequential
                // TODO: I think this is a struct, but not sure at this point, assuming it is for now
                pub const _ScsiInformation_e__Struct = extern struct {
                    MediumType: u8,
                    DensityCode: u8,
                };
            };
        };
        // --------------------------------------------------------
        // Type: _DiskInfo_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _DiskInfo_e__Struct = extern struct {
            Cylinders: LARGE_INTEGER,
            MediaType: STORAGE_MEDIA_TYPE,
            TracksPerCylinder: u32,
            SectorsPerTrack: u32,
            BytesPerSector: u32,
            NumberMediaSides: u32,
            MediaCharacteristics: u32,
        };
        // --------------------------------------------------------
        // Type: _RemovableDiskInfo_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _RemovableDiskInfo_e__Struct = extern struct {
            Cylinders: LARGE_INTEGER,
            MediaType: STORAGE_MEDIA_TYPE,
            TracksPerCylinder: u32,
            SectorsPerTrack: u32,
            BytesPerSector: u32,
            NumberMediaSides: u32,
            MediaCharacteristics: u32,
        };
    };
};
// --------------------------------------------------------
// Type: GET_MEDIA_TYPES
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const GET_MEDIA_TYPES = extern struct {
    DeviceType: u32,
    MediaInfoCount: u32,
    MediaInfo: ?[*]DEVICE_MEDIA_INFO,
};
// --------------------------------------------------------
// Type: STORAGE_PREDICT_FAILURE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const STORAGE_PREDICT_FAILURE = extern struct {
    PredictFailure: u32,
    VendorSpecific: ?[*]u8,
};
// --------------------------------------------------------
// Type: STORAGE_FAILURE_PREDICTION_CONFIG
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const STORAGE_FAILURE_PREDICTION_CONFIG = extern struct {
    Version: u32,
    Size: u32,
    Set: u8,
    Enabled: u8,
    Reserved: u16,
};
// --------------------------------------------------------
// Type: STORAGE_SET_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const STORAGE_SET_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: STORAGE_PROPERTY_SET
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const STORAGE_PROPERTY_SET = extern struct {
    PropertyId: STORAGE_PROPERTY_ID,
    SetType: STORAGE_SET_TYPE,
    AdditionalParameters: ?[*]u8,
};
// --------------------------------------------------------
// Type: STORAGE_IDENTIFIER_CODE_SET
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const STORAGE_IDENTIFIER_CODE_SET = *opaque{
};
// --------------------------------------------------------
// Type: STORAGE_IDENTIFIER_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const STORAGE_IDENTIFIER_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: STORAGE_ID_NAA_FORMAT
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const STORAGE_ID_NAA_FORMAT = *opaque{
};
// --------------------------------------------------------
// Type: STORAGE_ASSOCIATION_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const STORAGE_ASSOCIATION_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: STORAGE_IDENTIFIER
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const STORAGE_IDENTIFIER = extern struct {
    CodeSet: STORAGE_IDENTIFIER_CODE_SET,
    Type: STORAGE_IDENTIFIER_TYPE,
    IdentifierSize: u16,
    NextOffset: u16,
    Association: STORAGE_ASSOCIATION_TYPE,
    Identifier: ?[*]u8,
};
// --------------------------------------------------------
// Type: STORAGE_LB_PROVISIONING_MAP_RESOURCES
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const STORAGE_LB_PROVISIONING_MAP_RESOURCES = extern struct {
    Size: u32,
    Version: u32,
    _bitfield1: u8,
    Reserved1: ?[*]u8,
    _bitfield2: u8,
    Reserved3: ?[*]u8,
    AvailableMappingResources: u64,
    UsedMappingResources: u64,
};
// --------------------------------------------------------
// Type: STORAGE_RPMB_FRAME_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const STORAGE_RPMB_FRAME_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: STORAGE_RPMB_DESCRIPTOR
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const STORAGE_RPMB_DESCRIPTOR = extern struct {
    Version: u32,
    Size: u32,
    SizeInBytes: u32,
    MaxReliableWriteSizeInBytes: u32,
    FrameFormat: STORAGE_RPMB_FRAME_TYPE,
};
// --------------------------------------------------------
// Type: STORAGE_CRYPTO_ALGORITHM_ID
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const STORAGE_CRYPTO_ALGORITHM_ID = *opaque{
};
// --------------------------------------------------------
// Type: STORAGE_CRYPTO_KEY_SIZE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const STORAGE_CRYPTO_KEY_SIZE = *opaque{
};
// --------------------------------------------------------
// Type: STORAGE_CRYPTO_CAPABILITY
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const STORAGE_CRYPTO_CAPABILITY = extern struct {
    Version: u32,
    Size: u32,
    CryptoCapabilityIndex: u32,
    AlgorithmId: STORAGE_CRYPTO_ALGORITHM_ID,
    KeySize: STORAGE_CRYPTO_KEY_SIZE,
    DataUnitSizeBitmask: u32,
};
// --------------------------------------------------------
// Type: STORAGE_CRYPTO_DESCRIPTOR
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const STORAGE_CRYPTO_DESCRIPTOR = extern struct {
    Version: u32,
    Size: u32,
    NumKeysSupported: u32,
    NumCryptoCapabilities: u32,
    CryptoCapabilities: ?[*]STORAGE_CRYPTO_CAPABILITY,
};
// --------------------------------------------------------
// Type: STORAGE_TIER_MEDIA_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const STORAGE_TIER_MEDIA_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: STORAGE_TIER_CLASS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const STORAGE_TIER_CLASS = *opaque{
};
// --------------------------------------------------------
// Type: STORAGE_TIER
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const STORAGE_TIER = extern struct {
    Id: Guid,
    Name: ?[*]u16,
    Description: ?[*]u16,
    Flags: u64,
    ProvisionedCapacity: u64,
    MediaType: STORAGE_TIER_MEDIA_TYPE,
    Class: STORAGE_TIER_CLASS,
};
// --------------------------------------------------------
// Type: STORAGE_DEVICE_TIERING_DESCRIPTOR
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const STORAGE_DEVICE_TIERING_DESCRIPTOR = extern struct {
    Version: u32,
    Size: u32,
    Flags: u32,
    TotalNumberOfTiers: u32,
    NumberOfTiersReturned: u32,
    Tiers: ?[*]STORAGE_TIER,
};
// --------------------------------------------------------
// Type: STORAGE_DEVICE_FAULT_DOMAIN_DESCRIPTOR
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const STORAGE_DEVICE_FAULT_DOMAIN_DESCRIPTOR = extern struct {
    Version: u32,
    Size: u32,
    NumberOfFaultDomains: u32,
    FaultDomainIds: ?[*]Guid,
};
// --------------------------------------------------------
// Type: STORAGE_PROTOCOL_UFS_DATA_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const STORAGE_PROTOCOL_UFS_DATA_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: STORAGE_PROTOCOL_SPECIFIC_DATA_EXT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const STORAGE_PROTOCOL_SPECIFIC_DATA_EXT = extern struct {
    ProtocolType: STORAGE_PROTOCOL_TYPE,
    DataType: u32,
    ProtocolDataValue: u32,
    ProtocolDataSubValue: u32,
    ProtocolDataOffset: u32,
    ProtocolDataLength: u32,
    FixedProtocolReturnData: u32,
    ProtocolDataSubValue2: u32,
    ProtocolDataSubValue3: u32,
    ProtocolDataSubValue4: u32,
    ProtocolDataSubValue5: u32,
    Reserved: ?[*]u32,
};
// --------------------------------------------------------
// Type: STORAGE_PROTOCOL_DATA_DESCRIPTOR_EXT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const STORAGE_PROTOCOL_DATA_DESCRIPTOR_EXT = extern struct {
    Version: u32,
    Size: u32,
    ProtocolSpecificData: STORAGE_PROTOCOL_SPECIFIC_DATA_EXT,
};
// --------------------------------------------------------
// Type: STORAGE_DISK_HEALTH_STATUS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const STORAGE_DISK_HEALTH_STATUS = *opaque{
};
// --------------------------------------------------------
// Type: STORAGE_DISK_OPERATIONAL_STATUS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const STORAGE_DISK_OPERATIONAL_STATUS = *opaque{
};
// --------------------------------------------------------
// Type: STORAGE_OPERATIONAL_STATUS_REASON
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const STORAGE_OPERATIONAL_STATUS_REASON = *opaque{
};
// --------------------------------------------------------
// Type: STORAGE_OPERATIONAL_REASON
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const STORAGE_OPERATIONAL_REASON = extern struct {
    Version: u32,
    Size: u32,
    Reason: STORAGE_OPERATIONAL_STATUS_REASON,
    RawBytes: _RawBytes_e__Union,
    // --------------------------------------------------------
    // Type: _RawBytes_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _RawBytes_e__Union = *opaque{
        // --------------------------------------------------------
        // Type: _NVDIMM_N_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _NVDIMM_N_e__Struct = extern struct {
            CriticalHealth: u8,
            ModuleHealth: ?[*]u8,
            ErrorThresholdStatus: u8,
        };
        // --------------------------------------------------------
        // Type: _ScsiSenseKey_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _ScsiSenseKey_e__Struct = extern struct {
            SenseKey: u8,
            ASC: u8,
            ASCQ: u8,
            Reserved: u8,
        };
    };
};
// --------------------------------------------------------
// Type: STORAGE_DEVICE_MANAGEMENT_STATUS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const STORAGE_DEVICE_MANAGEMENT_STATUS = extern struct {
    Version: u32,
    Size: u32,
    Health: STORAGE_DISK_HEALTH_STATUS,
    NumberOfOperationalStatus: u32,
    NumberOfAdditionalReasons: u32,
    OperationalStatus: ?[*]STORAGE_DISK_OPERATIONAL_STATUS,
    AdditionalReasons: ?[*]STORAGE_OPERATIONAL_REASON,
};
// --------------------------------------------------------
// Type: STORAGE_ZONED_DEVICE_TYPES
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const STORAGE_ZONED_DEVICE_TYPES = *opaque{
};
// --------------------------------------------------------
// Type: STORAGE_ZONE_TYPES
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const STORAGE_ZONE_TYPES = *opaque{
};
// --------------------------------------------------------
// Type: STORAGE_ZONE_GROUP
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const STORAGE_ZONE_GROUP = extern struct {
    ZoneCount: u32,
    ZoneType: STORAGE_ZONE_TYPES,
    ZoneSize: u64,
};
// --------------------------------------------------------
// Type: STORAGE_ZONED_DEVICE_DESCRIPTOR
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const STORAGE_ZONED_DEVICE_DESCRIPTOR = extern struct {
    Version: u32,
    Size: u32,
    DeviceType: STORAGE_ZONED_DEVICE_TYPES,
    ZoneCount: u32,
    ZoneAttributes: _ZoneAttributes_e__Union,
    ZoneGroupCount: u32,
    ZoneGroup: ?[*]STORAGE_ZONE_GROUP,
    // --------------------------------------------------------
    // Type: _ZoneAttributes_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _ZoneAttributes_e__Union = *opaque{
        // --------------------------------------------------------
        // Type: _SequentialPreferredZone_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _SequentialPreferredZone_e__Struct = extern struct {
            OptimalOpenZoneCount: u32,
            Reserved: u32,
        };
        // --------------------------------------------------------
        // Type: _SequentialRequiredZone_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _SequentialRequiredZone_e__Struct = extern struct {
            MaxOpenZoneCount: u32,
            UnrestrictedRead: u8,
            Reserved: ?[*]u8,
        };
    };
};
// --------------------------------------------------------
// Type: DEVICE_LOCATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DEVICE_LOCATION = extern struct {
    Socket: u32,
    Slot: u32,
    Adapter: u32,
    Port: u32,
    Anonymous: _Anonymous_e__Union,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
        // --------------------------------------------------------
        // Type: _Anonymous2_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _Anonymous2_e__Struct = extern struct {
            Target: u32,
            Lun: u32,
        };
        // --------------------------------------------------------
        // Type: _Anonymous1_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _Anonymous1_e__Struct = extern struct {
            Channel: u32,
            Device: u32,
        };
    };
};
// --------------------------------------------------------
// Type: STORAGE_DEVICE_LOCATION_DESCRIPTOR
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const STORAGE_DEVICE_LOCATION_DESCRIPTOR = extern struct {
    Version: u32,
    Size: u32,
    Location: DEVICE_LOCATION,
    StringOffset: u32,
};
// --------------------------------------------------------
// Type: STORAGE_DEVICE_NUMA_PROPERTY
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const STORAGE_DEVICE_NUMA_PROPERTY = extern struct {
    Version: u32,
    Size: u32,
    NumaNode: u32,
};
// --------------------------------------------------------
// Type: STORAGE_DEVICE_UNSAFE_SHUTDOWN_COUNT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const STORAGE_DEVICE_UNSAFE_SHUTDOWN_COUNT = extern struct {
    Version: u32,
    Size: u32,
    UnsafeShutdownCount: u32,
};
// --------------------------------------------------------
// Type: STORAGE_HW_ENDURANCE_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const STORAGE_HW_ENDURANCE_INFO = extern struct {
    ValidFields: u32,
    GroupId: u32,
    Flags: _Flags_e__Struct,
    LifePercentage: u32,
    BytesReadCount: ?[*]u8,
    ByteWriteCount: ?[*]u8,
    // --------------------------------------------------------
    // Type: _Flags_e__Struct
    // TypeLayoutAttr: sequential
    // TODO: I think this is a struct, but not sure at this point, assuming it is for now
    pub const _Flags_e__Struct = extern struct {
        _bitfield: u32,
    };
};
// --------------------------------------------------------
// Type: STORAGE_HW_ENDURANCE_DATA_DESCRIPTOR
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const STORAGE_HW_ENDURANCE_DATA_DESCRIPTOR = extern struct {
    Version: u32,
    Size: u32,
    EnduranceInfo: STORAGE_HW_ENDURANCE_INFO,
};
// --------------------------------------------------------
// Type: DEVICE_DATA_SET_RANGE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DEVICE_DATA_SET_RANGE = extern struct {
    StartingOffset: i64,
    LengthInBytes: u64,
};
// --------------------------------------------------------
// Type: DEVICE_MANAGE_DATA_SET_ATTRIBUTES
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DEVICE_MANAGE_DATA_SET_ATTRIBUTES = extern struct {
    Size: u32,
    Action: u32,
    Flags: u32,
    ParameterBlockOffset: u32,
    ParameterBlockLength: u32,
    DataSetRangesOffset: u32,
    DataSetRangesLength: u32,
};
// --------------------------------------------------------
// Type: DEVICE_MANAGE_DATA_SET_ATTRIBUTES_OUTPUT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DEVICE_MANAGE_DATA_SET_ATTRIBUTES_OUTPUT = extern struct {
    Size: u32,
    Action: u32,
    Flags: u32,
    OperationStatus: u32,
    ExtendedError: u32,
    TargetDetailedError: u32,
    ReservedStatus: u32,
    OutputBlockOffset: u32,
    OutputBlockLength: u32,
};
// --------------------------------------------------------
// Type: DEVICE_DSM_DEFINITION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DEVICE_DSM_DEFINITION = extern struct {
    Action: u32,
    SingleRange: u8,
    ParameterBlockAlignment: u32,
    ParameterBlockLength: u32,
    HasOutput: u8,
    OutputBlockAlignment: u32,
    OutputBlockLength: u32,
};
// --------------------------------------------------------
// Type: DEVICE_DSM_NOTIFICATION_PARAMETERS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DEVICE_DSM_NOTIFICATION_PARAMETERS = extern struct {
    Size: u32,
    Flags: u32,
    NumFileTypeIDs: u32,
    FileTypeID: ?[*]Guid,
};
// --------------------------------------------------------
// Type: STORAGE_OFFLOAD_TOKEN
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const STORAGE_OFFLOAD_TOKEN = extern struct {
    TokenType: ?[*]u8,
    Reserved: ?[*]u8,
    TokenIdLength: ?[*]u8,
    Anonymous: _Anonymous_e__Union,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
        // --------------------------------------------------------
        // Type: _StorageOffloadZeroDataToken_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _StorageOffloadZeroDataToken_e__Struct = extern struct {
            Reserved2: ?[*]u8,
        };
    };
};
// --------------------------------------------------------
// Type: DEVICE_DSM_OFFLOAD_READ_PARAMETERS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DEVICE_DSM_OFFLOAD_READ_PARAMETERS = extern struct {
    Flags: u32,
    TimeToLive: u32,
    Reserved: ?[*]u32,
};
// --------------------------------------------------------
// Type: STORAGE_OFFLOAD_READ_OUTPUT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const STORAGE_OFFLOAD_READ_OUTPUT = extern struct {
    OffloadReadFlags: u32,
    Reserved: u32,
    LengthProtected: u64,
    TokenLength: u32,
    Token: STORAGE_OFFLOAD_TOKEN,
};
// --------------------------------------------------------
// Type: DEVICE_DSM_OFFLOAD_WRITE_PARAMETERS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DEVICE_DSM_OFFLOAD_WRITE_PARAMETERS = extern struct {
    Flags: u32,
    Reserved: u32,
    TokenOffset: u64,
    Token: STORAGE_OFFLOAD_TOKEN,
};
// --------------------------------------------------------
// Type: STORAGE_OFFLOAD_WRITE_OUTPUT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const STORAGE_OFFLOAD_WRITE_OUTPUT = extern struct {
    OffloadWriteFlags: u32,
    Reserved: u32,
    LengthCopied: u64,
};
// --------------------------------------------------------
// Type: DEVICE_DATA_SET_LBP_STATE_PARAMETERS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DEVICE_DATA_SET_LBP_STATE_PARAMETERS = extern struct {
    Version: u32,
    Size: u32,
    Flags: u32,
    OutputVersion: u32,
};
// --------------------------------------------------------
// Type: DEVICE_DATA_SET_LB_PROVISIONING_STATE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DEVICE_DATA_SET_LB_PROVISIONING_STATE = extern struct {
    Size: u32,
    Version: u32,
    SlabSizeInBytes: u64,
    SlabOffsetDeltaInBytes: u32,
    SlabAllocationBitMapBitCount: u32,
    SlabAllocationBitMapLength: u32,
    SlabAllocationBitMap: ?[*]u32,
};
// --------------------------------------------------------
// Type: DEVICE_DATA_SET_LB_PROVISIONING_STATE_V2
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DEVICE_DATA_SET_LB_PROVISIONING_STATE_V2 = extern struct {
    Size: u32,
    Version: u32,
    SlabSizeInBytes: u64,
    SlabOffsetDeltaInBytes: u64,
    SlabAllocationBitMapBitCount: u32,
    SlabAllocationBitMapLength: u32,
    SlabAllocationBitMap: ?[*]u32,
};
// --------------------------------------------------------
// Type: DEVICE_DATA_SET_REPAIR_PARAMETERS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DEVICE_DATA_SET_REPAIR_PARAMETERS = extern struct {
    NumberOfRepairCopies: u32,
    SourceCopy: u32,
    RepairCopies: ?[*]u32,
};
// --------------------------------------------------------
// Type: DEVICE_DATA_SET_REPAIR_OUTPUT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DEVICE_DATA_SET_REPAIR_OUTPUT = extern struct {
    ParityExtent: DEVICE_DATA_SET_RANGE,
};
// --------------------------------------------------------
// Type: DEVICE_DATA_SET_SCRUB_OUTPUT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DEVICE_DATA_SET_SCRUB_OUTPUT = extern struct {
    BytesProcessed: u64,
    BytesRepaired: u64,
    BytesFailed: u64,
};
// --------------------------------------------------------
// Type: DEVICE_DATA_SET_SCRUB_EX_OUTPUT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DEVICE_DATA_SET_SCRUB_EX_OUTPUT = extern struct {
    BytesProcessed: u64,
    BytesRepaired: u64,
    BytesFailed: u64,
    ParityExtent: DEVICE_DATA_SET_RANGE,
};
// --------------------------------------------------------
// Type: DEVICE_DSM_TIERING_QUERY_INPUT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DEVICE_DSM_TIERING_QUERY_INPUT = extern struct {
    Version: u32,
    Size: u32,
    Flags: u32,
    NumberOfTierIds: u32,
    TierIds: ?[*]Guid,
};
// --------------------------------------------------------
// Type: STORAGE_TIER_REGION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const STORAGE_TIER_REGION = extern struct {
    TierId: Guid,
    Offset: u64,
    Length: u64,
};
// --------------------------------------------------------
// Type: DEVICE_DSM_TIERING_QUERY_OUTPUT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DEVICE_DSM_TIERING_QUERY_OUTPUT = extern struct {
    Version: u32,
    Size: u32,
    Flags: u32,
    Reserved: u32,
    Alignment: u64,
    TotalNumberOfRegions: u32,
    NumberOfRegionsReturned: u32,
    Regions: ?[*]STORAGE_TIER_REGION,
};
// --------------------------------------------------------
// Type: DEVICE_DSM_NVCACHE_CHANGE_PRIORITY_PARAMETERS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DEVICE_DSM_NVCACHE_CHANGE_PRIORITY_PARAMETERS = extern struct {
    Size: u32,
    TargetPriority: u8,
    Reserved: ?[*]u8,
};
// --------------------------------------------------------
// Type: DEVICE_DATA_SET_TOPOLOGY_ID_QUERY_OUTPUT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DEVICE_DATA_SET_TOPOLOGY_ID_QUERY_OUTPUT = extern struct {
    TopologyRangeBytes: u64,
    TopologyId: ?[*]u8,
};
// --------------------------------------------------------
// Type: DEVICE_STORAGE_ADDRESS_RANGE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DEVICE_STORAGE_ADDRESS_RANGE = extern struct {
    StartAddress: i64,
    LengthInBytes: u64,
};
// --------------------------------------------------------
// Type: DEVICE_DSM_PHYSICAL_ADDRESSES_OUTPUT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DEVICE_DSM_PHYSICAL_ADDRESSES_OUTPUT = extern struct {
    Version: u32,
    Flags: u32,
    TotalNumberOfRanges: u32,
    NumberOfRangesReturned: u32,
    Ranges: ?[*]DEVICE_STORAGE_ADDRESS_RANGE,
};
// --------------------------------------------------------
// Type: DEVICE_DSM_REPORT_ZONES_PARAMETERS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DEVICE_DSM_REPORT_ZONES_PARAMETERS = extern struct {
    Size: u32,
    ReportOption: u8,
    Partial: u8,
    Reserved: ?[*]u8,
};
// --------------------------------------------------------
// Type: STORAGE_ZONES_ATTRIBUTES
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const STORAGE_ZONES_ATTRIBUTES = *opaque{
};
// --------------------------------------------------------
// Type: STORAGE_ZONE_CONDITION
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const STORAGE_ZONE_CONDITION = *opaque{
};
// --------------------------------------------------------
// Type: STORAGE_ZONE_DESCRIPTOR
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const STORAGE_ZONE_DESCRIPTOR = extern struct {
    Size: u32,
    ZoneType: STORAGE_ZONE_TYPES,
    ZoneCondition: STORAGE_ZONE_CONDITION,
    ResetWritePointerRecommend: u8,
    Reserved0: ?[*]u8,
    ZoneSize: u64,
    WritePointerOffset: u64,
};
// --------------------------------------------------------
// Type: DEVICE_DSM_REPORT_ZONES_DATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DEVICE_DSM_REPORT_ZONES_DATA = extern struct {
    Size: u32,
    ZoneCount: u32,
    Attributes: STORAGE_ZONES_ATTRIBUTES,
    Reserved0: u32,
    ZoneDescriptors: ?[*]STORAGE_ZONE_DESCRIPTOR,
};
// --------------------------------------------------------
// Type: DEVICE_STORAGE_RANGE_ATTRIBUTES
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DEVICE_STORAGE_RANGE_ATTRIBUTES = extern struct {
    LengthInBytes: u64,
    Anonymous: _Anonymous_e__Union,
    Reserved: u32,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
        // --------------------------------------------------------
        // Type: _Anonymous_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _Anonymous_e__Struct = extern struct {
            _bitfield: u32,
        };
    };
};
// --------------------------------------------------------
// Type: DEVICE_DSM_RANGE_ERROR_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DEVICE_DSM_RANGE_ERROR_INFO = extern struct {
    Version: u32,
    Flags: u32,
    TotalNumberOfRanges: u32,
    NumberOfRangesReturned: u32,
    Ranges: ?[*]DEVICE_STORAGE_RANGE_ATTRIBUTES,
};
// --------------------------------------------------------
// Type: DEVICE_DSM_LOST_QUERY_PARAMETERS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DEVICE_DSM_LOST_QUERY_PARAMETERS = extern struct {
    Version: u32,
    Granularity: u64,
};
// --------------------------------------------------------
// Type: DEVICE_DSM_LOST_QUERY_OUTPUT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DEVICE_DSM_LOST_QUERY_OUTPUT = extern struct {
    Version: u32,
    Size: u32,
    Alignment: u64,
    NumberOfBits: u32,
    BitMap: ?[*]u32,
};
// --------------------------------------------------------
// Type: DEVICE_DSM_FREE_SPACE_OUTPUT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DEVICE_DSM_FREE_SPACE_OUTPUT = extern struct {
    Version: u32,
    FreeSpace: u64,
};
// --------------------------------------------------------
// Type: DEVICE_DSM_CONVERSION_OUTPUT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DEVICE_DSM_CONVERSION_OUTPUT = extern struct {
    Version: u32,
    Source: Guid,
};
// --------------------------------------------------------
// Type: STORAGE_GET_BC_PROPERTIES_OUTPUT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const STORAGE_GET_BC_PROPERTIES_OUTPUT = extern struct {
    MaximumRequestsPerPeriod: u32,
    MinimumPeriod: u32,
    MaximumRequestSize: u64,
    EstimatedTimePerRequest: u32,
    NumOutStandingRequests: u32,
    RequestSize: u64,
};
// --------------------------------------------------------
// Type: STORAGE_ALLOCATE_BC_STREAM_INPUT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const STORAGE_ALLOCATE_BC_STREAM_INPUT = extern struct {
    Version: u32,
    RequestsPerPeriod: u32,
    Period: u32,
    RetryFailures: u8,
    Discardable: u8,
    Reserved1: ?[*]u8,
    AccessType: u32,
    AccessMode: u32,
};
// --------------------------------------------------------
// Type: STORAGE_ALLOCATE_BC_STREAM_OUTPUT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const STORAGE_ALLOCATE_BC_STREAM_OUTPUT = extern struct {
    RequestSize: u64,
    NumOutStandingRequests: u32,
};
// --------------------------------------------------------
// Type: STORAGE_PRIORITY_HINT_SUPPORT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const STORAGE_PRIORITY_HINT_SUPPORT = extern struct {
    SupportFlags: u32,
};
// --------------------------------------------------------
// Type: STORAGE_DIAGNOSTIC_LEVEL
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const STORAGE_DIAGNOSTIC_LEVEL = *opaque{
};
// --------------------------------------------------------
// Type: STORAGE_DIAGNOSTIC_TARGET_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const STORAGE_DIAGNOSTIC_TARGET_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: STORAGE_DIAGNOSTIC_REQUEST
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const STORAGE_DIAGNOSTIC_REQUEST = extern struct {
    Version: u32,
    Size: u32,
    Reserved: u32,
    TargetType: STORAGE_DIAGNOSTIC_TARGET_TYPE,
    Level: STORAGE_DIAGNOSTIC_LEVEL,
};
// --------------------------------------------------------
// Type: STORAGE_DIAGNOSTIC_DATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const STORAGE_DIAGNOSTIC_DATA = extern struct {
    Version: u32,
    Size: u32,
    ProviderId: Guid,
    BufferSize: u32,
    Reserved: u32,
    DiagnosticDataBuffer: ?[*]u8,
};
// --------------------------------------------------------
// Type: PHYSICAL_ELEMENT_STATUS_REQUEST
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PHYSICAL_ELEMENT_STATUS_REQUEST = extern struct {
    Version: u32,
    Size: u32,
    StartingElement: u32,
    Filter: u8,
    ReportType: u8,
    Reserved: ?[*]u8,
};
// --------------------------------------------------------
// Type: PHYSICAL_ELEMENT_STATUS_DESCRIPTOR
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PHYSICAL_ELEMENT_STATUS_DESCRIPTOR = extern struct {
    Version: u32,
    Size: u32,
    ElementIdentifier: u32,
    PhysicalElementType: u8,
    PhysicalElementHealth: u8,
    Reserved1: ?[*]u8,
    AssociatedCapacity: u64,
    Reserved2: ?[*]u32,
};
// --------------------------------------------------------
// Type: PHYSICAL_ELEMENT_STATUS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PHYSICAL_ELEMENT_STATUS = extern struct {
    Version: u32,
    Size: u32,
    DescriptorCount: u32,
    ReturnedDescriptorCount: u32,
    ElementIdentifierBeingDepoped: u32,
    Reserved: u32,
    Descriptors: ?[*]PHYSICAL_ELEMENT_STATUS_DESCRIPTOR,
};
// --------------------------------------------------------
// Type: REMOVE_ELEMENT_AND_TRUNCATE_REQUEST
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const REMOVE_ELEMENT_AND_TRUNCATE_REQUEST = extern struct {
    Version: u32,
    Size: u32,
    RequestCapacity: u64,
    ElementIdentifier: u32,
    Reserved: u32,
};
// --------------------------------------------------------
// Type: DEVICE_INTERNAL_STATUS_DATA_REQUEST_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const DEVICE_INTERNAL_STATUS_DATA_REQUEST_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: DEVICE_INTERNAL_STATUS_DATA_SET
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const DEVICE_INTERNAL_STATUS_DATA_SET = *opaque{
};
// --------------------------------------------------------
// Type: GET_DEVICE_INTERNAL_STATUS_DATA_REQUEST
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const GET_DEVICE_INTERNAL_STATUS_DATA_REQUEST = extern struct {
    Version: u32,
    Size: u32,
    RequestDataType: DEVICE_INTERNAL_STATUS_DATA_REQUEST_TYPE,
    RequestDataSet: DEVICE_INTERNAL_STATUS_DATA_SET,
};
// --------------------------------------------------------
// Type: DEVICE_INTERNAL_STATUS_DATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DEVICE_INTERNAL_STATUS_DATA = extern struct {
    Version: u32,
    Size: u32,
    T10VendorId: u64,
    DataSet1Length: u32,
    DataSet2Length: u32,
    DataSet3Length: u32,
    DataSet4Length: u32,
    StatusDataVersion: u8,
    Reserved: ?[*]u8,
    ReasonIdentifier: ?[*]u8,
    StatusDataLength: u32,
    StatusData: ?[*]u8,
};
// --------------------------------------------------------
// Type: STORAGE_MEDIA_SERIAL_NUMBER_DATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const STORAGE_MEDIA_SERIAL_NUMBER_DATA = extern struct {
    Reserved: u16,
    SerialNumberLength: u16,
    SerialNumber: ?[*]u8,
};
// --------------------------------------------------------
// Type: STORAGE_READ_CAPACITY
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const STORAGE_READ_CAPACITY = extern struct {
    Version: u32,
    Size: u32,
    BlockLength: u32,
    NumberOfBlocks: LARGE_INTEGER,
    DiskLength: LARGE_INTEGER,
};
// --------------------------------------------------------
// Type: PERSISTENT_RESERVE_COMMAND
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PERSISTENT_RESERVE_COMMAND = extern struct {
    Version: u32,
    Size: u32,
    Anonymous: _Anonymous_e__Union,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
        // --------------------------------------------------------
        // Type: _PR_IN_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _PR_IN_e__Struct = extern struct {
            _bitfield: u8,
            AllocationLength: u16,
        };
        // --------------------------------------------------------
        // Type: _PR_OUT_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _PR_OUT_e__Struct = extern struct {
            _bitfield1: u8,
            _bitfield2: u8,
            ParameterList: ?[*]u8,
        };
    };
};
// --------------------------------------------------------
// Type: _DEVICEDUMP_COLLECTION_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const _DEVICEDUMP_COLLECTION_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: DEVICEDUMP_SUBSECTION_POINTER
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const DEVICEDUMP_SUBSECTION_POINTER = *opaque{
};
// --------------------------------------------------------
// Type: DEVICEDUMP_STRUCTURE_VERSION
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const DEVICEDUMP_STRUCTURE_VERSION = *opaque{
};
// --------------------------------------------------------
// Type: DEVICEDUMP_SECTION_HEADER
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const DEVICEDUMP_SECTION_HEADER = *opaque{
};
// --------------------------------------------------------
// Type: GP_LOG_PAGE_DESCRIPTOR
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const GP_LOG_PAGE_DESCRIPTOR = *opaque{
};
// --------------------------------------------------------
// Type: DEVICEDUMP_PUBLIC_SUBSECTION
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const DEVICEDUMP_PUBLIC_SUBSECTION = *opaque{
};
// --------------------------------------------------------
// Type: DEVICEDUMP_RESTRICTED_SUBSECTION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DEVICEDUMP_RESTRICTED_SUBSECTION = extern struct {
    bData: ?[*]u8,
};
// --------------------------------------------------------
// Type: DEVICEDUMP_PRIVATE_SUBSECTION
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const DEVICEDUMP_PRIVATE_SUBSECTION = *opaque{
};
// --------------------------------------------------------
// Type: DEVICEDUMP_STORAGEDEVICE_DATA
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const DEVICEDUMP_STORAGEDEVICE_DATA = *opaque{
};
// --------------------------------------------------------
// Type: DEVICEDUMP_STORAGESTACK_PUBLIC_STATE_RECORD
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const DEVICEDUMP_STORAGESTACK_PUBLIC_STATE_RECORD = *opaque{
    // --------------------------------------------------------
    // Type: _StackSpecific_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _StackSpecific_e__Union = *opaque{
        // --------------------------------------------------------
        // Type: _StorPort_e__Struct
        // TypeLayoutAttr: sequential
        // not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
        pub const _StorPort_e__Struct = *opaque{
        };
        // --------------------------------------------------------
        // Type: _ExternalStack_e__Struct
        // TypeLayoutAttr: sequential
        // not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
        pub const _ExternalStack_e__Struct = *opaque{
        };
        // --------------------------------------------------------
        // Type: _AtaPort_e__Struct
        // TypeLayoutAttr: sequential
        // not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
        pub const _AtaPort_e__Struct = *opaque{
        };
    };
};
// --------------------------------------------------------
// Type: DEVICEDUMP_STORAGESTACK_PUBLIC_DUMP
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const DEVICEDUMP_STORAGESTACK_PUBLIC_DUMP = *opaque{
};
// --------------------------------------------------------
// Type: STORAGE_IDLE_POWER
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const STORAGE_IDLE_POWER = extern struct {
    Version: u32,
    Size: u32,
    _bitfield: u32,
    D3IdleTimeout: u32,
};
// --------------------------------------------------------
// Type: STORAGE_POWERUP_REASON_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const STORAGE_POWERUP_REASON_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: STORAGE_IDLE_POWERUP_REASON
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const STORAGE_IDLE_POWERUP_REASON = extern struct {
    Version: u32,
    Size: u32,
    PowerupReason: STORAGE_POWERUP_REASON_TYPE,
};
// --------------------------------------------------------
// Type: STORAGE_RPMB_DATA_FRAME
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const STORAGE_RPMB_DATA_FRAME = extern struct {
    Stuff: ?[*]u8,
    KeyOrMAC: ?[*]u8,
    Data: ?[*]u8,
    Nonce: ?[*]u8,
    WriteCounter: ?[*]u8,
    Address: ?[*]u8,
    BlockCount: ?[*]u8,
    OperationResult: ?[*]u8,
    RequestOrResponseType: ?[*]u8,
};
// --------------------------------------------------------
// Type: STORAGE_RPMB_COMMAND_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const STORAGE_RPMB_COMMAND_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: STORAGE_EVENT_NOTIFICATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const STORAGE_EVENT_NOTIFICATION = extern struct {
    Version: u32,
    Size: u32,
    Events: u64,
};
// --------------------------------------------------------
// Type: STORAGE_COUNTER_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const STORAGE_COUNTER_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: STORAGE_COUNTER
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const STORAGE_COUNTER = extern struct {
    Type: STORAGE_COUNTER_TYPE,
    Value: _Value_e__Union,
    // --------------------------------------------------------
    // Type: _Value_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Value_e__Union = *opaque{
        // --------------------------------------------------------
        // Type: _ManufactureDate_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _ManufactureDate_e__Struct = extern struct {
            Week: u32,
            Year: u32,
        };
    };
};
// --------------------------------------------------------
// Type: STORAGE_COUNTERS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const STORAGE_COUNTERS = extern struct {
    Version: u32,
    Size: u32,
    NumberOfCounters: u32,
    Counters: ?[*]STORAGE_COUNTER,
};
// --------------------------------------------------------
// Type: STORAGE_HW_FIRMWARE_INFO_QUERY
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const STORAGE_HW_FIRMWARE_INFO_QUERY = extern struct {
    Version: u32,
    Size: u32,
    Flags: u32,
    Reserved: u32,
};
// --------------------------------------------------------
// Type: STORAGE_HW_FIRMWARE_SLOT_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const STORAGE_HW_FIRMWARE_SLOT_INFO = extern struct {
    Version: u32,
    Size: u32,
    SlotNumber: u8,
    _bitfield: u8,
    Reserved1: ?[*]u8,
    Revision: ?[*]u8,
};
// --------------------------------------------------------
// Type: STORAGE_HW_FIRMWARE_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const STORAGE_HW_FIRMWARE_INFO = extern struct {
    Version: u32,
    Size: u32,
    _bitfield: u8,
    SlotCount: u8,
    ActiveSlot: u8,
    PendingActivateSlot: u8,
    FirmwareShared: u8,
    Reserved: ?[*]u8,
    ImagePayloadAlignment: u32,
    ImagePayloadMaxSize: u32,
    Slot: ?[*]STORAGE_HW_FIRMWARE_SLOT_INFO,
};
// --------------------------------------------------------
// Type: STORAGE_HW_FIRMWARE_DOWNLOAD_V2
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const STORAGE_HW_FIRMWARE_DOWNLOAD_V2 = extern struct {
    Version: u32,
    Size: u32,
    Flags: u32,
    Slot: u8,
    Reserved: ?[*]u8,
    Offset: u64,
    BufferSize: u64,
    ImageSize: u32,
    Reserved2: u32,
    ImageBuffer: ?[*]u8,
};
// --------------------------------------------------------
// Type: STORAGE_ATTRIBUTE_MGMT_ACTION
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const STORAGE_ATTRIBUTE_MGMT_ACTION = *opaque{
};
// --------------------------------------------------------
// Type: STORAGE_ATTRIBUTE_MGMT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const STORAGE_ATTRIBUTE_MGMT = extern struct {
    Version: u32,
    Size: u32,
    Action: STORAGE_ATTRIBUTE_MGMT_ACTION,
    Attribute: u32,
};
// --------------------------------------------------------
// Type: SCM_PD_HEALTH_NOTIFICATION_DATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SCM_PD_HEALTH_NOTIFICATION_DATA = extern struct {
    DeviceGuid: Guid,
};
// --------------------------------------------------------
// Type: SCM_LOGICAL_DEVICE_INSTANCE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SCM_LOGICAL_DEVICE_INSTANCE = extern struct {
    Version: u32,
    Size: u32,
    DeviceGuid: Guid,
    SymbolicLink: ?[*]u16,
};
// --------------------------------------------------------
// Type: SCM_LOGICAL_DEVICES
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SCM_LOGICAL_DEVICES = extern struct {
    Version: u32,
    Size: u32,
    DeviceCount: u32,
    Devices: ?[*]SCM_LOGICAL_DEVICE_INSTANCE,
};
// --------------------------------------------------------
// Type: SCM_PHYSICAL_DEVICE_INSTANCE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SCM_PHYSICAL_DEVICE_INSTANCE = extern struct {
    Version: u32,
    Size: u32,
    NfitHandle: u32,
    SymbolicLink: ?[*]u16,
};
// --------------------------------------------------------
// Type: SCM_PHYSICAL_DEVICES
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SCM_PHYSICAL_DEVICES = extern struct {
    Version: u32,
    Size: u32,
    DeviceCount: u32,
    Devices: ?[*]SCM_PHYSICAL_DEVICE_INSTANCE,
};
// --------------------------------------------------------
// Type: SCM_REGION_FLAG
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const SCM_REGION_FLAG = *opaque{
};
// --------------------------------------------------------
// Type: SCM_REGION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SCM_REGION = extern struct {
    Version: u32,
    Size: u32,
    Flags: u32,
    NfitHandle: u32,
    LogicalDeviceGuid: Guid,
    AddressRangeType: Guid,
    AssociatedId: u32,
    Length: u64,
    StartingDPA: u64,
    BaseSPA: u64,
    SPAOffset: u64,
    RegionOffset: u64,
};
// --------------------------------------------------------
// Type: SCM_REGIONS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SCM_REGIONS = extern struct {
    Version: u32,
    Size: u32,
    RegionCount: u32,
    Regions: ?[*]SCM_REGION,
};
// --------------------------------------------------------
// Type: SCM_INTERLEAVED_PD_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SCM_INTERLEAVED_PD_INFO = extern struct {
    DeviceHandle: u32,
    DeviceGuid: Guid,
};
// --------------------------------------------------------
// Type: SCM_LD_INTERLEAVE_SET_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SCM_LD_INTERLEAVE_SET_INFO = extern struct {
    Version: u32,
    Size: u32,
    InterleaveSetSize: u32,
    InterleaveSet: ?[*]SCM_INTERLEAVED_PD_INFO,
};
// --------------------------------------------------------
// Type: SCM_PD_QUERY_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const SCM_PD_QUERY_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: SCM_PD_PROPERTY_ID
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const SCM_PD_PROPERTY_ID = *opaque{
};
// --------------------------------------------------------
// Type: SCM_PD_PROPERTY_QUERY
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SCM_PD_PROPERTY_QUERY = extern struct {
    Version: u32,
    Size: u32,
    PropertyId: SCM_PD_PROPERTY_ID,
    QueryType: SCM_PD_QUERY_TYPE,
    AdditionalParameters: ?[*]u8,
};
// --------------------------------------------------------
// Type: SCM_PD_DESCRIPTOR_HEADER
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SCM_PD_DESCRIPTOR_HEADER = extern struct {
    Version: u32,
    Size: u32,
};
// --------------------------------------------------------
// Type: SCM_PD_DEVICE_HANDLE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SCM_PD_DEVICE_HANDLE = extern struct {
    Version: u32,
    Size: u32,
    DeviceGuid: Guid,
    DeviceHandle: u32,
};
// --------------------------------------------------------
// Type: SCM_PD_DEVICE_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SCM_PD_DEVICE_INFO = extern struct {
    Version: u32,
    Size: u32,
    DeviceGuid: Guid,
    UnsafeShutdownCount: u32,
    PersistentMemorySizeInBytes: u64,
    VolatileMemorySizeInBytes: u64,
    TotalMemorySizeInBytes: u64,
    SlotNumber: u32,
    DeviceHandle: u32,
    PhysicalId: u16,
    NumberOfFormatInterfaceCodes: u8,
    FormatInterfaceCodes: ?[*]u16,
    VendorId: u32,
    ProductId: u32,
    SubsystemDeviceId: u32,
    SubsystemVendorId: u32,
    ManufacturingLocation: u8,
    ManufacturingWeek: u8,
    ManufacturingYear: u8,
    SerialNumber4Byte: u32,
    SerialNumberLengthInChars: u32,
    SerialNumber: ?[*]i8,
};
// --------------------------------------------------------
// Type: SCM_PD_DEVICE_SPECIFIC_PROPERTY
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SCM_PD_DEVICE_SPECIFIC_PROPERTY = extern struct {
    Name: ?[*]u16,
    Value: i64,
};
// --------------------------------------------------------
// Type: SCM_PD_DEVICE_SPECIFIC_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SCM_PD_DEVICE_SPECIFIC_INFO = extern struct {
    Version: u32,
    Size: u32,
    NumberOfProperties: u32,
    DeviceSpecificProperties: ?[*]SCM_PD_DEVICE_SPECIFIC_PROPERTY,
};
// --------------------------------------------------------
// Type: SCM_PD_FIRMWARE_SLOT_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SCM_PD_FIRMWARE_SLOT_INFO = extern struct {
    Version: u32,
    Size: u32,
    SlotNumber: u8,
    _bitfield: u8,
    Reserved1: ?[*]u8,
    Revision: ?[*]u8,
};
// --------------------------------------------------------
// Type: SCM_PD_FIRMWARE_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SCM_PD_FIRMWARE_INFO = extern struct {
    Version: u32,
    Size: u32,
    ActiveSlot: u8,
    NextActiveSlot: u8,
    SlotCount: u8,
    Slots: ?[*]SCM_PD_FIRMWARE_SLOT_INFO,
};
// --------------------------------------------------------
// Type: SCM_PD_HEALTH_STATUS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const SCM_PD_HEALTH_STATUS = *opaque{
};
// --------------------------------------------------------
// Type: SCM_PD_OPERATIONAL_STATUS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const SCM_PD_OPERATIONAL_STATUS = *opaque{
};
// --------------------------------------------------------
// Type: SCM_PD_OPERATIONAL_STATUS_REASON
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const SCM_PD_OPERATIONAL_STATUS_REASON = *opaque{
};
// --------------------------------------------------------
// Type: SCM_PD_MANAGEMENT_STATUS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SCM_PD_MANAGEMENT_STATUS = extern struct {
    Version: u32,
    Size: u32,
    Health: SCM_PD_HEALTH_STATUS,
    NumberOfOperationalStatus: u32,
    NumberOfAdditionalReasons: u32,
    OperationalStatus: ?[*]SCM_PD_OPERATIONAL_STATUS,
    AdditionalReasons: ?[*]SCM_PD_OPERATIONAL_STATUS_REASON,
};
// --------------------------------------------------------
// Type: SCM_PD_LOCATION_STRING
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SCM_PD_LOCATION_STRING = extern struct {
    Version: u32,
    Size: u32,
    Location: ?[*]u16,
};
// --------------------------------------------------------
// Type: SCM_PD_FIRMWARE_DOWNLOAD
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SCM_PD_FIRMWARE_DOWNLOAD = extern struct {
    Version: u32,
    Size: u32,
    Flags: u32,
    Slot: u8,
    Reserved: ?[*]u8,
    Offset: u64,
    FirmwareImageSizeInBytes: u32,
    FirmwareImage: ?[*]u8,
};
// --------------------------------------------------------
// Type: SCM_PD_FIRMWARE_ACTIVATE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SCM_PD_FIRMWARE_ACTIVATE = extern struct {
    Version: u32,
    Size: u32,
    Flags: u32,
    Slot: u8,
};
// --------------------------------------------------------
// Type: SCM_PD_PASSTHROUGH_INPUT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SCM_PD_PASSTHROUGH_INPUT = extern struct {
    Version: u32,
    Size: u32,
    ProtocolGuid: Guid,
    DataSize: u32,
    Data: ?[*]u8,
};
// --------------------------------------------------------
// Type: SCM_PD_PASSTHROUGH_OUTPUT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SCM_PD_PASSTHROUGH_OUTPUT = extern struct {
    Version: u32,
    Size: u32,
    ProtocolGuid: Guid,
    DataSize: u32,
    Data: ?[*]u8,
};
// --------------------------------------------------------
// Type: SCM_PD_PASSTHROUGH_INVDIMM_INPUT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SCM_PD_PASSTHROUGH_INVDIMM_INPUT = extern struct {
    Opcode: u32,
    OpcodeParametersLength: u32,
    OpcodeParameters: ?[*]u8,
};
// --------------------------------------------------------
// Type: SCM_PD_PASSTHROUGH_INVDIMM_OUTPUT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SCM_PD_PASSTHROUGH_INVDIMM_OUTPUT = extern struct {
    GeneralStatus: u16,
    ExtendedStatus: u16,
    OutputDataLength: u32,
    OutputData: ?[*]u8,
};
// --------------------------------------------------------
// Type: SCM_PD_REINITIALIZE_MEDIA_INPUT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SCM_PD_REINITIALIZE_MEDIA_INPUT = extern struct {
    Version: u32,
    Size: u32,
    Options: _Options_e__Struct,
    // --------------------------------------------------------
    // Type: _Options_e__Struct
    // TypeLayoutAttr: sequential
    // TODO: I think this is a struct, but not sure at this point, assuming it is for now
    pub const _Options_e__Struct = extern struct {
        _bitfield: u32,
    };
};
// --------------------------------------------------------
// Type: SCM_PD_MEDIA_REINITIALIZATION_STATUS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const SCM_PD_MEDIA_REINITIALIZATION_STATUS = *opaque{
};
// --------------------------------------------------------
// Type: SCM_PD_REINITIALIZE_MEDIA_OUTPUT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SCM_PD_REINITIALIZE_MEDIA_OUTPUT = extern struct {
    Version: u32,
    Size: u32,
    Status: SCM_PD_MEDIA_REINITIALIZATION_STATUS,
};
// --------------------------------------------------------
// Type: SET_PARTITION_INFORMATION_EX
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SET_PARTITION_INFORMATION_EX = extern struct {
    PartitionStyle: PARTITION_STYLE,
    Anonymous: _Anonymous_e__Union,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: DETECTION_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const DETECTION_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: DISK_CONTROLLER_NUMBER
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DISK_CONTROLLER_NUMBER = extern struct {
    ControllerNumber: u32,
    DiskNumber: u32,
};
// --------------------------------------------------------
// Type: DISK_CACHE_RETENTION_PRIORITY
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const DISK_CACHE_RETENTION_PRIORITY = *opaque{
};
// --------------------------------------------------------
// Type: HISTOGRAM_BUCKET
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HISTOGRAM_BUCKET = extern struct {
    Reads: u32,
    Writes: u32,
};
// --------------------------------------------------------
// Type: DISK_HISTOGRAM
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DISK_HISTOGRAM = extern struct {
    DiskSize: LARGE_INTEGER,
    Start: LARGE_INTEGER,
    End: LARGE_INTEGER,
    Average: LARGE_INTEGER,
    AverageRead: LARGE_INTEGER,
    AverageWrite: LARGE_INTEGER,
    Granularity: u32,
    Size: u32,
    ReadCount: u32,
    WriteCount: u32,
    Histogram: ?*HISTOGRAM_BUCKET,
};
// --------------------------------------------------------
// Type: DISK_RECORD
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DISK_RECORD = extern struct {
    ByteOffset: LARGE_INTEGER,
    StartTime: LARGE_INTEGER,
    EndTime: LARGE_INTEGER,
    VirtualAddress: ?*opaque{},
    NumberOfBytes: u32,
    DeviceNumber: u8,
    ReadRequest: u8,
};
// --------------------------------------------------------
// Type: DISK_LOGGING
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DISK_LOGGING = extern struct {
    Function: u8,
    BufferAddress: ?*opaque{},
    BufferSize: u32,
};
// --------------------------------------------------------
// Type: BIN_TYPES
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const BIN_TYPES = *opaque{
};
// --------------------------------------------------------
// Type: BIN_RANGE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const BIN_RANGE = extern struct {
    StartValue: LARGE_INTEGER,
    Length: LARGE_INTEGER,
};
// --------------------------------------------------------
// Type: PERF_BIN
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PERF_BIN = extern struct {
    NumberOfBins: u32,
    TypeOfBin: u32,
    BinsRanges: ?[*]BIN_RANGE,
};
// --------------------------------------------------------
// Type: BIN_COUNT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const BIN_COUNT = extern struct {
    BinRange: BIN_RANGE,
    BinCount: u32,
};
// --------------------------------------------------------
// Type: BIN_RESULTS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const BIN_RESULTS = extern struct {
    NumberOfBins: u32,
    BinCounts: ?[*]BIN_COUNT,
};
// --------------------------------------------------------
// Type: GETVERSIONINPARAMS
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const GETVERSIONINPARAMS = *opaque{
};
// --------------------------------------------------------
// Type: IDEREGS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const IDEREGS = extern struct {
    bFeaturesReg: u8,
    bSectorCountReg: u8,
    bSectorNumberReg: u8,
    bCylLowReg: u8,
    bCylHighReg: u8,
    bDriveHeadReg: u8,
    bCommandReg: u8,
    bReserved: u8,
};
// --------------------------------------------------------
// Type: SENDCMDINPARAMS
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const SENDCMDINPARAMS = *opaque{
};
// --------------------------------------------------------
// Type: DRIVERSTATUS
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const DRIVERSTATUS = *opaque{
};
// --------------------------------------------------------
// Type: SENDCMDOUTPARAMS
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const SENDCMDOUTPARAMS = *opaque{
};
// --------------------------------------------------------
// Type: ELEMENT_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const ELEMENT_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: CHANGER_ELEMENT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CHANGER_ELEMENT = extern struct {
    ElementType: ELEMENT_TYPE,
    ElementAddress: u32,
};
// --------------------------------------------------------
// Type: CHANGER_ELEMENT_LIST
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CHANGER_ELEMENT_LIST = extern struct {
    Element: CHANGER_ELEMENT,
    NumberOfElements: u32,
};
// --------------------------------------------------------
// Type: GET_CHANGER_PARAMETERS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const GET_CHANGER_PARAMETERS = extern struct {
    Size: u32,
    NumberTransportElements: u16,
    NumberStorageElements: u16,
    NumberCleanerSlots: u16,
    NumberIEElements: u16,
    NumberDataTransferElements: u16,
    NumberOfDoors: u16,
    FirstSlotNumber: u16,
    FirstDriveNumber: u16,
    FirstTransportNumber: u16,
    FirstIEPortNumber: u16,
    FirstCleanerSlotAddress: u16,
    MagazineSize: u16,
    DriveCleanTimeout: u32,
    Features0: u32,
    Features1: u32,
    MoveFromTransport: u8,
    MoveFromSlot: u8,
    MoveFromIePort: u8,
    MoveFromDrive: u8,
    ExchangeFromTransport: u8,
    ExchangeFromSlot: u8,
    ExchangeFromIePort: u8,
    ExchangeFromDrive: u8,
    LockUnlockCapabilities: u8,
    PositionCapabilities: u8,
    Reserved1: ?[*]u8,
    Reserved2: ?[*]u32,
};
// --------------------------------------------------------
// Type: CHANGER_PRODUCT_DATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CHANGER_PRODUCT_DATA = extern struct {
    VendorId: ?[*]u8,
    ProductId: ?[*]u8,
    Revision: ?[*]u8,
    SerialNumber: ?[*]u8,
    DeviceType: u8,
};
// --------------------------------------------------------
// Type: CHANGER_SET_ACCESS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CHANGER_SET_ACCESS = extern struct {
    Element: CHANGER_ELEMENT,
    Control: u32,
};
// --------------------------------------------------------
// Type: CHANGER_READ_ELEMENT_STATUS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CHANGER_READ_ELEMENT_STATUS = extern struct {
    ElementList: CHANGER_ELEMENT_LIST,
    VolumeTagInfo: u8,
};
// --------------------------------------------------------
// Type: CHANGER_ELEMENT_STATUS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CHANGER_ELEMENT_STATUS = extern struct {
    Element: CHANGER_ELEMENT,
    SrcElementAddress: CHANGER_ELEMENT,
    Flags: u32,
    ExceptionCode: u32,
    TargetId: u8,
    Lun: u8,
    Reserved: u16,
    PrimaryVolumeID: ?[*]u8,
    AlternateVolumeID: ?[*]u8,
};
// --------------------------------------------------------
// Type: CHANGER_ELEMENT_STATUS_EX
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CHANGER_ELEMENT_STATUS_EX = extern struct {
    Element: CHANGER_ELEMENT,
    SrcElementAddress: CHANGER_ELEMENT,
    Flags: u32,
    ExceptionCode: u32,
    TargetId: u8,
    Lun: u8,
    Reserved: u16,
    PrimaryVolumeID: ?[*]u8,
    AlternateVolumeID: ?[*]u8,
    VendorIdentification: ?[*]u8,
    ProductIdentification: ?[*]u8,
    SerialNumber: ?[*]u8,
};
// --------------------------------------------------------
// Type: CHANGER_INITIALIZE_ELEMENT_STATUS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CHANGER_INITIALIZE_ELEMENT_STATUS = extern struct {
    ElementList: CHANGER_ELEMENT_LIST,
    BarCodeScan: u8,
};
// --------------------------------------------------------
// Type: CHANGER_SET_POSITION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CHANGER_SET_POSITION = extern struct {
    Transport: CHANGER_ELEMENT,
    Destination: CHANGER_ELEMENT,
    Flip: u8,
};
// --------------------------------------------------------
// Type: CHANGER_EXCHANGE_MEDIUM
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CHANGER_EXCHANGE_MEDIUM = extern struct {
    Transport: CHANGER_ELEMENT,
    Source: CHANGER_ELEMENT,
    Destination1: CHANGER_ELEMENT,
    Destination2: CHANGER_ELEMENT,
    Flip1: u8,
    Flip2: u8,
};
// --------------------------------------------------------
// Type: CHANGER_MOVE_MEDIUM
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CHANGER_MOVE_MEDIUM = extern struct {
    Transport: CHANGER_ELEMENT,
    Source: CHANGER_ELEMENT,
    Destination: CHANGER_ELEMENT,
    Flip: u8,
};
// --------------------------------------------------------
// Type: CHANGER_SEND_VOLUME_TAG_INFORMATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CHANGER_SEND_VOLUME_TAG_INFORMATION = extern struct {
    StartingElement: CHANGER_ELEMENT,
    ActionCode: u32,
    VolumeIDTemplate: ?[*]u8,
};
// --------------------------------------------------------
// Type: READ_ELEMENT_ADDRESS_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const READ_ELEMENT_ADDRESS_INFO = extern struct {
    NumberOfElements: u32,
    ElementStatus: ?[*]CHANGER_ELEMENT_STATUS,
};
// --------------------------------------------------------
// Type: CHANGER_DEVICE_PROBLEM_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const CHANGER_DEVICE_PROBLEM_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: PATHNAME_BUFFER
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PATHNAME_BUFFER = extern struct {
    PathNameLength: u32,
    Name: ?[*]u16,
};
// --------------------------------------------------------
// Type: FSCTL_QUERY_FAT_BPB_BUFFER
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const FSCTL_QUERY_FAT_BPB_BUFFER = extern struct {
    First0x24BytesOfBootSector: ?[*]u8,
};
// --------------------------------------------------------
// Type: REFS_VOLUME_DATA_BUFFER
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const REFS_VOLUME_DATA_BUFFER = extern struct {
    ByteCount: u32,
    MajorVersion: u32,
    MinorVersion: u32,
    BytesPerPhysicalSector: u32,
    VolumeSerialNumber: LARGE_INTEGER,
    NumberSectors: LARGE_INTEGER,
    TotalClusters: LARGE_INTEGER,
    FreeClusters: LARGE_INTEGER,
    TotalReserved: LARGE_INTEGER,
    BytesPerSector: u32,
    BytesPerCluster: u32,
    MaximumSizeOfResidentFile: LARGE_INTEGER,
    FastTierDataFillRatio: u16,
    SlowTierDataFillRatio: u16,
    DestagesFastTierToSlowTierRate: u32,
    Reserved: ?[*]LARGE_INTEGER,
};
// --------------------------------------------------------
// Type: STARTING_LCN_INPUT_BUFFER_EX
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const STARTING_LCN_INPUT_BUFFER_EX = extern struct {
    StartingLcn: LARGE_INTEGER,
    Flags: u32,
};
// --------------------------------------------------------
// Type: RETRIEVAL_POINTERS_AND_REFCOUNT_BUFFER
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const RETRIEVAL_POINTERS_AND_REFCOUNT_BUFFER = extern struct {
    ExtentCount: u32,
    StartingVcn: LARGE_INTEGER,
    Extents: ?[*]_Anonymous_e__Struct,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Struct
    // TypeLayoutAttr: sequential
    // TODO: I think this is a struct, but not sure at this point, assuming it is for now
    pub const _Anonymous_e__Struct = extern struct {
        NextVcn: LARGE_INTEGER,
        Lcn: LARGE_INTEGER,
        ReferenceCount: u32,
    };
};
// --------------------------------------------------------
// Type: RETRIEVAL_POINTER_COUNT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const RETRIEVAL_POINTER_COUNT = extern struct {
    ExtentCount: u32,
};
// --------------------------------------------------------
// Type: MOVE_FILE_RECORD_DATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const MOVE_FILE_RECORD_DATA = extern struct {
    FileHandle: HANDLE,
    SourceFileRecord: LARGE_INTEGER,
    TargetFileRecord: LARGE_INTEGER,
};
// --------------------------------------------------------
// Type: USN_RECORD_UNION
// TypeLayoutAttr: explicit
// not generating the actual code for this type because it has an explicit layout
pub const USN_RECORD_UNION = *opaque{
};
// --------------------------------------------------------
// Type: BULK_SECURITY_TEST_DATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const BULK_SECURITY_TEST_DATA = extern struct {
    DesiredAccess: u32,
    SecurityIds: ?[*]u32,
};
// --------------------------------------------------------
// Type: FILE_PREFETCH
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const FILE_PREFETCH = extern struct {
    Type: u32,
    Count: u32,
    Prefetch: ?[*]u64,
};
// --------------------------------------------------------
// Type: FILE_PREFETCH_EX
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const FILE_PREFETCH_EX = extern struct {
    Type: u32,
    Count: u32,
    Context: ?*opaque{},
    Prefetch: ?[*]u64,
};
// --------------------------------------------------------
// Type: FILE_ZERO_DATA_INFORMATION_EX
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const FILE_ZERO_DATA_INFORMATION_EX = extern struct {
    FileOffset: LARGE_INTEGER,
    BeyondFinalZero: LARGE_INTEGER,
    Flags: u32,
};
// --------------------------------------------------------
// Type: ENCRYPTION_BUFFER
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const ENCRYPTION_BUFFER = extern struct {
    EncryptionOperation: u32,
    Private: ?[*]u8,
};
// --------------------------------------------------------
// Type: DECRYPTION_STATUS_BUFFER
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DECRYPTION_STATUS_BUFFER = extern struct {
    NoEncryptedStreams: u8,
};
// --------------------------------------------------------
// Type: REQUEST_RAW_ENCRYPTED_DATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const REQUEST_RAW_ENCRYPTED_DATA = extern struct {
    FileOffset: i64,
    Length: u32,
};
// --------------------------------------------------------
// Type: ENCRYPTED_DATA_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const ENCRYPTED_DATA_INFO = extern struct {
    StartingFileOffset: u64,
    OutputBufferOffset: u32,
    BytesWithinFileSize: u32,
    BytesWithinValidDataLength: u32,
    CompressionFormat: u16,
    DataUnitShift: u8,
    ChunkShift: u8,
    ClusterShift: u8,
    EncryptionFormat: u8,
    NumberOfDataBlocks: u16,
    DataBlockSize: ?[*]u32,
};
// --------------------------------------------------------
// Type: EXTENDED_ENCRYPTED_DATA_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const EXTENDED_ENCRYPTED_DATA_INFO = extern struct {
    ExtendedCode: u32,
    Length: u32,
    Flags: u32,
    Reserved: u32,
};
// --------------------------------------------------------
// Type: SI_COPYFILE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SI_COPYFILE = extern struct {
    SourceFileNameLength: u32,
    DestinationFileNameLength: u32,
    Flags: u32,
    FileNameBuffer: ?[*]u16,
};
// --------------------------------------------------------
// Type: FILE_INITIATE_REPAIR_OUTPUT_BUFFER
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const FILE_INITIATE_REPAIR_OUTPUT_BUFFER = extern struct {
    Hint1: u64,
    Hint2: u64,
    Clsn: u64,
    Status: u32,
};
// --------------------------------------------------------
// Type: SHRINK_VOLUME_REQUEST_TYPES
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const SHRINK_VOLUME_REQUEST_TYPES = *opaque{
};
// --------------------------------------------------------
// Type: TXFS_ROLLFORWARD_REDO_INFORMATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TXFS_ROLLFORWARD_REDO_INFORMATION = extern struct {
    LastVirtualClock: LARGE_INTEGER,
    LastRedoLsn: u64,
    HighestRecoveryLsn: u64,
    Flags: u32,
};
// --------------------------------------------------------
// Type: TXFS_START_RM_INFORMATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TXFS_START_RM_INFORMATION = extern struct {
    Flags: u32,
    LogContainerSize: u64,
    LogContainerCountMin: u32,
    LogContainerCountMax: u32,
    LogGrowthIncrement: u32,
    LogAutoShrinkPercentage: u32,
    TmLogPathOffset: u32,
    TmLogPathLength: u16,
    LoggingMode: u16,
    LogPathLength: u16,
    Reserved: u16,
    LogPath: ?[*]u16,
};
// --------------------------------------------------------
// Type: FILE_FS_PERSISTENT_VOLUME_INFORMATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const FILE_FS_PERSISTENT_VOLUME_INFORMATION = extern struct {
    VolumeFlags: u32,
    FlagMask: u32,
    Version: u32,
    Reserved: u32,
};
// --------------------------------------------------------
// Type: STORAGE_QUERY_DEPENDENT_VOLUME_REQUEST
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const STORAGE_QUERY_DEPENDENT_VOLUME_REQUEST = extern struct {
    RequestLevel: u32,
    RequestFlags: u32,
};
// --------------------------------------------------------
// Type: STORAGE_QUERY_DEPENDENT_VOLUME_LEV1_ENTRY
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const STORAGE_QUERY_DEPENDENT_VOLUME_LEV1_ENTRY = extern struct {
    EntryLength: u32,
    DependencyTypeFlags: u32,
    ProviderSpecificFlags: u32,
    VirtualStorageType: VIRTUAL_STORAGE_TYPE,
};
// --------------------------------------------------------
// Type: STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY = extern struct {
    EntryLength: u32,
    DependencyTypeFlags: u32,
    ProviderSpecificFlags: u32,
    VirtualStorageType: VIRTUAL_STORAGE_TYPE,
    AncestorLevel: u32,
    HostVolumeNameOffset: u32,
    HostVolumeNameSize: u32,
    DependentVolumeNameOffset: u32,
    DependentVolumeNameSize: u32,
    RelativePathOffset: u32,
    RelativePathSize: u32,
    DependentDeviceNameOffset: u32,
    DependentDeviceNameSize: u32,
};
// --------------------------------------------------------
// Type: STORAGE_QUERY_DEPENDENT_VOLUME_RESPONSE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const STORAGE_QUERY_DEPENDENT_VOLUME_RESPONSE = extern struct {
    ResponseLevel: u32,
    NumberEntries: u32,
    Anonymous: _Anonymous_e__Union,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: SD_CHANGE_MACHINE_SID_INPUT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SD_CHANGE_MACHINE_SID_INPUT = extern struct {
    CurrentMachineSIDOffset: u16,
    CurrentMachineSIDLength: u16,
    NewMachineSIDOffset: u16,
    NewMachineSIDLength: u16,
};
// --------------------------------------------------------
// Type: SD_CHANGE_MACHINE_SID_OUTPUT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SD_CHANGE_MACHINE_SID_OUTPUT = extern struct {
    NumSDChangedSuccess: u64,
    NumSDChangedFail: u64,
    NumSDUnused: u64,
    NumSDTotal: u64,
    NumMftSDChangedSuccess: u64,
    NumMftSDChangedFail: u64,
    NumMftSDTotal: u64,
};
// --------------------------------------------------------
// Type: SD_QUERY_STATS_INPUT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SD_QUERY_STATS_INPUT = extern struct {
    Reserved: u32,
};
// --------------------------------------------------------
// Type: SD_QUERY_STATS_OUTPUT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SD_QUERY_STATS_OUTPUT = extern struct {
    SdsStreamSize: u64,
    SdsAllocationSize: u64,
    SiiStreamSize: u64,
    SiiAllocationSize: u64,
    SdhStreamSize: u64,
    SdhAllocationSize: u64,
    NumSDTotal: u64,
    NumSDUnused: u64,
};
// --------------------------------------------------------
// Type: SD_ENUM_SDS_INPUT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SD_ENUM_SDS_INPUT = extern struct {
    StartingOffset: u64,
    MaxSDEntriesToReturn: u64,
};
// --------------------------------------------------------
// Type: SD_ENUM_SDS_ENTRY
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SD_ENUM_SDS_ENTRY = extern struct {
    Hash: u32,
    SecurityId: u32,
    Offset: u64,
    Length: u32,
    Descriptor: ?[*]u8,
};
// --------------------------------------------------------
// Type: SD_ENUM_SDS_OUTPUT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SD_ENUM_SDS_OUTPUT = extern struct {
    NextOffset: u64,
    NumSDEntriesReturned: u64,
    NumSDBytesReturned: u64,
    SDEntry: ?[*]SD_ENUM_SDS_ENTRY,
};
// --------------------------------------------------------
// Type: SD_GLOBAL_CHANGE_INPUT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SD_GLOBAL_CHANGE_INPUT = extern struct {
    Flags: u32,
    ChangeType: u32,
    Anonymous: _Anonymous_e__Union,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: SD_GLOBAL_CHANGE_OUTPUT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SD_GLOBAL_CHANGE_OUTPUT = extern struct {
    Flags: u32,
    ChangeType: u32,
    Anonymous: _Anonymous_e__Union,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: FILE_TYPE_NOTIFICATION_INPUT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const FILE_TYPE_NOTIFICATION_INPUT = extern struct {
    Flags: u32,
    NumFileTypeIDs: u32,
    FileTypeID: ?[*]Guid,
};
// --------------------------------------------------------
// Type: CSV_MGMT_LOCK
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CSV_MGMT_LOCK = extern struct {
    Flags: u32,
};
// --------------------------------------------------------
// Type: CSV_QUERY_FILE_REVISION_FILE_ID_128
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CSV_QUERY_FILE_REVISION_FILE_ID_128 = extern struct {
    FileId: FILE_ID_128,
    FileRevision: ?[*]i64,
};
// --------------------------------------------------------
// Type: CSVFS_DISK_CONNECTIVITY
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const CSVFS_DISK_CONNECTIVITY = *opaque{
};
// --------------------------------------------------------
// Type: CSV_QUERY_VOLUME_REDIRECT_STATE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CSV_QUERY_VOLUME_REDIRECT_STATE = extern struct {
    MdsNodeId: u32,
    DsNodeId: u32,
    IsDiskConnected: u8,
    ClusterEnableDirectIo: u8,
    DiskConnectivity: CSVFS_DISK_CONNECTIVITY,
};
// --------------------------------------------------------
// Type: CSV_QUERY_MDS_PATH_V2
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CSV_QUERY_MDS_PATH_V2 = extern struct {
    Version: i64,
    RequiredSize: u32,
    MdsNodeId: u32,
    DsNodeId: u32,
    Flags: u32,
    DiskConnectivity: CSVFS_DISK_CONNECTIVITY,
    VolumeId: Guid,
    IpAddressOffset: u32,
    IpAddressLength: u32,
    PathOffset: u32,
    PathLength: u32,
};
// --------------------------------------------------------
// Type: STORAGE_RESERVE_ID
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const STORAGE_RESERVE_ID = *opaque{
};
// --------------------------------------------------------
// Type: QUERY_FILE_LAYOUT_FILTER_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const QUERY_FILE_LAYOUT_FILTER_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: CLUSTER_RANGE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CLUSTER_RANGE = extern struct {
    StartingCluster: LARGE_INTEGER,
    ClusterCount: LARGE_INTEGER,
};
// --------------------------------------------------------
// Type: FILE_REFERENCE_RANGE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const FILE_REFERENCE_RANGE = extern struct {
    StartingFileReferenceNumber: u64,
    EndingFileReferenceNumber: u64,
};
// --------------------------------------------------------
// Type: QUERY_FILE_LAYOUT_INPUT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const QUERY_FILE_LAYOUT_INPUT = extern struct {
    Anonymous: _Anonymous_e__Union,
    Flags: u32,
    FilterType: QUERY_FILE_LAYOUT_FILTER_TYPE,
    Reserved: u32,
    Filter: _Filter_e__Union,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
    };
    // --------------------------------------------------------
    // Type: _Filter_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Filter_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: QUERY_FILE_LAYOUT_OUTPUT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const QUERY_FILE_LAYOUT_OUTPUT = extern struct {
    FileEntryCount: u32,
    FirstFileOffset: u32,
    Flags: u32,
    Reserved: u32,
};
// --------------------------------------------------------
// Type: FILE_LAYOUT_ENTRY
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const FILE_LAYOUT_ENTRY = extern struct {
    Version: u32,
    NextFileOffset: u32,
    Flags: u32,
    FileAttributes: u32,
    FileReferenceNumber: u64,
    FirstNameOffset: u32,
    FirstStreamOffset: u32,
    ExtraInfoOffset: u32,
    ExtraInfoLength: u32,
};
// --------------------------------------------------------
// Type: FILE_LAYOUT_NAME_ENTRY
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const FILE_LAYOUT_NAME_ENTRY = extern struct {
    NextNameOffset: u32,
    Flags: u32,
    ParentFileReferenceNumber: u64,
    FileNameLength: u32,
    Reserved: u32,
    FileName: ?[*]u16,
};
// --------------------------------------------------------
// Type: FILE_LAYOUT_INFO_ENTRY
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const FILE_LAYOUT_INFO_ENTRY = extern struct {
    BasicInformation: _BasicInformation_e__Struct,
    OwnerId: u32,
    SecurityId: u32,
    Usn: i64,
    StorageReserveId: STORAGE_RESERVE_ID,
    // --------------------------------------------------------
    // Type: _BasicInformation_e__Struct
    // TypeLayoutAttr: sequential
    // TODO: I think this is a struct, but not sure at this point, assuming it is for now
    pub const _BasicInformation_e__Struct = extern struct {
        CreationTime: LARGE_INTEGER,
        LastAccessTime: LARGE_INTEGER,
        LastWriteTime: LARGE_INTEGER,
        ChangeTime: LARGE_INTEGER,
        FileAttributes: u32,
    };
};
// --------------------------------------------------------
// Type: STREAM_LAYOUT_ENTRY
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const STREAM_LAYOUT_ENTRY = extern struct {
    Version: u32,
    NextStreamOffset: u32,
    Flags: u32,
    ExtentInformationOffset: u32,
    AllocationSize: LARGE_INTEGER,
    EndOfFile: LARGE_INTEGER,
    StreamInformationOffset: u32,
    AttributeTypeCode: u32,
    AttributeFlags: u32,
    StreamIdentifierLength: u32,
    StreamIdentifier: ?[*]u16,
};
// --------------------------------------------------------
// Type: STREAM_EXTENT_ENTRY
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const STREAM_EXTENT_ENTRY = extern struct {
    Flags: u32,
    ExtentInformation: _ExtentInformation_e__Union,
    // --------------------------------------------------------
    // Type: _ExtentInformation_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _ExtentInformation_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: FSCTL_SET_INTEGRITY_INFORMATION_BUFFER_EX
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const FSCTL_SET_INTEGRITY_INFORMATION_BUFFER_EX = extern struct {
    EnableIntegrity: u8,
    KeepIntegrityStateUnchanged: u8,
    Reserved: u16,
    Flags: u32,
    Version: u8,
    Reserved2: ?[*]u8,
};
// --------------------------------------------------------
// Type: FSCTL_OFFLOAD_READ_INPUT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const FSCTL_OFFLOAD_READ_INPUT = extern struct {
    Size: u32,
    Flags: u32,
    TokenTimeToLive: u32,
    Reserved: u32,
    FileOffset: u64,
    CopyLength: u64,
};
// --------------------------------------------------------
// Type: FSCTL_OFFLOAD_READ_OUTPUT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const FSCTL_OFFLOAD_READ_OUTPUT = extern struct {
    Size: u32,
    Flags: u32,
    TransferLength: u64,
    Token: ?[*]u8,
};
// --------------------------------------------------------
// Type: FSCTL_OFFLOAD_WRITE_INPUT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const FSCTL_OFFLOAD_WRITE_INPUT = extern struct {
    Size: u32,
    Flags: u32,
    FileOffset: u64,
    CopyLength: u64,
    TransferOffset: u64,
    Token: ?[*]u8,
};
// --------------------------------------------------------
// Type: FSCTL_OFFLOAD_WRITE_OUTPUT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const FSCTL_OFFLOAD_WRITE_OUTPUT = extern struct {
    Size: u32,
    Flags: u32,
    LengthWritten: u64,
};
// --------------------------------------------------------
// Type: SET_PURGE_FAILURE_MODE_INPUT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SET_PURGE_FAILURE_MODE_INPUT = extern struct {
    Flags: u32,
};
// --------------------------------------------------------
// Type: FILE_REGION_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const FILE_REGION_INFO = extern struct {
    FileOffset: i64,
    Length: i64,
    Usage: u32,
    Reserved: u32,
};
// --------------------------------------------------------
// Type: FILE_REGION_OUTPUT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const FILE_REGION_OUTPUT = extern struct {
    Flags: u32,
    TotalRegionEntryCount: u32,
    RegionEntryCount: u32,
    Reserved: u32,
    Region: ?[*]FILE_REGION_INFO,
};
// --------------------------------------------------------
// Type: FILE_REGION_INPUT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const FILE_REGION_INPUT = extern struct {
    FileOffset: i64,
    Length: i64,
    DesiredUsage: u32,
};
// --------------------------------------------------------
// Type: WRITE_USN_REASON_INPUT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const WRITE_USN_REASON_INPUT = extern struct {
    Flags: u32,
    UsnReasonToWrite: u32,
};
// --------------------------------------------------------
// Type: FILE_STORAGE_TIER_CLASS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const FILE_STORAGE_TIER_CLASS = *opaque{
};
// --------------------------------------------------------
// Type: STREAM_INFORMATION_ENTRY
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const STREAM_INFORMATION_ENTRY = extern struct {
    Version: u32,
    Flags: u32,
    StreamInformation: _StreamInformation,
    // --------------------------------------------------------
    // Type: _StreamInformation
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _StreamInformation = *opaque{
        // --------------------------------------------------------
        // Type: _Ea
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _Ea = extern struct {
            Length: u16,
            Flags: u16,
            EaSize: u32,
            EaInformationOffset: u32,
        };
        // --------------------------------------------------------
        // Type: _DataStream
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _DataStream = extern struct {
            Length: u16,
            Flags: u16,
            Reserved: u32,
            Vdl: u64,
        };
        // --------------------------------------------------------
        // Type: _Reparse
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _Reparse = extern struct {
            Length: u16,
            Flags: u16,
            ReparseDataSize: u32,
            ReparseDataOffset: u32,
        };
        // --------------------------------------------------------
        // Type: _DesiredStorageClass
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _DesiredStorageClass = extern struct {
            Class: FILE_STORAGE_TIER_CLASS,
            Flags: u32,
        };
    };
};
// --------------------------------------------------------
// Type: FILE_DESIRED_STORAGE_CLASS_INFORMATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const FILE_DESIRED_STORAGE_CLASS_INFORMATION = extern struct {
    Class: FILE_STORAGE_TIER_CLASS,
    Flags: u32,
};
// --------------------------------------------------------
// Type: DUPLICATE_EXTENTS_DATA_EX
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DUPLICATE_EXTENTS_DATA_EX = extern struct {
    Size: ?*opaque{},
    FileHandle: HANDLE,
    SourceFileOffset: LARGE_INTEGER,
    TargetFileOffset: LARGE_INTEGER,
    ByteCount: LARGE_INTEGER,
    Flags: u32,
};
// --------------------------------------------------------
// Type: REFS_SMR_VOLUME_GC_STATE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const REFS_SMR_VOLUME_GC_STATE = *opaque{
};
// --------------------------------------------------------
// Type: REFS_SMR_VOLUME_INFO_OUTPUT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const REFS_SMR_VOLUME_INFO_OUTPUT = extern struct {
    Version: u32,
    Flags: u32,
    SizeOfRandomlyWritableTier: LARGE_INTEGER,
    FreeSpaceInRandomlyWritableTier: LARGE_INTEGER,
    SizeofSMRTier: LARGE_INTEGER,
    FreeSpaceInSMRTier: LARGE_INTEGER,
    UsableFreeSpaceInSMRTier: LARGE_INTEGER,
    VolumeGcState: REFS_SMR_VOLUME_GC_STATE,
    VolumeGcLastStatus: u32,
    Unused: ?[*]u64,
};
// --------------------------------------------------------
// Type: REFS_SMR_VOLUME_GC_ACTION
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const REFS_SMR_VOLUME_GC_ACTION = *opaque{
};
// --------------------------------------------------------
// Type: REFS_SMR_VOLUME_GC_METHOD
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const REFS_SMR_VOLUME_GC_METHOD = *opaque{
};
// --------------------------------------------------------
// Type: REFS_SMR_VOLUME_GC_PARAMETERS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const REFS_SMR_VOLUME_GC_PARAMETERS = extern struct {
    Version: u32,
    Flags: u32,
    Action: REFS_SMR_VOLUME_GC_ACTION,
    Method: REFS_SMR_VOLUME_GC_METHOD,
    IoGranularity: u32,
    CompressionFormat: u32,
    Unused: ?[*]u64,
};
// --------------------------------------------------------
// Type: STREAMS_QUERY_PARAMETERS_OUTPUT_BUFFER
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const STREAMS_QUERY_PARAMETERS_OUTPUT_BUFFER = extern struct {
    OptimalWriteSize: u32,
    StreamGranularitySize: u32,
    StreamIdMin: u32,
    StreamIdMax: u32,
};
// --------------------------------------------------------
// Type: STREAMS_ASSOCIATE_ID_INPUT_BUFFER
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const STREAMS_ASSOCIATE_ID_INPUT_BUFFER = extern struct {
    Flags: u32,
    StreamId: u32,
};
// --------------------------------------------------------
// Type: STREAMS_QUERY_ID_OUTPUT_BUFFER
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const STREAMS_QUERY_ID_OUTPUT_BUFFER = extern struct {
    StreamId: u32,
};
// --------------------------------------------------------
// Type: QUERY_BAD_RANGES_INPUT_RANGE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const QUERY_BAD_RANGES_INPUT_RANGE = extern struct {
    StartOffset: u64,
    LengthInBytes: u64,
};
// --------------------------------------------------------
// Type: QUERY_BAD_RANGES_INPUT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const QUERY_BAD_RANGES_INPUT = extern struct {
    Flags: u32,
    NumRanges: u32,
    Ranges: ?[*]QUERY_BAD_RANGES_INPUT_RANGE,
};
// --------------------------------------------------------
// Type: QUERY_BAD_RANGES_OUTPUT_RANGE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const QUERY_BAD_RANGES_OUTPUT_RANGE = extern struct {
    Flags: u32,
    Reserved: u32,
    StartOffset: u64,
    LengthInBytes: u64,
};
// --------------------------------------------------------
// Type: QUERY_BAD_RANGES_OUTPUT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const QUERY_BAD_RANGES_OUTPUT = extern struct {
    Flags: u32,
    NumBadRanges: u32,
    NextOffsetToLookUp: u64,
    BadRanges: ?[*]QUERY_BAD_RANGES_OUTPUT_RANGE,
};
// --------------------------------------------------------
// Type: SET_DAX_ALLOC_ALIGNMENT_HINT_INPUT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SET_DAX_ALLOC_ALIGNMENT_HINT_INPUT = extern struct {
    Flags: u32,
    AlignmentShift: u32,
    FileOffsetToAlign: u64,
    FallbackAlignmentShift: u32,
};
// --------------------------------------------------------
// Type: VIRTUAL_STORAGE_BEHAVIOR_CODE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const VIRTUAL_STORAGE_BEHAVIOR_CODE = *opaque{
};
// --------------------------------------------------------
// Type: VIRTUAL_STORAGE_SET_BEHAVIOR_INPUT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VIRTUAL_STORAGE_SET_BEHAVIOR_INPUT = extern struct {
    Size: u32,
    BehaviorCode: VIRTUAL_STORAGE_BEHAVIOR_CODE,
};
// --------------------------------------------------------
// Type: ENCRYPTION_KEY_CTRL_INPUT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const ENCRYPTION_KEY_CTRL_INPUT = extern struct {
    HeaderSize: u32,
    StructureSize: u32,
    KeyOffset: u16,
    KeySize: u16,
    DplLock: u32,
    DplUserId: u64,
    DplCredentialId: u64,
};
// --------------------------------------------------------
// Type: WOF_EXTERNAL_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const WOF_EXTERNAL_INFO = extern struct {
    Version: u32,
    Provider: u32,
};
// --------------------------------------------------------
// Type: WOF_EXTERNAL_FILE_ID
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const WOF_EXTERNAL_FILE_ID = extern struct {
    FileId: FILE_ID_128,
};
// --------------------------------------------------------
// Type: WOF_VERSION_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const WOF_VERSION_INFO = extern struct {
    WofVersion: u32,
};
// --------------------------------------------------------
// Type: WIM_PROVIDER_EXTERNAL_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const WIM_PROVIDER_EXTERNAL_INFO = extern struct {
    Version: u32,
    Flags: u32,
    DataSourceId: LARGE_INTEGER,
    ResourceHash: ?[*]u8,
};
// --------------------------------------------------------
// Type: WIM_PROVIDER_ADD_OVERLAY_INPUT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const WIM_PROVIDER_ADD_OVERLAY_INPUT = extern struct {
    WimType: u32,
    WimIndex: u32,
    WimFileNameOffset: u32,
    WimFileNameLength: u32,
};
// --------------------------------------------------------
// Type: WIM_PROVIDER_UPDATE_OVERLAY_INPUT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const WIM_PROVIDER_UPDATE_OVERLAY_INPUT = extern struct {
    DataSourceId: LARGE_INTEGER,
    WimFileNameOffset: u32,
    WimFileNameLength: u32,
};
// --------------------------------------------------------
// Type: WIM_PROVIDER_REMOVE_OVERLAY_INPUT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const WIM_PROVIDER_REMOVE_OVERLAY_INPUT = extern struct {
    DataSourceId: LARGE_INTEGER,
};
// --------------------------------------------------------
// Type: WIM_PROVIDER_SUSPEND_OVERLAY_INPUT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const WIM_PROVIDER_SUSPEND_OVERLAY_INPUT = extern struct {
    DataSourceId: LARGE_INTEGER,
};
// --------------------------------------------------------
// Type: WIM_PROVIDER_OVERLAY_ENTRY
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const WIM_PROVIDER_OVERLAY_ENTRY = extern struct {
    NextEntryOffset: u32,
    DataSourceId: LARGE_INTEGER,
    WimGuid: Guid,
    WimFileNameOffset: u32,
    WimType: u32,
    WimIndex: u32,
    Flags: u32,
};
// --------------------------------------------------------
// Type: FILE_PROVIDER_EXTERNAL_INFO_V0
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const FILE_PROVIDER_EXTERNAL_INFO_V0 = extern struct {
    Version: u32,
    Algorithm: u32,
};
// --------------------------------------------------------
// Type: FILE_PROVIDER_EXTERNAL_INFO_V1
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const FILE_PROVIDER_EXTERNAL_INFO_V1 = extern struct {
    Version: u32,
    Algorithm: u32,
    Flags: u32,
};
// --------------------------------------------------------
// Type: CONTAINER_VOLUME_STATE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CONTAINER_VOLUME_STATE = extern struct {
    Flags: u32,
};
// --------------------------------------------------------
// Type: CONTAINER_ROOT_INFO_INPUT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CONTAINER_ROOT_INFO_INPUT = extern struct {
    Flags: u32,
};
// --------------------------------------------------------
// Type: CONTAINER_ROOT_INFO_OUTPUT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CONTAINER_ROOT_INFO_OUTPUT = extern struct {
    ContainerRootIdLength: u16,
    ContainerRootId: ?[*]u8,
};
// --------------------------------------------------------
// Type: VIRTUALIZATION_INSTANCE_INFO_INPUT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VIRTUALIZATION_INSTANCE_INFO_INPUT = extern struct {
    NumberOfWorkerThreads: u32,
    Flags: u32,
};
// --------------------------------------------------------
// Type: VIRTUALIZATION_INSTANCE_INFO_INPUT_EX
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VIRTUALIZATION_INSTANCE_INFO_INPUT_EX = extern struct {
    HeaderSize: u16,
    Flags: u32,
    NotificationInfoSize: u32,
    NotificationInfoOffset: u16,
    ProviderMajorVersion: u16,
};
// --------------------------------------------------------
// Type: VIRTUALIZATION_INSTANCE_INFO_OUTPUT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VIRTUALIZATION_INSTANCE_INFO_OUTPUT = extern struct {
    VirtualizationInstanceID: Guid,
};
// --------------------------------------------------------
// Type: GET_FILTER_FILE_IDENTIFIER_INPUT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const GET_FILTER_FILE_IDENTIFIER_INPUT = extern struct {
    AltitudeLength: u16,
    Altitude: ?[*]u16,
};
// --------------------------------------------------------
// Type: GET_FILTER_FILE_IDENTIFIER_OUTPUT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const GET_FILTER_FILE_IDENTIFIER_OUTPUT = extern struct {
    FilterFileIdentifierLength: u16,
    FilterFileIdentifier: ?[*]u8,
};
// --------------------------------------------------------
// Type: PIO_IRP_EXT_PROCESS_TRACKED_OFFSET_CALLBACK
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PIO_IRP_EXT_PROCESS_TRACKED_OFFSET_CALLBACK = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: IO_IRP_EXT_TRACK_OFFSET_HEADER
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const IO_IRP_EXT_TRACK_OFFSET_HEADER = extern struct {
    Validation: u16,
    Flags: u16,
    TrackedOffsetCallback: PIO_IRP_EXT_PROCESS_TRACKED_OFFSET_CALLBACK,
};
// --------------------------------------------------------
// Type: SCARD_IO_REQUEST
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SCARD_IO_REQUEST = extern struct {
    dwProtocol: u32,
    cbPciLength: u32,
};
// --------------------------------------------------------
// Type: SCARD_T0_COMMAND
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SCARD_T0_COMMAND = extern struct {
    bCla: u8,
    bIns: u8,
    bP1: u8,
    bP2: u8,
    bP3: u8,
};
// --------------------------------------------------------
// Type: SCARD_T0_REQUEST
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SCARD_T0_REQUEST = extern struct {
    ioRequest: SCARD_IO_REQUEST,
    bSw1: u8,
    bSw2: u8,
    Anonymous: _Anonymous_e__Union,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: SCARD_T1_REQUEST
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SCARD_T1_REQUEST = extern struct {
    ioRequest: SCARD_IO_REQUEST,
};
// --------------------------------------------------------
// Type: PRINTER_INFO_1A
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PRINTER_INFO_1A = extern struct {
    Flags: u32,
    pDescription: ?*i8,
    pName: ?*i8,
    pComment: ?*i8,
};
// --------------------------------------------------------
// Type: PRINTER_INFO_1W
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PRINTER_INFO_1W = extern struct {
    Flags: u32,
    pDescription: ?*u16,
    pName: ?*u16,
    pComment: ?*u16,
};
// --------------------------------------------------------
// Type: PRINTER_INFO_2A
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PRINTER_INFO_2A = extern struct {
    pServerName: ?*i8,
    pPrinterName: ?*i8,
    pShareName: ?*i8,
    pPortName: ?*i8,
    pDriverName: ?*i8,
    pComment: ?*i8,
    pLocation: ?*i8,
    pDevMode: ?*DEVMODEA,
    pSepFile: ?*i8,
    pPrintProcessor: ?*i8,
    pDatatype: ?*i8,
    pParameters: ?*i8,
    pSecurityDescriptor: ?*opaque{},
    Attributes: u32,
    Priority: u32,
    DefaultPriority: u32,
    StartTime: u32,
    UntilTime: u32,
    Status: u32,
    cJobs: u32,
    AveragePPM: u32,
};
// --------------------------------------------------------
// Type: PRINTER_INFO_2W
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PRINTER_INFO_2W = extern struct {
    pServerName: ?*u16,
    pPrinterName: ?*u16,
    pShareName: ?*u16,
    pPortName: ?*u16,
    pDriverName: ?*u16,
    pComment: ?*u16,
    pLocation: ?*u16,
    pDevMode: ?*DEVMODEW,
    pSepFile: ?*u16,
    pPrintProcessor: ?*u16,
    pDatatype: ?*u16,
    pParameters: ?*u16,
    pSecurityDescriptor: ?*opaque{},
    Attributes: u32,
    Priority: u32,
    DefaultPriority: u32,
    StartTime: u32,
    UntilTime: u32,
    Status: u32,
    cJobs: u32,
    AveragePPM: u32,
};
// --------------------------------------------------------
// Type: PRINTER_INFO_3
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PRINTER_INFO_3 = extern struct {
    pSecurityDescriptor: ?*opaque{},
};
// --------------------------------------------------------
// Type: PRINTER_INFO_4A
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PRINTER_INFO_4A = extern struct {
    pPrinterName: ?*i8,
    pServerName: ?*i8,
    Attributes: u32,
};
// --------------------------------------------------------
// Type: PRINTER_INFO_4W
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PRINTER_INFO_4W = extern struct {
    pPrinterName: ?*u16,
    pServerName: ?*u16,
    Attributes: u32,
};
// --------------------------------------------------------
// Type: PRINTER_INFO_5A
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PRINTER_INFO_5A = extern struct {
    pPrinterName: ?*i8,
    pPortName: ?*i8,
    Attributes: u32,
    DeviceNotSelectedTimeout: u32,
    TransmissionRetryTimeout: u32,
};
// --------------------------------------------------------
// Type: PRINTER_INFO_5W
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PRINTER_INFO_5W = extern struct {
    pPrinterName: ?*u16,
    pPortName: ?*u16,
    Attributes: u32,
    DeviceNotSelectedTimeout: u32,
    TransmissionRetryTimeout: u32,
};
// --------------------------------------------------------
// Type: PRINTER_INFO_6
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PRINTER_INFO_6 = extern struct {
    dwStatus: u32,
};
// --------------------------------------------------------
// Type: PRINTER_INFO_7A
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PRINTER_INFO_7A = extern struct {
    pszObjectGUID: ?*i8,
    dwAction: u32,
};
// --------------------------------------------------------
// Type: PRINTER_INFO_7W
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PRINTER_INFO_7W = extern struct {
    pszObjectGUID: ?*u16,
    dwAction: u32,
};
// --------------------------------------------------------
// Type: PRINTER_INFO_8A
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PRINTER_INFO_8A = extern struct {
    pDevMode: ?*DEVMODEA,
};
// --------------------------------------------------------
// Type: PRINTER_INFO_8W
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PRINTER_INFO_8W = extern struct {
    pDevMode: ?*DEVMODEW,
};
// --------------------------------------------------------
// Type: PRINTER_INFO_9A
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PRINTER_INFO_9A = extern struct {
    pDevMode: ?*DEVMODEA,
};
// --------------------------------------------------------
// Type: PRINTER_INFO_9W
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PRINTER_INFO_9W = extern struct {
    pDevMode: ?*DEVMODEW,
};
// --------------------------------------------------------
// Type: JOB_INFO_1A
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const JOB_INFO_1A = extern struct {
    JobId: u32,
    pPrinterName: ?*i8,
    pMachineName: ?*i8,
    pUserName: ?*i8,
    pDocument: ?*i8,
    pDatatype: ?*i8,
    pStatus: ?*i8,
    Status: u32,
    Priority: u32,
    Position: u32,
    TotalPages: u32,
    PagesPrinted: u32,
    Submitted: SYSTEMTIME,
};
// --------------------------------------------------------
// Type: JOB_INFO_1W
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const JOB_INFO_1W = extern struct {
    JobId: u32,
    pPrinterName: ?*u16,
    pMachineName: ?*u16,
    pUserName: ?*u16,
    pDocument: ?*u16,
    pDatatype: ?*u16,
    pStatus: ?*u16,
    Status: u32,
    Priority: u32,
    Position: u32,
    TotalPages: u32,
    PagesPrinted: u32,
    Submitted: SYSTEMTIME,
};
// --------------------------------------------------------
// Type: JOB_INFO_2A
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const JOB_INFO_2A = extern struct {
    JobId: u32,
    pPrinterName: ?*i8,
    pMachineName: ?*i8,
    pUserName: ?*i8,
    pDocument: ?*i8,
    pNotifyName: ?*i8,
    pDatatype: ?*i8,
    pPrintProcessor: ?*i8,
    pParameters: ?*i8,
    pDriverName: ?*i8,
    pDevMode: ?*DEVMODEA,
    pStatus: ?*i8,
    pSecurityDescriptor: ?*opaque{},
    Status: u32,
    Priority: u32,
    Position: u32,
    StartTime: u32,
    UntilTime: u32,
    TotalPages: u32,
    Size: u32,
    Submitted: SYSTEMTIME,
    Time: u32,
    PagesPrinted: u32,
};
// --------------------------------------------------------
// Type: JOB_INFO_2W
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const JOB_INFO_2W = extern struct {
    JobId: u32,
    pPrinterName: ?*u16,
    pMachineName: ?*u16,
    pUserName: ?*u16,
    pDocument: ?*u16,
    pNotifyName: ?*u16,
    pDatatype: ?*u16,
    pPrintProcessor: ?*u16,
    pParameters: ?*u16,
    pDriverName: ?*u16,
    pDevMode: ?*DEVMODEW,
    pStatus: ?*u16,
    pSecurityDescriptor: ?*opaque{},
    Status: u32,
    Priority: u32,
    Position: u32,
    StartTime: u32,
    UntilTime: u32,
    TotalPages: u32,
    Size: u32,
    Submitted: SYSTEMTIME,
    Time: u32,
    PagesPrinted: u32,
};
// --------------------------------------------------------
// Type: JOB_INFO_3
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const JOB_INFO_3 = extern struct {
    JobId: u32,
    NextJobId: u32,
    Reserved: u32,
};
// --------------------------------------------------------
// Type: JOB_INFO_4A
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const JOB_INFO_4A = extern struct {
    JobId: u32,
    pPrinterName: ?*i8,
    pMachineName: ?*i8,
    pUserName: ?*i8,
    pDocument: ?*i8,
    pNotifyName: ?*i8,
    pDatatype: ?*i8,
    pPrintProcessor: ?*i8,
    pParameters: ?*i8,
    pDriverName: ?*i8,
    pDevMode: ?*DEVMODEA,
    pStatus: ?*i8,
    pSecurityDescriptor: ?*opaque{},
    Status: u32,
    Priority: u32,
    Position: u32,
    StartTime: u32,
    UntilTime: u32,
    TotalPages: u32,
    Size: u32,
    Submitted: SYSTEMTIME,
    Time: u32,
    PagesPrinted: u32,
    SizeHigh: i32,
};
// --------------------------------------------------------
// Type: JOB_INFO_4W
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const JOB_INFO_4W = extern struct {
    JobId: u32,
    pPrinterName: ?*u16,
    pMachineName: ?*u16,
    pUserName: ?*u16,
    pDocument: ?*u16,
    pNotifyName: ?*u16,
    pDatatype: ?*u16,
    pPrintProcessor: ?*u16,
    pParameters: ?*u16,
    pDriverName: ?*u16,
    pDevMode: ?*DEVMODEW,
    pStatus: ?*u16,
    pSecurityDescriptor: ?*opaque{},
    Status: u32,
    Priority: u32,
    Position: u32,
    StartTime: u32,
    UntilTime: u32,
    TotalPages: u32,
    Size: u32,
    Submitted: SYSTEMTIME,
    Time: u32,
    PagesPrinted: u32,
    SizeHigh: i32,
};
// --------------------------------------------------------
// Type: ADDJOB_INFO_1A
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const ADDJOB_INFO_1A = extern struct {
    Path: ?*i8,
    JobId: u32,
};
// --------------------------------------------------------
// Type: ADDJOB_INFO_1W
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const ADDJOB_INFO_1W = extern struct {
    Path: ?*u16,
    JobId: u32,
};
// --------------------------------------------------------
// Type: DRIVER_INFO_1A
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DRIVER_INFO_1A = extern struct {
    pName: ?*i8,
};
// --------------------------------------------------------
// Type: DRIVER_INFO_1W
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DRIVER_INFO_1W = extern struct {
    pName: ?*u16,
};
// --------------------------------------------------------
// Type: DRIVER_INFO_2A
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DRIVER_INFO_2A = extern struct {
    cVersion: u32,
    pName: ?*i8,
    pEnvironment: ?*i8,
    pDriverPath: ?*i8,
    pDataFile: ?*i8,
    pConfigFile: ?*i8,
};
// --------------------------------------------------------
// Type: DRIVER_INFO_2W
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DRIVER_INFO_2W = extern struct {
    cVersion: u32,
    pName: ?*u16,
    pEnvironment: ?*u16,
    pDriverPath: ?*u16,
    pDataFile: ?*u16,
    pConfigFile: ?*u16,
};
// --------------------------------------------------------
// Type: DRIVER_INFO_3A
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DRIVER_INFO_3A = extern struct {
    cVersion: u32,
    pName: ?*i8,
    pEnvironment: ?*i8,
    pDriverPath: ?*i8,
    pDataFile: ?*i8,
    pConfigFile: ?*i8,
    pHelpFile: ?*i8,
    pDependentFiles: ?*i8,
    pMonitorName: ?*i8,
    pDefaultDataType: ?*i8,
};
// --------------------------------------------------------
// Type: DRIVER_INFO_3W
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DRIVER_INFO_3W = extern struct {
    cVersion: u32,
    pName: ?*u16,
    pEnvironment: ?*u16,
    pDriverPath: ?*u16,
    pDataFile: ?*u16,
    pConfigFile: ?*u16,
    pHelpFile: ?*u16,
    pDependentFiles: ?*u16,
    pMonitorName: ?*u16,
    pDefaultDataType: ?*u16,
};
// --------------------------------------------------------
// Type: DRIVER_INFO_4A
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DRIVER_INFO_4A = extern struct {
    cVersion: u32,
    pName: ?*i8,
    pEnvironment: ?*i8,
    pDriverPath: ?*i8,
    pDataFile: ?*i8,
    pConfigFile: ?*i8,
    pHelpFile: ?*i8,
    pDependentFiles: ?*i8,
    pMonitorName: ?*i8,
    pDefaultDataType: ?*i8,
    pszzPreviousNames: ?*i8,
};
// --------------------------------------------------------
// Type: DRIVER_INFO_4W
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DRIVER_INFO_4W = extern struct {
    cVersion: u32,
    pName: ?*u16,
    pEnvironment: ?*u16,
    pDriverPath: ?*u16,
    pDataFile: ?*u16,
    pConfigFile: ?*u16,
    pHelpFile: ?*u16,
    pDependentFiles: ?*u16,
    pMonitorName: ?*u16,
    pDefaultDataType: ?*u16,
    pszzPreviousNames: ?*u16,
};
// --------------------------------------------------------
// Type: DRIVER_INFO_5A
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DRIVER_INFO_5A = extern struct {
    cVersion: u32,
    pName: ?*i8,
    pEnvironment: ?*i8,
    pDriverPath: ?*i8,
    pDataFile: ?*i8,
    pConfigFile: ?*i8,
    dwDriverAttributes: u32,
    dwConfigVersion: u32,
    dwDriverVersion: u32,
};
// --------------------------------------------------------
// Type: DRIVER_INFO_5W
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DRIVER_INFO_5W = extern struct {
    cVersion: u32,
    pName: ?*u16,
    pEnvironment: ?*u16,
    pDriverPath: ?*u16,
    pDataFile: ?*u16,
    pConfigFile: ?*u16,
    dwDriverAttributes: u32,
    dwConfigVersion: u32,
    dwDriverVersion: u32,
};
// --------------------------------------------------------
// Type: DRIVER_INFO_6A
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DRIVER_INFO_6A = extern struct {
    cVersion: u32,
    pName: ?*i8,
    pEnvironment: ?*i8,
    pDriverPath: ?*i8,
    pDataFile: ?*i8,
    pConfigFile: ?*i8,
    pHelpFile: ?*i8,
    pDependentFiles: ?*i8,
    pMonitorName: ?*i8,
    pDefaultDataType: ?*i8,
    pszzPreviousNames: ?*i8,
    ftDriverDate: FILETIME,
    dwlDriverVersion: u64,
    pszMfgName: ?*i8,
    pszOEMUrl: ?*i8,
    pszHardwareID: ?*i8,
    pszProvider: ?*i8,
};
// --------------------------------------------------------
// Type: DRIVER_INFO_6W
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DRIVER_INFO_6W = extern struct {
    cVersion: u32,
    pName: ?*u16,
    pEnvironment: ?*u16,
    pDriverPath: ?*u16,
    pDataFile: ?*u16,
    pConfigFile: ?*u16,
    pHelpFile: ?*u16,
    pDependentFiles: ?*u16,
    pMonitorName: ?*u16,
    pDefaultDataType: ?*u16,
    pszzPreviousNames: ?*u16,
    ftDriverDate: FILETIME,
    dwlDriverVersion: u64,
    pszMfgName: ?*u16,
    pszOEMUrl: ?*u16,
    pszHardwareID: ?*u16,
    pszProvider: ?*u16,
};
// --------------------------------------------------------
// Type: DRIVER_INFO_8A
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DRIVER_INFO_8A = extern struct {
    cVersion: u32,
    pName: ?*i8,
    pEnvironment: ?*i8,
    pDriverPath: ?*i8,
    pDataFile: ?*i8,
    pConfigFile: ?*i8,
    pHelpFile: ?*i8,
    pDependentFiles: ?*i8,
    pMonitorName: ?*i8,
    pDefaultDataType: ?*i8,
    pszzPreviousNames: ?*i8,
    ftDriverDate: FILETIME,
    dwlDriverVersion: u64,
    pszMfgName: ?*i8,
    pszOEMUrl: ?*i8,
    pszHardwareID: ?*i8,
    pszProvider: ?*i8,
    pszPrintProcessor: ?*i8,
    pszVendorSetup: ?*i8,
    pszzColorProfiles: ?*i8,
    pszInfPath: ?*i8,
    dwPrinterDriverAttributes: u32,
    pszzCoreDriverDependencies: ?*i8,
    ftMinInboxDriverVerDate: FILETIME,
    dwlMinInboxDriverVerVersion: u64,
};
// --------------------------------------------------------
// Type: DRIVER_INFO_8W
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DRIVER_INFO_8W = extern struct {
    cVersion: u32,
    pName: ?*u16,
    pEnvironment: ?*u16,
    pDriverPath: ?*u16,
    pDataFile: ?*u16,
    pConfigFile: ?*u16,
    pHelpFile: ?*u16,
    pDependentFiles: ?*u16,
    pMonitorName: ?*u16,
    pDefaultDataType: ?*u16,
    pszzPreviousNames: ?*u16,
    ftDriverDate: FILETIME,
    dwlDriverVersion: u64,
    pszMfgName: ?*u16,
    pszOEMUrl: ?*u16,
    pszHardwareID: ?*u16,
    pszProvider: ?*u16,
    pszPrintProcessor: ?*u16,
    pszVendorSetup: ?*u16,
    pszzColorProfiles: ?*u16,
    pszInfPath: ?*u16,
    dwPrinterDriverAttributes: u32,
    pszzCoreDriverDependencies: ?*u16,
    ftMinInboxDriverVerDate: FILETIME,
    dwlMinInboxDriverVerVersion: u64,
};
// --------------------------------------------------------
// Type: DOC_INFO_1A
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DOC_INFO_1A = extern struct {
    pDocName: ?*i8,
    pOutputFile: ?*i8,
    pDatatype: ?*i8,
};
// --------------------------------------------------------
// Type: DOC_INFO_1W
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DOC_INFO_1W = extern struct {
    pDocName: ?*u16,
    pOutputFile: ?*u16,
    pDatatype: ?*u16,
};
// --------------------------------------------------------
// Type: FORM_INFO_1A
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const FORM_INFO_1A = extern struct {
    Flags: u32,
    pName: ?*i8,
    Size: SIZE,
    ImageableArea: RECTL,
};
// --------------------------------------------------------
// Type: FORM_INFO_1W
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const FORM_INFO_1W = extern struct {
    Flags: u32,
    pName: ?*u16,
    Size: SIZE,
    ImageableArea: RECTL,
};
// --------------------------------------------------------
// Type: FORM_INFO_2A
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const FORM_INFO_2A = extern struct {
    Flags: u32,
    pName: ?*i8,
    Size: SIZE,
    ImageableArea: RECTL,
    pKeyword: ?*i8,
    StringType: u32,
    pMuiDll: ?*i8,
    dwResourceId: u32,
    pDisplayName: ?*i8,
    wLangId: u16,
};
// --------------------------------------------------------
// Type: FORM_INFO_2W
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const FORM_INFO_2W = extern struct {
    Flags: u32,
    pName: ?*u16,
    Size: SIZE,
    ImageableArea: RECTL,
    pKeyword: ?*i8,
    StringType: u32,
    pMuiDll: ?*u16,
    dwResourceId: u32,
    pDisplayName: ?*u16,
    wLangId: u16,
};
// --------------------------------------------------------
// Type: DOC_INFO_2A
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DOC_INFO_2A = extern struct {
    pDocName: ?*i8,
    pOutputFile: ?*i8,
    pDatatype: ?*i8,
    dwMode: u32,
    JobId: u32,
};
// --------------------------------------------------------
// Type: DOC_INFO_2W
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DOC_INFO_2W = extern struct {
    pDocName: ?*u16,
    pOutputFile: ?*u16,
    pDatatype: ?*u16,
    dwMode: u32,
    JobId: u32,
};
// --------------------------------------------------------
// Type: DOC_INFO_3A
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DOC_INFO_3A = extern struct {
    pDocName: ?*i8,
    pOutputFile: ?*i8,
    pDatatype: ?*i8,
    dwFlags: u32,
};
// --------------------------------------------------------
// Type: DOC_INFO_3W
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DOC_INFO_3W = extern struct {
    pDocName: ?*u16,
    pOutputFile: ?*u16,
    pDatatype: ?*u16,
    dwFlags: u32,
};
// --------------------------------------------------------
// Type: PRINTPROCESSOR_INFO_1A
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PRINTPROCESSOR_INFO_1A = extern struct {
    pName: ?*i8,
};
// --------------------------------------------------------
// Type: PRINTPROCESSOR_INFO_1W
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PRINTPROCESSOR_INFO_1W = extern struct {
    pName: ?*u16,
};
// --------------------------------------------------------
// Type: PRINTPROCESSOR_CAPS_1
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PRINTPROCESSOR_CAPS_1 = extern struct {
    dwLevel: u32,
    dwNupOptions: u32,
    dwPageOrderFlags: u32,
    dwNumberOfCopies: u32,
};
// --------------------------------------------------------
// Type: PRINTPROCESSOR_CAPS_2
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PRINTPROCESSOR_CAPS_2 = extern struct {
    dwLevel: u32,
    dwNupOptions: u32,
    dwPageOrderFlags: u32,
    dwNumberOfCopies: u32,
    dwDuplexHandlingCaps: u32,
    dwNupDirectionCaps: u32,
    dwNupBorderCaps: u32,
    dwBookletHandlingCaps: u32,
    dwScalingCaps: u32,
};
// --------------------------------------------------------
// Type: PORT_INFO_1A
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PORT_INFO_1A = extern struct {
    pName: ?*i8,
};
// --------------------------------------------------------
// Type: PORT_INFO_1W
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PORT_INFO_1W = extern struct {
    pName: ?*u16,
};
// --------------------------------------------------------
// Type: PORT_INFO_2A
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PORT_INFO_2A = extern struct {
    pPortName: ?*i8,
    pMonitorName: ?*i8,
    pDescription: ?*i8,
    fPortType: u32,
    Reserved: u32,
};
// --------------------------------------------------------
// Type: PORT_INFO_2W
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PORT_INFO_2W = extern struct {
    pPortName: ?*u16,
    pMonitorName: ?*u16,
    pDescription: ?*u16,
    fPortType: u32,
    Reserved: u32,
};
// --------------------------------------------------------
// Type: PORT_INFO_3A
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PORT_INFO_3A = extern struct {
    dwStatus: u32,
    pszStatus: ?*i8,
    dwSeverity: u32,
};
// --------------------------------------------------------
// Type: PORT_INFO_3W
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PORT_INFO_3W = extern struct {
    dwStatus: u32,
    pszStatus: ?*u16,
    dwSeverity: u32,
};
// --------------------------------------------------------
// Type: MONITOR_INFO_1A
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const MONITOR_INFO_1A = extern struct {
    pName: ?*i8,
};
// --------------------------------------------------------
// Type: MONITOR_INFO_1W
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const MONITOR_INFO_1W = extern struct {
    pName: ?*u16,
};
// --------------------------------------------------------
// Type: MONITOR_INFO_2A
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const MONITOR_INFO_2A = extern struct {
    pName: ?*i8,
    pEnvironment: ?*i8,
    pDLLName: ?*i8,
};
// --------------------------------------------------------
// Type: MONITOR_INFO_2W
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const MONITOR_INFO_2W = extern struct {
    pName: ?*u16,
    pEnvironment: ?*u16,
    pDLLName: ?*u16,
};
// --------------------------------------------------------
// Type: DATATYPES_INFO_1A
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DATATYPES_INFO_1A = extern struct {
    pName: ?*i8,
};
// --------------------------------------------------------
// Type: DATATYPES_INFO_1W
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DATATYPES_INFO_1W = extern struct {
    pName: ?*u16,
};
// --------------------------------------------------------
// Type: PRINTER_DEFAULTSA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PRINTER_DEFAULTSA = extern struct {
    pDatatype: ?*i8,
    pDevMode: ?*DEVMODEA,
    DesiredAccess: u32,
};
// --------------------------------------------------------
// Type: PRINTER_DEFAULTSW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PRINTER_DEFAULTSW = extern struct {
    pDatatype: ?*u16,
    pDevMode: ?*DEVMODEW,
    DesiredAccess: u32,
};
// --------------------------------------------------------
// Type: PRINTER_ENUM_VALUESA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PRINTER_ENUM_VALUESA = extern struct {
    pValueName: ?*i8,
    cbValueName: u32,
    dwType: u32,
    pData: ?*u8,
    cbData: u32,
};
// --------------------------------------------------------
// Type: PRINTER_ENUM_VALUESW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PRINTER_ENUM_VALUESW = extern struct {
    pValueName: ?*u16,
    cbValueName: u32,
    dwType: u32,
    pData: ?*u8,
    cbData: u32,
};
// --------------------------------------------------------
// Type: PRINTER_NOTIFY_OPTIONS_TYPE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PRINTER_NOTIFY_OPTIONS_TYPE = extern struct {
    Type: u16,
    Reserved0: u16,
    Reserved1: u32,
    Reserved2: u32,
    Count: u32,
    pFields: ?*u16,
};
// --------------------------------------------------------
// Type: PRINTER_NOTIFY_OPTIONS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PRINTER_NOTIFY_OPTIONS = extern struct {
    Version: u32,
    Flags: u32,
    Count: u32,
    pTypes: ?*PRINTER_NOTIFY_OPTIONS_TYPE,
};
// --------------------------------------------------------
// Type: PRINTER_NOTIFY_INFO_DATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PRINTER_NOTIFY_INFO_DATA = extern struct {
    Type: u16,
    Field: u16,
    Reserved: u32,
    Id: u32,
    NotifyData: _NotifyData_e__Union,
    // --------------------------------------------------------
    // Type: _NotifyData_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _NotifyData_e__Union = *opaque{
        // --------------------------------------------------------
        // Type: _Data_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _Data_e__Struct = extern struct {
            cbBuf: u32,
            pBuf: ?*opaque{},
        };
    };
};
// --------------------------------------------------------
// Type: PRINTER_NOTIFY_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PRINTER_NOTIFY_INFO = extern struct {
    Version: u32,
    Flags: u32,
    Count: u32,
    aData: ?[*]PRINTER_NOTIFY_INFO_DATA,
};
// --------------------------------------------------------
// Type: BINARY_CONTAINER
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const BINARY_CONTAINER = extern struct {
    cbBuf: u32,
    pData: ?*u8,
};
// --------------------------------------------------------
// Type: BIDI_DATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const BIDI_DATA = extern struct {
    dwBidiType: u32,
    u: _u_e__Union,
    // --------------------------------------------------------
    // Type: _u_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _u_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: BIDI_REQUEST_DATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const BIDI_REQUEST_DATA = extern struct {
    dwReqNumber: u32,
    pSchema: ?*u16,
    data: BIDI_DATA,
};
// --------------------------------------------------------
// Type: BIDI_REQUEST_CONTAINER
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const BIDI_REQUEST_CONTAINER = extern struct {
    Version: u32,
    Flags: u32,
    Count: u32,
    aData: ?[*]BIDI_REQUEST_DATA,
};
// --------------------------------------------------------
// Type: BIDI_RESPONSE_DATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const BIDI_RESPONSE_DATA = extern struct {
    dwResult: u32,
    dwReqNumber: u32,
    pSchema: ?*u16,
    data: BIDI_DATA,
};
// --------------------------------------------------------
// Type: BIDI_RESPONSE_CONTAINER
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const BIDI_RESPONSE_CONTAINER = extern struct {
    Version: u32,
    Flags: u32,
    Count: u32,
    aData: ?[*]BIDI_RESPONSE_DATA,
};
// --------------------------------------------------------
// Type: BIDI_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const BIDI_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: PROVIDOR_INFO_1A
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PROVIDOR_INFO_1A = extern struct {
    pName: ?*i8,
    pEnvironment: ?*i8,
    pDLLName: ?*i8,
};
// --------------------------------------------------------
// Type: PROVIDOR_INFO_1W
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PROVIDOR_INFO_1W = extern struct {
    pName: ?*u16,
    pEnvironment: ?*u16,
    pDLLName: ?*u16,
};
// --------------------------------------------------------
// Type: PROVIDOR_INFO_2A
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PROVIDOR_INFO_2A = extern struct {
    pOrder: ?*i8,
};
// --------------------------------------------------------
// Type: PROVIDOR_INFO_2W
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PROVIDOR_INFO_2W = extern struct {
    pOrder: ?*u16,
};
// --------------------------------------------------------
// Type: PRINTER_OPTION_FLAGS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PRINTER_OPTION_FLAGS = *opaque{
};
// --------------------------------------------------------
// Type: PRINTER_OPTIONSA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PRINTER_OPTIONSA = extern struct {
    cbSize: u32,
    dwFlags: u32,
};
// --------------------------------------------------------
// Type: PRINTER_OPTIONSW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PRINTER_OPTIONSW = extern struct {
    cbSize: u32,
    dwFlags: u32,
};
// --------------------------------------------------------
// Type: PRINTER_CONNECTION_INFO_1A
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PRINTER_CONNECTION_INFO_1A = extern struct {
    dwFlags: u32,
    pszDriverName: ?*i8,
};
// --------------------------------------------------------
// Type: PRINTER_CONNECTION_INFO_1W
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PRINTER_CONNECTION_INFO_1W = extern struct {
    dwFlags: u32,
    pszDriverName: ?*u16,
};
// --------------------------------------------------------
// Type: CORE_PRINTER_DRIVERA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CORE_PRINTER_DRIVERA = extern struct {
    CoreDriverGUID: Guid,
    ftDriverDate: FILETIME,
    dwlDriverVersion: u64,
    szPackageID: ?[*]i8,
};
// --------------------------------------------------------
// Type: CORE_PRINTER_DRIVERW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CORE_PRINTER_DRIVERW = extern struct {
    CoreDriverGUID: Guid,
    ftDriverDate: FILETIME,
    dwlDriverVersion: u64,
    szPackageID: ?[*]u16,
};
// --------------------------------------------------------
// Type: EPrintPropertyType
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const EPrintPropertyType = *opaque{
};
// --------------------------------------------------------
// Type: EPrintXPSJobProgress
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const EPrintXPSJobProgress = *opaque{
};
// --------------------------------------------------------
// Type: EPrintXPSJobOperation
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const EPrintXPSJobOperation = *opaque{
};
// --------------------------------------------------------
// Type: PrintPropertyValue
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PrintPropertyValue = extern struct {
    ePropertyType: EPrintPropertyType,
    value: _value_e__Union,
    // --------------------------------------------------------
    // Type: _value_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _value_e__Union = *opaque{
        // --------------------------------------------------------
        // Type: _propertyBlob_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _propertyBlob_e__Struct = extern struct {
            cbBuf: u32,
            pBuf: ?*opaque{},
        };
    };
};
// --------------------------------------------------------
// Type: PrintNamedProperty
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PrintNamedProperty = extern struct {
    propertyName: ?*u16,
    propertyValue: PrintPropertyValue,
};
// --------------------------------------------------------
// Type: PrintPropertiesCollection
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PrintPropertiesCollection = extern struct {
    numberOfProperties: u32,
    propertiesCollection: ?*PrintNamedProperty,
};
// --------------------------------------------------------
// Type: PRINT_EXECUTION_CONTEXT
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PRINT_EXECUTION_CONTEXT = *opaque{
};
// --------------------------------------------------------
// Type: PRINT_EXECUTION_DATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PRINT_EXECUTION_DATA = extern struct {
    context: PRINT_EXECUTION_CONTEXT,
    clientAppPID: u32,
};
// --------------------------------------------------------
// Type: IServiceProvider
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IServiceProvider = *opaque{
    // TODO: Method 'QueryService'
};
// --------------------------------------------------------
// Type: MODEMDEVCAPS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const MODEMDEVCAPS = extern struct {
    dwActualSize: u32,
    dwRequiredSize: u32,
    dwDevSpecificOffset: u32,
    dwDevSpecificSize: u32,
    dwModemProviderVersion: u32,
    dwModemManufacturerOffset: u32,
    dwModemManufacturerSize: u32,
    dwModemModelOffset: u32,
    dwModemModelSize: u32,
    dwModemVersionOffset: u32,
    dwModemVersionSize: u32,
    dwDialOptions: u32,
    dwCallSetupFailTimer: u32,
    dwInactivityTimeout: u32,
    dwSpeakerVolume: u32,
    dwSpeakerMode: u32,
    dwModemOptions: u32,
    dwMaxDTERate: u32,
    dwMaxDCERate: u32,
    abVariablePortion: ?[*]u8,
};
// --------------------------------------------------------
// Type: MODEMSETTINGS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const MODEMSETTINGS = extern struct {
    dwActualSize: u32,
    dwRequiredSize: u32,
    dwDevSpecificOffset: u32,
    dwDevSpecificSize: u32,
    dwCallSetupFailTimer: u32,
    dwInactivityTimeout: u32,
    dwSpeakerVolume: u32,
    dwSpeakerMode: u32,
    dwPreferredModemOptions: u32,
    dwNegotiatedModemOptions: u32,
    dwNegotiatedDCERate: u32,
    abVariablePortion: ?[*]u8,
};
// --------------------------------------------------------
// Type: DISPATCHERQUEUE_THREAD_APARTMENTTYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const DISPATCHERQUEUE_THREAD_APARTMENTTYPE = *opaque{
};
// --------------------------------------------------------
// Type: DISPATCHERQUEUE_THREAD_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const DISPATCHERQUEUE_THREAD_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: DispatcherQueueOptions
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DispatcherQueueOptions = extern struct {
    dwSize: u32,
    threadType: DISPATCHERQUEUE_THREAD_TYPE,
    apartmentType: DISPATCHERQUEUE_THREAD_APARTMENTTYPE,
};
// --------------------------------------------------------
// Type: VDS_STORAGE_IDENTIFIER_CODE_SET
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const VDS_STORAGE_IDENTIFIER_CODE_SET = *opaque{
};
// --------------------------------------------------------
// Type: VDS_STORAGE_IDENTIFIER_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const VDS_STORAGE_IDENTIFIER_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: VDS_STORAGE_BUS_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const VDS_STORAGE_BUS_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: VDS_STORAGE_IDENTIFIER
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VDS_STORAGE_IDENTIFIER = extern struct {
    m_CodeSet: VDS_STORAGE_IDENTIFIER_CODE_SET,
    m_Type: VDS_STORAGE_IDENTIFIER_TYPE,
    m_cbIdentifier: u32,
    m_rgbIdentifier: ?*u8,
};
// --------------------------------------------------------
// Type: VDS_STORAGE_DEVICE_ID_DESCRIPTOR
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VDS_STORAGE_DEVICE_ID_DESCRIPTOR = extern struct {
    m_version: u32,
    m_cIdentifiers: u32,
    m_rgIdentifiers: ?*VDS_STORAGE_IDENTIFIER,
};
// --------------------------------------------------------
// Type: VDS_INTERCONNECT_ADDRESS_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const VDS_INTERCONNECT_ADDRESS_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: VDS_INTERCONNECT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VDS_INTERCONNECT = extern struct {
    m_addressType: VDS_INTERCONNECT_ADDRESS_TYPE,
    m_cbPort: u32,
    m_pbPort: ?*u8,
    m_cbAddress: u32,
    m_pbAddress: ?*u8,
};
// --------------------------------------------------------
// Type: VDS_LUN_INFORMATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VDS_LUN_INFORMATION = extern struct {
    m_version: u32,
    m_DeviceType: u8,
    m_DeviceTypeModifier: u8,
    m_bCommandQueueing: BOOL,
    m_BusType: VDS_STORAGE_BUS_TYPE,
    m_szVendorId: ?*i8,
    m_szProductId: ?*i8,
    m_szProductRevision: ?*i8,
    m_szSerialNumber: ?*i8,
    m_diskSignature: Guid,
    m_deviceIdDescriptor: VDS_STORAGE_DEVICE_ID_DESCRIPTOR,
    m_cInterconnects: u32,
    m_rgInterconnects: ?*VDS_INTERCONNECT,
};
// --------------------------------------------------------
// Type: VDS_OBJECT_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const VDS_OBJECT_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: VDS_PROVIDER_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const VDS_PROVIDER_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: VDS_PROVIDER_FLAG
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const VDS_PROVIDER_FLAG = *opaque{
};
// --------------------------------------------------------
// Type: VDS_RECOVER_ACTION
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const VDS_RECOVER_ACTION = *opaque{
};
// --------------------------------------------------------
// Type: VDS_NOTIFICATION_TARGET_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const VDS_NOTIFICATION_TARGET_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: VDS_PACK_NOTIFICATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VDS_PACK_NOTIFICATION = extern struct {
    ulEvent: u32,
    packId: Guid,
};
// --------------------------------------------------------
// Type: VDS_DISK_NOTIFICATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VDS_DISK_NOTIFICATION = extern struct {
    ulEvent: u32,
    diskId: Guid,
};
// --------------------------------------------------------
// Type: VDS_VOLUME_NOTIFICATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VDS_VOLUME_NOTIFICATION = extern struct {
    ulEvent: u32,
    volumeId: Guid,
    plexId: Guid,
    ulPercentCompleted: u32,
};
// --------------------------------------------------------
// Type: VDS_PARTITION_NOTIFICATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VDS_PARTITION_NOTIFICATION = extern struct {
    ulEvent: u32,
    diskId: Guid,
    ullOffset: u64,
};
// --------------------------------------------------------
// Type: VDS_SERVICE_NOTIFICATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VDS_SERVICE_NOTIFICATION = extern struct {
    ulEvent: u32,
    action: VDS_RECOVER_ACTION,
};
// --------------------------------------------------------
// Type: VDS_DRIVE_LETTER_NOTIFICATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VDS_DRIVE_LETTER_NOTIFICATION = extern struct {
    ulEvent: u32,
    wcLetter: u16,
    volumeId: Guid,
};
// --------------------------------------------------------
// Type: VDS_FILE_SYSTEM_NOTIFICATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VDS_FILE_SYSTEM_NOTIFICATION = extern struct {
    ulEvent: u32,
    volumeId: Guid,
    dwPercentCompleted: u32,
};
// --------------------------------------------------------
// Type: VDS_MOUNT_POINT_NOTIFICATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VDS_MOUNT_POINT_NOTIFICATION = extern struct {
    ulEvent: u32,
    volumeId: Guid,
};
// --------------------------------------------------------
// Type: VDS_SUB_SYSTEM_NOTIFICATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VDS_SUB_SYSTEM_NOTIFICATION = extern struct {
    ulEvent: u32,
    subSystemId: Guid,
};
// --------------------------------------------------------
// Type: VDS_CONTROLLER_NOTIFICATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VDS_CONTROLLER_NOTIFICATION = extern struct {
    ulEvent: u32,
    controllerId: Guid,
};
// --------------------------------------------------------
// Type: VDS_DRIVE_NOTIFICATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VDS_DRIVE_NOTIFICATION = extern struct {
    ulEvent: u32,
    driveId: Guid,
};
// --------------------------------------------------------
// Type: VDS_LUN_NOTIFICATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VDS_LUN_NOTIFICATION = extern struct {
    ulEvent: u32,
    LunId: Guid,
};
// --------------------------------------------------------
// Type: VDS_PORT_NOTIFICATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VDS_PORT_NOTIFICATION = extern struct {
    ulEvent: u32,
    portId: Guid,
};
// --------------------------------------------------------
// Type: VDS_PORTAL_NOTIFICATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VDS_PORTAL_NOTIFICATION = extern struct {
    ulEvent: u32,
    portalId: Guid,
};
// --------------------------------------------------------
// Type: VDS_TARGET_NOTIFICATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VDS_TARGET_NOTIFICATION = extern struct {
    ulEvent: u32,
    targetId: Guid,
};
// --------------------------------------------------------
// Type: VDS_PORTAL_GROUP_NOTIFICATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VDS_PORTAL_GROUP_NOTIFICATION = extern struct {
    ulEvent: u32,
    portalGroupId: Guid,
};
// --------------------------------------------------------
// Type: VDS_NOTIFICATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VDS_NOTIFICATION = extern struct {
    objectType: VDS_NOTIFICATION_TARGET_TYPE,
    Anonymous: _Anonymous_e__Union,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: VDS_ASYNC_OUTPUT_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const VDS_ASYNC_OUTPUT_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: VDS_ASYNC_OUTPUT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VDS_ASYNC_OUTPUT = extern struct {
    type: VDS_ASYNC_OUTPUT_TYPE,
    Anonymous: _Anonymous_e__Union,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
        // --------------------------------------------------------
        // Type: _cpg
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _cpg = extern struct {
            pPortalGroupUnk: IUnknown,
        };
        // --------------------------------------------------------
        // Type: _cl
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _cl = extern struct {
            pLunUnk: IUnknown,
        };
        // --------------------------------------------------------
        // Type: _bvp
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _bvp = extern struct {
            pVolumeUnk: IUnknown,
        };
        // --------------------------------------------------------
        // Type: _cp
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _cp = extern struct {
            ullOffset: u64,
            volumeId: Guid,
        };
        // --------------------------------------------------------
        // Type: _ct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _ct = extern struct {
            pTargetUnk: IUnknown,
        };
        // --------------------------------------------------------
        // Type: _cv
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _cv = extern struct {
            pVolumeUnk: IUnknown,
        };
        // --------------------------------------------------------
        // Type: _cvd
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _cvd = extern struct {
            pVDiskUnk: IUnknown,
        };
        // --------------------------------------------------------
        // Type: _sv
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _sv = extern struct {
            ullReclaimedBytes: u64,
        };
    };
};
// --------------------------------------------------------
// Type: VDS_IPADDRESS_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const VDS_IPADDRESS_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: VDS_HEALTH
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const VDS_HEALTH = *opaque{
};
// --------------------------------------------------------
// Type: VDS_TRANSITION_STATE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const VDS_TRANSITION_STATE = *opaque{
};
// --------------------------------------------------------
// Type: VDS_FILE_SYSTEM_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const VDS_FILE_SYSTEM_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: VDS_HBAPORT_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const VDS_HBAPORT_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: VDS_HBAPORT_STATUS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const VDS_HBAPORT_STATUS = *opaque{
};
// --------------------------------------------------------
// Type: VDS_HBAPORT_SPEED_FLAG
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const VDS_HBAPORT_SPEED_FLAG = *opaque{
};
// --------------------------------------------------------
// Type: VDS_PATH_STATUS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const VDS_PATH_STATUS = *opaque{
};
// --------------------------------------------------------
// Type: VDS_LOADBALANCE_POLICY_ENUM
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const VDS_LOADBALANCE_POLICY_ENUM = *opaque{
};
// --------------------------------------------------------
// Type: VDS_PROVIDER_LBSUPPORT_FLAG
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const VDS_PROVIDER_LBSUPPORT_FLAG = *opaque{
};
// --------------------------------------------------------
// Type: VDS_VERSION_SUPPORT_FLAG
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const VDS_VERSION_SUPPORT_FLAG = *opaque{
};
// --------------------------------------------------------
// Type: VDS_HWPROVIDER_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const VDS_HWPROVIDER_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: VDS_ISCSI_LOGIN_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const VDS_ISCSI_LOGIN_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: VDS_ISCSI_AUTH_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const VDS_ISCSI_AUTH_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: VDS_ISCSI_IPSEC_FLAG
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const VDS_ISCSI_IPSEC_FLAG = *opaque{
};
// --------------------------------------------------------
// Type: VDS_ISCSI_LOGIN_FLAG
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const VDS_ISCSI_LOGIN_FLAG = *opaque{
};
// --------------------------------------------------------
// Type: VDS_PATH_ID
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VDS_PATH_ID = extern struct {
    ullSourceId: u64,
    ullPathId: u64,
};
// --------------------------------------------------------
// Type: VDS_WWN
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VDS_WWN = extern struct {
    rguchWwn: ?[*]u8,
};
// --------------------------------------------------------
// Type: VDS_IPADDRESS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VDS_IPADDRESS = extern struct {
    type: VDS_IPADDRESS_TYPE,
    ipv4Address: u32,
    ipv6Address: ?[*]u8,
    ulIpv6FlowInfo: u32,
    ulIpv6ScopeId: u32,
    wszTextAddress: ?[*]u16,
    ulPort: u32,
};
// --------------------------------------------------------
// Type: VDS_ISCSI_IPSEC_KEY
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VDS_ISCSI_IPSEC_KEY = extern struct {
    pKey: ?*u8,
    ulKeySize: u32,
};
// --------------------------------------------------------
// Type: VDS_ISCSI_SHARED_SECRET
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VDS_ISCSI_SHARED_SECRET = extern struct {
    pSharedSecret: ?*u8,
    ulSharedSecretSize: u32,
};
// --------------------------------------------------------
// Type: VDS_HBAPORT_PROP
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VDS_HBAPORT_PROP = extern struct {
    id: Guid,
    wwnNode: VDS_WWN,
    wwnPort: VDS_WWN,
    type: VDS_HBAPORT_TYPE,
    status: VDS_HBAPORT_STATUS,
    ulPortSpeed: u32,
    ulSupportedPortSpeed: u32,
};
// --------------------------------------------------------
// Type: VDS_ISCSI_INITIATOR_ADAPTER_PROP
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VDS_ISCSI_INITIATOR_ADAPTER_PROP = extern struct {
    id: Guid,
    pwszName: ?*u16,
};
// --------------------------------------------------------
// Type: VDS_ISCSI_INITIATOR_PORTAL_PROP
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VDS_ISCSI_INITIATOR_PORTAL_PROP = extern struct {
    id: Guid,
    address: VDS_IPADDRESS,
    ulPortIndex: u32,
};
// --------------------------------------------------------
// Type: VDS_PROVIDER_PROP
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VDS_PROVIDER_PROP = extern struct {
    id: Guid,
    pwszName: ?*u16,
    guidVersionId: Guid,
    pwszVersion: ?*u16,
    type: VDS_PROVIDER_TYPE,
    ulFlags: u32,
    ulStripeSizeFlags: u32,
    sRebuildPriority: i16,
};
// --------------------------------------------------------
// Type: VDS_PATH_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VDS_PATH_INFO = extern struct {
    pathId: VDS_PATH_ID,
    type: VDS_HWPROVIDER_TYPE,
    status: VDS_PATH_STATUS,
    Anonymous1: _Anonymous1_e__Union,
    Anonymous2: _Anonymous2_e__Union,
    Anonymous3: _Anonymous3_e__Union,
    // --------------------------------------------------------
    // Type: _Anonymous2_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous2_e__Union = *opaque{
    };
    // --------------------------------------------------------
    // Type: _Anonymous1_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous1_e__Union = *opaque{
    };
    // --------------------------------------------------------
    // Type: _Anonymous3_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous3_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: VDS_PATH_POLICY
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VDS_PATH_POLICY = extern struct {
    pathId: VDS_PATH_ID,
    bPrimaryPath: BOOL,
    ulWeight: u32,
};
// --------------------------------------------------------
// Type: IEnumVdsObject
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IEnumVdsObject = *opaque{
    // TODO: Method 'Next'
    // TODO: Method 'Skip'
    // TODO: Method 'Reset'
    // TODO: Method 'Clone'
};
// --------------------------------------------------------
// Type: IVdsAsync
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IVdsAsync = *opaque{
    // TODO: Method 'Cancel'
    // TODO: Method 'Wait'
    // TODO: Method 'QueryStatus'
};
// --------------------------------------------------------
// Type: IVdsAdviseSink
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IVdsAdviseSink = *opaque{
    // TODO: Method 'OnNotify'
};
// --------------------------------------------------------
// Type: IVdsProvider
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IVdsProvider = *opaque{
    // TODO: Method 'GetProperties'
};
// --------------------------------------------------------
// Type: IVdsProviderSupport
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IVdsProviderSupport = *opaque{
    // TODO: Method 'GetVersionSupport'
};
// --------------------------------------------------------
// Type: IVdsProviderPrivate
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IVdsProviderPrivate = *opaque{
    // TODO: Method 'GetObjectA'
    // TODO: Method 'OnLoad'
    // TODO: Method 'OnUnload'
};
// --------------------------------------------------------
// Type: VDS_SUB_SYSTEM_STATUS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const VDS_SUB_SYSTEM_STATUS = *opaque{
};
// --------------------------------------------------------
// Type: VDS_SUB_SYSTEM_FLAG
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const VDS_SUB_SYSTEM_FLAG = *opaque{
};
// --------------------------------------------------------
// Type: VDS_SUB_SYSTEM_SUPPORTED_RAID_TYPE_FLAG
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const VDS_SUB_SYSTEM_SUPPORTED_RAID_TYPE_FLAG = *opaque{
};
// --------------------------------------------------------
// Type: VDS_INTERCONNECT_FLAG
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const VDS_INTERCONNECT_FLAG = *opaque{
};
// --------------------------------------------------------
// Type: VDS_CONTROLLER_STATUS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const VDS_CONTROLLER_STATUS = *opaque{
};
// --------------------------------------------------------
// Type: VDS_PORT_STATUS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const VDS_PORT_STATUS = *opaque{
};
// --------------------------------------------------------
// Type: VDS_DRIVE_STATUS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const VDS_DRIVE_STATUS = *opaque{
};
// --------------------------------------------------------
// Type: VDS_DRIVE_FLAG
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const VDS_DRIVE_FLAG = *opaque{
};
// --------------------------------------------------------
// Type: VDS_LUN_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const VDS_LUN_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: VDS_LUN_STATUS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const VDS_LUN_STATUS = *opaque{
};
// --------------------------------------------------------
// Type: VDS_LUN_FLAG
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const VDS_LUN_FLAG = *opaque{
};
// --------------------------------------------------------
// Type: VDS_LUN_PLEX_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const VDS_LUN_PLEX_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: VDS_LUN_PLEX_STATUS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const VDS_LUN_PLEX_STATUS = *opaque{
};
// --------------------------------------------------------
// Type: VDS_LUN_PLEX_FLAG
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const VDS_LUN_PLEX_FLAG = *opaque{
};
// --------------------------------------------------------
// Type: VDS_ISCSI_PORTAL_STATUS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const VDS_ISCSI_PORTAL_STATUS = *opaque{
};
// --------------------------------------------------------
// Type: VDS_STORAGE_POOL_STATUS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const VDS_STORAGE_POOL_STATUS = *opaque{
};
// --------------------------------------------------------
// Type: VDS_STORAGE_POOL_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const VDS_STORAGE_POOL_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: VDS_MAINTENANCE_OPERATION
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const VDS_MAINTENANCE_OPERATION = *opaque{
};
// --------------------------------------------------------
// Type: VDS_HINTS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VDS_HINTS = extern struct {
    ullHintMask: u64,
    ullExpectedMaximumSize: u64,
    ulOptimalReadSize: u32,
    ulOptimalReadAlignment: u32,
    ulOptimalWriteSize: u32,
    ulOptimalWriteAlignment: u32,
    ulMaximumDriveCount: u32,
    ulStripeSize: u32,
    bFastCrashRecoveryRequired: BOOL,
    bMostlyReads: BOOL,
    bOptimizeForSequentialReads: BOOL,
    bOptimizeForSequentialWrites: BOOL,
    bRemapEnabled: BOOL,
    bReadBackVerifyEnabled: BOOL,
    bWriteThroughCachingEnabled: BOOL,
    bHardwareChecksumEnabled: BOOL,
    bIsYankable: BOOL,
    sRebuildPriority: i16,
};
// --------------------------------------------------------
// Type: VDS_HINTS2
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VDS_HINTS2 = extern struct {
    ullHintMask: u64,
    ullExpectedMaximumSize: u64,
    ulOptimalReadSize: u32,
    ulOptimalReadAlignment: u32,
    ulOptimalWriteSize: u32,
    ulOptimalWriteAlignment: u32,
    ulMaximumDriveCount: u32,
    ulStripeSize: u32,
    ulReserved1: u32,
    ulReserved2: u32,
    ulReserved3: u32,
    bFastCrashRecoveryRequired: BOOL,
    bMostlyReads: BOOL,
    bOptimizeForSequentialReads: BOOL,
    bOptimizeForSequentialWrites: BOOL,
    bRemapEnabled: BOOL,
    bReadBackVerifyEnabled: BOOL,
    bWriteThroughCachingEnabled: BOOL,
    bHardwareChecksumEnabled: BOOL,
    bIsYankable: BOOL,
    bAllocateHotSpare: BOOL,
    bUseMirroredCache: BOOL,
    bReadCachingEnabled: BOOL,
    bWriteCachingEnabled: BOOL,
    bMediaScanEnabled: BOOL,
    bConsistencyCheckEnabled: BOOL,
    BusType: VDS_STORAGE_BUS_TYPE,
    bReserved1: BOOL,
    bReserved2: BOOL,
    bReserved3: BOOL,
    sRebuildPriority: i16,
};
// --------------------------------------------------------
// Type: VDS_SUB_SYSTEM_PROP
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VDS_SUB_SYSTEM_PROP = extern struct {
    id: Guid,
    pwszFriendlyName: ?*u16,
    pwszIdentification: ?*u16,
    ulFlags: u32,
    ulStripeSizeFlags: u32,
    status: VDS_SUB_SYSTEM_STATUS,
    health: VDS_HEALTH,
    sNumberOfInternalBuses: i16,
    sMaxNumberOfSlotsEachBus: i16,
    sMaxNumberOfControllers: i16,
    sRebuildPriority: i16,
};
// --------------------------------------------------------
// Type: VDS_SUB_SYSTEM_PROP2
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VDS_SUB_SYSTEM_PROP2 = extern struct {
    id: Guid,
    pwszFriendlyName: ?*u16,
    pwszIdentification: ?*u16,
    ulFlags: u32,
    ulStripeSizeFlags: u32,
    ulSupportedRaidTypeFlags: u32,
    status: VDS_SUB_SYSTEM_STATUS,
    health: VDS_HEALTH,
    sNumberOfInternalBuses: i16,
    sMaxNumberOfSlotsEachBus: i16,
    sMaxNumberOfControllers: i16,
    sRebuildPriority: i16,
    ulNumberOfEnclosures: u32,
};
// --------------------------------------------------------
// Type: VDS_CONTROLLER_PROP
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VDS_CONTROLLER_PROP = extern struct {
    id: Guid,
    pwszFriendlyName: ?*u16,
    pwszIdentification: ?*u16,
    status: VDS_CONTROLLER_STATUS,
    health: VDS_HEALTH,
    sNumberOfPorts: i16,
};
// --------------------------------------------------------
// Type: VDS_DRIVE_PROP
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VDS_DRIVE_PROP = extern struct {
    id: Guid,
    ullSize: u64,
    pwszFriendlyName: ?*u16,
    pwszIdentification: ?*u16,
    ulFlags: u32,
    status: VDS_DRIVE_STATUS,
    health: VDS_HEALTH,
    sInternalBusNumber: i16,
    sSlotNumber: i16,
};
// --------------------------------------------------------
// Type: VDS_DRIVE_PROP2
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VDS_DRIVE_PROP2 = extern struct {
    id: Guid,
    ullSize: u64,
    pwszFriendlyName: ?*u16,
    pwszIdentification: ?*u16,
    ulFlags: u32,
    status: VDS_DRIVE_STATUS,
    health: VDS_HEALTH,
    sInternalBusNumber: i16,
    sSlotNumber: i16,
    ulEnclosureNumber: u32,
    busType: VDS_STORAGE_BUS_TYPE,
    ulSpindleSpeed: u32,
};
// --------------------------------------------------------
// Type: VDS_DRIVE_EXTENT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VDS_DRIVE_EXTENT = extern struct {
    id: Guid,
    LunId: Guid,
    ullSize: u64,
    bUsed: BOOL,
};
// --------------------------------------------------------
// Type: VDS_LUN_PROP
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VDS_LUN_PROP = extern struct {
    id: Guid,
    ullSize: u64,
    pwszFriendlyName: ?*u16,
    pwszIdentification: ?*u16,
    pwszUnmaskingList: ?*u16,
    ulFlags: u32,
    type: VDS_LUN_TYPE,
    status: VDS_LUN_STATUS,
    health: VDS_HEALTH,
    TransitionState: VDS_TRANSITION_STATE,
    sRebuildPriority: i16,
};
// --------------------------------------------------------
// Type: VDS_LUN_PLEX_PROP
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VDS_LUN_PLEX_PROP = extern struct {
    id: Guid,
    ullSize: u64,
    type: VDS_LUN_PLEX_TYPE,
    status: VDS_LUN_PLEX_STATUS,
    health: VDS_HEALTH,
    TransitionState: VDS_TRANSITION_STATE,
    ulFlags: u32,
    ulStripeSize: u32,
    sRebuildPriority: i16,
};
// --------------------------------------------------------
// Type: VDS_PORT_PROP
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VDS_PORT_PROP = extern struct {
    id: Guid,
    pwszFriendlyName: ?*u16,
    pwszIdentification: ?*u16,
    status: VDS_PORT_STATUS,
};
// --------------------------------------------------------
// Type: VDS_ISCSI_PORTAL_PROP
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VDS_ISCSI_PORTAL_PROP = extern struct {
    id: Guid,
    address: VDS_IPADDRESS,
    status: VDS_ISCSI_PORTAL_STATUS,
};
// --------------------------------------------------------
// Type: VDS_ISCSI_TARGET_PROP
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VDS_ISCSI_TARGET_PROP = extern struct {
    id: Guid,
    pwszIscsiName: ?*u16,
    pwszFriendlyName: ?*u16,
    bChapEnabled: BOOL,
};
// --------------------------------------------------------
// Type: VDS_ISCSI_PORTALGROUP_PROP
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VDS_ISCSI_PORTALGROUP_PROP = extern struct {
    id: Guid,
    tag: u16,
};
// --------------------------------------------------------
// Type: VDS_RAID_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const VDS_RAID_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: VDS_POOL_CUSTOM_ATTRIBUTES
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VDS_POOL_CUSTOM_ATTRIBUTES = extern struct {
    pwszName: ?*u16,
    pwszValue: ?*u16,
};
// --------------------------------------------------------
// Type: VDS_POOL_ATTRIBUTES
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VDS_POOL_ATTRIBUTES = extern struct {
    ullAttributeMask: u64,
    raidType: VDS_RAID_TYPE,
    busType: VDS_STORAGE_BUS_TYPE,
    pwszIntendedUsage: ?*u16,
    bSpinDown: BOOL,
    bIsThinProvisioned: BOOL,
    ullProvisionedSpace: u64,
    bNoSinglePointOfFailure: BOOL,
    ulDataRedundancyMax: u32,
    ulDataRedundancyMin: u32,
    ulDataRedundancyDefault: u32,
    ulPackageRedundancyMax: u32,
    ulPackageRedundancyMin: u32,
    ulPackageRedundancyDefault: u32,
    ulStripeSize: u32,
    ulStripeSizeMax: u32,
    ulStripeSizeMin: u32,
    ulDefaultStripeSize: u32,
    ulNumberOfColumns: u32,
    ulNumberOfColumnsMax: u32,
    ulNumberOfColumnsMin: u32,
    ulDefaultNumberofColumns: u32,
    ulDataAvailabilityHint: u32,
    ulAccessRandomnessHint: u32,
    ulAccessDirectionHint: u32,
    ulAccessSizeHint: u32,
    ulAccessLatencyHint: u32,
    ulAccessBandwidthWeightHint: u32,
    ulStorageCostHint: u32,
    ulStorageEfficiencyHint: u32,
    ulNumOfCustomAttributes: u32,
    pPoolCustomAttributes: ?*VDS_POOL_CUSTOM_ATTRIBUTES,
    bReserved1: BOOL,
    bReserved2: BOOL,
    ulReserved1: u32,
    ulReserved2: u32,
    ullReserved1: u64,
    ullReserved2: u64,
};
// --------------------------------------------------------
// Type: VDS_STORAGE_POOL_PROP
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VDS_STORAGE_POOL_PROP = extern struct {
    id: Guid,
    status: VDS_STORAGE_POOL_STATUS,
    health: VDS_HEALTH,
    type: VDS_STORAGE_POOL_TYPE,
    pwszName: ?*u16,
    pwszDescription: ?*u16,
    ullTotalConsumedSpace: u64,
    ullTotalManagedSpace: u64,
    ullRemainingFreeSpace: u64,
};
// --------------------------------------------------------
// Type: VDS_STORAGE_POOL_DRIVE_EXTENT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VDS_STORAGE_POOL_DRIVE_EXTENT = extern struct {
    id: Guid,
    ullSize: u64,
    bUsed: BOOL,
};
// --------------------------------------------------------
// Type: IVdsHwProvider
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IVdsHwProvider = *opaque{
    // TODO: Method 'QuerySubSystems'
    // TODO: Method 'Reenumerate'
    // TODO: Method 'Refresh'
};
// --------------------------------------------------------
// Type: IVdsHwProviderType
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IVdsHwProviderType = *opaque{
    // TODO: Method 'GetProviderType'
};
// --------------------------------------------------------
// Type: IVdsHwProviderType2
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IVdsHwProviderType2 = *opaque{
    // TODO: Method 'GetProviderType2'
};
// --------------------------------------------------------
// Type: IVdsHwProviderStoragePools
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IVdsHwProviderStoragePools = *opaque{
    // TODO: Method 'QueryStoragePools'
    // TODO: Method 'CreateLunInStoragePool'
    // TODO: Method 'QueryMaxLunCreateSizeInStoragePool'
};
// --------------------------------------------------------
// Type: IVdsSubSystem
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IVdsSubSystem = *opaque{
    // TODO: Method 'GetProperties'
    // TODO: Method 'GetProvider'
    // TODO: Method 'QueryControllers'
    // TODO: Method 'QueryLuns'
    // TODO: Method 'QueryDrives'
    // TODO: Method 'GetDrive'
    // TODO: Method 'Reenumerate'
    // TODO: Method 'SetControllerStatus'
    // TODO: Method 'CreateLun'
    // TODO: Method 'ReplaceDrive'
    // TODO: Method 'SetStatus'
    // TODO: Method 'QueryMaxLunCreateSize'
};
// --------------------------------------------------------
// Type: IVdsSubSystem2
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IVdsSubSystem2 = *opaque{
    // TODO: Method 'GetProperties2'
    // TODO: Method 'GetDrive2'
    // TODO: Method 'CreateLun2'
    // TODO: Method 'QueryMaxLunCreateSize2'
};
// --------------------------------------------------------
// Type: IVdsSubSystemNaming
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IVdsSubSystemNaming = *opaque{
    // TODO: Method 'SetFriendlyName'
};
// --------------------------------------------------------
// Type: IVdsSubSystemIscsi
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IVdsSubSystemIscsi = *opaque{
    // TODO: Method 'QueryTargets'
    // TODO: Method 'QueryPortals'
    // TODO: Method 'CreateTarget'
    // TODO: Method 'SetIpsecGroupPresharedKey'
};
// --------------------------------------------------------
// Type: IVdsSubSystemInterconnect
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IVdsSubSystemInterconnect = *opaque{
    // TODO: Method 'GetSupportedInterconnects'
};
// --------------------------------------------------------
// Type: IVdsControllerPort
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IVdsControllerPort = *opaque{
    // TODO: Method 'GetProperties'
    // TODO: Method 'GetController'
    // TODO: Method 'QueryAssociatedLuns'
    // TODO: Method 'Reset'
    // TODO: Method 'SetStatus'
};
// --------------------------------------------------------
// Type: IVdsController
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IVdsController = *opaque{
    // TODO: Method 'GetProperties'
    // TODO: Method 'GetSubSystem'
    // TODO: Method 'GetPortProperties'
    // TODO: Method 'FlushCache'
    // TODO: Method 'InvalidateCache'
    // TODO: Method 'Reset'
    // TODO: Method 'QueryAssociatedLuns'
    // TODO: Method 'SetStatus'
};
// --------------------------------------------------------
// Type: IVdsControllerControllerPort
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IVdsControllerControllerPort = *opaque{
    // TODO: Method 'QueryControllerPorts'
};
// --------------------------------------------------------
// Type: IVdsDrive
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IVdsDrive = *opaque{
    // TODO: Method 'GetProperties'
    // TODO: Method 'GetSubSystem'
    // TODO: Method 'QueryExtents'
    // TODO: Method 'SetFlags'
    // TODO: Method 'ClearFlags'
    // TODO: Method 'SetStatus'
};
// --------------------------------------------------------
// Type: IVdsDrive2
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IVdsDrive2 = *opaque{
    // TODO: Method 'GetProperties2'
};
// --------------------------------------------------------
// Type: IVdsLun
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IVdsLun = *opaque{
    // TODO: Method 'GetProperties'
    // TODO: Method 'GetSubSystem'
    // TODO: Method 'GetIdentificationData'
    // TODO: Method 'QueryActiveControllers'
    // TODO: Method 'Extend'
    // TODO: Method 'Shrink'
    // TODO: Method 'QueryPlexes'
    // TODO: Method 'AddPlex'
    // TODO: Method 'RemovePlex'
    // TODO: Method 'Recover'
    // TODO: Method 'SetMask'
    // TODO: Method 'Delete'
    // TODO: Method 'AssociateControllers'
    // TODO: Method 'QueryHints'
    // TODO: Method 'ApplyHints'
    // TODO: Method 'SetStatus'
    // TODO: Method 'QueryMaxLunExtendSize'
};
// --------------------------------------------------------
// Type: IVdsLun2
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IVdsLun2 = *opaque{
    // TODO: Method 'QueryHints2'
    // TODO: Method 'ApplyHints2'
};
// --------------------------------------------------------
// Type: IVdsLunNaming
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IVdsLunNaming = *opaque{
    // TODO: Method 'SetFriendlyName'
};
// --------------------------------------------------------
// Type: IVdsLunNumber
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IVdsLunNumber = *opaque{
    // TODO: Method 'GetLunNumber'
};
// --------------------------------------------------------
// Type: IVdsLunControllerPorts
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IVdsLunControllerPorts = *opaque{
    // TODO: Method 'AssociateControllerPorts'
    // TODO: Method 'QueryActiveControllerPorts'
};
// --------------------------------------------------------
// Type: IVdsLunMpio
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IVdsLunMpio = *opaque{
    // TODO: Method 'GetPathInfo'
    // TODO: Method 'GetLoadBalancePolicy'
    // TODO: Method 'SetLoadBalancePolicy'
    // TODO: Method 'GetSupportedLbPolicies'
};
// --------------------------------------------------------
// Type: IVdsLunIscsi
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IVdsLunIscsi = *opaque{
    // TODO: Method 'AssociateTargets'
    // TODO: Method 'QueryAssociatedTargets'
};
// --------------------------------------------------------
// Type: IVdsLunPlex
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IVdsLunPlex = *opaque{
    // TODO: Method 'GetProperties'
    // TODO: Method 'GetLun'
    // TODO: Method 'QueryExtents'
    // TODO: Method 'QueryHints'
    // TODO: Method 'ApplyHints'
};
// --------------------------------------------------------
// Type: IVdsIscsiPortal
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IVdsIscsiPortal = *opaque{
    // TODO: Method 'GetProperties'
    // TODO: Method 'GetSubSystem'
    // TODO: Method 'QueryAssociatedPortalGroups'
    // TODO: Method 'SetStatus'
    // TODO: Method 'SetIpsecTunnelAddress'
    // TODO: Method 'GetIpsecSecurity'
    // TODO: Method 'SetIpsecSecurity'
};
// --------------------------------------------------------
// Type: IVdsIscsiTarget
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IVdsIscsiTarget = *opaque{
    // TODO: Method 'GetProperties'
    // TODO: Method 'GetSubSystem'
    // TODO: Method 'QueryPortalGroups'
    // TODO: Method 'QueryAssociatedLuns'
    // TODO: Method 'CreatePortalGroup'
    // TODO: Method 'Delete'
    // TODO: Method 'SetFriendlyName'
    // TODO: Method 'SetSharedSecret'
    // TODO: Method 'RememberInitiatorSharedSecret'
    // TODO: Method 'GetConnectedInitiators'
};
// --------------------------------------------------------
// Type: IVdsIscsiPortalGroup
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IVdsIscsiPortalGroup = *opaque{
    // TODO: Method 'GetProperties'
    // TODO: Method 'GetTarget'
    // TODO: Method 'QueryAssociatedPortals'
    // TODO: Method 'AddPortal'
    // TODO: Method 'RemovePortal'
    // TODO: Method 'Delete'
};
// --------------------------------------------------------
// Type: IVdsStoragePool
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IVdsStoragePool = *opaque{
    // TODO: Method 'GetProvider'
    // TODO: Method 'GetProperties'
    // TODO: Method 'GetAttributes'
    // TODO: Method 'QueryDriveExtents'
    // TODO: Method 'QueryAllocatedLuns'
    // TODO: Method 'QueryAllocatedStoragePools'
};
// --------------------------------------------------------
// Type: IVdsMaintenance
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IVdsMaintenance = *opaque{
    // TODO: Method 'StartMaintenance'
    // TODO: Method 'StopMaintenance'
    // TODO: Method 'PulseMaintenance'
};
// --------------------------------------------------------
// Type: IVdsHwProviderPrivate
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IVdsHwProviderPrivate = *opaque{
    // TODO: Method 'QueryIfCreatedLun'
};
// --------------------------------------------------------
// Type: IVdsHwProviderPrivateMpio
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IVdsHwProviderPrivateMpio = *opaque{
    // TODO: Method 'SetAllPathStatusesFromHbaPort'
};
// --------------------------------------------------------
// Type: IVdsAdmin
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IVdsAdmin = *opaque{
    // TODO: Method 'RegisterProvider'
    // TODO: Method 'UnregisterProvider'
};
// --------------------------------------------------------
// Type: VSS_OBJECT_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const VSS_OBJECT_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: VSS_SNAPSHOT_STATE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const VSS_SNAPSHOT_STATE = *opaque{
};
// --------------------------------------------------------
// Type: VSS_VOLUME_SNAPSHOT_ATTRIBUTES
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const VSS_VOLUME_SNAPSHOT_ATTRIBUTES = *opaque{
};
// --------------------------------------------------------
// Type: VSS_SNAPSHOT_CONTEXT
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const VSS_SNAPSHOT_CONTEXT = *opaque{
};
// --------------------------------------------------------
// Type: VSS_PROVIDER_CAPABILITIES
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const VSS_PROVIDER_CAPABILITIES = *opaque{
};
// --------------------------------------------------------
// Type: VSS_HARDWARE_OPTIONS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const VSS_HARDWARE_OPTIONS = *opaque{
};
// --------------------------------------------------------
// Type: VSS_RECOVERY_OPTIONS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const VSS_RECOVERY_OPTIONS = *opaque{
};
// --------------------------------------------------------
// Type: VSS_WRITER_STATE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const VSS_WRITER_STATE = *opaque{
};
// --------------------------------------------------------
// Type: VSS_BACKUP_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const VSS_BACKUP_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: VSS_RESTORE_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const VSS_RESTORE_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: VSS_ROLLFORWARD_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const VSS_ROLLFORWARD_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: VSS_PROVIDER_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const VSS_PROVIDER_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: VSS_APPLICATION_LEVEL
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const VSS_APPLICATION_LEVEL = *opaque{
};
// --------------------------------------------------------
// Type: VSS_SNAPSHOT_COMPATIBILITY
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const VSS_SNAPSHOT_COMPATIBILITY = *opaque{
};
// --------------------------------------------------------
// Type: VSS_SNAPSHOT_PROPERTY_ID
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const VSS_SNAPSHOT_PROPERTY_ID = *opaque{
};
// --------------------------------------------------------
// Type: VSS_FILE_SPEC_BACKUP_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const VSS_FILE_SPEC_BACKUP_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: VSS_BACKUP_SCHEMA
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const VSS_BACKUP_SCHEMA = *opaque{
};
// --------------------------------------------------------
// Type: VSS_SNAPSHOT_PROP
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VSS_SNAPSHOT_PROP = extern struct {
    m_SnapshotId: Guid,
    m_SnapshotSetId: Guid,
    m_lSnapshotsCount: i32,
    m_pwszSnapshotDeviceObject: ?*u16,
    m_pwszOriginalVolumeName: ?*u16,
    m_pwszOriginatingMachine: ?*u16,
    m_pwszServiceMachine: ?*u16,
    m_pwszExposedName: ?*u16,
    m_pwszExposedPath: ?*u16,
    m_ProviderId: Guid,
    m_lSnapshotAttributes: i32,
    m_tsCreationTimestamp: i64,
    m_eStatus: VSS_SNAPSHOT_STATE,
};
// --------------------------------------------------------
// Type: VSS_PROVIDER_PROP
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VSS_PROVIDER_PROP = extern struct {
    m_ProviderId: Guid,
    m_pwszProviderName: ?*u16,
    m_eProviderType: VSS_PROVIDER_TYPE,
    m_pwszProviderVersion: ?*u16,
    m_ProviderVersionId: Guid,
    m_ClassId: Guid,
};
// --------------------------------------------------------
// Type: __MIDL___MIDL_itf_vss_0000_0000_0001
// TypeLayoutAttr: explicit
// not generating the actual code for this type because it has an explicit layout
pub const __MIDL___MIDL_itf_vss_0000_0000_0001 = *opaque{
};
// --------------------------------------------------------
// Type: VSS_OBJECT_PROP
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VSS_OBJECT_PROP = extern struct {
    Type: VSS_OBJECT_TYPE,
    Obj: __MIDL___MIDL_itf_vss_0000_0000_0001,
};
// --------------------------------------------------------
// Type: IVssEnumObject
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IVssEnumObject = *opaque{
    // TODO: Method 'Next'
    // TODO: Method 'Skip'
    // TODO: Method 'Reset'
    // TODO: Method 'Clone'
};
// --------------------------------------------------------
// Type: IVssAsync
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IVssAsync = *opaque{
    // TODO: Method 'Cancel'
    // TODO: Method 'Wait'
    // TODO: Method 'QueryStatus'
};
// --------------------------------------------------------
// Type: VSS_USAGE_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const VSS_USAGE_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: VSS_SOURCE_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const VSS_SOURCE_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: VSS_RESTOREMETHOD_ENUM
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const VSS_RESTOREMETHOD_ENUM = *opaque{
};
// --------------------------------------------------------
// Type: VSS_WRITERRESTORE_ENUM
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const VSS_WRITERRESTORE_ENUM = *opaque{
};
// --------------------------------------------------------
// Type: VSS_COMPONENT_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const VSS_COMPONENT_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: VSS_ALTERNATE_WRITER_STATE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const VSS_ALTERNATE_WRITER_STATE = *opaque{
};
// --------------------------------------------------------
// Type: VSS_SUBSCRIBE_MASK
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const VSS_SUBSCRIBE_MASK = *opaque{
};
// --------------------------------------------------------
// Type: VSS_RESTORE_TARGET
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const VSS_RESTORE_TARGET = *opaque{
};
// --------------------------------------------------------
// Type: VSS_FILE_RESTORE_STATUS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const VSS_FILE_RESTORE_STATUS = *opaque{
};
// --------------------------------------------------------
// Type: VSS_COMPONENT_FLAGS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const VSS_COMPONENT_FLAGS = *opaque{
};
// --------------------------------------------------------
// Type: IVssExamineWriterMetadata
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const IVssExamineWriterMetadata = opaque {
};
// --------------------------------------------------------
// Type: IVssWMFiledesc
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IVssWMFiledesc = *opaque{
    // TODO: Method 'GetPath'
    // TODO: Method 'GetFilespec'
    // TODO: Method 'GetRecursive'
    // TODO: Method 'GetAlternateLocation'
    // TODO: Method 'GetBackupTypeMask'
};
// --------------------------------------------------------
// Type: IVssWMDependency
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IVssWMDependency = *opaque{
    // TODO: Method 'GetWriterId'
    // TODO: Method 'GetLogicalPath'
    // TODO: Method 'GetComponentName'
};
// --------------------------------------------------------
// Type: IVssComponent
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IVssComponent = *opaque{
    // TODO: Method 'GetLogicalPath'
    // TODO: Method 'GetComponentType'
    // TODO: Method 'GetComponentName'
    // TODO: Method 'GetBackupSucceeded'
    // TODO: Method 'GetAlternateLocationMappingCount'
    // TODO: Method 'GetAlternateLocationMapping'
    // TODO: Method 'SetBackupMetadata'
    // TODO: Method 'GetBackupMetadata'
    // TODO: Method 'AddPartialFile'
    // TODO: Method 'GetPartialFileCount'
    // TODO: Method 'GetPartialFile'
    // TODO: Method 'IsSelectedForRestore'
    // TODO: Method 'GetAdditionalRestores'
    // TODO: Method 'GetNewTargetCount'
    // TODO: Method 'GetNewTarget'
    // TODO: Method 'AddDirectedTarget'
    // TODO: Method 'GetDirectedTargetCount'
    // TODO: Method 'GetDirectedTarget'
    // TODO: Method 'SetRestoreMetadata'
    // TODO: Method 'GetRestoreMetadata'
    // TODO: Method 'SetRestoreTarget'
    // TODO: Method 'GetRestoreTarget'
    // TODO: Method 'SetPreRestoreFailureMsg'
    // TODO: Method 'GetPreRestoreFailureMsg'
    // TODO: Method 'SetPostRestoreFailureMsg'
    // TODO: Method 'GetPostRestoreFailureMsg'
    // TODO: Method 'SetBackupStamp'
    // TODO: Method 'GetBackupStamp'
    // TODO: Method 'GetPreviousBackupStamp'
    // TODO: Method 'GetBackupOptions'
    // TODO: Method 'GetRestoreOptions'
    // TODO: Method 'GetRestoreSubcomponentCount'
    // TODO: Method 'GetRestoreSubcomponent'
    // TODO: Method 'GetFileRestoreStatus'
    // TODO: Method 'AddDifferencedFilesByLastModifyTime'
    // TODO: Method 'AddDifferencedFilesByLastModifyLSN'
    // TODO: Method 'GetDifferencedFilesCount'
    // TODO: Method 'GetDifferencedFile'
};
// --------------------------------------------------------
// Type: IVssWriterComponents
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IVssWriterComponents = *opaque{
    // TODO: Method 'GetComponentCount'
    // TODO: Method 'GetWriterInfo'
    // TODO: Method 'GetComponent'
};
// --------------------------------------------------------
// Type: IVssComponentEx
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IVssComponentEx = *opaque{
    // TODO: Method 'SetPrepareForBackupFailureMsg'
    // TODO: Method 'SetPostSnapshotFailureMsg'
    // TODO: Method 'GetPrepareForBackupFailureMsg'
    // TODO: Method 'GetPostSnapshotFailureMsg'
    // TODO: Method 'GetAuthoritativeRestore'
    // TODO: Method 'GetRollForward'
    // TODO: Method 'GetRestoreName'
};
// --------------------------------------------------------
// Type: IVssComponentEx2
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IVssComponentEx2 = *opaque{
    // TODO: Method 'SetFailure'
    // TODO: Method 'GetFailure'
};
// --------------------------------------------------------
// Type: IVssCreateWriterMetadata
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IVssCreateWriterMetadata = *opaque{
    // TODO: Method 'AddIncludeFiles'
    // TODO: Method 'AddExcludeFiles'
    // TODO: Method 'AddComponent'
    // TODO: Method 'AddDatabaseFiles'
    // TODO: Method 'AddDatabaseLogFiles'
    // TODO: Method 'AddFilesToFileGroup'
    // TODO: Method 'SetRestoreMethod'
    // TODO: Method 'AddAlternateLocationMapping'
    // TODO: Method 'AddComponentDependency'
    // TODO: Method 'SetBackupSchema'
    // TODO: Method 'GetDocument'
    // TODO: Method 'SaveAsXML'
};
// --------------------------------------------------------
// Type: IVssCreateWriterMetadataEx
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IVssCreateWriterMetadataEx = *opaque{
    // TODO: Method 'AddDatabaseFiles'
    // TODO: Method 'AddDatabaseLogFiles'
    // TODO: Method 'AddFilesToFileGroup'
    // TODO: Method 'SetRestoreMethod'
    // TODO: Method 'AddAlternateLocationMapping'
    // TODO: Method 'AddComponentDependency'
    // TODO: Method 'SetBackupSchema'
    // TODO: Method 'GetDocument'
    // TODO: Method 'SaveAsXML'
    // TODO: Method 'QueryInterface'
    // TODO: Method 'AddRef'
    // TODO: Method 'Release'
    // TODO: Method 'AddExcludeFilesFromSnapshot'
};
// --------------------------------------------------------
// Type: IVssWriterImpl
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IVssWriterImpl = *opaque{
    // TODO: Method 'Initialize'
    // TODO: Method 'Subscribe'
    // TODO: Method 'Unsubscribe'
    // TODO: Method 'Uninitialize'
    // TODO: Method 'GetCurrentVolumeArray'
    // TODO: Method 'GetCurrentVolumeCount'
    // TODO: Method 'GetSnapshotDeviceName'
    // TODO: Method 'GetCurrentSnapshotSetId'
    // TODO: Method 'GetContext'
    // TODO: Method 'GetCurrentLevel'
    // TODO: Method 'IsPathAffected'
    // TODO: Method 'IsBootableSystemStateBackedUp'
    // TODO: Method 'AreComponentsSelected'
    // TODO: Method 'GetBackupType'
    // TODO: Method 'GetRestoreType'
    // TODO: Method 'SetWriterFailure'
    // TODO: Method 'IsPartialFileSupportEnabled'
    // TODO: Method 'InstallAlternateWriter'
    // TODO: Method 'GetIdentityInformation'
    // TODO: Method 'SetWriterFailureEx'
    // TODO: Method 'GetSessionId'
    // TODO: Method 'IsWriterShuttingDown'
};
// --------------------------------------------------------
// Type: IVssCreateExpressWriterMetadata
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IVssCreateExpressWriterMetadata = *opaque{
    // TODO: Method 'AddExcludeFiles'
    // TODO: Method 'AddComponent'
    // TODO: Method 'AddFilesToFileGroup'
    // TODO: Method 'SetRestoreMethod'
    // TODO: Method 'AddComponentDependency'
    // TODO: Method 'SetBackupSchema'
    // TODO: Method 'SaveAsXML'
};
// --------------------------------------------------------
// Type: IVssExpressWriter
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IVssExpressWriter = *opaque{
    // TODO: Method 'CreateMetadata'
    // TODO: Method 'LoadMetadata'
    // TODO: Method 'Register'
    // TODO: Method 'Unregister'
};
// --------------------------------------------------------
// Type: VssSnapshotMgmt
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const VssSnapshotMgmt = opaque {
};
// --------------------------------------------------------
// Type: VSS_MGMT_OBJECT_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const VSS_MGMT_OBJECT_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: VSS_VOLUME_PROP
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VSS_VOLUME_PROP = extern struct {
    m_pwszVolumeName: ?*u16,
    m_pwszVolumeDisplayName: ?*u16,
};
// --------------------------------------------------------
// Type: VSS_DIFF_VOLUME_PROP
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VSS_DIFF_VOLUME_PROP = extern struct {
    m_pwszVolumeName: ?*u16,
    m_pwszVolumeDisplayName: ?*u16,
    m_llVolumeFreeSpace: i64,
    m_llVolumeTotalSpace: i64,
};
// --------------------------------------------------------
// Type: VSS_DIFF_AREA_PROP
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VSS_DIFF_AREA_PROP = extern struct {
    m_pwszVolumeName: ?*u16,
    m_pwszDiffAreaVolumeName: ?*u16,
    m_llMaximumDiffSpace: i64,
    m_llAllocatedDiffSpace: i64,
    m_llUsedDiffSpace: i64,
};
// --------------------------------------------------------
// Type: __MIDL___MIDL_itf_vsmgmt_0000_0000_0001
// TypeLayoutAttr: explicit
// not generating the actual code for this type because it has an explicit layout
pub const __MIDL___MIDL_itf_vsmgmt_0000_0000_0001 = *opaque{
};
// --------------------------------------------------------
// Type: VSS_MGMT_OBJECT_PROP
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VSS_MGMT_OBJECT_PROP = extern struct {
    Type: VSS_MGMT_OBJECT_TYPE,
    Obj: __MIDL___MIDL_itf_vsmgmt_0000_0000_0001,
};
// --------------------------------------------------------
// Type: VSS_PROTECTION_LEVEL
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const VSS_PROTECTION_LEVEL = *opaque{
};
// --------------------------------------------------------
// Type: VSS_PROTECTION_FAULT
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const VSS_PROTECTION_FAULT = *opaque{
};
// --------------------------------------------------------
// Type: VSS_VOLUME_PROTECTION_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VSS_VOLUME_PROTECTION_INFO = extern struct {
    m_protectionLevel: VSS_PROTECTION_LEVEL,
    m_volumeIsOfflineForProtection: BOOL,
    m_protectionFault: VSS_PROTECTION_FAULT,
    m_failureStatus: i32,
    m_volumeHasUnusedDiffArea: BOOL,
    m_reserved: u32,
};
// --------------------------------------------------------
// Type: IVssSnapshotMgmt
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IVssSnapshotMgmt = *opaque{
    // TODO: Method 'GetProviderMgmtInterface'
    // TODO: Method 'QueryVolumesSupportedForSnapshots'
    // TODO: Method 'QuerySnapshotsByVolume'
};
// --------------------------------------------------------
// Type: IVssSnapshotMgmt2
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IVssSnapshotMgmt2 = *opaque{
    // TODO: Method 'GetMinDiffAreaSize'
};
// --------------------------------------------------------
// Type: IVssDifferentialSoftwareSnapshotMgmt
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IVssDifferentialSoftwareSnapshotMgmt = *opaque{
    // TODO: Method 'AddDiffArea'
    // TODO: Method 'ChangeDiffAreaMaximumSize'
    // TODO: Method 'QueryVolumesSupportedForDiffAreas'
    // TODO: Method 'QueryDiffAreasForVolume'
    // TODO: Method 'QueryDiffAreasOnVolume'
    // TODO: Method 'QueryDiffAreasForSnapshot'
};
// --------------------------------------------------------
// Type: IVssDifferentialSoftwareSnapshotMgmt2
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IVssDifferentialSoftwareSnapshotMgmt2 = *opaque{
    // TODO: Method 'ChangeDiffAreaMaximumSizeEx'
    // TODO: Method 'MigrateDiffAreas'
    // TODO: Method 'QueryMigrationStatus'
    // TODO: Method 'SetSnapshotPriority'
};
// --------------------------------------------------------
// Type: IVssDifferentialSoftwareSnapshotMgmt3
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IVssDifferentialSoftwareSnapshotMgmt3 = *opaque{
    // TODO: Method 'SetVolumeProtectLevel'
    // TODO: Method 'GetVolumeProtectLevel'
    // TODO: Method 'ClearVolumeProtectFault'
    // TODO: Method 'DeleteUnusedDiffAreas'
    // TODO: Method 'QuerySnapshotDeltaBitmap'
};
// --------------------------------------------------------
// Type: IVssEnumMgmtObject
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IVssEnumMgmtObject = *opaque{
    // TODO: Method 'Next'
    // TODO: Method 'Skip'
    // TODO: Method 'Reset'
    // TODO: Method 'Clone'
};
// --------------------------------------------------------
// Type: VSSCoordinator
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const VSSCoordinator = opaque {
};
// --------------------------------------------------------
// Type: IVssAdmin
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IVssAdmin = *opaque{
    // TODO: Method 'RegisterProvider'
    // TODO: Method 'UnregisterProvider'
    // TODO: Method 'QueryProviders'
    // TODO: Method 'AbortAllSnapshotsInProgress'
};
// --------------------------------------------------------
// Type: IVssAdminEx
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IVssAdminEx = *opaque{
    // TODO: Method 'GetProviderCapability'
    // TODO: Method 'GetProviderContext'
    // TODO: Method 'SetProviderContext'
};
// --------------------------------------------------------
// Type: IVssSoftwareSnapshotProvider
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IVssSoftwareSnapshotProvider = *opaque{
    // TODO: Method 'SetContext'
    // TODO: Method 'GetSnapshotProperties'
    // TODO: Method 'Query'
    // TODO: Method 'DeleteSnapshots'
    // TODO: Method 'BeginPrepareSnapshot'
    // TODO: Method 'IsVolumeSupported'
    // TODO: Method 'IsVolumeSnapshotted'
    // TODO: Method 'SetSnapshotProperty'
    // TODO: Method 'RevertToSnapshot'
    // TODO: Method 'QueryRevertStatus'
};
// --------------------------------------------------------
// Type: IVssProviderCreateSnapshotSet
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IVssProviderCreateSnapshotSet = *opaque{
    // TODO: Method 'EndPrepareSnapshots'
    // TODO: Method 'PreCommitSnapshots'
    // TODO: Method 'CommitSnapshots'
    // TODO: Method 'PostCommitSnapshots'
    // TODO: Method 'PreFinalCommitSnapshots'
    // TODO: Method 'PostFinalCommitSnapshots'
    // TODO: Method 'AbortSnapshots'
};
// --------------------------------------------------------
// Type: IVssProviderNotifications
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IVssProviderNotifications = *opaque{
    // TODO: Method 'OnLoad'
    // TODO: Method 'OnUnload'
};
// --------------------------------------------------------
// Type: IVssHardwareSnapshotProvider
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IVssHardwareSnapshotProvider = *opaque{
    // TODO: Method 'AreLunsSupported'
    // TODO: Method 'FillInLunInfo'
    // TODO: Method 'BeginPrepareSnapshot'
    // TODO: Method 'GetTargetLuns'
    // TODO: Method 'LocateLuns'
    // TODO: Method 'OnLunEmpty'
};
// --------------------------------------------------------
// Type: IVssHardwareSnapshotProviderEx
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IVssHardwareSnapshotProviderEx = *opaque{
    // TODO: Method 'GetProviderCapabilities'
    // TODO: Method 'OnLunStateChange'
    // TODO: Method 'ResyncLuns'
    // TODO: Method 'OnReuseLuns'
};
// --------------------------------------------------------
// Type: IVssFileShareSnapshotProvider
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IVssFileShareSnapshotProvider = *opaque{
    // TODO: Method 'SetContext'
    // TODO: Method 'GetSnapshotProperties'
    // TODO: Method 'Query'
    // TODO: Method 'DeleteSnapshots'
    // TODO: Method 'BeginPrepareSnapshot'
    // TODO: Method 'IsPathSupported'
    // TODO: Method 'IsPathSnapshotted'
    // TODO: Method 'SetSnapshotProperty'
};
// --------------------------------------------------------
// Type: IDDVideoPortContainer
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const IDDVideoPortContainer = opaque {
};
// --------------------------------------------------------
// Type: IDirectDrawVideoPort
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const IDirectDrawVideoPort = opaque {
};
// --------------------------------------------------------
// Type: IDirectDrawVideoPortNotify
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const IDirectDrawVideoPortNotify = opaque {
};
// --------------------------------------------------------
// Type: IDDVideoPortContainerVtbl
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const IDDVideoPortContainerVtbl = opaque {
};
// --------------------------------------------------------
// Type: IDirectDrawVideoPortVtbl
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const IDirectDrawVideoPortVtbl = opaque {
};
// --------------------------------------------------------
// Type: IDirectDrawVideoPortNotifyVtbl
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const IDirectDrawVideoPortNotifyVtbl = opaque {
};
// --------------------------------------------------------
// Type: LPDDENUMVIDEOCALLBACK
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const LPDDENUMVIDEOCALLBACK = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: DDVIDEOPORTSTATUS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DDVIDEOPORTSTATUS = extern struct {
    dwSize: u32,
    bInUse: BOOL,
    dwFlags: u32,
    dwReserved1: u32,
    VideoPortType: DDVIDEOPORTCONNECT,
    dwReserved2: ?*opaque{},
    dwReserved3: ?*opaque{},
};
// --------------------------------------------------------
// Type: DDVIDEOPORTNOTIFY
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DDVIDEOPORTNOTIFY = extern struct {
    ApproximateTimeStamp: LARGE_INTEGER,
    lField: i32,
    dwSurfaceIndex: u32,
    lDone: i32,
};
// --------------------------------------------------------
// Type: _DD_DESTROYDRIVERDATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const _DD_DESTROYDRIVERDATA = opaque {
};
// --------------------------------------------------------
// Type: _DD_SETMODEDATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const _DD_SETMODEDATA = opaque {
};
// --------------------------------------------------------
// Type: _DD_GETVPORTAUTOFLIPSURFACEDATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const _DD_GETVPORTAUTOFLIPSURFACEDATA = opaque {
};
// --------------------------------------------------------
// Type: PDD_SETCOLORKEY
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PDD_SETCOLORKEY = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PDD_DESTROYDRIVER
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PDD_DESTROYDRIVER = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PDD_SETMODE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PDD_SETMODE = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PDD_ALPHABLT
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PDD_ALPHABLT = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PDD_SURFCB_SETCLIPLIST
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PDD_SURFCB_SETCLIPLIST = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PDD_VPORTCB_GETAUTOFLIPSURF
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PDD_VPORTCB_GETAUTOFLIPSURF = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: DD_MORECAPS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DD_MORECAPS = extern struct {
    dwSize: u32,
    dwAlphaCaps: u32,
    dwSVBAlphaCaps: u32,
    dwVSBAlphaCaps: u32,
    dwSSBAlphaCaps: u32,
    dwFilterCaps: u32,
    dwSVBFilterCaps: u32,
    dwVSBFilterCaps: u32,
    dwSSBFilterCaps: u32,
};
// --------------------------------------------------------
// Type: DDNTCORECAPS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DDNTCORECAPS = extern struct {
    dwSize: u32,
    dwCaps: u32,
    dwCaps2: u32,
    dwCKeyCaps: u32,
    dwFXCaps: u32,
    dwFXAlphaCaps: u32,
    dwPalCaps: u32,
    dwSVCaps: u32,
    dwAlphaBltConstBitDepths: u32,
    dwAlphaBltPixelBitDepths: u32,
    dwAlphaBltSurfaceBitDepths: u32,
    dwAlphaOverlayConstBitDepths: u32,
    dwAlphaOverlayPixelBitDepths: u32,
    dwAlphaOverlaySurfaceBitDepths: u32,
    dwZBufferBitDepths: u32,
    dwVidMemTotal: u32,
    dwVidMemFree: u32,
    dwMaxVisibleOverlays: u32,
    dwCurrVisibleOverlays: u32,
    dwNumFourCCCodes: u32,
    dwAlignBoundarySrc: u32,
    dwAlignSizeSrc: u32,
    dwAlignBoundaryDest: u32,
    dwAlignSizeDest: u32,
    dwAlignStrideAlign: u32,
    dwRops: ?[*]u32,
    ddsCaps: DDSCAPS,
    dwMinOverlayStretch: u32,
    dwMaxOverlayStretch: u32,
    dwMinLiveVideoStretch: u32,
    dwMaxLiveVideoStretch: u32,
    dwMinHwCodecStretch: u32,
    dwMaxHwCodecStretch: u32,
    dwReserved1: u32,
    dwReserved2: u32,
    dwReserved3: u32,
    dwSVBCaps: u32,
    dwSVBCKeyCaps: u32,
    dwSVBFXCaps: u32,
    dwSVBRops: ?[*]u32,
    dwVSBCaps: u32,
    dwVSBCKeyCaps: u32,
    dwVSBFXCaps: u32,
    dwVSBRops: ?[*]u32,
    dwSSBCaps: u32,
    dwSSBCKeyCaps: u32,
    dwSSBFXCaps: u32,
    dwSSBRops: ?[*]u32,
    dwMaxVideoPorts: u32,
    dwCurrVideoPorts: u32,
    dwSVBCaps2: u32,
};
// --------------------------------------------------------
// Type: DD_HALINFO_V4
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DD_HALINFO_V4 = extern struct {
    dwSize: u32,
    vmiData: VIDEOMEMORYINFO,
    ddCaps: DDNTCORECAPS,
    GetDriverInfo: PDD_GETDRIVERINFO,
    dwFlags: u32,
};
// --------------------------------------------------------
// Type: DD_SETCLIPLISTDATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DD_SETCLIPLISTDATA = extern struct {
    lpDD: ?*DD_DIRECTDRAW_GLOBAL,
    lpDDSurface: ?*DD_SURFACE_LOCAL,
    ddRVal: HRESULT,
    SetClipList: ?*opaque{},
};
// --------------------------------------------------------
// Type: DD_DRVSETCOLORKEYDATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DD_DRVSETCOLORKEYDATA = extern struct {
    lpDDSurface: ?*DD_SURFACE_LOCAL,
    dwFlags: u32,
    ckNew: DDCOLORKEY,
    ddRVal: HRESULT,
    SetColorKey: ?*opaque{},
};
// --------------------------------------------------------
// Type: DD_DESTROYDDLOCALDATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DD_DESTROYDDLOCALDATA = extern struct {
    dwFlags: u32,
    pDDLcl: ?*DD_DIRECTDRAW_LOCAL,
    ddRVal: HRESULT,
};
// --------------------------------------------------------
// Type: LPD3DVALIDATECALLBACK
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const LPD3DVALIDATECALLBACK = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: LPD3DENUMTEXTUREFORMATSCALLBACK
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const LPD3DENUMTEXTUREFORMATSCALLBACK = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: LPD3DENUMPIXELFORMATSCALLBACK
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const LPD3DENUMPIXELFORMATSCALLBACK = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: D3DRECT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const D3DRECT = extern struct {
    Anonymous1: _Anonymous1_e__Union,
    Anonymous2: _Anonymous2_e__Union,
    Anonymous3: _Anonymous3_e__Union,
    Anonymous4: _Anonymous4_e__Union,
    // --------------------------------------------------------
    // Type: _Anonymous3_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous3_e__Union = *opaque{
    };
    // --------------------------------------------------------
    // Type: _Anonymous1_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous1_e__Union = *opaque{
    };
    // --------------------------------------------------------
    // Type: _Anonymous2_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous2_e__Union = *opaque{
    };
    // --------------------------------------------------------
    // Type: _Anonymous4_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous4_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: D3DVECTOR
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const D3DVECTOR = extern struct {
    Anonymous1: _Anonymous1_e__Union,
    Anonymous2: _Anonymous2_e__Union,
    Anonymous3: _Anonymous3_e__Union,
    // --------------------------------------------------------
    // Type: _Anonymous3_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous3_e__Union = *opaque{
    };
    // --------------------------------------------------------
    // Type: _Anonymous1_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous1_e__Union = *opaque{
    };
    // --------------------------------------------------------
    // Type: _Anonymous2_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous2_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: D3DHVERTEX
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const D3DHVERTEX = extern struct {
    dwFlags: u32,
    Anonymous1: _Anonymous1_e__Union,
    Anonymous2: _Anonymous2_e__Union,
    Anonymous3: _Anonymous3_e__Union,
    // --------------------------------------------------------
    // Type: _Anonymous2_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous2_e__Union = *opaque{
    };
    // --------------------------------------------------------
    // Type: _Anonymous3_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous3_e__Union = *opaque{
    };
    // --------------------------------------------------------
    // Type: _Anonymous1_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous1_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: D3DTLVERTEX
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const D3DTLVERTEX = extern struct {
    Anonymous1: _Anonymous1_e__Union,
    Anonymous2: _Anonymous2_e__Union,
    Anonymous3: _Anonymous3_e__Union,
    Anonymous4: _Anonymous4_e__Union,
    Anonymous5: _Anonymous5_e__Union,
    Anonymous6: _Anonymous6_e__Union,
    Anonymous7: _Anonymous7_e__Union,
    Anonymous8: _Anonymous8_e__Union,
    // --------------------------------------------------------
    // Type: _Anonymous7_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous7_e__Union = *opaque{
    };
    // --------------------------------------------------------
    // Type: _Anonymous5_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous5_e__Union = *opaque{
    };
    // --------------------------------------------------------
    // Type: _Anonymous3_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous3_e__Union = *opaque{
    };
    // --------------------------------------------------------
    // Type: _Anonymous1_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous1_e__Union = *opaque{
    };
    // --------------------------------------------------------
    // Type: _Anonymous8_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous8_e__Union = *opaque{
    };
    // --------------------------------------------------------
    // Type: _Anonymous4_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous4_e__Union = *opaque{
    };
    // --------------------------------------------------------
    // Type: _Anonymous6_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous6_e__Union = *opaque{
    };
    // --------------------------------------------------------
    // Type: _Anonymous2_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous2_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: D3DLVERTEX
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const D3DLVERTEX = extern struct {
    Anonymous1: _Anonymous1_e__Union,
    Anonymous2: _Anonymous2_e__Union,
    Anonymous3: _Anonymous3_e__Union,
    dwReserved: u32,
    Anonymous4: _Anonymous4_e__Union,
    Anonymous5: _Anonymous5_e__Union,
    Anonymous6: _Anonymous6_e__Union,
    Anonymous7: _Anonymous7_e__Union,
    // --------------------------------------------------------
    // Type: _Anonymous7_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous7_e__Union = *opaque{
    };
    // --------------------------------------------------------
    // Type: _Anonymous5_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous5_e__Union = *opaque{
    };
    // --------------------------------------------------------
    // Type: _Anonymous3_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous3_e__Union = *opaque{
    };
    // --------------------------------------------------------
    // Type: _Anonymous1_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous1_e__Union = *opaque{
    };
    // --------------------------------------------------------
    // Type: _Anonymous4_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous4_e__Union = *opaque{
    };
    // --------------------------------------------------------
    // Type: _Anonymous6_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous6_e__Union = *opaque{
    };
    // --------------------------------------------------------
    // Type: _Anonymous2_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous2_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: D3DVERTEX
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const D3DVERTEX = extern struct {
    Anonymous1: _Anonymous1_e__Union,
    Anonymous2: _Anonymous2_e__Union,
    Anonymous3: _Anonymous3_e__Union,
    Anonymous4: _Anonymous4_e__Union,
    Anonymous5: _Anonymous5_e__Union,
    Anonymous6: _Anonymous6_e__Union,
    Anonymous7: _Anonymous7_e__Union,
    Anonymous8: _Anonymous8_e__Union,
    // --------------------------------------------------------
    // Type: _Anonymous8_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous8_e__Union = *opaque{
    };
    // --------------------------------------------------------
    // Type: _Anonymous6_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous6_e__Union = *opaque{
    };
    // --------------------------------------------------------
    // Type: _Anonymous4_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous4_e__Union = *opaque{
    };
    // --------------------------------------------------------
    // Type: _Anonymous2_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous2_e__Union = *opaque{
    };
    // --------------------------------------------------------
    // Type: _Anonymous5_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous5_e__Union = *opaque{
    };
    // --------------------------------------------------------
    // Type: _Anonymous1_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous1_e__Union = *opaque{
    };
    // --------------------------------------------------------
    // Type: _Anonymous7_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous7_e__Union = *opaque{
    };
    // --------------------------------------------------------
    // Type: _Anonymous3_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous3_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: D3DVIEWPORT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const D3DVIEWPORT = extern struct {
    dwSize: u32,
    dwX: u32,
    dwY: u32,
    dwWidth: u32,
    dwHeight: u32,
    dvScaleX: f32,
    dvScaleY: f32,
    dvMaxX: f32,
    dvMaxY: f32,
    dvMinZ: f32,
    dvMaxZ: f32,
};
// --------------------------------------------------------
// Type: D3DVIEWPORT2
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const D3DVIEWPORT2 = extern struct {
    dwSize: u32,
    dwX: u32,
    dwY: u32,
    dwWidth: u32,
    dwHeight: u32,
    dvClipX: f32,
    dvClipY: f32,
    dvClipWidth: f32,
    dvClipHeight: f32,
    dvMinZ: f32,
    dvMaxZ: f32,
};
// --------------------------------------------------------
// Type: D3DVIEWPORT7
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const D3DVIEWPORT7 = extern struct {
    dwX: u32,
    dwY: u32,
    dwWidth: u32,
    dwHeight: u32,
    dvMinZ: f32,
    dvMaxZ: f32,
};
// --------------------------------------------------------
// Type: D3DTRANSFORMDATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const D3DTRANSFORMDATA = extern struct {
    dwSize: u32,
    lpIn: ?*opaque{},
    dwInSize: u32,
    lpOut: ?*opaque{},
    dwOutSize: u32,
    lpHOut: ?*D3DHVERTEX,
    dwClip: u32,
    dwClipIntersection: u32,
    dwClipUnion: u32,
    drExtent: D3DRECT,
};
// --------------------------------------------------------
// Type: D3DLIGHTINGELEMENT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const D3DLIGHTINGELEMENT = extern struct {
    dvPosition: D3DVECTOR,
    dvNormal: D3DVECTOR,
};
// --------------------------------------------------------
// Type: D3DMATERIAL
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const D3DMATERIAL = extern struct {
    dwSize: u32,
    Anonymous1: _Anonymous1_e__Union,
    Anonymous2: _Anonymous2_e__Union,
    Anonymous3: _Anonymous3_e__Union,
    Anonymous4: _Anonymous4_e__Union,
    Anonymous5: _Anonymous5_e__Union,
    hTexture: u32,
    dwRampSize: u32,
    // --------------------------------------------------------
    // Type: _Anonymous4_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous4_e__Union = *opaque{
    };
    // --------------------------------------------------------
    // Type: _Anonymous2_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous2_e__Union = *opaque{
    };
    // --------------------------------------------------------
    // Type: _Anonymous5_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous5_e__Union = *opaque{
    };
    // --------------------------------------------------------
    // Type: _Anonymous1_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous1_e__Union = *opaque{
    };
    // --------------------------------------------------------
    // Type: _Anonymous3_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous3_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: D3DMATERIAL7
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const D3DMATERIAL7 = extern struct {
    Anonymous1: _Anonymous1_e__Union,
    Anonymous2: _Anonymous2_e__Union,
    Anonymous3: _Anonymous3_e__Union,
    Anonymous4: _Anonymous4_e__Union,
    Anonymous5: _Anonymous5_e__Union,
    // --------------------------------------------------------
    // Type: _Anonymous5_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous5_e__Union = *opaque{
    };
    // --------------------------------------------------------
    // Type: _Anonymous3_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous3_e__Union = *opaque{
    };
    // --------------------------------------------------------
    // Type: _Anonymous1_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous1_e__Union = *opaque{
    };
    // --------------------------------------------------------
    // Type: _Anonymous4_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous4_e__Union = *opaque{
    };
    // --------------------------------------------------------
    // Type: _Anonymous2_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous2_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: D3DLIGHTTYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const D3DLIGHTTYPE = *opaque{
};
// --------------------------------------------------------
// Type: D3DLIGHT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const D3DLIGHT = extern struct {
    dwSize: u32,
    dltType: D3DLIGHTTYPE,
    dcvColor: DXGI_RGBA,
    dvPosition: D3DVECTOR,
    dvDirection: D3DVECTOR,
    dvRange: f32,
    dvFalloff: f32,
    dvAttenuation0: f32,
    dvAttenuation1: f32,
    dvAttenuation2: f32,
    dvTheta: f32,
    dvPhi: f32,
};
// --------------------------------------------------------
// Type: D3DLIGHT7
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const D3DLIGHT7 = extern struct {
    dltType: D3DLIGHTTYPE,
    dcvDiffuse: DXGI_RGBA,
    dcvSpecular: DXGI_RGBA,
    dcvAmbient: DXGI_RGBA,
    dvPosition: D3DVECTOR,
    dvDirection: D3DVECTOR,
    dvRange: f32,
    dvFalloff: f32,
    dvAttenuation0: f32,
    dvAttenuation1: f32,
    dvAttenuation2: f32,
    dvTheta: f32,
    dvPhi: f32,
};
// --------------------------------------------------------
// Type: D3DLIGHT2
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const D3DLIGHT2 = extern struct {
    dwSize: u32,
    dltType: D3DLIGHTTYPE,
    dcvColor: DXGI_RGBA,
    dvPosition: D3DVECTOR,
    dvDirection: D3DVECTOR,
    dvRange: f32,
    dvFalloff: f32,
    dvAttenuation0: f32,
    dvAttenuation1: f32,
    dvAttenuation2: f32,
    dvTheta: f32,
    dvPhi: f32,
    dwFlags: u32,
};
// --------------------------------------------------------
// Type: D3DLIGHTDATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const D3DLIGHTDATA = extern struct {
    dwSize: u32,
    lpIn: ?*D3DLIGHTINGELEMENT,
    dwInSize: u32,
    lpOut: ?*D3DTLVERTEX,
    dwOutSize: u32,
};
// --------------------------------------------------------
// Type: D3DOPCODE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const D3DOPCODE = *opaque{
};
// --------------------------------------------------------
// Type: D3DINSTRUCTION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const D3DINSTRUCTION = extern struct {
    bOpcode: u8,
    bSize: u8,
    wCount: u16,
};
// --------------------------------------------------------
// Type: D3DTEXTURELOAD
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const D3DTEXTURELOAD = extern struct {
    hDestTexture: u32,
    hSrcTexture: u32,
};
// --------------------------------------------------------
// Type: D3DPICKRECORD
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const D3DPICKRECORD = extern struct {
    bOpcode: u8,
    bPad: u8,
    dwOffset: u32,
    dvZ: f32,
};
// --------------------------------------------------------
// Type: D3DSHADEMODE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const D3DSHADEMODE = *opaque{
};
// --------------------------------------------------------
// Type: D3DFILLMODE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const D3DFILLMODE = *opaque{
};
// --------------------------------------------------------
// Type: D3DLINEPATTERN
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const D3DLINEPATTERN = extern struct {
    wRepeatFactor: u16,
    wLinePattern: u16,
};
// --------------------------------------------------------
// Type: D3DTEXTUREFILTER
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const D3DTEXTUREFILTER = *opaque{
};
// --------------------------------------------------------
// Type: D3DBLEND
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const D3DBLEND = *opaque{
};
// --------------------------------------------------------
// Type: D3DTEXTUREBLEND
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const D3DTEXTUREBLEND = *opaque{
};
// --------------------------------------------------------
// Type: D3DTEXTUREADDRESS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const D3DTEXTUREADDRESS = *opaque{
};
// --------------------------------------------------------
// Type: D3DCULL
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const D3DCULL = *opaque{
};
// --------------------------------------------------------
// Type: D3DCMPFUNC
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const D3DCMPFUNC = *opaque{
};
// --------------------------------------------------------
// Type: D3DSTENCILOP
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const D3DSTENCILOP = *opaque{
};
// --------------------------------------------------------
// Type: D3DFOGMODE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const D3DFOGMODE = *opaque{
};
// --------------------------------------------------------
// Type: D3DZBUFFERTYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const D3DZBUFFERTYPE = *opaque{
};
// --------------------------------------------------------
// Type: D3DANTIALIASMODE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const D3DANTIALIASMODE = *opaque{
};
// --------------------------------------------------------
// Type: D3DVERTEXTYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const D3DVERTEXTYPE = *opaque{
};
// --------------------------------------------------------
// Type: D3DPRIMITIVETYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const D3DPRIMITIVETYPE = *opaque{
};
// --------------------------------------------------------
// Type: D3DTRANSFORMSTATETYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const D3DTRANSFORMSTATETYPE = *opaque{
};
// --------------------------------------------------------
// Type: D3DLIGHTSTATETYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const D3DLIGHTSTATETYPE = *opaque{
};
// --------------------------------------------------------
// Type: D3DRENDERSTATETYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const D3DRENDERSTATETYPE = *opaque{
};
// --------------------------------------------------------
// Type: D3DMATERIALCOLORSOURCE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const D3DMATERIALCOLORSOURCE = *opaque{
};
// --------------------------------------------------------
// Type: D3DSTATE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const D3DSTATE = extern struct {
    Anonymous1: _Anonymous1_e__Union,
    Anonymous2: _Anonymous2_e__Union,
    // --------------------------------------------------------
    // Type: _Anonymous2_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous2_e__Union = *opaque{
    };
    // --------------------------------------------------------
    // Type: _Anonymous1_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous1_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: D3DMATRIXLOAD
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const D3DMATRIXLOAD = extern struct {
    hDestMatrix: u32,
    hSrcMatrix: u32,
};
// --------------------------------------------------------
// Type: D3DMATRIXMULTIPLY
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const D3DMATRIXMULTIPLY = extern struct {
    hDestMatrix: u32,
    hSrcMatrix1: u32,
    hSrcMatrix2: u32,
};
// --------------------------------------------------------
// Type: D3DPROCESSVERTICES
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const D3DPROCESSVERTICES = extern struct {
    dwFlags: u32,
    wStart: u16,
    wDest: u16,
    dwCount: u32,
    dwReserved: u32,
};
// --------------------------------------------------------
// Type: D3DTEXTURESTAGESTATETYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const D3DTEXTURESTAGESTATETYPE = *opaque{
};
// --------------------------------------------------------
// Type: D3DTEXTUREOP
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const D3DTEXTUREOP = *opaque{
};
// --------------------------------------------------------
// Type: D3DTEXTUREMAGFILTER
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const D3DTEXTUREMAGFILTER = *opaque{
};
// --------------------------------------------------------
// Type: D3DTEXTUREMINFILTER
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const D3DTEXTUREMINFILTER = *opaque{
};
// --------------------------------------------------------
// Type: D3DTEXTUREMIPFILTER
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const D3DTEXTUREMIPFILTER = *opaque{
};
// --------------------------------------------------------
// Type: D3DTRIANGLE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const D3DTRIANGLE = extern struct {
    Anonymous1: _Anonymous1_e__Union,
    Anonymous2: _Anonymous2_e__Union,
    Anonymous3: _Anonymous3_e__Union,
    wFlags: u16,
    // --------------------------------------------------------
    // Type: _Anonymous2_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous2_e__Union = *opaque{
    };
    // --------------------------------------------------------
    // Type: _Anonymous1_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous1_e__Union = *opaque{
    };
    // --------------------------------------------------------
    // Type: _Anonymous3_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous3_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: D3DLINE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const D3DLINE = extern struct {
    Anonymous1: _Anonymous1_e__Union,
    Anonymous2: _Anonymous2_e__Union,
    // --------------------------------------------------------
    // Type: _Anonymous1_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous1_e__Union = *opaque{
    };
    // --------------------------------------------------------
    // Type: _Anonymous2_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous2_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: D3DSPAN
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const D3DSPAN = extern struct {
    wCount: u16,
    wFirst: u16,
};
// --------------------------------------------------------
// Type: D3DPOINT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const D3DPOINT = extern struct {
    wCount: u16,
    wFirst: u16,
};
// --------------------------------------------------------
// Type: D3DBRANCH
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const D3DBRANCH = extern struct {
    dwMask: u32,
    dwValue: u32,
    bNegate: BOOL,
    dwOffset: u32,
};
// --------------------------------------------------------
// Type: D3DSTATUS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const D3DSTATUS = extern struct {
    dwFlags: u32,
    dwStatus: u32,
    drExtent: D3DRECT,
};
// --------------------------------------------------------
// Type: D3DCLIPSTATUS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const D3DCLIPSTATUS = extern struct {
    dwFlags: u32,
    dwStatus: u32,
    minx: f32,
    maxx: f32,
    miny: f32,
    maxy: f32,
    minz: f32,
    maxz: f32,
};
// --------------------------------------------------------
// Type: D3DSTATS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const D3DSTATS = extern struct {
    dwSize: u32,
    dwTrianglesDrawn: u32,
    dwLinesDrawn: u32,
    dwPointsDrawn: u32,
    dwSpansDrawn: u32,
    dwVerticesProcessed: u32,
};
// --------------------------------------------------------
// Type: D3DEXECUTEDATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const D3DEXECUTEDATA = extern struct {
    dwSize: u32,
    dwVertexOffset: u32,
    dwVertexCount: u32,
    dwInstructionOffset: u32,
    dwInstructionLength: u32,
    dwHVertexOffset: u32,
    dsStatus: D3DSTATUS,
};
// --------------------------------------------------------
// Type: D3DVERTEXBUFFERDESC
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const D3DVERTEXBUFFERDESC = extern struct {
    dwSize: u32,
    dwCaps: u32,
    dwFVF: u32,
    dwNumVertices: u32,
};
// --------------------------------------------------------
// Type: D3DDP_PTRSTRIDE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const D3DDP_PTRSTRIDE = extern struct {
    lpvData: ?*opaque{},
    dwStride: u32,
};
// --------------------------------------------------------
// Type: D3DDRAWPRIMITIVESTRIDEDDATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const D3DDRAWPRIMITIVESTRIDEDDATA = extern struct {
    position: D3DDP_PTRSTRIDE,
    normal: D3DDP_PTRSTRIDE,
    diffuse: D3DDP_PTRSTRIDE,
    specular: D3DDP_PTRSTRIDE,
    textureCoords: ?[*]D3DDP_PTRSTRIDE,
};
// --------------------------------------------------------
// Type: D3DSTATEBLOCKTYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const D3DSTATEBLOCKTYPE = *opaque{
};
// --------------------------------------------------------
// Type: D3DVERTEXBLENDFLAGS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const D3DVERTEXBLENDFLAGS = *opaque{
};
// --------------------------------------------------------
// Type: D3DTEXTURETRANSFORMFLAGS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const D3DTEXTURETRANSFORMFLAGS = *opaque{
};
// --------------------------------------------------------
// Type: D3DTRANSFORMCAPS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const D3DTRANSFORMCAPS = extern struct {
    dwSize: u32,
    dwCaps: u32,
};
// --------------------------------------------------------
// Type: D3DLIGHTINGCAPS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const D3DLIGHTINGCAPS = extern struct {
    dwSize: u32,
    dwCaps: u32,
    dwLightingModel: u32,
    dwNumLights: u32,
};
// --------------------------------------------------------
// Type: _D3DPrimCaps
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const _D3DPrimCaps = extern struct {
    dwSize: u32,
    dwMiscCaps: u32,
    dwRasterCaps: u32,
    dwZCmpCaps: u32,
    dwSrcBlendCaps: u32,
    dwDestBlendCaps: u32,
    dwAlphaCmpCaps: u32,
    dwShadeCaps: u32,
    dwTextureCaps: u32,
    dwTextureFilterCaps: u32,
    dwTextureBlendCaps: u32,
    dwTextureAddressCaps: u32,
    dwStippleWidth: u32,
    dwStippleHeight: u32,
};
// --------------------------------------------------------
// Type: _D3DDeviceDesc
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const _D3DDeviceDesc = extern struct {
    dwSize: u32,
    dwFlags: u32,
    dcmColorModel: u32,
    dwDevCaps: u32,
    dtcTransformCaps: D3DTRANSFORMCAPS,
    bClipping: BOOL,
    dlcLightingCaps: D3DLIGHTINGCAPS,
    dpcLineCaps: _D3DPrimCaps,
    dpcTriCaps: _D3DPrimCaps,
    dwDeviceRenderBitDepth: u32,
    dwDeviceZBufferBitDepth: u32,
    dwMaxBufferSize: u32,
    dwMaxVertexCount: u32,
    dwMinTextureWidth: u32,
    dwMinTextureHeight: u32,
    dwMaxTextureWidth: u32,
    dwMaxTextureHeight: u32,
    dwMinStippleWidth: u32,
    dwMaxStippleWidth: u32,
    dwMinStippleHeight: u32,
    dwMaxStippleHeight: u32,
    dwMaxTextureRepeat: u32,
    dwMaxTextureAspectRatio: u32,
    dwMaxAnisotropy: u32,
    dvGuardBandLeft: f32,
    dvGuardBandTop: f32,
    dvGuardBandRight: f32,
    dvGuardBandBottom: f32,
    dvExtentsAdjust: f32,
    dwStencilCaps: u32,
    dwFVFCaps: u32,
    dwTextureOpCaps: u32,
    wMaxTextureBlendStages: u16,
    wMaxSimultaneousTextures: u16,
};
// --------------------------------------------------------
// Type: _D3DDeviceDesc7
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const _D3DDeviceDesc7 = extern struct {
    dwDevCaps: u32,
    dpcLineCaps: _D3DPrimCaps,
    dpcTriCaps: _D3DPrimCaps,
    dwDeviceRenderBitDepth: u32,
    dwDeviceZBufferBitDepth: u32,
    dwMinTextureWidth: u32,
    dwMinTextureHeight: u32,
    dwMaxTextureWidth: u32,
    dwMaxTextureHeight: u32,
    dwMaxTextureRepeat: u32,
    dwMaxTextureAspectRatio: u32,
    dwMaxAnisotropy: u32,
    dvGuardBandLeft: f32,
    dvGuardBandTop: f32,
    dvGuardBandRight: f32,
    dvGuardBandBottom: f32,
    dvExtentsAdjust: f32,
    dwStencilCaps: u32,
    dwFVFCaps: u32,
    dwTextureOpCaps: u32,
    wMaxTextureBlendStages: u16,
    wMaxSimultaneousTextures: u16,
    dwMaxActiveLights: u32,
    dvMaxVertexW: f32,
    deviceGUID: Guid,
    wMaxUserClipPlanes: u16,
    wMaxVertexBlendMatrices: u16,
    dwVertexProcessingCaps: u32,
    dwReserved1: u32,
    dwReserved2: u32,
    dwReserved3: u32,
    dwReserved4: u32,
};
// --------------------------------------------------------
// Type: LPD3DENUMDEVICESCALLBACK
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const LPD3DENUMDEVICESCALLBACK = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: LPD3DENUMDEVICESCALLBACK7
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const LPD3DENUMDEVICESCALLBACK7 = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: D3DFINDDEVICESEARCH
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const D3DFINDDEVICESEARCH = extern struct {
    dwSize: u32,
    dwFlags: u32,
    bHardware: BOOL,
    dcmColorModel: u32,
    guid: Guid,
    dwCaps: u32,
    dpcPrimCaps: _D3DPrimCaps,
};
// --------------------------------------------------------
// Type: D3DFINDDEVICERESULT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const D3DFINDDEVICERESULT = extern struct {
    dwSize: u32,
    guid: Guid,
    ddHwDesc: _D3DDeviceDesc,
    ddSwDesc: _D3DDeviceDesc,
};
// --------------------------------------------------------
// Type: _D3DExecuteBufferDesc
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const _D3DExecuteBufferDesc = extern struct {
    dwSize: u32,
    dwFlags: u32,
    dwCaps: u32,
    dwBufferSize: u32,
    lpData: ?*opaque{},
};
// --------------------------------------------------------
// Type: D3DDEVINFO_TEXTUREMANAGER
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const D3DDEVINFO_TEXTUREMANAGER = extern struct {
    bThrashing: BOOL,
    dwApproxBytesDownloaded: u32,
    dwNumEvicts: u32,
    dwNumVidCreates: u32,
    dwNumTexturesUsed: u32,
    dwNumUsedTexInVid: u32,
    dwWorkingSet: u32,
    dwWorkingSetBytes: u32,
    dwTotalManaged: u32,
    dwTotalBytes: u32,
    dwLastPri: u32,
};
// --------------------------------------------------------
// Type: D3DDEVINFO_TEXTURING
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const D3DDEVINFO_TEXTURING = extern struct {
    dwNumLoads: u32,
    dwApproxBytesLoaded: u32,
    dwNumPreLoads: u32,
    dwNumSet: u32,
    dwNumCreates: u32,
    dwNumDestroys: u32,
    dwNumSetPriorities: u32,
    dwNumSetLODs: u32,
    dwNumLocks: u32,
    dwNumGetDCs: u32,
};
// --------------------------------------------------------
// Type: _D3DNTHALDeviceDesc_V1
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const _D3DNTHALDeviceDesc_V1 = extern struct {
    dwSize: u32,
    dwFlags: u32,
    dcmColorModel: u32,
    dwDevCaps: u32,
    dtcTransformCaps: D3DTRANSFORMCAPS,
    bClipping: BOOL,
    dlcLightingCaps: D3DLIGHTINGCAPS,
    dpcLineCaps: _D3DPrimCaps,
    dpcTriCaps: _D3DPrimCaps,
    dwDeviceRenderBitDepth: u32,
    dwDeviceZBufferBitDepth: u32,
    dwMaxBufferSize: u32,
    dwMaxVertexCount: u32,
};
// --------------------------------------------------------
// Type: _D3DNTHALDeviceDesc_V2
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const _D3DNTHALDeviceDesc_V2 = extern struct {
    dwSize: u32,
    dwFlags: u32,
    dcmColorModel: u32,
    dwDevCaps: u32,
    dtcTransformCaps: D3DTRANSFORMCAPS,
    bClipping: BOOL,
    dlcLightingCaps: D3DLIGHTINGCAPS,
    dpcLineCaps: _D3DPrimCaps,
    dpcTriCaps: _D3DPrimCaps,
    dwDeviceRenderBitDepth: u32,
    dwDeviceZBufferBitDepth: u32,
    dwMaxBufferSize: u32,
    dwMaxVertexCount: u32,
    dwMinTextureWidth: u32,
    dwMinTextureHeight: u32,
    dwMaxTextureWidth: u32,
    dwMaxTextureHeight: u32,
    dwMinStippleWidth: u32,
    dwMaxStippleWidth: u32,
    dwMinStippleHeight: u32,
    dwMaxStippleHeight: u32,
};
// --------------------------------------------------------
// Type: _D3DNTDeviceDesc_V3
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const _D3DNTDeviceDesc_V3 = extern struct {
    dwSize: u32,
    dwFlags: u32,
    dcmColorModel: u32,
    dwDevCaps: u32,
    dtcTransformCaps: D3DTRANSFORMCAPS,
    bClipping: BOOL,
    dlcLightingCaps: D3DLIGHTINGCAPS,
    dpcLineCaps: _D3DPrimCaps,
    dpcTriCaps: _D3DPrimCaps,
    dwDeviceRenderBitDepth: u32,
    dwDeviceZBufferBitDepth: u32,
    dwMaxBufferSize: u32,
    dwMaxVertexCount: u32,
    dwMinTextureWidth: u32,
    dwMinTextureHeight: u32,
    dwMaxTextureWidth: u32,
    dwMaxTextureHeight: u32,
    dwMinStippleWidth: u32,
    dwMaxStippleWidth: u32,
    dwMinStippleHeight: u32,
    dwMaxStippleHeight: u32,
    dwMaxTextureRepeat: u32,
    dwMaxTextureAspectRatio: u32,
    dwMaxAnisotropy: u32,
    dvGuardBandLeft: f32,
    dvGuardBandTop: f32,
    dvGuardBandRight: f32,
    dvGuardBandBottom: f32,
    dvExtentsAdjust: f32,
    dwStencilCaps: u32,
    dwFVFCaps: u32,
    dwTextureOpCaps: u32,
    wMaxTextureBlendStages: u16,
    wMaxSimultaneousTextures: u16,
};
// --------------------------------------------------------
// Type: D3DNTHAL_GLOBALDRIVERDATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const D3DNTHAL_GLOBALDRIVERDATA = extern struct {
    dwSize: u32,
    hwCaps: _D3DNTHALDeviceDesc_V1,
    dwNumVertices: u32,
    dwNumClipVertices: u32,
    dwNumTextureFormats: u32,
    lpTextureFormats: ?*DDSURFACEDESC,
};
// --------------------------------------------------------
// Type: D3DNTHAL_D3DDX6EXTENDEDCAPS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const D3DNTHAL_D3DDX6EXTENDEDCAPS = extern struct {
    dwSize: u32,
    dwMinTextureWidth: u32,
    dwMaxTextureWidth: u32,
    dwMinTextureHeight: u32,
    dwMaxTextureHeight: u32,
    dwMinStippleWidth: u32,
    dwMaxStippleWidth: u32,
    dwMinStippleHeight: u32,
    dwMaxStippleHeight: u32,
    dwMaxTextureRepeat: u32,
    dwMaxTextureAspectRatio: u32,
    dwMaxAnisotropy: u32,
    dvGuardBandLeft: f32,
    dvGuardBandTop: f32,
    dvGuardBandRight: f32,
    dvGuardBandBottom: f32,
    dvExtentsAdjust: f32,
    dwStencilCaps: u32,
    dwFVFCaps: u32,
    dwTextureOpCaps: u32,
    wMaxTextureBlendStages: u16,
    wMaxSimultaneousTextures: u16,
};
// --------------------------------------------------------
// Type: D3DNTHAL_D3DEXTENDEDCAPS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const D3DNTHAL_D3DEXTENDEDCAPS = extern struct {
    dwSize: u32,
    dwMinTextureWidth: u32,
    dwMaxTextureWidth: u32,
    dwMinTextureHeight: u32,
    dwMaxTextureHeight: u32,
    dwMinStippleWidth: u32,
    dwMaxStippleWidth: u32,
    dwMinStippleHeight: u32,
    dwMaxStippleHeight: u32,
    dwMaxTextureRepeat: u32,
    dwMaxTextureAspectRatio: u32,
    dwMaxAnisotropy: u32,
    dvGuardBandLeft: f32,
    dvGuardBandTop: f32,
    dvGuardBandRight: f32,
    dvGuardBandBottom: f32,
    dvExtentsAdjust: f32,
    dwStencilCaps: u32,
    dwFVFCaps: u32,
    dwTextureOpCaps: u32,
    wMaxTextureBlendStages: u16,
    wMaxSimultaneousTextures: u16,
    dwMaxActiveLights: u32,
    dvMaxVertexW: f32,
    wMaxUserClipPlanes: u16,
    wMaxVertexBlendMatrices: u16,
    dwVertexProcessingCaps: u32,
    dwReserved1: u32,
    dwReserved2: u32,
    dwReserved3: u32,
    dwReserved4: u32,
};
// --------------------------------------------------------
// Type: D3DNTHAL_CONTEXTCREATEDATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const D3DNTHAL_CONTEXTCREATEDATA = extern struct {
    Anonymous1: _Anonymous1_e__Union,
    Anonymous2: _Anonymous2_e__Union,
    Anonymous3: _Anonymous3_e__Union,
    dwPID: u32,
    dwhContext: ?*opaque{},
    ddrval: HRESULT,
    // --------------------------------------------------------
    // Type: _Anonymous3_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous3_e__Union = *opaque{
    };
    // --------------------------------------------------------
    // Type: _Anonymous1_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous1_e__Union = *opaque{
    };
    // --------------------------------------------------------
    // Type: _Anonymous2_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous2_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: D3DNTHAL_CONTEXTDESTROYDATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const D3DNTHAL_CONTEXTDESTROYDATA = extern struct {
    dwhContext: ?*opaque{},
    ddrval: HRESULT,
};
// --------------------------------------------------------
// Type: D3DNTHAL_CONTEXTDESTROYALLDATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const D3DNTHAL_CONTEXTDESTROYALLDATA = extern struct {
    dwPID: u32,
    ddrval: HRESULT,
};
// --------------------------------------------------------
// Type: D3DNTHAL_SCENECAPTUREDATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const D3DNTHAL_SCENECAPTUREDATA = extern struct {
    dwhContext: ?*opaque{},
    dwFlag: u32,
    ddrval: HRESULT,
};
// --------------------------------------------------------
// Type: D3DNTHAL_TEXTURECREATEDATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const D3DNTHAL_TEXTURECREATEDATA = extern struct {
    dwhContext: ?*opaque{},
    hDDS: HANDLE,
    dwHandle: ?*opaque{},
    ddrval: HRESULT,
};
// --------------------------------------------------------
// Type: D3DNTHAL_TEXTUREDESTROYDATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const D3DNTHAL_TEXTUREDESTROYDATA = extern struct {
    dwhContext: ?*opaque{},
    dwHandle: ?*opaque{},
    ddrval: HRESULT,
};
// --------------------------------------------------------
// Type: D3DNTHAL_TEXTURESWAPDATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const D3DNTHAL_TEXTURESWAPDATA = extern struct {
    dwhContext: ?*opaque{},
    dwHandle1: ?*opaque{},
    dwHandle2: ?*opaque{},
    ddrval: HRESULT,
};
// --------------------------------------------------------
// Type: D3DNTHAL_TEXTUREGETSURFDATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const D3DNTHAL_TEXTUREGETSURFDATA = extern struct {
    dwhContext: ?*opaque{},
    hDDS: HANDLE,
    dwHandle: ?*opaque{},
    ddrval: HRESULT,
};
// --------------------------------------------------------
// Type: LPD3DNTHAL_CONTEXTCREATECB
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const LPD3DNTHAL_CONTEXTCREATECB = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: LPD3DNTHAL_CONTEXTDESTROYCB
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const LPD3DNTHAL_CONTEXTDESTROYCB = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: LPD3DNTHAL_CONTEXTDESTROYALLCB
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const LPD3DNTHAL_CONTEXTDESTROYALLCB = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: LPD3DNTHAL_SCENECAPTURECB
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const LPD3DNTHAL_SCENECAPTURECB = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: LPD3DNTHAL_TEXTURECREATECB
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const LPD3DNTHAL_TEXTURECREATECB = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: LPD3DNTHAL_TEXTUREDESTROYCB
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const LPD3DNTHAL_TEXTUREDESTROYCB = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: LPD3DNTHAL_TEXTURESWAPCB
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const LPD3DNTHAL_TEXTURESWAPCB = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: LPD3DNTHAL_TEXTUREGETSURFCB
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const LPD3DNTHAL_TEXTUREGETSURFCB = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: D3DNTHAL_CALLBACKS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const D3DNTHAL_CALLBACKS = extern struct {
    dwSize: u32,
    ContextCreate: LPD3DNTHAL_CONTEXTCREATECB,
    ContextDestroy: LPD3DNTHAL_CONTEXTDESTROYCB,
    ContextDestroyAll: LPD3DNTHAL_CONTEXTDESTROYALLCB,
    SceneCapture: LPD3DNTHAL_SCENECAPTURECB,
    dwReserved10: ?*opaque{},
    dwReserved11: ?*opaque{},
    dwReserved22: ?*opaque{},
    dwReserved23: ?*opaque{},
    dwReserved: ?*opaque{},
    TextureCreate: LPD3DNTHAL_TEXTURECREATECB,
    TextureDestroy: LPD3DNTHAL_TEXTUREDESTROYCB,
    TextureSwap: LPD3DNTHAL_TEXTURESWAPCB,
    TextureGetSurf: LPD3DNTHAL_TEXTUREGETSURFCB,
    dwReserved12: ?*opaque{},
    dwReserved13: ?*opaque{},
    dwReserved14: ?*opaque{},
    dwReserved15: ?*opaque{},
    dwReserved16: ?*opaque{},
    dwReserved17: ?*opaque{},
    dwReserved18: ?*opaque{},
    dwReserved19: ?*opaque{},
    dwReserved20: ?*opaque{},
    dwReserved21: ?*opaque{},
    dwReserved24: ?*opaque{},
    dwReserved0: ?*opaque{},
    dwReserved1: ?*opaque{},
    dwReserved2: ?*opaque{},
    dwReserved3: ?*opaque{},
    dwReserved4: ?*opaque{},
    dwReserved5: ?*opaque{},
    dwReserved6: ?*opaque{},
    dwReserved7: ?*opaque{},
    dwReserved8: ?*opaque{},
    dwReserved9: ?*opaque{},
};
// --------------------------------------------------------
// Type: D3DNTHAL_SETRENDERTARGETDATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const D3DNTHAL_SETRENDERTARGETDATA = extern struct {
    dwhContext: ?*opaque{},
    lpDDS: ?*DD_SURFACE_LOCAL,
    lpDDSZ: ?*DD_SURFACE_LOCAL,
    ddrval: HRESULT,
};
// --------------------------------------------------------
// Type: LPD3DNTHAL_SETRENDERTARGETCB
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const LPD3DNTHAL_SETRENDERTARGETCB = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: D3DNTHAL_CALLBACKS2
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const D3DNTHAL_CALLBACKS2 = extern struct {
    dwSize: u32,
    dwFlags: u32,
    SetRenderTarget: LPD3DNTHAL_SETRENDERTARGETCB,
    dwReserved1: ?*opaque{},
    dwReserved2: ?*opaque{},
    dwReserved3: ?*opaque{},
    dwReserved4: ?*opaque{},
};
// --------------------------------------------------------
// Type: D3DNTHAL_CLEAR2DATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const D3DNTHAL_CLEAR2DATA = extern struct {
    dwhContext: ?*opaque{},
    dwFlags: u32,
    dwFillColor: u32,
    dvFillDepth: f32,
    dwFillStencil: u32,
    lpRects: ?*D3DRECT,
    dwNumRects: u32,
    ddrval: HRESULT,
};
// --------------------------------------------------------
// Type: D3DNTHAL_VALIDATETEXTURESTAGESTATEDATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const D3DNTHAL_VALIDATETEXTURESTAGESTATEDATA = extern struct {
    dwhContext: ?*opaque{},
    dwFlags: u32,
    dwReserved: ?*opaque{},
    dwNumPasses: u32,
    ddrval: HRESULT,
};
// --------------------------------------------------------
// Type: D3DNTHAL_DP2COMMAND
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const D3DNTHAL_DP2COMMAND = extern struct {
    bCommand: u8,
    bReserved: u8,
    Anonymous: _Anonymous_e__Union,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: D3DNTHAL_DP2OPERATION
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const D3DNTHAL_DP2OPERATION = *opaque{
};
// --------------------------------------------------------
// Type: D3DNTHAL_DP2POINTS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const D3DNTHAL_DP2POINTS = extern struct {
    wCount: u16,
    wVStart: u16,
};
// --------------------------------------------------------
// Type: D3DNTHAL_DP2STARTVERTEX
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const D3DNTHAL_DP2STARTVERTEX = extern struct {
    wVStart: u16,
};
// --------------------------------------------------------
// Type: D3DNTHAL_DP2LINELIST
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const D3DNTHAL_DP2LINELIST = extern struct {
    wVStart: u16,
};
// --------------------------------------------------------
// Type: D3DNTHAL_DP2INDEXEDLINELIST
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const D3DNTHAL_DP2INDEXEDLINELIST = extern struct {
    wV1: u16,
    wV2: u16,
};
// --------------------------------------------------------
// Type: D3DNTHAL_DP2LINESTRIP
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const D3DNTHAL_DP2LINESTRIP = extern struct {
    wVStart: u16,
};
// --------------------------------------------------------
// Type: D3DNTHAL_DP2INDEXEDLINESTRIP
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const D3DNTHAL_DP2INDEXEDLINESTRIP = extern struct {
    wV: ?[*]u16,
};
// --------------------------------------------------------
// Type: D3DNTHAL_DP2TRIANGLELIST
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const D3DNTHAL_DP2TRIANGLELIST = extern struct {
    wVStart: u16,
};
// --------------------------------------------------------
// Type: D3DNTHAL_DP2INDEXEDTRIANGLELIST
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const D3DNTHAL_DP2INDEXEDTRIANGLELIST = extern struct {
    wV1: u16,
    wV2: u16,
    wV3: u16,
    wFlags: u16,
};
// --------------------------------------------------------
// Type: D3DNTHAL_DP2INDEXEDTRIANGLELIST2
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const D3DNTHAL_DP2INDEXEDTRIANGLELIST2 = extern struct {
    wV1: u16,
    wV2: u16,
    wV3: u16,
};
// --------------------------------------------------------
// Type: D3DNTHAL_DP2TRIANGLESTRIP
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const D3DNTHAL_DP2TRIANGLESTRIP = extern struct {
    wVStart: u16,
};
// --------------------------------------------------------
// Type: D3DNTHAL_DP2INDEXEDTRIANGLESTRIP
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const D3DNTHAL_DP2INDEXEDTRIANGLESTRIP = extern struct {
    wV: ?[*]u16,
};
// --------------------------------------------------------
// Type: D3DNTHAL_DP2TRIANGLEFAN
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const D3DNTHAL_DP2TRIANGLEFAN = extern struct {
    wVStart: u16,
};
// --------------------------------------------------------
// Type: D3DNTHAL_DP2INDEXEDTRIANGLEFAN
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const D3DNTHAL_DP2INDEXEDTRIANGLEFAN = extern struct {
    wV: ?[*]u16,
};
// --------------------------------------------------------
// Type: D3DNTHAL_DP2TRIANGLEFAN_IMM
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const D3DNTHAL_DP2TRIANGLEFAN_IMM = extern struct {
    dwEdgeFlags: u32,
};
// --------------------------------------------------------
// Type: D3DNTHAL_DP2RENDERSTATE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const D3DNTHAL_DP2RENDERSTATE = extern struct {
    RenderState: D3DRENDERSTATETYPE,
    Anonymous: _Anonymous_e__Union,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: D3DNTHAL_DP2TEXTURESTAGESTATE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const D3DNTHAL_DP2TEXTURESTAGESTATE = extern struct {
    wStage: u16,
    TSState: u16,
    dwValue: u32,
};
// --------------------------------------------------------
// Type: D3DNTHAL_DP2VIEWPORTINFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const D3DNTHAL_DP2VIEWPORTINFO = extern struct {
    dwX: u32,
    dwY: u32,
    dwWidth: u32,
    dwHeight: u32,
};
// --------------------------------------------------------
// Type: D3DNTHAL_DP2WINFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const D3DNTHAL_DP2WINFO = extern struct {
    dvWNear: f32,
    dvWFar: f32,
};
// --------------------------------------------------------
// Type: D3DNTHAL_DP2SETPALETTE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const D3DNTHAL_DP2SETPALETTE = extern struct {
    dwPaletteHandle: u32,
    dwPaletteFlags: u32,
    dwSurfaceHandle: u32,
};
// --------------------------------------------------------
// Type: D3DNTHAL_DP2UPDATEPALETTE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const D3DNTHAL_DP2UPDATEPALETTE = extern struct {
    dwPaletteHandle: u32,
    wStartIndex: u16,
    wNumEntries: u16,
};
// --------------------------------------------------------
// Type: D3DNTHAL_DP2SETRENDERTARGET
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const D3DNTHAL_DP2SETRENDERTARGET = extern struct {
    hRenderTarget: u32,
    hZBuffer: u32,
};
// --------------------------------------------------------
// Type: D3DNTHAL_DP2STATESET
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const D3DNTHAL_DP2STATESET = extern struct {
    dwOperation: u32,
    dwParam: u32,
    sbType: D3DSTATEBLOCKTYPE,
};
// --------------------------------------------------------
// Type: D3DNTHAL_DP2ZRANGE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const D3DNTHAL_DP2ZRANGE = extern struct {
    dvMinZ: f32,
    dvMaxZ: f32,
};
// --------------------------------------------------------
// Type: D3DNTHAL_DP2SETLIGHT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const D3DNTHAL_DP2SETLIGHT = extern struct {
    dwIndex: u32,
    Anonymous: _Anonymous_e__Union,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: D3DNTHAL_DP2SETCLIPPLANE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const D3DNTHAL_DP2SETCLIPPLANE = extern struct {
    dwIndex: u32,
    plane: ?[*]f32,
};
// --------------------------------------------------------
// Type: D3DNTHAL_DP2CREATELIGHT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const D3DNTHAL_DP2CREATELIGHT = extern struct {
    dwIndex: u32,
};
// --------------------------------------------------------
// Type: D3DNTHAL_DP2SETTRANSFORM
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const D3DNTHAL_DP2SETTRANSFORM = extern struct {
    xfrmType: D3DTRANSFORMSTATETYPE,
    matrix: D3DMATRIX,
};
// --------------------------------------------------------
// Type: D3DNTHAL_DP2EXT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const D3DNTHAL_DP2EXT = extern struct {
    dwExtToken: u32,
    dwSize: u32,
};
// --------------------------------------------------------
// Type: D3DNTHAL_DP2TEXBLT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const D3DNTHAL_DP2TEXBLT = extern struct {
    dwDDDestSurface: u32,
    dwDDSrcSurface: u32,
    pDest: POINT,
    rSrc: RECTL,
    dwFlags: u32,
};
// --------------------------------------------------------
// Type: D3DNTHAL_DP2SETPRIORITY
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const D3DNTHAL_DP2SETPRIORITY = extern struct {
    dwDDDestSurface: u32,
    dwPriority: u32,
};
// --------------------------------------------------------
// Type: D3DNTHAL_DP2CLEAR
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const D3DNTHAL_DP2CLEAR = extern struct {
    dwFlags: u32,
    dwFillColor: u32,
    dvFillDepth: f32,
    dwFillStencil: u32,
    Rects: ?[*]RECT,
};
// --------------------------------------------------------
// Type: D3DNTHAL_DP2SETTEXLOD
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const D3DNTHAL_DP2SETTEXLOD = extern struct {
    dwDDSurface: u32,
    dwLOD: u32,
};
// --------------------------------------------------------
// Type: D3DNTHAL_DRAWPRIMITIVES2DATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const D3DNTHAL_DRAWPRIMITIVES2DATA = extern struct {
    dwhContext: ?*opaque{},
    dwFlags: u32,
    dwVertexType: u32,
    lpDDCommands: ?*DD_SURFACE_LOCAL,
    dwCommandOffset: u32,
    dwCommandLength: u32,
    Anonymous1: _Anonymous1_e__Union,
    dwVertexOffset: u32,
    dwVertexLength: u32,
    dwReqVertexBufSize: u32,
    dwReqCommandBufSize: u32,
    lpdwRStates: ?*u32,
    Anonymous2: _Anonymous2_e__Union,
    dwErrorOffset: u32,
    // --------------------------------------------------------
    // Type: _Anonymous1_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous1_e__Union = *opaque{
    };
    // --------------------------------------------------------
    // Type: _Anonymous2_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous2_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: LPD3DNTHAL_CLEAR2CB
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const LPD3DNTHAL_CLEAR2CB = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: LPD3DNTHAL_VALIDATETEXTURESTAGESTATECB
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const LPD3DNTHAL_VALIDATETEXTURESTAGESTATECB = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: LPD3DNTHAL_DRAWPRIMITIVES2CB
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const LPD3DNTHAL_DRAWPRIMITIVES2CB = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: D3DNTHAL_CALLBACKS3
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const D3DNTHAL_CALLBACKS3 = extern struct {
    dwSize: u32,
    dwFlags: u32,
    Clear2: LPD3DNTHAL_CLEAR2CB,
    lpvReserved: ?*opaque{},
    ValidateTextureStageState: LPD3DNTHAL_VALIDATETEXTURESTAGESTATECB,
    DrawPrimitives2: LPD3DNTHAL_DRAWPRIMITIVES2CB,
};
// --------------------------------------------------------
// Type: PFND3DNTPARSEUNKNOWNCOMMAND
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFND3DNTPARSEUNKNOWNCOMMAND = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: POINTE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const POINTE = extern struct {
    x: u32,
    y: u32,
};
// --------------------------------------------------------
// Type: FLOAT_LONG
// TypeLayoutAttr: explicit
// not generating the actual code for this type because it has an explicit layout
pub const FLOAT_LONG = *opaque{
};
// --------------------------------------------------------
// Type: POINTFIX
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const POINTFIX = extern struct {
    x: i32,
    y: i32,
};
// --------------------------------------------------------
// Type: RECTFX
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const RECTFX = extern struct {
    xLeft: i32,
    yTop: i32,
    xRight: i32,
    yBottom: i32,
};
// --------------------------------------------------------
// Type: HBM__
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HBM__ = extern struct {
    unused: i32,
};
// --------------------------------------------------------
// Type: HDEV__
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HDEV__ = extern struct {
    unused: i32,
};
// --------------------------------------------------------
// Type: HSURF__
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HSURF__ = extern struct {
    unused: i32,
};
// --------------------------------------------------------
// Type: DHSURF__
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DHSURF__ = extern struct {
    unused: i32,
};
// --------------------------------------------------------
// Type: DHPDEV__
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DHPDEV__ = extern struct {
    unused: i32,
};
// --------------------------------------------------------
// Type: HDRVOBJ__
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HDRVOBJ__ = extern struct {
    unused: i32,
};
// --------------------------------------------------------
// Type: LIGATURE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const LIGATURE = extern struct {
    culSize: u32,
    pwsz: ?*u16,
    chglyph: u32,
    ahglyph: ?[*]u32,
};
// --------------------------------------------------------
// Type: FD_LIGATURE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const FD_LIGATURE = extern struct {
    culThis: u32,
    ulType: u32,
    cLigatures: u32,
    alig: ?[*]LIGATURE,
};
// --------------------------------------------------------
// Type: POINTQF
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const POINTQF = extern struct {
    x: LARGE_INTEGER,
    y: LARGE_INTEGER,
};
// --------------------------------------------------------
// Type: PFN
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFN = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: CDDDXGK_REDIRBITMAPPRESENTINFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CDDDXGK_REDIRBITMAPPRESENTINFO = extern struct {
    NumDirtyRects: u32,
    DirtyRect: ?*RECT,
    NumContexts: u32,
    hContext: ?[*]?*opaque{},
    bDoNotSynchronizeWithDxContent: u8,
};
// --------------------------------------------------------
// Type: FREEOBJPROC
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const FREEOBJPROC = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: XFORMOBJ
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const XFORMOBJ = extern struct {
    ulReserved: u32,
};
// --------------------------------------------------------
// Type: WNDOBJCHANGEPROC
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const WNDOBJCHANGEPROC = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: HSEMAPHORE__
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HSEMAPHORE__ = extern struct {
    unused: i32,
};
// --------------------------------------------------------
// Type: HFASTMUTEX__
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HFASTMUTEX__ = extern struct {
    unused: i32,
};
// --------------------------------------------------------
// Type: SORTCOMP
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const SORTCOMP = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: ENG_SYSTEM_ATTRIBUTE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const ENG_SYSTEM_ATTRIBUTE = *opaque{
};
// --------------------------------------------------------
// Type: ENG_DEVICE_ATTRIBUTE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const ENG_DEVICE_ATTRIBUTE = *opaque{
};
// --------------------------------------------------------
// Type: EMFINFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const EMFINFO = extern struct {
    nSize: u32,
    hdc: HDC,
    pvEMF: ?*u8,
    pvCurrentRecord: ?*u8,
};
// --------------------------------------------------------
// Type: PFN_DrvEnableDriver
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFN_DrvEnableDriver = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PFN_DrvEnablePDEV
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFN_DrvEnablePDEV = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PFN_DrvCompletePDEV
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFN_DrvCompletePDEV = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PFN_DrvResetDevice
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFN_DrvResetDevice = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PFN_DrvDisablePDEV
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFN_DrvDisablePDEV = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PFN_DrvSynchronize
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFN_DrvSynchronize = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PFN_DrvEnableSurface
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFN_DrvEnableSurface = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PFN_DrvDisableDriver
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFN_DrvDisableDriver = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PFN_DrvDisableSurface
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFN_DrvDisableSurface = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PFN_DrvAssertMode
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFN_DrvAssertMode = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PFN_DrvTextOut
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFN_DrvTextOut = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PFN_DrvStretchBlt
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFN_DrvStretchBlt = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PFN_DrvStretchBltROP
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFN_DrvStretchBltROP = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PFN_DrvTransparentBlt
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFN_DrvTransparentBlt = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PFN_DrvPlgBlt
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFN_DrvPlgBlt = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PFN_DrvBitBlt
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFN_DrvBitBlt = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PFN_DrvRealizeBrush
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFN_DrvRealizeBrush = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PFN_DrvCopyBits
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFN_DrvCopyBits = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PFN_DrvDitherColor
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFN_DrvDitherColor = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PFN_DrvCreateDeviceBitmap
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFN_DrvCreateDeviceBitmap = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PFN_DrvDeleteDeviceBitmap
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFN_DrvDeleteDeviceBitmap = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PFN_DrvSetPalette
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFN_DrvSetPalette = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PFN_DrvEscape
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFN_DrvEscape = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PFN_DrvDrawEscape
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFN_DrvDrawEscape = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PFN_DrvQueryFont
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFN_DrvQueryFont = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PFN_DrvQueryFontTree
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFN_DrvQueryFontTree = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PFN_DrvQueryFontData
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFN_DrvQueryFontData = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PFN_DrvFree
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFN_DrvFree = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PFN_DrvDestroyFont
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFN_DrvDestroyFont = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PFN_DrvQueryFontCaps
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFN_DrvQueryFontCaps = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PFN_DrvLoadFontFile
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFN_DrvLoadFontFile = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PFN_DrvUnloadFontFile
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFN_DrvUnloadFontFile = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PFN_DrvSetPointerShape
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFN_DrvSetPointerShape = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PFN_DrvMovePointer
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFN_DrvMovePointer = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PFN_DrvSendPage
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFN_DrvSendPage = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PFN_DrvStartPage
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFN_DrvStartPage = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PFN_DrvStartDoc
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFN_DrvStartDoc = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PFN_DrvEndDoc
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFN_DrvEndDoc = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PFN_DrvQuerySpoolType
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFN_DrvQuerySpoolType = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PFN_DrvLineTo
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFN_DrvLineTo = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PFN_DrvStrokePath
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFN_DrvStrokePath = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PFN_DrvFillPath
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFN_DrvFillPath = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PFN_DrvStrokeAndFillPath
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFN_DrvStrokeAndFillPath = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PFN_DrvPaint
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFN_DrvPaint = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PFN_DrvGetGlyphMode
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFN_DrvGetGlyphMode = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PFN_DrvResetPDEV
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFN_DrvResetPDEV = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PFN_DrvSaveScreenBits
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFN_DrvSaveScreenBits = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PFN_DrvGetModes
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFN_DrvGetModes = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PFN_DrvQueryTrueTypeTable
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFN_DrvQueryTrueTypeTable = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PFN_DrvQueryTrueTypeSection
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFN_DrvQueryTrueTypeSection = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PFN_DrvQueryTrueTypeOutline
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFN_DrvQueryTrueTypeOutline = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PFN_DrvGetTrueTypeFile
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFN_DrvGetTrueTypeFile = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PFN_DrvQueryFontFile
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFN_DrvQueryFontFile = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PFN_DrvQueryAdvanceWidths
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFN_DrvQueryAdvanceWidths = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PFN_DrvFontManagement
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFN_DrvFontManagement = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PFN_DrvSetPixelFormat
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFN_DrvSetPixelFormat = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PFN_DrvDescribePixelFormat
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFN_DrvDescribePixelFormat = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PFN_DrvSwapBuffers
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFN_DrvSwapBuffers = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PFN_DrvStartBanding
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFN_DrvStartBanding = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PFN_DrvNextBand
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFN_DrvNextBand = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PFN_DrvQueryPerBandInfo
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFN_DrvQueryPerBandInfo = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PFN_DrvEnableDirectDraw
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFN_DrvEnableDirectDraw = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PFN_DrvDisableDirectDraw
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFN_DrvDisableDirectDraw = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PFN_DrvGetDirectDrawInfo
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFN_DrvGetDirectDrawInfo = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PFN_DrvIcmCreateColorTransform
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFN_DrvIcmCreateColorTransform = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PFN_DrvIcmDeleteColorTransform
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFN_DrvIcmDeleteColorTransform = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PFN_DrvIcmCheckBitmapBits
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFN_DrvIcmCheckBitmapBits = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PFN_DrvIcmSetDeviceGammaRamp
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFN_DrvIcmSetDeviceGammaRamp = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PFN_DrvAlphaBlend
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFN_DrvAlphaBlend = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PFN_DrvGradientFill
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFN_DrvGradientFill = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PFN_DrvQueryDeviceSupport
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFN_DrvQueryDeviceSupport = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PFN_DrvDeriveSurface
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFN_DrvDeriveSurface = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PFN_DrvSynchronizeSurface
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFN_DrvSynchronizeSurface = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PFN_DrvNotify
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFN_DrvNotify = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PFN_DrvRenderHint
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFN_DrvRenderHint = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: DRH_APIBITMAPDATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DRH_APIBITMAPDATA = extern struct {
    pso: ?*SURFOBJ,
    b: BOOL,
};
// --------------------------------------------------------
// Type: PFN_EngCreateRectRgn
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFN_EngCreateRectRgn = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PFN_EngDeleteRgn
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFN_EngDeleteRgn = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PFN_EngCombineRgn
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFN_EngCombineRgn = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PFN_EngCopyRgn
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFN_EngCopyRgn = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PFN_EngIntersectRgn
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFN_EngIntersectRgn = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PFN_EngSubtractRgn
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFN_EngSubtractRgn = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PFN_EngUnionRgn
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFN_EngUnionRgn = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PFN_EngXorRgn
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFN_EngXorRgn = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PFN_DrvCreateDeviceBitmapEx
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFN_DrvCreateDeviceBitmapEx = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PFN_DrvDeleteDeviceBitmapEx
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFN_DrvDeleteDeviceBitmapEx = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PFN_DrvAssociateSharedSurface
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFN_DrvAssociateSharedSurface = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PFN_DrvSynchronizeRedirectionBitmaps
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFN_DrvSynchronizeRedirectionBitmaps = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PFN_DrvAccumulateD3DDirtyRect
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFN_DrvAccumulateD3DDirtyRect = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PFN_DrvStartDxInterop
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFN_DrvStartDxInterop = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PFN_DrvEndDxInterop
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFN_DrvEndDxInterop = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PFN_DrvLockDisplayArea
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFN_DrvLockDisplayArea = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PFN_DrvUnlockDisplayArea
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFN_DrvUnlockDisplayArea = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PFN_DrvSurfaceComplete
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFN_DrvSurfaceComplete = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: DEVICE_EVENT_MOUNT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DEVICE_EVENT_MOUNT = extern struct {
    Version: u32,
    Flags: u32,
    FileSystemNameLength: u32,
    FileSystemNameOffset: u32,
};
// --------------------------------------------------------
// Type: DEVICE_EVENT_BECOMING_READY
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DEVICE_EVENT_BECOMING_READY = extern struct {
    Version: u32,
    Reason: u32,
    Estimated100msToReady: u32,
};
// --------------------------------------------------------
// Type: DEVICE_EVENT_EXTERNAL_REQUEST
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DEVICE_EVENT_EXTERNAL_REQUEST = extern struct {
    Version: u32,
    DeviceClass: u32,
    ButtonStatus: u16,
    Request: u16,
    SystemTime: LARGE_INTEGER,
};
// --------------------------------------------------------
// Type: DEVICE_EVENT_GENERIC_DATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DEVICE_EVENT_GENERIC_DATA = extern struct {
    EventNumber: u32,
};
// --------------------------------------------------------
// Type: DEVICE_EVENT_RBC_DATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DEVICE_EVENT_RBC_DATA = extern struct {
    EventNumber: u32,
    SenseQualifier: u8,
    SenseCode: u8,
    SenseKey: u8,
    Reserved: u8,
    Information: u32,
};
// --------------------------------------------------------
// Type: GUID_IO_DISK_CLONE_ARRIVAL_INFORMATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const GUID_IO_DISK_CLONE_ARRIVAL_INFORMATION = extern struct {
    DiskNumber: u32,
};
// --------------------------------------------------------
// Type: DISK_HEALTH_NOTIFICATION_DATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DISK_HEALTH_NOTIFICATION_DATA = extern struct {
    DeviceGuid: Guid,
};
// --------------------------------------------------------
// Type: DEVPROPKEY
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DEVPROPKEY = extern struct {
    fmtid: Guid,
    pid: u32,
};
// --------------------------------------------------------
// Type: DEVPROPSTORE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const DEVPROPSTORE = *opaque{
};
// --------------------------------------------------------
// Type: DEVPROPCOMPKEY
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DEVPROPCOMPKEY = extern struct {
    Key: DEVPROPKEY,
    Store: DEVPROPSTORE,
    LocaleName: ?*u16,
};
// --------------------------------------------------------
// Type: DEVPROPERTY
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DEVPROPERTY = extern struct {
    CompKey: DEVPROPCOMPKEY,
    Type: u32,
    BufferSize: u32,
    Buffer: ?*opaque{},
};
// --------------------------------------------------------
// Type: REDBOOK_DIGITAL_AUDIO_EXTRACTION_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const REDBOOK_DIGITAL_AUDIO_EXTRACTION_INFO = extern struct {
    Version: u32,
    Accurate: u32,
    Supported: u32,
    AccurateMask0: u32,
};
// --------------------------------------------------------
// Type: DEV_BROADCAST_HDR
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DEV_BROADCAST_HDR = extern struct {
    dbch_size: u32,
    dbch_devicetype: u32,
    dbch_reserved: u32,
};
// --------------------------------------------------------
// Type: VolLockBroadcast
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VolLockBroadcast = extern struct {
    vlb_dbh: DEV_BROADCAST_HDR,
    vlb_owner: u32,
    vlb_perms: u8,
    vlb_lockType: u8,
    vlb_drive: u8,
    vlb_flags: u8,
};
// --------------------------------------------------------
// Type: _DEV_BROADCAST_HEADER
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const _DEV_BROADCAST_HEADER = extern struct {
    dbcd_size: u32,
    dbcd_devicetype: u32,
    dbcd_reserved: u32,
};
// --------------------------------------------------------
// Type: DEV_BROADCAST_OEM
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DEV_BROADCAST_OEM = extern struct {
    dbco_size: u32,
    dbco_devicetype: u32,
    dbco_reserved: u32,
    dbco_identifier: u32,
    dbco_suppfunc: u32,
};
// --------------------------------------------------------
// Type: DEV_BROADCAST_DEVNODE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DEV_BROADCAST_DEVNODE = extern struct {
    dbcd_size: u32,
    dbcd_devicetype: u32,
    dbcd_reserved: u32,
    dbcd_devnode: u32,
};
// --------------------------------------------------------
// Type: DEV_BROADCAST_VOLUME
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DEV_BROADCAST_VOLUME = extern struct {
    dbcv_size: u32,
    dbcv_devicetype: u32,
    dbcv_reserved: u32,
    dbcv_unitmask: u32,
    dbcv_flags: u16,
};
// --------------------------------------------------------
// Type: DEV_BROADCAST_PORT_A
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DEV_BROADCAST_PORT_A = extern struct {
    dbcp_size: u32,
    dbcp_devicetype: u32,
    dbcp_reserved: u32,
    dbcp_name: ?[*]i8,
};
// --------------------------------------------------------
// Type: DEV_BROADCAST_PORT_W
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DEV_BROADCAST_PORT_W = extern struct {
    dbcp_size: u32,
    dbcp_devicetype: u32,
    dbcp_reserved: u32,
    dbcp_name: ?[*]u16,
};
// --------------------------------------------------------
// Type: DEV_BROADCAST_NET
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DEV_BROADCAST_NET = extern struct {
    dbcn_size: u32,
    dbcn_devicetype: u32,
    dbcn_reserved: u32,
    dbcn_resource: u32,
    dbcn_flags: u32,
};
// --------------------------------------------------------
// Type: DEV_BROADCAST_DEVICEINTERFACE_A
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DEV_BROADCAST_DEVICEINTERFACE_A = extern struct {
    dbcc_size: u32,
    dbcc_devicetype: u32,
    dbcc_reserved: u32,
    dbcc_classguid: Guid,
    dbcc_name: ?[*]i8,
};
// --------------------------------------------------------
// Type: DEV_BROADCAST_DEVICEINTERFACE_W
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DEV_BROADCAST_DEVICEINTERFACE_W = extern struct {
    dbcc_size: u32,
    dbcc_devicetype: u32,
    dbcc_reserved: u32,
    dbcc_classguid: Guid,
    dbcc_name: ?[*]u16,
};
// --------------------------------------------------------
// Type: DEV_BROADCAST_HANDLE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DEV_BROADCAST_HANDLE = extern struct {
    dbch_size: u32,
    dbch_devicetype: u32,
    dbch_reserved: u32,
    dbch_handle: HANDLE,
    dbch_hdevnotify: ?*opaque{},
    dbch_eventguid: Guid,
    dbch_nameoffset: i32,
    dbch_data: ?[*]u8,
};
// --------------------------------------------------------
// Type: DEV_BROADCAST_HANDLE32
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DEV_BROADCAST_HANDLE32 = extern struct {
    dbch_size: u32,
    dbch_devicetype: u32,
    dbch_reserved: u32,
    dbch_handle: u32,
    dbch_hdevnotify: u32,
    dbch_eventguid: Guid,
    dbch_nameoffset: i32,
    dbch_data: ?[*]u8,
};
// --------------------------------------------------------
// Type: DEV_BROADCAST_HANDLE64
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DEV_BROADCAST_HANDLE64 = extern struct {
    dbch_size: u32,
    dbch_devicetype: u32,
    dbch_reserved: u32,
    dbch_handle: u64,
    dbch_hdevnotify: u64,
    dbch_eventguid: Guid,
    dbch_nameoffset: i32,
    dbch_data: ?[*]u8,
};
// --------------------------------------------------------
// Type: _DEV_BROADCAST_USERDEFINED
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const _DEV_BROADCAST_USERDEFINED = extern struct {
    dbud_dbh: DEV_BROADCAST_HDR,
    dbud_szName: ?[*]i8,
};
// --------------------------------------------------------
// Type: PWM_CONTROLLER_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PWM_CONTROLLER_INFO = extern struct {
    Size: ?*opaque{},
    PinCount: u32,
    MinimumPeriod: u64,
    MaximumPeriod: u64,
};
// --------------------------------------------------------
// Type: PWM_CONTROLLER_GET_ACTUAL_PERIOD_OUTPUT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PWM_CONTROLLER_GET_ACTUAL_PERIOD_OUTPUT = extern struct {
    ActualPeriod: u64,
};
// --------------------------------------------------------
// Type: PWM_CONTROLLER_SET_DESIRED_PERIOD_INPUT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PWM_CONTROLLER_SET_DESIRED_PERIOD_INPUT = extern struct {
    DesiredPeriod: u64,
};
// --------------------------------------------------------
// Type: PWM_CONTROLLER_SET_DESIRED_PERIOD_OUTPUT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PWM_CONTROLLER_SET_DESIRED_PERIOD_OUTPUT = extern struct {
    ActualPeriod: u64,
};
// --------------------------------------------------------
// Type: PWM_PIN_GET_ACTIVE_DUTY_CYCLE_PERCENTAGE_OUTPUT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PWM_PIN_GET_ACTIVE_DUTY_CYCLE_PERCENTAGE_OUTPUT = extern struct {
    Percentage: u64,
};
// --------------------------------------------------------
// Type: PWM_PIN_SET_ACTIVE_DUTY_CYCLE_PERCENTAGE_INPUT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PWM_PIN_SET_ACTIVE_DUTY_CYCLE_PERCENTAGE_INPUT = extern struct {
    Percentage: u64,
};
// --------------------------------------------------------
// Type: PWM_POLARITY
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PWM_POLARITY = *opaque{
};
// --------------------------------------------------------
// Type: PWM_PIN_GET_POLARITY_OUTPUT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PWM_PIN_GET_POLARITY_OUTPUT = extern struct {
    Polarity: PWM_POLARITY,
};
// --------------------------------------------------------
// Type: PWM_PIN_SET_POLARITY_INPUT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PWM_PIN_SET_POLARITY_INPUT = extern struct {
    Polarity: PWM_POLARITY,
};
// --------------------------------------------------------
// Type: PWM_PIN_IS_STARTED_OUTPUT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PWM_PIN_IS_STARTED_OUTPUT = extern struct {
    IsStarted: u8,
};
// --------------------------------------------------------
// Type: AtlThunkData_t
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const AtlThunkData_t = opaque {
};
// --------------------------------------------------------
// Type: ENCLAVE_SEALING_IDENTITY_POLICY
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const ENCLAVE_SEALING_IDENTITY_POLICY = *opaque{
};
// --------------------------------------------------------
// Type: ENCLAVE_IDENTITY
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const ENCLAVE_IDENTITY = *opaque{
};
// --------------------------------------------------------
// Type: VBS_ENCLAVE_REPORT_PKG_HEADER
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const VBS_ENCLAVE_REPORT_PKG_HEADER = *opaque{
};
// --------------------------------------------------------
// Type: VBS_ENCLAVE_REPORT
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const VBS_ENCLAVE_REPORT = *opaque{
};
// --------------------------------------------------------
// Type: VBS_ENCLAVE_REPORT_VARDATA_HEADER
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const VBS_ENCLAVE_REPORT_VARDATA_HEADER = *opaque{
};
// --------------------------------------------------------
// Type: VBS_ENCLAVE_REPORT_MODULE
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const VBS_ENCLAVE_REPORT_MODULE = *opaque{
};
// --------------------------------------------------------
// Type: ENCLAVE_INFORMATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const ENCLAVE_INFORMATION = extern struct {
    EnclaveType: u32,
    Reserved: u32,
    BaseAddress: ?*opaque{},
    Size: ?*opaque{},
    Identity: ENCLAVE_IDENTITY,
};
// --------------------------------------------------------
// Type: VBS_BASIC_ENCLAVE_THREAD_DESCRIPTOR32
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VBS_BASIC_ENCLAVE_THREAD_DESCRIPTOR32 = extern struct {
    ThreadContext: ?[*]u32,
    EntryPoint: u32,
    StackPointer: u32,
    ExceptionEntryPoint: u32,
    ExceptionStack: u32,
    ExceptionActive: u32,
};
// --------------------------------------------------------
// Type: VBS_BASIC_ENCLAVE_THREAD_DESCRIPTOR64
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VBS_BASIC_ENCLAVE_THREAD_DESCRIPTOR64 = extern struct {
    ThreadContext: ?[*]u64,
    EntryPoint: u64,
    StackPointer: u64,
    ExceptionEntryPoint: u64,
    ExceptionStack: u64,
    ExceptionActive: u32,
};
// --------------------------------------------------------
// Type: VBS_BASIC_ENCLAVE_EXCEPTION_AMD64
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VBS_BASIC_ENCLAVE_EXCEPTION_AMD64 = extern struct {
    ExceptionCode: u32,
    NumberParameters: u32,
    ExceptionInformation: ?[*]?*opaque{},
    ExceptionRAX: ?*opaque{},
    ExceptionRCX: ?*opaque{},
    ExceptionRIP: ?*opaque{},
    ExceptionRFLAGS: ?*opaque{},
    ExceptionRSP: ?*opaque{},
};
// --------------------------------------------------------
// Type: VBS_BASIC_ENCLAVE_BASIC_CALL_RETURN_FROM_ENCLAVE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const VBS_BASIC_ENCLAVE_BASIC_CALL_RETURN_FROM_ENCLAVE = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: VBS_BASIC_ENCLAVE_BASIC_CALL_RETURN_FROM_EXCEPTION
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const VBS_BASIC_ENCLAVE_BASIC_CALL_RETURN_FROM_EXCEPTION = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: VBS_BASIC_ENCLAVE_BASIC_CALL_TERMINATE_THREAD
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const VBS_BASIC_ENCLAVE_BASIC_CALL_TERMINATE_THREAD = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: VBS_BASIC_ENCLAVE_BASIC_CALL_INTERRUPT_THREAD
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const VBS_BASIC_ENCLAVE_BASIC_CALL_INTERRUPT_THREAD = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: VBS_BASIC_ENCLAVE_BASIC_CALL_COMMIT_PAGES
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const VBS_BASIC_ENCLAVE_BASIC_CALL_COMMIT_PAGES = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: VBS_BASIC_ENCLAVE_BASIC_CALL_DECOMMIT_PAGES
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const VBS_BASIC_ENCLAVE_BASIC_CALL_DECOMMIT_PAGES = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: VBS_BASIC_ENCLAVE_BASIC_CALL_PROTECT_PAGES
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const VBS_BASIC_ENCLAVE_BASIC_CALL_PROTECT_PAGES = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: VBS_BASIC_ENCLAVE_BASIC_CALL_CREATE_THREAD
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const VBS_BASIC_ENCLAVE_BASIC_CALL_CREATE_THREAD = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: VBS_BASIC_ENCLAVE_BASIC_CALL_GET_ENCLAVE_INFORMATION
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const VBS_BASIC_ENCLAVE_BASIC_CALL_GET_ENCLAVE_INFORMATION = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: ENCLAVE_VBS_BASIC_KEY_REQUEST
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const ENCLAVE_VBS_BASIC_KEY_REQUEST = extern struct {
    RequestSize: u32,
    Flags: u32,
    EnclaveSVN: u32,
    SystemKeyID: u32,
    CurrentSystemKeyID: u32,
};
// --------------------------------------------------------
// Type: VBS_BASIC_ENCLAVE_BASIC_CALL_GENERATE_KEY
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const VBS_BASIC_ENCLAVE_BASIC_CALL_GENERATE_KEY = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: VBS_BASIC_ENCLAVE_BASIC_CALL_GENERATE_REPORT
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const VBS_BASIC_ENCLAVE_BASIC_CALL_GENERATE_REPORT = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: VBS_BASIC_ENCLAVE_BASIC_CALL_VERIFY_REPORT
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const VBS_BASIC_ENCLAVE_BASIC_CALL_VERIFY_REPORT = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: VBS_BASIC_ENCLAVE_BASIC_CALL_GENERATE_RANDOM_DATA
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const VBS_BASIC_ENCLAVE_BASIC_CALL_GENERATE_RANDOM_DATA = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: VBS_BASIC_ENCLAVE_SYSCALL_PAGE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VBS_BASIC_ENCLAVE_SYSCALL_PAGE = extern struct {
    ReturnFromEnclave: ?*VBS_BASIC_ENCLAVE_BASIC_CALL_RETURN_FROM_ENCLAVE,
    ReturnFromException: ?*VBS_BASIC_ENCLAVE_BASIC_CALL_RETURN_FROM_EXCEPTION,
    TerminateThread: ?*VBS_BASIC_ENCLAVE_BASIC_CALL_TERMINATE_THREAD,
    InterruptThread: ?*VBS_BASIC_ENCLAVE_BASIC_CALL_INTERRUPT_THREAD,
    CommitPages: ?*VBS_BASIC_ENCLAVE_BASIC_CALL_COMMIT_PAGES,
    DecommitPages: ?*VBS_BASIC_ENCLAVE_BASIC_CALL_DECOMMIT_PAGES,
    ProtectPages: ?*VBS_BASIC_ENCLAVE_BASIC_CALL_PROTECT_PAGES,
    CreateThread: ?*VBS_BASIC_ENCLAVE_BASIC_CALL_CREATE_THREAD,
    GetEnclaveInformation: ?*VBS_BASIC_ENCLAVE_BASIC_CALL_GET_ENCLAVE_INFORMATION,
    GenerateKey: ?*VBS_BASIC_ENCLAVE_BASIC_CALL_GENERATE_KEY,
    GenerateReport: ?*VBS_BASIC_ENCLAVE_BASIC_CALL_GENERATE_REPORT,
    VerifyReport: ?*VBS_BASIC_ENCLAVE_BASIC_CALL_VERIFY_REPORT,
    GenerateRandomData: ?*VBS_BASIC_ENCLAVE_BASIC_CALL_GENERATE_RANDOM_DATA,
};
// --------------------------------------------------------
// Type: EFFECTIVE_POWER_MODE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const EFFECTIVE_POWER_MODE = *opaque{
};
// --------------------------------------------------------
// Type: EFFECTIVE_POWER_MODE_CALLBACK
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const EFFECTIVE_POWER_MODE_CALLBACK = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: GLOBAL_MACHINE_POWER_POLICY
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const GLOBAL_MACHINE_POWER_POLICY = extern struct {
    Revision: u32,
    LidOpenWakeAc: SYSTEM_POWER_STATE,
    LidOpenWakeDc: SYSTEM_POWER_STATE,
    BroadcastCapacityResolution: u32,
};
// --------------------------------------------------------
// Type: GLOBAL_USER_POWER_POLICY
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const GLOBAL_USER_POWER_POLICY = extern struct {
    Revision: u32,
    PowerButtonAc: POWER_ACTION_POLICY,
    PowerButtonDc: POWER_ACTION_POLICY,
    SleepButtonAc: POWER_ACTION_POLICY,
    SleepButtonDc: POWER_ACTION_POLICY,
    LidCloseAc: POWER_ACTION_POLICY,
    LidCloseDc: POWER_ACTION_POLICY,
    DischargePolicy: ?[*]SYSTEM_POWER_LEVEL,
    GlobalFlags: u32,
};
// --------------------------------------------------------
// Type: GLOBAL_POWER_POLICY
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const GLOBAL_POWER_POLICY = extern struct {
    user: GLOBAL_USER_POWER_POLICY,
    mach: GLOBAL_MACHINE_POWER_POLICY,
};
// --------------------------------------------------------
// Type: MACHINE_POWER_POLICY
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const MACHINE_POWER_POLICY = extern struct {
    Revision: u32,
    MinSleepAc: SYSTEM_POWER_STATE,
    MinSleepDc: SYSTEM_POWER_STATE,
    ReducedLatencySleepAc: SYSTEM_POWER_STATE,
    ReducedLatencySleepDc: SYSTEM_POWER_STATE,
    DozeTimeoutAc: u32,
    DozeTimeoutDc: u32,
    DozeS4TimeoutAc: u32,
    DozeS4TimeoutDc: u32,
    MinThrottleAc: u8,
    MinThrottleDc: u8,
    pad1: ?[*]u8,
    OverThrottledAc: POWER_ACTION_POLICY,
    OverThrottledDc: POWER_ACTION_POLICY,
};
// --------------------------------------------------------
// Type: MACHINE_PROCESSOR_POWER_POLICY
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const MACHINE_PROCESSOR_POWER_POLICY = extern struct {
    Revision: u32,
    ProcessorPolicyAc: PROCESSOR_POWER_POLICY,
    ProcessorPolicyDc: PROCESSOR_POWER_POLICY,
};
// --------------------------------------------------------
// Type: USER_POWER_POLICY
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const USER_POWER_POLICY = extern struct {
    Revision: u32,
    IdleAc: POWER_ACTION_POLICY,
    IdleDc: POWER_ACTION_POLICY,
    IdleTimeoutAc: u32,
    IdleTimeoutDc: u32,
    IdleSensitivityAc: u8,
    IdleSensitivityDc: u8,
    ThrottlePolicyAc: u8,
    ThrottlePolicyDc: u8,
    MaxSleepAc: SYSTEM_POWER_STATE,
    MaxSleepDc: SYSTEM_POWER_STATE,
    Reserved: ?[*]u32,
    VideoTimeoutAc: u32,
    VideoTimeoutDc: u32,
    SpindownTimeoutAc: u32,
    SpindownTimeoutDc: u32,
    OptimizeForPowerAc: u8,
    OptimizeForPowerDc: u8,
    FanThrottleToleranceAc: u8,
    FanThrottleToleranceDc: u8,
    ForcedThrottleAc: u8,
    ForcedThrottleDc: u8,
};
// --------------------------------------------------------
// Type: POWER_POLICY
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const POWER_POLICY = extern struct {
    user: USER_POWER_POLICY,
    mach: MACHINE_POWER_POLICY,
};
// --------------------------------------------------------
// Type: PWRSCHEMESENUMPROC_V1
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PWRSCHEMESENUMPROC_V1 = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PWRSCHEMESENUMPROC_V2
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PWRSCHEMESENUMPROC_V2 = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PWRSCHEMESENUMPROC
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PWRSCHEMESENUMPROC = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: POWER_DATA_ACCESSOR
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const POWER_DATA_ACCESSOR = *opaque{
};
// --------------------------------------------------------
// Type: DEVICE_NOTIFY_CALLBACK_ROUTINE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const DEVICE_NOTIFY_CALLBACK_ROUTINE = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PDEVICE_NOTIFY_CALLBACK_ROUTINE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PDEVICE_NOTIFY_CALLBACK_ROUTINE = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: DEVICE_NOTIFY_SUBSCRIBE_PARAMETERS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DEVICE_NOTIFY_SUBSCRIBE_PARAMETERS = extern struct {
    Callback: PDEVICE_NOTIFY_CALLBACK_ROUTINE,
    Context: ?*opaque{},
};
// --------------------------------------------------------
// Type: THERMAL_EVENT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const THERMAL_EVENT = extern struct {
    Version: u32,
    Size: u32,
    Type: u32,
    Temperature: u32,
    TripPointTemperature: u32,
    Initiator: ?*u16,
};
// --------------------------------------------------------
// Type: BATTERY_QUERY_INFORMATION_LEVEL
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const BATTERY_QUERY_INFORMATION_LEVEL = *opaque{
};
// --------------------------------------------------------
// Type: BATTERY_QUERY_INFORMATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const BATTERY_QUERY_INFORMATION = extern struct {
    BatteryTag: u32,
    InformationLevel: BATTERY_QUERY_INFORMATION_LEVEL,
    AtRate: u32,
};
// --------------------------------------------------------
// Type: BATTERY_INFORMATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const BATTERY_INFORMATION = extern struct {
    Capabilities: u32,
    Technology: u8,
    Reserved: ?[*]u8,
    Chemistry: ?[*]u8,
    DesignedCapacity: u32,
    FullChargedCapacity: u32,
    DefaultAlert1: u32,
    DefaultAlert2: u32,
    CriticalBias: u32,
    CycleCount: u32,
};
// --------------------------------------------------------
// Type: BATTERY_CHARGING_SOURCE_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const BATTERY_CHARGING_SOURCE_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: BATTERY_CHARGING_SOURCE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const BATTERY_CHARGING_SOURCE = extern struct {
    Type: BATTERY_CHARGING_SOURCE_TYPE,
    MaxCurrent: u32,
};
// --------------------------------------------------------
// Type: BATTERY_CHARGING_SOURCE_INFORMATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const BATTERY_CHARGING_SOURCE_INFORMATION = extern struct {
    Type: BATTERY_CHARGING_SOURCE_TYPE,
    SourceOnline: u8,
};
// --------------------------------------------------------
// Type: USB_CHARGER_PORT
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const USB_CHARGER_PORT = *opaque{
};
// --------------------------------------------------------
// Type: BATTERY_SET_INFORMATION_LEVEL
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const BATTERY_SET_INFORMATION_LEVEL = *opaque{
};
// --------------------------------------------------------
// Type: BATTERY_SET_INFORMATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const BATTERY_SET_INFORMATION = extern struct {
    BatteryTag: u32,
    InformationLevel: BATTERY_SET_INFORMATION_LEVEL,
    Buffer: ?[*]u8,
};
// --------------------------------------------------------
// Type: BATTERY_CHARGER_STATUS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const BATTERY_CHARGER_STATUS = extern struct {
    Type: BATTERY_CHARGING_SOURCE_TYPE,
    VaData: ?[*]u32,
};
// --------------------------------------------------------
// Type: BATTERY_USB_CHARGER_STATUS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const BATTERY_USB_CHARGER_STATUS = extern struct {
    Type: BATTERY_CHARGING_SOURCE_TYPE,
    Reserved: u32,
    Flags: u32,
    MaxCurrent: u32,
    Voltage: u32,
    PortType: USB_CHARGER_PORT,
    PortId: u64,
    PowerSourceInformation: ?*opaque{},
    OemCharger: Guid,
};
// --------------------------------------------------------
// Type: BATTERY_WAIT_STATUS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const BATTERY_WAIT_STATUS = extern struct {
    BatteryTag: u32,
    Timeout: u32,
    PowerState: u32,
    LowCapacity: u32,
    HighCapacity: u32,
};
// --------------------------------------------------------
// Type: BATTERY_STATUS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const BATTERY_STATUS = extern struct {
    PowerState: u32,
    Capacity: u32,
    Voltage: u32,
    Rate: i32,
};
// --------------------------------------------------------
// Type: BATTERY_MANUFACTURE_DATE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const BATTERY_MANUFACTURE_DATE = extern struct {
    Day: u8,
    Month: u8,
    Year: u16,
};
// --------------------------------------------------------
// Type: THERMAL_INFORMATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const THERMAL_INFORMATION = extern struct {
    ThermalStamp: u32,
    ThermalConstant1: u32,
    ThermalConstant2: u32,
    Processors: ?*opaque{},
    SamplingPeriod: u32,
    CurrentTemperature: u32,
    PassiveTripPoint: u32,
    CriticalTripPoint: u32,
    ActiveTripPointCount: u8,
    ActiveTripPoint: ?[*]u32,
};
// --------------------------------------------------------
// Type: THERMAL_WAIT_READ
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const THERMAL_WAIT_READ = extern struct {
    Timeout: u32,
    LowTemperature: u32,
    HighTemperature: u32,
};
// --------------------------------------------------------
// Type: THERMAL_POLICY
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const THERMAL_POLICY = extern struct {
    Version: u32,
    WaitForUpdate: u8,
    Hibernate: u8,
    Critical: u8,
    ThermalStandby: u8,
    ActivationReasons: u32,
    PassiveLimit: u32,
    ActiveLevel: u32,
    OverThrottled: u8,
};
// --------------------------------------------------------
// Type: PROCESSOR_OBJECT_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PROCESSOR_OBJECT_INFO = extern struct {
    PhysicalID: u32,
    PBlkAddress: u32,
    PBlkLength: u8,
};
// --------------------------------------------------------
// Type: PROCESSOR_OBJECT_INFO_EX
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PROCESSOR_OBJECT_INFO_EX = extern struct {
    PhysicalID: u32,
    PBlkAddress: u32,
    PBlkLength: u8,
    InitialApicId: u32,
};
// --------------------------------------------------------
// Type: WAKE_ALARM_INFORMATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const WAKE_ALARM_INFORMATION = extern struct {
    TimerIdentifier: u32,
    Timeout: u32,
};
// --------------------------------------------------------
// Type: ACPI_REAL_TIME
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const ACPI_REAL_TIME = extern struct {
    Year: u16,
    Month: u8,
    Day: u8,
    Hour: u8,
    Minute: u8,
    Second: u8,
    Valid: u8,
    Milliseconds: u16,
    TimeZone: i16,
    DayLight: u8,
    Reserved1: ?[*]u8,
};
// --------------------------------------------------------
// Type: INDIRECT_DISPLAY_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const INDIRECT_DISPLAY_INFO = extern struct {
    DisplayAdapterLuid: LUID,
    Flags: u32,
    NumMonitors: u32,
    DisplayAdapterTargetBase: u32,
};
// --------------------------------------------------------
// Type: VIDEO_VDM
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VIDEO_VDM = extern struct {
    ProcessHandle: HANDLE,
};
// --------------------------------------------------------
// Type: VIDEO_REGISTER_VDM
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VIDEO_REGISTER_VDM = extern struct {
    MinimumStateSize: u32,
};
// --------------------------------------------------------
// Type: VIDEO_MONITOR_DESCRIPTOR
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VIDEO_MONITOR_DESCRIPTOR = extern struct {
    DescriptorSize: u32,
    Descriptor: ?[*]u8,
};
// --------------------------------------------------------
// Type: VIDEO_WIN32K_CALLBACKS_PARAMS_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const VIDEO_WIN32K_CALLBACKS_PARAMS_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: BlackScreenDiagnosticsCalloutParam
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const BlackScreenDiagnosticsCalloutParam = *opaque{
};
// --------------------------------------------------------
// Type: DXGK_WIN32K_PARAM_DATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DXGK_WIN32K_PARAM_DATA = extern struct {
    PathsArray: ?*opaque{},
    ModesArray: ?*opaque{},
    NumPathArrayElements: u32,
    NumModeArrayElements: u32,
    SDCFlags: u32,
};
// --------------------------------------------------------
// Type: VIDEO_WIN32K_CALLBACKS_PARAMS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VIDEO_WIN32K_CALLBACKS_PARAMS = extern struct {
    CalloutType: VIDEO_WIN32K_CALLBACKS_PARAMS_TYPE,
    PhysDisp: ?*opaque{},
    Param: ?*opaque{},
    Status: i32,
    LockUserSession: u8,
    IsPostDevice: u8,
    SurpriseRemoval: u8,
    WaitForQueueReady: u8,
};
// --------------------------------------------------------
// Type: PVIDEO_WIN32K_CALLOUT
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PVIDEO_WIN32K_CALLOUT = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: VIDEO_WIN32K_CALLBACKS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VIDEO_WIN32K_CALLBACKS = extern struct {
    PhysDisp: ?*opaque{},
    Callout: PVIDEO_WIN32K_CALLOUT,
    bACPI: u32,
    pPhysDeviceObject: HANDLE,
    DualviewFlags: u32,
};
// --------------------------------------------------------
// Type: VIDEO_DEVICE_SESSION_STATUS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VIDEO_DEVICE_SESSION_STATUS = extern struct {
    bEnable: u32,
    bSuccess: u32,
};
// --------------------------------------------------------
// Type: VIDEO_HARDWARE_STATE_HEADER
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VIDEO_HARDWARE_STATE_HEADER = extern struct {
    Length: u32,
    PortValue: ?[*]u8,
    AttribIndexDataState: u32,
    BasicSequencerOffset: u32,
    BasicCrtContOffset: u32,
    BasicGraphContOffset: u32,
    BasicAttribContOffset: u32,
    BasicDacOffset: u32,
    BasicLatchesOffset: u32,
    ExtendedSequencerOffset: u32,
    ExtendedCrtContOffset: u32,
    ExtendedGraphContOffset: u32,
    ExtendedAttribContOffset: u32,
    ExtendedDacOffset: u32,
    ExtendedValidatorStateOffset: u32,
    ExtendedMiscDataOffset: u32,
    PlaneLength: u32,
    Plane1Offset: u32,
    Plane2Offset: u32,
    Plane3Offset: u32,
    Plane4Offset: u32,
    VGAStateFlags: u32,
    DIBOffset: u32,
    DIBBitsPerPixel: u32,
    DIBXResolution: u32,
    DIBYResolution: u32,
    DIBXlatOffset: u32,
    DIBXlatLength: u32,
    VesaInfoOffset: u32,
    FrameBufferData: ?*opaque{},
};
// --------------------------------------------------------
// Type: VIDEO_HARDWARE_STATE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VIDEO_HARDWARE_STATE = extern struct {
    StateHeader: ?*VIDEO_HARDWARE_STATE_HEADER,
    StateLength: u32,
};
// --------------------------------------------------------
// Type: VIDEO_NUM_MODES
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VIDEO_NUM_MODES = extern struct {
    NumModes: u32,
    ModeInformationLength: u32,
};
// --------------------------------------------------------
// Type: VIDEO_MODE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VIDEO_MODE = extern struct {
    RequestedMode: u32,
};
// --------------------------------------------------------
// Type: VIDEO_MODE_INFORMATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VIDEO_MODE_INFORMATION = extern struct {
    Length: u32,
    ModeIndex: u32,
    VisScreenWidth: u32,
    VisScreenHeight: u32,
    ScreenStride: u32,
    NumberOfPlanes: u32,
    BitsPerPlane: u32,
    Frequency: u32,
    XMillimeter: u32,
    YMillimeter: u32,
    NumberRedBits: u32,
    NumberGreenBits: u32,
    NumberBlueBits: u32,
    RedMask: u32,
    GreenMask: u32,
    BlueMask: u32,
    AttributeFlags: u32,
    VideoMemoryBitmapWidth: u32,
    VideoMemoryBitmapHeight: u32,
    DriverSpecificAttributeFlags: u32,
};
// --------------------------------------------------------
// Type: VIDEO_LOAD_FONT_INFORMATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VIDEO_LOAD_FONT_INFORMATION = extern struct {
    WidthInPixels: u16,
    HeightInPixels: u16,
    FontSize: u32,
    Font: ?[*]u8,
};
// --------------------------------------------------------
// Type: VIDEO_PALETTE_DATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VIDEO_PALETTE_DATA = extern struct {
    NumEntries: u16,
    FirstEntry: u16,
    Colors: ?[*]u16,
};
// --------------------------------------------------------
// Type: VIDEO_CLUTDATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VIDEO_CLUTDATA = extern struct {
    Red: u8,
    Green: u8,
    Blue: u8,
    Unused: u8,
};
// --------------------------------------------------------
// Type: VIDEO_CLUT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VIDEO_CLUT = extern struct {
    NumEntries: u16,
    FirstEntry: u16,
    LookupTable: ?[*]_Anonymous_e__Union,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: VIDEO_CURSOR_POSITION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VIDEO_CURSOR_POSITION = extern struct {
    Column: i16,
    Row: i16,
};
// --------------------------------------------------------
// Type: VIDEO_CURSOR_ATTRIBUTES
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VIDEO_CURSOR_ATTRIBUTES = extern struct {
    Width: u16,
    Height: u16,
    Column: i16,
    Row: i16,
    Rate: u8,
    Enable: u8,
};
// --------------------------------------------------------
// Type: VIDEO_POINTER_POSITION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VIDEO_POINTER_POSITION = extern struct {
    Column: i16,
    Row: i16,
};
// --------------------------------------------------------
// Type: VIDEO_POINTER_ATTRIBUTES
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VIDEO_POINTER_ATTRIBUTES = extern struct {
    Flags: u32,
    Width: u32,
    Height: u32,
    WidthInBytes: u32,
    Enable: u32,
    Column: i16,
    Row: i16,
    Pixels: ?[*]u8,
};
// --------------------------------------------------------
// Type: VIDEO_POINTER_CAPABILITIES
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VIDEO_POINTER_CAPABILITIES = extern struct {
    Flags: u32,
    MaxWidth: u32,
    MaxHeight: u32,
    HWPtrBitmapStart: u32,
    HWPtrBitmapEnd: u32,
};
// --------------------------------------------------------
// Type: VIDEO_BANK_SELECT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VIDEO_BANK_SELECT = extern struct {
    Length: u32,
    Size: u32,
    BankingFlags: u32,
    BankingType: u32,
    PlanarHCBankingType: u32,
    BitmapWidthInBytes: u32,
    BitmapSize: u32,
    Granularity: u32,
    PlanarHCGranularity: u32,
    CodeOffset: u32,
    PlanarHCBankCodeOffset: u32,
    PlanarHCEnableCodeOffset: u32,
    PlanarHCDisableCodeOffset: u32,
};
// --------------------------------------------------------
// Type: VIDEO_BANK_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const VIDEO_BANK_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: VIDEO_MEMORY
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VIDEO_MEMORY = extern struct {
    RequestedVirtualAddress: ?*opaque{},
};
// --------------------------------------------------------
// Type: VIDEO_SHARE_MEMORY
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VIDEO_SHARE_MEMORY = extern struct {
    ProcessHandle: HANDLE,
    ViewOffset: u32,
    ViewSize: u32,
    RequestedVirtualAddress: ?*opaque{},
};
// --------------------------------------------------------
// Type: VIDEO_SHARE_MEMORY_INFORMATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VIDEO_SHARE_MEMORY_INFORMATION = extern struct {
    SharedViewOffset: u32,
    SharedViewSize: u32,
    VirtualAddress: ?*opaque{},
};
// --------------------------------------------------------
// Type: VIDEO_MEMORY_INFORMATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VIDEO_MEMORY_INFORMATION = extern struct {
    VideoRamBase: ?*opaque{},
    VideoRamLength: u32,
    FrameBufferBase: ?*opaque{},
    FrameBufferLength: u32,
};
// --------------------------------------------------------
// Type: VIDEO_PUBLIC_ACCESS_RANGES
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VIDEO_PUBLIC_ACCESS_RANGES = extern struct {
    InIoSpace: u32,
    MappedInIoSpace: u32,
    VirtualAddress: ?*opaque{},
};
// --------------------------------------------------------
// Type: VIDEO_COLOR_CAPABILITIES
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VIDEO_COLOR_CAPABILITIES = extern struct {
    Length: u32,
    AttributeFlags: u32,
    RedPhosphoreDecay: i32,
    GreenPhosphoreDecay: i32,
    BluePhosphoreDecay: i32,
    WhiteChromaticity_x: i32,
    WhiteChromaticity_y: i32,
    WhiteChromaticity_Y: i32,
    RedChromaticity_x: i32,
    RedChromaticity_y: i32,
    GreenChromaticity_x: i32,
    GreenChromaticity_y: i32,
    BlueChromaticity_x: i32,
    BlueChromaticity_y: i32,
    WhiteGamma: i32,
    RedGamma: i32,
    GreenGamma: i32,
    BlueGamma: i32,
};
// --------------------------------------------------------
// Type: VIDEO_POWER_STATE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const VIDEO_POWER_STATE = *opaque{
};
// --------------------------------------------------------
// Type: VIDEO_POWER_MANAGEMENT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VIDEO_POWER_MANAGEMENT = extern struct {
    Length: u32,
    DPMSVersion: u32,
    PowerState: u32,
};
// --------------------------------------------------------
// Type: VIDEO_COLOR_LUT_DATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VIDEO_COLOR_LUT_DATA = extern struct {
    Length: u32,
    LutDataFormat: u32,
    LutData: ?[*]u8,
};
// --------------------------------------------------------
// Type: VIDEO_LUT_RGB256WORDS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VIDEO_LUT_RGB256WORDS = extern struct {
    Red: ?[*]u16,
    Green: ?[*]u16,
    Blue: ?[*]u16,
};
// --------------------------------------------------------
// Type: BANK_POSITION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const BANK_POSITION = extern struct {
    ReadBankPosition: u32,
    WriteBankPosition: u32,
};
// --------------------------------------------------------
// Type: DISPLAY_BRIGHTNESS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DISPLAY_BRIGHTNESS = extern struct {
    ucDisplayPolicy: u8,
    ucACBrightness: u8,
    ucDCBrightness: u8,
};
// --------------------------------------------------------
// Type: VIDEO_BRIGHTNESS_POLICY
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VIDEO_BRIGHTNESS_POLICY = extern struct {
    DefaultToBiosPolicy: u8,
    LevelCount: u8,
    Level: ?[*]_Anonymous_e__Struct,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Struct
    // TypeLayoutAttr: sequential
    // TODO: I think this is a struct, but not sure at this point, assuming it is for now
    pub const _Anonymous_e__Struct = extern struct {
        BatteryLevel: u8,
        Brightness: u8,
    };
};
// --------------------------------------------------------
// Type: FSCNTL_SCREEN_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const FSCNTL_SCREEN_INFO = extern struct {
    Position: COORD,
    ScreenSize: COORD,
    nNumberOfChars: u32,
};
// --------------------------------------------------------
// Type: FONT_IMAGE_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const FONT_IMAGE_INFO = extern struct {
    FontSize: COORD,
    ImageBits: ?*u8,
};
// --------------------------------------------------------
// Type: CHAR_IMAGE_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CHAR_IMAGE_INFO = extern struct {
    CharInfo: CHAR_INFO,
    FontImageInfo: FONT_IMAGE_INFO,
};
// --------------------------------------------------------
// Type: VGA_CHAR
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VGA_CHAR = extern struct {
    Char: i8,
    Attributes: i8,
};
// --------------------------------------------------------
// Type: FSVIDEO_COPY_FRAME_BUFFER
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const FSVIDEO_COPY_FRAME_BUFFER = extern struct {
    SrcScreen: FSCNTL_SCREEN_INFO,
    DestScreen: FSCNTL_SCREEN_INFO,
};
// --------------------------------------------------------
// Type: FSVIDEO_WRITE_TO_FRAME_BUFFER
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const FSVIDEO_WRITE_TO_FRAME_BUFFER = extern struct {
    SrcBuffer: ?*CHAR_IMAGE_INFO,
    DestScreen: FSCNTL_SCREEN_INFO,
};
// --------------------------------------------------------
// Type: FSVIDEO_REVERSE_MOUSE_POINTER
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const FSVIDEO_REVERSE_MOUSE_POINTER = extern struct {
    Screen: FSCNTL_SCREEN_INFO,
    dwType: u32,
};
// --------------------------------------------------------
// Type: FSVIDEO_MODE_INFORMATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const FSVIDEO_MODE_INFORMATION = extern struct {
    VideoMode: VIDEO_MODE_INFORMATION,
    VideoMemory: VIDEO_MEMORY_INFORMATION,
};
// --------------------------------------------------------
// Type: FSVIDEO_SCREEN_INFORMATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const FSVIDEO_SCREEN_INFORMATION = extern struct {
    ScreenSize: COORD,
    FontSize: COORD,
};
// --------------------------------------------------------
// Type: FSVIDEO_CURSOR_POSITION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const FSVIDEO_CURSOR_POSITION = extern struct {
    Coord: VIDEO_CURSOR_POSITION,
    dwType: u32,
};
// --------------------------------------------------------
// Type: ENG_EVENT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const ENG_EVENT = extern struct {
    pKEvent: ?*opaque{},
    fFlags: u32,
};
// --------------------------------------------------------
// Type: VIDEO_PERFORMANCE_COUNTER
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VIDEO_PERFORMANCE_COUNTER = extern struct {
    NbOfAllocationEvicted: ?[*]u64,
    NbOfAllocationMarked: ?[*]u64,
    NbOfAllocationRestored: ?[*]u64,
    KBytesEvicted: ?[*]u64,
    KBytesMarked: ?[*]u64,
    KBytesRestored: ?[*]u64,
    NbProcessCommited: u64,
    NbAllocationCommited: u64,
    NbAllocationMarked: u64,
    KBytesAllocated: u64,
    KBytesAvailable: u64,
    KBytesCurMarked: u64,
    Reference: u64,
    Unreference: u64,
    TrueReference: u64,
    NbOfPageIn: u64,
    KBytesPageIn: u64,
    NbOfPageOut: u64,
    KBytesPageOut: u64,
    NbOfRotateOut: u64,
    KBytesRotateOut: u64,
};
// --------------------------------------------------------
// Type: VIDEO_QUERY_PERFORMANCE_COUNTER
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VIDEO_QUERY_PERFORMANCE_COUNTER = extern struct {
    BufferSize: u32,
    Buffer: ?*VIDEO_PERFORMANCE_COUNTER,
};
// --------------------------------------------------------
// Type: BRIGHTNESS_INTERFACE_VERSION
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const BRIGHTNESS_INTERFACE_VERSION = *opaque{
};
// --------------------------------------------------------
// Type: PANEL_QUERY_BRIGHTNESS_CAPS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PANEL_QUERY_BRIGHTNESS_CAPS = extern struct {
    Version: BRIGHTNESS_INTERFACE_VERSION,
    Anonymous: _Anonymous_e__Union,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
        // --------------------------------------------------------
        // Type: _Anonymous_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _Anonymous_e__Struct = extern struct {
            _bitfield: u32,
        };
    };
};
// --------------------------------------------------------
// Type: BRIGHTNESS_LEVEL
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const BRIGHTNESS_LEVEL = extern struct {
    Count: u8,
    Level: ?[*]u8,
};
// --------------------------------------------------------
// Type: BRIGHTNESS_NIT_RANGE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const BRIGHTNESS_NIT_RANGE = extern struct {
    MinLevelInMillinit: u32,
    MaxLevelInMillinit: u32,
    StepSizeInMillinit: u32,
};
// --------------------------------------------------------
// Type: BRIGHTNESS_NIT_RANGES
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const BRIGHTNESS_NIT_RANGES = extern struct {
    NormalRangeCount: u32,
    RangeCount: u32,
    PreferredMaximumBrightness: u32,
    SupportedRanges: ?[*]BRIGHTNESS_NIT_RANGE,
};
// --------------------------------------------------------
// Type: PANEL_QUERY_BRIGHTNESS_RANGES
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PANEL_QUERY_BRIGHTNESS_RANGES = extern struct {
    Version: BRIGHTNESS_INTERFACE_VERSION,
    Anonymous: _Anonymous_e__Union,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: PANEL_GET_BRIGHTNESS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PANEL_GET_BRIGHTNESS = extern struct {
    Version: BRIGHTNESS_INTERFACE_VERSION,
    Anonymous: _Anonymous_e__Union,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
        // --------------------------------------------------------
        // Type: _Anonymous_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _Anonymous_e__Struct = extern struct {
            CurrentInMillinits: u32,
            TargetInMillinits: u32,
        };
    };
};
// --------------------------------------------------------
// Type: CHROMATICITY_COORDINATE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CHROMATICITY_COORDINATE = extern struct {
    x: f32,
    y: f32,
};
// --------------------------------------------------------
// Type: PANEL_BRIGHTNESS_SENSOR_DATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PANEL_BRIGHTNESS_SENSOR_DATA = extern struct {
    Anonymous: _Anonymous_e__Union,
    AlsReading: f32,
    ChromaticityCoordinate: CHROMATICITY_COORDINATE,
    ColorTemperature: f32,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
        // --------------------------------------------------------
        // Type: _Anonymous_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _Anonymous_e__Struct = extern struct {
            _bitfield: u32,
        };
    };
};
// --------------------------------------------------------
// Type: PANEL_SET_BRIGHTNESS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PANEL_SET_BRIGHTNESS = extern struct {
    Version: BRIGHTNESS_INTERFACE_VERSION,
    Anonymous: _Anonymous_e__Union,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
        // --------------------------------------------------------
        // Type: _Anonymous_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _Anonymous_e__Struct = extern struct {
            Millinits: u32,
            TransitionTimeInMs: u32,
            SensorData: PANEL_BRIGHTNESS_SENSOR_DATA,
        };
    };
};
// --------------------------------------------------------
// Type: PANEL_SET_BRIGHTNESS_STATE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PANEL_SET_BRIGHTNESS_STATE = extern struct {
    Anonymous: _Anonymous_e__Union,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
        // --------------------------------------------------------
        // Type: _Anonymous_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _Anonymous_e__Struct = extern struct {
            _bitfield: u32,
        };
    };
};
// --------------------------------------------------------
// Type: BACKLIGHT_OPTIMIZATION_LEVEL
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const BACKLIGHT_OPTIMIZATION_LEVEL = *opaque{
};
// --------------------------------------------------------
// Type: PANEL_SET_BACKLIGHT_OPTIMIZATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PANEL_SET_BACKLIGHT_OPTIMIZATION = extern struct {
    Level: BACKLIGHT_OPTIMIZATION_LEVEL,
};
// --------------------------------------------------------
// Type: BACKLIGHT_REDUCTION_GAMMA_RAMP
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const BACKLIGHT_REDUCTION_GAMMA_RAMP = extern struct {
    R: ?[*]u16,
    G: ?[*]u16,
    B: ?[*]u16,
};
// --------------------------------------------------------
// Type: PANEL_GET_BACKLIGHT_REDUCTION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PANEL_GET_BACKLIGHT_REDUCTION = extern struct {
    BacklightUsersetting: u16,
    BacklightEffective: u16,
    GammaRamp: BACKLIGHT_REDUCTION_GAMMA_RAMP,
};
// --------------------------------------------------------
// Type: COLORSPACE_TRANSFORM_DATA_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const COLORSPACE_TRANSFORM_DATA_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: COLORSPACE_TRANSFORM_DATA_CAP
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const COLORSPACE_TRANSFORM_DATA_CAP = extern struct {
    DataType: COLORSPACE_TRANSFORM_DATA_TYPE,
    Anonymous: _Anonymous_e__Union,
    NumericRangeMin: f32,
    NumericRangeMax: f32,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
        // --------------------------------------------------------
        // Type: _Anonymous1_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _Anonymous1_e__Struct = extern struct {
            _bitfield: u32,
        };
        // --------------------------------------------------------
        // Type: _Anonymous2_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _Anonymous2_e__Struct = extern struct {
            _bitfield: u32,
        };
    };
};
// --------------------------------------------------------
// Type: COLORSPACE_TRANSFORM_1DLUT_CAP
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const COLORSPACE_TRANSFORM_1DLUT_CAP = extern struct {
    NumberOfLUTEntries: u32,
    DataCap: COLORSPACE_TRANSFORM_DATA_CAP,
};
// --------------------------------------------------------
// Type: COLORSPACE_TRANSFORM_MATRIX_CAP
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const COLORSPACE_TRANSFORM_MATRIX_CAP = extern struct {
    Anonymous: _Anonymous_e__Union,
    DataCap: COLORSPACE_TRANSFORM_DATA_CAP,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
        // --------------------------------------------------------
        // Type: _Anonymous_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _Anonymous_e__Struct = extern struct {
            _bitfield: u32,
        };
    };
};
// --------------------------------------------------------
// Type: COLORSPACE_TRANSFORM_TARGET_CAPS_VERSION
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const COLORSPACE_TRANSFORM_TARGET_CAPS_VERSION = *opaque{
};
// --------------------------------------------------------
// Type: COLORSPACE_TRANSFORM_TARGET_CAPS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const COLORSPACE_TRANSFORM_TARGET_CAPS = extern struct {
    Version: COLORSPACE_TRANSFORM_TARGET_CAPS_VERSION,
    LookupTable1DDegammaCap: COLORSPACE_TRANSFORM_1DLUT_CAP,
    ColorMatrix3x3Cap: COLORSPACE_TRANSFORM_MATRIX_CAP,
    LookupTable1DRegammaCap: COLORSPACE_TRANSFORM_1DLUT_CAP,
};
// --------------------------------------------------------
// Type: COLORSPACE_TRANSFORM_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const COLORSPACE_TRANSFORM_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: GAMMA_RAMP_RGB256x3x16
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const GAMMA_RAMP_RGB256x3x16 = extern struct {
    Red: ?[*]u16,
    Green: ?[*]u16,
    Blue: ?[*]u16,
};
// --------------------------------------------------------
// Type: GAMMA_RAMP_RGB
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const GAMMA_RAMP_RGB = extern struct {
    Red: f32,
    Green: f32,
    Blue: f32,
};
// --------------------------------------------------------
// Type: GAMMA_RAMP_DXGI_1
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const GAMMA_RAMP_DXGI_1 = extern struct {
    Scale: GAMMA_RAMP_RGB,
    Offset: GAMMA_RAMP_RGB,
    GammaCurve: ?[*]GAMMA_RAMP_RGB,
};
// --------------------------------------------------------
// Type: COLORSPACE_TRANSFORM_3x4
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const COLORSPACE_TRANSFORM_3x4 = extern struct {
    ColorMatrix3x4: ?[*]f32,
    ScalarMultiplier: f32,
    LookupTable1D: ?[*]GAMMA_RAMP_RGB,
};
// --------------------------------------------------------
// Type: OUTPUT_WIRE_COLOR_SPACE_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const OUTPUT_WIRE_COLOR_SPACE_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: OUTPUT_COLOR_ENCODING
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const OUTPUT_COLOR_ENCODING = *opaque{
};
// --------------------------------------------------------
// Type: OUTPUT_WIRE_FORMAT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const OUTPUT_WIRE_FORMAT = extern struct {
    ColorEncoding: OUTPUT_COLOR_ENCODING,
    BitsPerPixel: u32,
};
// --------------------------------------------------------
// Type: COLORSPACE_TRANSFORM_STAGE_CONTROL
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const COLORSPACE_TRANSFORM_STAGE_CONTROL = *opaque{
};
// --------------------------------------------------------
// Type: COLORSPACE_TRANSFORM_MATRIX_V2
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const COLORSPACE_TRANSFORM_MATRIX_V2 = extern struct {
    StageControlLookupTable1DDegamma: COLORSPACE_TRANSFORM_STAGE_CONTROL,
    LookupTable1DDegamma: ?[*]GAMMA_RAMP_RGB,
    StageControlColorMatrix3x3: COLORSPACE_TRANSFORM_STAGE_CONTROL,
    ColorMatrix3x3: ?[*]f32,
    StageControlLookupTable1DRegamma: COLORSPACE_TRANSFORM_STAGE_CONTROL,
    LookupTable1DRegamma: ?[*]GAMMA_RAMP_RGB,
};
// --------------------------------------------------------
// Type: COLORSPACE_TRANSFORM
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const COLORSPACE_TRANSFORM = extern struct {
    Type: COLORSPACE_TRANSFORM_TYPE,
    Data: _Data_e__Union,
    // --------------------------------------------------------
    // Type: _Data_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Data_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: COLORSPACE_TRANSFORM_SET_INPUT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const COLORSPACE_TRANSFORM_SET_INPUT = extern struct {
    OutputWireColorSpaceExpected: OUTPUT_WIRE_COLOR_SPACE_TYPE,
    OutputWireFormatExpected: OUTPUT_WIRE_FORMAT,
    ColorSpaceTransform: COLORSPACE_TRANSFORM,
};
// --------------------------------------------------------
// Type: SET_ACTIVE_COLOR_PROFILE_NAME
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SET_ACTIVE_COLOR_PROFILE_NAME = extern struct {
    ColorProfileName: ?[*]u16,
};
// --------------------------------------------------------
// Type: MIPI_DSI_CAPS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const MIPI_DSI_CAPS = extern struct {
    DSITypeMajor: u8,
    DSITypeMinor: u8,
    SpecVersionMajor: u8,
    SpecVersionMinor: u8,
    SpecVersionPatch: u8,
    TargetMaximumReturnPacketSize: u16,
    ResultCodeFlags: u8,
    ResultCodeStatus: u8,
    Revision: u8,
    Level: u8,
    DeviceClassHi: u8,
    DeviceClassLo: u8,
    ManufacturerHi: u8,
    ManufacturerLo: u8,
    ProductHi: u8,
    ProductLo: u8,
    LengthHi: u8,
    LengthLo: u8,
};
// --------------------------------------------------------
// Type: DSI_CONTROL_TRANSMISSION_MODE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const DSI_CONTROL_TRANSMISSION_MODE = *opaque{
};
// --------------------------------------------------------
// Type: MIPI_DSI_PACKET
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const MIPI_DSI_PACKET = extern struct {
    Anonymous1: _Anonymous1_e__Union,
    Anonymous2: _Anonymous2_e__Union,
    EccFiller: u8,
    Payload: ?[*]u8,
    // --------------------------------------------------------
    // Type: _Anonymous2_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous2_e__Union = *opaque{
        // --------------------------------------------------------
        // Type: _Anonymous_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _Anonymous_e__Struct = extern struct {
            Data0: u8,
            Data1: u8,
        };
    };
    // --------------------------------------------------------
    // Type: _Anonymous1_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous1_e__Union = *opaque{
        // --------------------------------------------------------
        // Type: _Anonymous_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _Anonymous_e__Struct = extern struct {
            _bitfield: u8,
        };
    };
};
// --------------------------------------------------------
// Type: MIPI_DSI_TRANSMISSION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const MIPI_DSI_TRANSMISSION = extern struct {
    TotalBufferSize: u32,
    PacketCount: u8,
    FailedPacket: u8,
    Anonymous: _Anonymous_e__Struct,
    ReadWordCount: u16,
    FinalCommandExtraPayload: u16,
    MipiErrors: u16,
    HostErrors: u16,
    Packets: ?[*]MIPI_DSI_PACKET,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Struct
    // TypeLayoutAttr: sequential
    // TODO: I think this is a struct, but not sure at this point, assuming it is for now
    pub const _Anonymous_e__Struct = extern struct {
        _bitfield: u16,
    };
};
// --------------------------------------------------------
// Type: MIPI_DSI_RESET
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const MIPI_DSI_RESET = extern struct {
    Flags: u32,
    Anonymous: _Anonymous_e__Union,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
        // --------------------------------------------------------
        // Type: _Anonymous_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _Anonymous_e__Struct = extern struct {
            _bitfield: u32,
        };
    };
};
// --------------------------------------------------------
// Type: PROCESSOR_NUMBER
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PROCESSOR_NUMBER = extern struct {
    Group: u16,
    Number: u8,
    Reserved: u8,
};
// --------------------------------------------------------
// Type: GROUP_AFFINITY
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const GROUP_AFFINITY = extern struct {
    Mask: ?*opaque{},
    Group: u16,
    Reserved: ?[*]u16,
};
// --------------------------------------------------------
// Type: PROCESS_INFORMATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PROCESS_INFORMATION = extern struct {
    hProcess: HANDLE,
    hThread: HANDLE,
    dwProcessId: u32,
    dwThreadId: u32,
};
// --------------------------------------------------------
// Type: STARTUPINFOA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const STARTUPINFOA = extern struct {
    cb: u32,
    lpReserved: ?*i8,
    lpDesktop: ?*i8,
    lpTitle: ?*i8,
    dwX: u32,
    dwY: u32,
    dwXSize: u32,
    dwYSize: u32,
    dwXCountChars: u32,
    dwYCountChars: u32,
    dwFillAttribute: u32,
    dwFlags: u32,
    wShowWindow: u16,
    cbReserved2: u16,
    lpReserved2: ?*u8,
    hStdInput: HANDLE,
    hStdOutput: HANDLE,
    hStdError: HANDLE,
};
// --------------------------------------------------------
// Type: STARTUPINFOW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const STARTUPINFOW = extern struct {
    cb: u32,
    lpReserved: ?*u16,
    lpDesktop: ?*u16,
    lpTitle: ?*u16,
    dwX: u32,
    dwY: u32,
    dwXSize: u32,
    dwYSize: u32,
    dwXCountChars: u32,
    dwYCountChars: u32,
    dwFillAttribute: u32,
    dwFlags: u32,
    wShowWindow: u16,
    cbReserved2: u16,
    lpReserved2: ?*u8,
    hStdInput: HANDLE,
    hStdOutput: HANDLE,
    hStdError: HANDLE,
};
// --------------------------------------------------------
// Type: MEMORY_PRIORITY_INFORMATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const MEMORY_PRIORITY_INFORMATION = extern struct {
    MemoryPriority: u32,
};
// --------------------------------------------------------
// Type: THREAD_POWER_THROTTLING_STATE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const THREAD_POWER_THROTTLING_STATE = extern struct {
    Version: u32,
    ControlMask: u32,
    StateMask: u32,
};
// --------------------------------------------------------
// Type: APP_MEMORY_INFORMATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const APP_MEMORY_INFORMATION = extern struct {
    AvailableCommit: u64,
    PrivateCommitUsage: u64,
    PeakPrivateCommitUsage: u64,
    TotalCommitUsage: u64,
};
// --------------------------------------------------------
// Type: PROCESS_MEMORY_EXHAUSTION_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PROCESS_MEMORY_EXHAUSTION_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: PROCESS_MEMORY_EXHAUSTION_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PROCESS_MEMORY_EXHAUSTION_INFO = extern struct {
    Version: u16,
    Reserved: u16,
    Type: PROCESS_MEMORY_EXHAUSTION_TYPE,
    Value: ?*opaque{},
};
// --------------------------------------------------------
// Type: PROCESS_POWER_THROTTLING_STATE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PROCESS_POWER_THROTTLING_STATE = extern struct {
    Version: u32,
    ControlMask: u32,
    StateMask: u32,
};
// --------------------------------------------------------
// Type: PROCESS_PROTECTION_LEVEL_INFORMATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PROCESS_PROTECTION_LEVEL_INFORMATION = extern struct {
    ProtectionLevel: u32,
};
// --------------------------------------------------------
// Type: PROCESS_LEAP_SECOND_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PROCESS_LEAP_SECOND_INFO = extern struct {
    Flags: u32,
    Reserved: u32,
};
// --------------------------------------------------------
// Type: MEMORYSTATUSEX
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const MEMORYSTATUSEX = extern struct {
    dwLength: u32,
    dwMemoryLoad: u32,
    ullTotalPhys: u64,
    ullAvailPhys: u64,
    ullTotalPageFile: u64,
    ullAvailPageFile: u64,
    ullTotalVirtual: u64,
    ullAvailVirtual: u64,
    ullAvailExtendedVirtual: u64,
};
// --------------------------------------------------------
// Type: PFIBER_START_ROUTINE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFIBER_START_ROUTINE = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: COMMPROP
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const COMMPROP = extern struct {
    wPacketLength: u16,
    wPacketVersion: u16,
    dwServiceMask: u32,
    dwReserved1: u32,
    dwMaxTxQueue: u32,
    dwMaxRxQueue: u32,
    dwMaxBaud: u32,
    dwProvSubType: u32,
    dwProvCapabilities: u32,
    dwSettableParams: u32,
    dwSettableBaud: u32,
    wSettableData: u16,
    wSettableStopParity: u16,
    dwCurrentTxQueue: u32,
    dwCurrentRxQueue: u32,
    dwProvSpec1: u32,
    dwProvSpec2: u32,
    wcProvChar: ?[*]u16,
};
// --------------------------------------------------------
// Type: COMSTAT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const COMSTAT = extern struct {
    _bitfield: u32,
    cbInQue: u32,
    cbOutQue: u32,
};
// --------------------------------------------------------
// Type: DCB
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DCB = extern struct {
    DCBlength: u32,
    BaudRate: u32,
    _bitfield: u32,
    wReserved: u16,
    XonLim: u16,
    XoffLim: u16,
    ByteSize: u8,
    Parity: u8,
    StopBits: u8,
    XonChar: i8,
    XoffChar: i8,
    ErrorChar: i8,
    EofChar: i8,
    EvtChar: i8,
    wReserved1: u16,
};
// --------------------------------------------------------
// Type: COMMTIMEOUTS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const COMMTIMEOUTS = extern struct {
    ReadIntervalTimeout: u32,
    ReadTotalTimeoutMultiplier: u32,
    ReadTotalTimeoutConstant: u32,
    WriteTotalTimeoutMultiplier: u32,
    WriteTotalTimeoutConstant: u32,
};
// --------------------------------------------------------
// Type: COMMCONFIG
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const COMMCONFIG = extern struct {
    dwSize: u32,
    wVersion: u16,
    wReserved: u16,
    dcb: DCB,
    dwProviderSubType: u32,
    dwProviderOffset: u32,
    dwProviderSize: u32,
    wcProviderData: ?[*]u16,
};
// --------------------------------------------------------
// Type: MEMORYSTATUS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const MEMORYSTATUS = extern struct {
    dwLength: u32,
    dwMemoryLoad: u32,
    dwTotalPhys: ?*opaque{},
    dwAvailPhys: ?*opaque{},
    dwTotalPageFile: ?*opaque{},
    dwAvailPageFile: ?*opaque{},
    dwTotalVirtual: ?*opaque{},
    dwAvailVirtual: ?*opaque{},
};
// --------------------------------------------------------
// Type: UMS_SCHEDULER_STARTUP_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const UMS_SCHEDULER_STARTUP_INFO = extern struct {
    UmsVersion: u32,
    CompletionList: ?*opaque{},
    SchedulerProc: PUMS_SCHEDULER_ENTRY_POINT,
    SchedulerParam: ?*opaque{},
};
// --------------------------------------------------------
// Type: UMS_SYSTEM_THREAD_INFORMATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const UMS_SYSTEM_THREAD_INFORMATION = extern struct {
    UmsVersion: u32,
    Anonymous: _Anonymous_e__Union,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
        // --------------------------------------------------------
        // Type: _Anonymous_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _Anonymous_e__Struct = extern struct {
            _bitfield: u32,
        };
    };
};
// --------------------------------------------------------
// Type: WIN32_STREAM_ID
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const WIN32_STREAM_ID = extern struct {
    dwStreamId: u32,
    dwStreamAttributes: u32,
    Size: LARGE_INTEGER,
    dwStreamNameSize: u32,
    cStreamName: ?[*]u16,
};
// --------------------------------------------------------
// Type: STARTUPINFOEXA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const STARTUPINFOEXA = extern struct {
    StartupInfo: STARTUPINFOA,
    lpAttributeList: ?*opaque{},
};
// --------------------------------------------------------
// Type: STARTUPINFOEXW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const STARTUPINFOEXW = extern struct {
    StartupInfo: STARTUPINFOW,
    lpAttributeList: ?*opaque{},
};
// --------------------------------------------------------
// Type: EVENTLOG_FULL_INFORMATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const EVENTLOG_FULL_INFORMATION = extern struct {
    dwFull: u32,
};
// --------------------------------------------------------
// Type: SYSTEM_POWER_STATUS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SYSTEM_POWER_STATUS = extern struct {
    ACLineStatus: u8,
    BatteryFlag: u8,
    BatteryLifePercent: u8,
    SystemStatusFlag: u8,
    BatteryLifeTime: u32,
    BatteryFullLifeTime: u32,
};
// --------------------------------------------------------
// Type: PEB_LDR_DATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PEB_LDR_DATA = extern struct {
    Reserved1: ?[*]u8,
    Reserved2: ?[*]?*opaque{},
    InMemoryOrderModuleList: LIST_ENTRY,
};
// --------------------------------------------------------
// Type: RTL_USER_PROCESS_PARAMETERS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const RTL_USER_PROCESS_PARAMETERS = extern struct {
    Reserved1: ?[*]u8,
    Reserved2: ?[*]?*opaque{},
    ImagePathName: UNICODE_STRING,
    CommandLine: UNICODE_STRING,
};
// --------------------------------------------------------
// Type: PEB
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PEB = extern struct {
    Reserved1: ?[*]u8,
    BeingDebugged: u8,
    Reserved2: ?[*]u8,
    Reserved3: ?[*]?*opaque{},
    Ldr: ?*PEB_LDR_DATA,
    ProcessParameters: ?*RTL_USER_PROCESS_PARAMETERS,
    Reserved4: ?[*]?*opaque{},
    AtlThunkSListPtr: ?*opaque{},
    Reserved5: ?*opaque{},
    Reserved6: u32,
    Reserved7: ?*opaque{},
    Reserved8: u32,
    AtlThunkSListPtr32: u32,
    Reserved9: ?[*]?*opaque{},
    Reserved10: ?[*]u8,
    PostProcessInitRoutine: PPS_POST_PROCESS_INIT_ROUTINE,
    Reserved11: ?[*]u8,
    Reserved12: ?[*]?*opaque{},
    SessionId: u32,
};

//
// functions
//

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn ExitWindowsEx(
    uFlags: u32,
    dwReason: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn IsWow64Message(
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn RegisterDeviceNotificationA(
    hRecipient: HANDLE,
    NotificationFilter: ?*opaque{},
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn RegisterDeviceNotificationW(
    hRecipient: HANDLE,
    NotificationFilter: ?*opaque{},
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn UnregisterDeviceNotification(
    Handle: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn RegisterPowerSettingNotification(
    hRecipient: HANDLE,
    PowerSettingGuid: ?*Guid,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn UnregisterPowerSettingNotification(
    Handle: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn RegisterSuspendResumeNotification(
    hRecipient: HANDLE,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn UnregisterSuspendResumeNotification(
    Handle: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn AttachThreadInput(
    idAttach: u32,
    idAttachTo: u32,
    fAttach: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn WaitForInputIdle(
    hProcess: HANDLE,
    dwMilliseconds: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn MsgWaitForMultipleObjects(
    nCount: u32,
    pHandles: ?*?*opaque{},
    fWaitAll: BOOL,
    dwMilliseconds: u32,
    dwWakeMask: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn MsgWaitForMultipleObjectsEx(
    nCount: u32,
    pHandles: ?*?*opaque{},
    dwMilliseconds: u32,
    dwWakeMask: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn GetGuiResources(
    hProcess: HANDLE,
    uiFlags: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn LockWorkStation(
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn UserHandleGrantAccess(
    hUserHandle: HANDLE,
    hJob: HANDLE,
    bGrant: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn ShutdownBlockReasonCreate(
    hWnd: HWND,
    pwszReason: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn ShutdownBlockReasonQuery(
    hWnd: HWND,
    pwszBuff: ?*u16,
    pcchBuff: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn ShutdownBlockReasonDestroy(
    hWnd: HWND,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn GetAutoRotationState(
    pState: ?*AR_STATE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn GetDisplayAutoRotationPreferences(
    pOrientation: ?*ORIENTATION_PREFERENCE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn SetDisplayAutoRotationPreferences(
    orientation: ORIENTATION_PREFERENCE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn IsImmersiveProcess(
    hProcess: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn SetProcessRestrictionExemption(
    fEnableExemption: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-core-rtlsupport-l1-1-0" fn RtlCompareMemory(
    Source1: ?*opaque{},
    Source2: ?*opaque{},
    Length: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=False (can and should we use this?)
pub extern "ntdll" fn RtlInitializeSListHead(
    ListHead: ?*SLIST_HEADER,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "ntdll" fn RtlFirstEntrySList(
    ListHead: ?*SLIST_HEADER,
) callconv(@import("std").os.windows.WINAPI) ?*SINGLE_LIST_ENTRY;

// set_last_errror=False (can and should we use this?)
pub extern "ntdll" fn RtlInterlockedPopEntrySList(
    ListHead: ?*SLIST_HEADER,
) callconv(@import("std").os.windows.WINAPI) ?*SINGLE_LIST_ENTRY;

// set_last_errror=False (can and should we use this?)
pub extern "ntdll" fn RtlInterlockedPushEntrySList(
    ListHead: ?*SLIST_HEADER,
    ListEntry: ?*SINGLE_LIST_ENTRY,
) callconv(@import("std").os.windows.WINAPI) ?*SINGLE_LIST_ENTRY;

// set_last_errror=False (can and should we use this?)
pub extern "ntdll" fn RtlInterlockedPushListSListEx(
    ListHead: ?*SLIST_HEADER,
    List: ?*SINGLE_LIST_ENTRY,
    ListEnd: ?*SINGLE_LIST_ENTRY,
    Count: u32,
) callconv(@import("std").os.windows.WINAPI) ?*SINGLE_LIST_ENTRY;

// set_last_errror=False (can and should we use this?)
pub extern "ntdll" fn RtlInterlockedFlushSList(
    ListHead: ?*SLIST_HEADER,
) callconv(@import("std").os.windows.WINAPI) ?*SINGLE_LIST_ENTRY;

// set_last_errror=False (can and should we use this?)
pub extern "ntdll" fn RtlQueryDepthSList(
    ListHead: ?*SLIST_HEADER,
) callconv(@import("std").os.windows.WINAPI) u16;

// set_last_errror=False (can and should we use this?)
pub extern "ntdll" fn RtlGetReturnAddressHijackTarget(
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=False (can and should we use this?)
pub extern "ntdll" fn RtlGetProductInfo(
    OSMajorVersion: u32,
    OSMinorVersion: u32,
    SpMajorVersion: u32,
    SpMinorVersion: u32,
    ReturnedProductType: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u8;

// set_last_errror=False (can and should we use this?)
pub extern "ntdll" fn RtlCrc32(
    Buffer: ?*opaque{},
    Size: ?*opaque{},
    InitialCrc: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "ntdll" fn RtlCrc64(
    Buffer: ?*opaque{},
    Size: ?*opaque{},
    InitialCrc: u64,
) callconv(@import("std").os.windows.WINAPI) u64;

// set_last_errror=False (can and should we use this?)
pub extern "ntdll" fn RtlOsDeploymentState(
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) OS_DEPLOYEMENT_STATE_VALUES;

// set_last_errror=False (can and should we use this?)
pub extern "ntdll" fn RtlInitializeCorrelationVector(
    CorrelationVector: ?*CORRELATION_VECTOR,
    Version: i32,
    Guid: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "ntdll" fn RtlIncrementCorrelationVector(
    CorrelationVector: ?*CORRELATION_VECTOR,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "ntdll" fn RtlExtendCorrelationVector(
    CorrelationVector: ?*CORRELATION_VECTOR,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "ntdll" fn RtlValidateCorrelationVector(
    Vector: ?*CORRELATION_VECTOR,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "ntdll" fn RtlRaiseCustomSystemEventTrigger(
    TriggerConfig: ?*CUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "ntdll" fn RtlIsZeroMemory(
    Buffer: ?*opaque{},
    Length: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) u8;

// set_last_errror=False (can and should we use this?)
pub extern "ntdll" fn RtlNormalizeSecurityDescriptor(
    SecurityDescriptor: ?*?*opaque{},
    SecurityDescriptorLength: u32,
    NewSecurityDescriptor: ?*?*opaque{},
    NewSecurityDescriptorLength: ?*u32,
    CheckOnly: u8,
) callconv(@import("std").os.windows.WINAPI) u8;

// set_last_errror=False (can and should we use this?)
pub extern "ntdll" fn RtlGetDeviceFamilyInfoEnum(
    pullUAPInfo: ?*u64,
    pulDeviceFamily: ?*u32,
    pulDeviceForm: ?*u32,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "ntdll" fn RtlConvertDeviceFamilyInfoToString(
    pulDeviceFamilyBufferSize: ?*u32,
    pulDeviceFormBufferSize: ?*u32,
    DeviceFamily: ?*u16,
    DeviceForm: ?*u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "ntdll" fn RtlSwitchedVVI(
    VersionInfo: ?*OSVERSIONINFOEXW,
    TypeMask: u32,
    ConditionMask: u64,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn FlsAlloc(
    lpCallback: PFLS_CALLBACK_FUNCTION,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn FlsGetValue(
    dwFlsIndex: u32,
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn FlsSetValue(
    dwFlsIndex: u32,
    lpFlsData: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn FlsFree(
    dwFlsIndex: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn IsThreadAFiber(
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn InitializeSRWLock(
    SRWLock: ?*RTL_SRWLOCK,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn ReleaseSRWLockExclusive(
    SRWLock: ?*RTL_SRWLOCK,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn ReleaseSRWLockShared(
    SRWLock: ?*RTL_SRWLOCK,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn AcquireSRWLockExclusive(
    SRWLock: ?*RTL_SRWLOCK,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn AcquireSRWLockShared(
    SRWLock: ?*RTL_SRWLOCK,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn TryAcquireSRWLockExclusive(
    SRWLock: ?*RTL_SRWLOCK,
) callconv(@import("std").os.windows.WINAPI) u8;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn TryAcquireSRWLockShared(
    SRWLock: ?*RTL_SRWLOCK,
) callconv(@import("std").os.windows.WINAPI) u8;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn InitializeCriticalSection(
    lpCriticalSection: ?*RTL_CRITICAL_SECTION,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn LeaveCriticalSection(
    lpCriticalSection: ?*RTL_CRITICAL_SECTION,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn InitializeCriticalSectionAndSpinCount(
    lpCriticalSection: ?*RTL_CRITICAL_SECTION,
    dwSpinCount: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn InitializeCriticalSectionEx(
    lpCriticalSection: ?*RTL_CRITICAL_SECTION,
    dwSpinCount: u32,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn SetCriticalSectionSpinCount(
    lpCriticalSection: ?*RTL_CRITICAL_SECTION,
    dwSpinCount: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn TryEnterCriticalSection(
    lpCriticalSection: ?*RTL_CRITICAL_SECTION,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn DeleteCriticalSection(
    lpCriticalSection: ?*RTL_CRITICAL_SECTION,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn InitOnceInitialize(
    InitOnce: ?*RTL_RUN_ONCE,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn InitOnceExecuteOnce(
    InitOnce: ?*RTL_RUN_ONCE,
    InitFn: PINIT_ONCE_FN,
    Parameter: ?*opaque{},
    Context: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn InitOnceBeginInitialize(
    lpInitOnce: ?*RTL_RUN_ONCE,
    dwFlags: u32,
    fPending: ?*i32,
    lpContext: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn InitOnceComplete(
    lpInitOnce: ?*RTL_RUN_ONCE,
    dwFlags: u32,
    lpContext: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn InitializeConditionVariable(
    ConditionVariable: ?*RTL_CONDITION_VARIABLE,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn WakeConditionVariable(
    ConditionVariable: ?*RTL_CONDITION_VARIABLE,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn WakeAllConditionVariable(
    ConditionVariable: ?*RTL_CONDITION_VARIABLE,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn SleepConditionVariableCS(
    ConditionVariable: ?*RTL_CONDITION_VARIABLE,
    CriticalSection: ?*RTL_CRITICAL_SECTION,
    dwMilliseconds: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn SleepConditionVariableSRW(
    ConditionVariable: ?*RTL_CONDITION_VARIABLE,
    SRWLock: ?*RTL_SRWLOCK,
    dwMilliseconds: u32,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn SetEvent(
    hEvent: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn ResetEvent(
    hEvent: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn ReleaseSemaphore(
    hSemaphore: HANDLE,
    lReleaseCount: i32,
    lpPreviousCount: ?*i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn ReleaseMutex(
    hMutex: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn WaitForSingleObject(
    hHandle: HANDLE,
    dwMilliseconds: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn SleepEx(
    dwMilliseconds: u32,
    bAlertable: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn WaitForSingleObjectEx(
    hHandle: HANDLE,
    dwMilliseconds: u32,
    bAlertable: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn WaitForMultipleObjectsEx(
    nCount: u32,
    lpHandles: ?*?*opaque{},
    bWaitAll: BOOL,
    dwMilliseconds: u32,
    bAlertable: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn CreateMutexA(
    lpMutexAttributes: ?*SECURITY_ATTRIBUTES,
    bInitialOwner: BOOL,
    lpName: ?*i8,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn CreateMutexW(
    lpMutexAttributes: ?*SECURITY_ATTRIBUTES,
    bInitialOwner: BOOL,
    lpName: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn OpenMutexW(
    dwDesiredAccess: u32,
    bInheritHandle: BOOL,
    lpName: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn CreateEventA(
    lpEventAttributes: ?*SECURITY_ATTRIBUTES,
    bManualReset: BOOL,
    bInitialState: BOOL,
    lpName: ?*i8,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn CreateEventW(
    lpEventAttributes: ?*SECURITY_ATTRIBUTES,
    bManualReset: BOOL,
    bInitialState: BOOL,
    lpName: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn OpenEventA(
    dwDesiredAccess: u32,
    bInheritHandle: BOOL,
    lpName: ?*i8,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn OpenEventW(
    dwDesiredAccess: u32,
    bInheritHandle: BOOL,
    lpName: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn OpenSemaphoreW(
    dwDesiredAccess: u32,
    bInheritHandle: BOOL,
    lpName: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn OpenWaitableTimerW(
    dwDesiredAccess: u32,
    bInheritHandle: BOOL,
    lpTimerName: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn SetWaitableTimerEx(
    hTimer: HANDLE,
    lpDueTime: ?*LARGE_INTEGER,
    lPeriod: i32,
    pfnCompletionRoutine: PTIMERAPCROUTINE,
    lpArgToCompletionRoutine: ?*opaque{},
    WakeContext: ?*REASON_CONTEXT,
    TolerableDelay: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn SetWaitableTimer(
    hTimer: HANDLE,
    lpDueTime: ?*LARGE_INTEGER,
    lPeriod: i32,
    pfnCompletionRoutine: PTIMERAPCROUTINE,
    lpArgToCompletionRoutine: ?*opaque{},
    fResume: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn CancelWaitableTimer(
    hTimer: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn CreateMutexExA(
    lpMutexAttributes: ?*SECURITY_ATTRIBUTES,
    lpName: ?*i8,
    dwFlags: u32,
    dwDesiredAccess: u32,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn CreateMutexExW(
    lpMutexAttributes: ?*SECURITY_ATTRIBUTES,
    lpName: ?*u16,
    dwFlags: u32,
    dwDesiredAccess: u32,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn CreateEventExA(
    lpEventAttributes: ?*SECURITY_ATTRIBUTES,
    lpName: ?*i8,
    dwFlags: u32,
    dwDesiredAccess: u32,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn CreateEventExW(
    lpEventAttributes: ?*SECURITY_ATTRIBUTES,
    lpName: ?*u16,
    dwFlags: u32,
    dwDesiredAccess: u32,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn CreateSemaphoreExW(
    lpSemaphoreAttributes: ?*SECURITY_ATTRIBUTES,
    lInitialCount: i32,
    lMaximumCount: i32,
    lpName: ?*u16,
    dwFlags: u32,
    dwDesiredAccess: u32,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn CreateWaitableTimerExW(
    lpTimerAttributes: ?*SECURITY_ATTRIBUTES,
    lpTimerName: ?*u16,
    dwFlags: u32,
    dwDesiredAccess: u32,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn EnterSynchronizationBarrier(
    lpBarrier: ?*RTL_BARRIER,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn InitializeSynchronizationBarrier(
    lpBarrier: ?*RTL_BARRIER,
    lTotalThreads: i32,
    lSpinCount: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn DeleteSynchronizationBarrier(
    lpBarrier: ?*RTL_BARRIER,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn Sleep(
    dwMilliseconds: u32,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=True (can and should we use this?)
pub extern "api-ms-win-core-synch-l1-2-0" fn WaitOnAddress(
    Address: ?*opaque{},
    CompareAddress: ?*opaque{},
    AddressSize: ?*opaque{},
    dwMilliseconds: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-core-synch-l1-2-0" fn WakeByAddressSingle(
    Address: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-core-synch-l1-2-0" fn WakeByAddressAll(
    Address: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn WaitForMultipleObjects(
    nCount: u32,
    lpHandles: ?*?*opaque{},
    bWaitAll: BOOL,
    dwMilliseconds: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn CreateSemaphoreW(
    lpSemaphoreAttributes: ?*SECURITY_ATTRIBUTES,
    lInitialCount: i32,
    lMaximumCount: i32,
    lpName: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn CreateWaitableTimerW(
    lpTimerAttributes: ?*SECURITY_ATTRIBUTES,
    bManualReset: BOOL,
    lpTimerName: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn InitializeSListHead(
    ListHead: ?*SLIST_HEADER,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn InterlockedPopEntrySList(
    ListHead: ?*SLIST_HEADER,
) callconv(@import("std").os.windows.WINAPI) ?*SINGLE_LIST_ENTRY;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn InterlockedPushEntrySList(
    ListHead: ?*SLIST_HEADER,
    ListEntry: ?*SINGLE_LIST_ENTRY,
) callconv(@import("std").os.windows.WINAPI) ?*SINGLE_LIST_ENTRY;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn InterlockedPushListSListEx(
    ListHead: ?*SLIST_HEADER,
    List: ?*SINGLE_LIST_ENTRY,
    ListEnd: ?*SINGLE_LIST_ENTRY,
    Count: u32,
) callconv(@import("std").os.windows.WINAPI) ?*SINGLE_LIST_ENTRY;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn InterlockedFlushSList(
    ListHead: ?*SLIST_HEADER,
) callconv(@import("std").os.windows.WINAPI) ?*SINGLE_LIST_ENTRY;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn QueryDepthSList(
    ListHead: ?*SLIST_HEADER,
) callconv(@import("std").os.windows.WINAPI) u16;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn QueueUserWorkItem(
    Function: LPTHREAD_START_ROUTINE,
    Context: ?*opaque{},
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn UnregisterWaitEx(
    WaitHandle: HANDLE,
    CompletionEvent: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn CreateTimerQueue(
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn CreateTimerQueueTimer(
    phNewTimer: ?*?*opaque{},
    TimerQueue: HANDLE,
    Callback: WAITORTIMERCALLBACK,
    Parameter: ?*opaque{},
    DueTime: u32,
    Period: u32,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn ChangeTimerQueueTimer(
    TimerQueue: HANDLE,
    Timer: HANDLE,
    DueTime: u32,
    Period: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn DeleteTimerQueueTimer(
    TimerQueue: HANDLE,
    Timer: HANDLE,
    CompletionEvent: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn DeleteTimerQueueEx(
    TimerQueue: HANDLE,
    CompletionEvent: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn CreateThreadpool(
    reserved: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) PTP_POOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn SetThreadpoolThreadMaximum(
    ptpp: PTP_POOL,
    cthrdMost: u32,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn SetThreadpoolThreadMinimum(
    ptpp: PTP_POOL,
    cthrdMic: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn SetThreadpoolStackInformation(
    ptpp: PTP_POOL,
    ptpsi: ?*TP_POOL_STACK_INFORMATION,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn QueryThreadpoolStackInformation(
    ptpp: PTP_POOL,
    ptpsi: ?*TP_POOL_STACK_INFORMATION,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn CloseThreadpool(
    ptpp: PTP_POOL,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn CreateThreadpoolCleanupGroup(
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn CloseThreadpoolCleanupGroupMembers(
    ptpcg: ?*opaque{},
    fCancelPendingCallbacks: BOOL,
    pvCleanupContext: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn CloseThreadpoolCleanupGroup(
    ptpcg: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn SetEventWhenCallbackReturns(
    pci: ?*TP_CALLBACK_INSTANCE,
    evt: HANDLE,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn ReleaseSemaphoreWhenCallbackReturns(
    pci: ?*TP_CALLBACK_INSTANCE,
    sem: HANDLE,
    crel: u32,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn ReleaseMutexWhenCallbackReturns(
    pci: ?*TP_CALLBACK_INSTANCE,
    mut: HANDLE,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn LeaveCriticalSectionWhenCallbackReturns(
    pci: ?*TP_CALLBACK_INSTANCE,
    pcs: ?*RTL_CRITICAL_SECTION,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn FreeLibraryWhenCallbackReturns(
    pci: ?*TP_CALLBACK_INSTANCE,
    mod: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn CallbackMayRunLong(
    pci: ?*TP_CALLBACK_INSTANCE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn DisassociateCurrentThreadFromCallback(
    pci: ?*TP_CALLBACK_INSTANCE,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn TrySubmitThreadpoolCallback(
    pfns: PTP_SIMPLE_CALLBACK,
    pv: ?*opaque{},
    pcbe: ?*TP_CALLBACK_ENVIRON_V3,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn CreateThreadpoolWork(
    pfnwk: PTP_WORK_CALLBACK,
    pv: ?*opaque{},
    pcbe: ?*TP_CALLBACK_ENVIRON_V3,
) callconv(@import("std").os.windows.WINAPI) ?*TP_WORK;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn SubmitThreadpoolWork(
    pwk: ?*TP_WORK,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn WaitForThreadpoolWorkCallbacks(
    pwk: ?*TP_WORK,
    fCancelPendingCallbacks: BOOL,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn CloseThreadpoolWork(
    pwk: ?*TP_WORK,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn CreateThreadpoolTimer(
    pfnti: PTP_TIMER_CALLBACK,
    pv: ?*opaque{},
    pcbe: ?*TP_CALLBACK_ENVIRON_V3,
) callconv(@import("std").os.windows.WINAPI) ?*TP_TIMER;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn SetThreadpoolTimer(
    pti: ?*TP_TIMER,
    pftDueTime: ?*FILETIME,
    msPeriod: u32,
    msWindowLength: u32,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn IsThreadpoolTimerSet(
    pti: ?*TP_TIMER,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn WaitForThreadpoolTimerCallbacks(
    pti: ?*TP_TIMER,
    fCancelPendingCallbacks: BOOL,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn CloseThreadpoolTimer(
    pti: ?*TP_TIMER,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn CreateThreadpoolWait(
    pfnwa: PTP_WAIT_CALLBACK,
    pv: ?*opaque{},
    pcbe: ?*TP_CALLBACK_ENVIRON_V3,
) callconv(@import("std").os.windows.WINAPI) ?*TP_WAIT;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn SetThreadpoolWait(
    pwa: ?*TP_WAIT,
    h: HANDLE,
    pftTimeout: ?*FILETIME,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn WaitForThreadpoolWaitCallbacks(
    pwa: ?*TP_WAIT,
    fCancelPendingCallbacks: BOOL,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn CloseThreadpoolWait(
    pwa: ?*TP_WAIT,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn CreateThreadpoolIo(
    fl: HANDLE,
    pfnio: PTP_WIN32_IO_CALLBACK,
    pv: ?*opaque{},
    pcbe: ?*TP_CALLBACK_ENVIRON_V3,
) callconv(@import("std").os.windows.WINAPI) ?*TP_IO;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn StartThreadpoolIo(
    pio: ?*TP_IO,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn CancelThreadpoolIo(
    pio: ?*TP_IO,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn WaitForThreadpoolIoCallbacks(
    pio: ?*TP_IO,
    fCancelPendingCallbacks: BOOL,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn CloseThreadpoolIo(
    pio: ?*TP_IO,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn SetThreadpoolTimerEx(
    pti: ?*TP_TIMER,
    pftDueTime: ?*FILETIME,
    msPeriod: u32,
    msWindowLength: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn SetThreadpoolWaitEx(
    pwa: ?*TP_WAIT,
    h: HANDLE,
    pftTimeout: ?*FILETIME,
    Reserved: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn IsProcessInJob(
    ProcessHandle: HANDLE,
    JobHandle: HANDLE,
    Result: ?*i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn CreateJobObjectW(
    lpJobAttributes: ?*SECURITY_ATTRIBUTES,
    lpName: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn FreeMemoryJobObject(
    Buffer: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn OpenJobObjectW(
    dwDesiredAccess: u32,
    bInheritHandle: BOOL,
    lpName: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn AssignProcessToJobObject(
    hJob: HANDLE,
    hProcess: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn TerminateJobObject(
    hJob: HANDLE,
    uExitCode: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn SetInformationJobObject(
    hJob: HANDLE,
    JobObjectInformationClass: JOBOBJECTINFOCLASS,
    lpJobObjectInformation: ?*opaque{},
    cbJobObjectInformationLength: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn SetIoRateControlInformationJobObject(
    hJob: HANDLE,
    IoRateControlInfo: ?*JOBOBJECT_IO_RATE_CONTROL_INFORMATION,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn QueryInformationJobObject(
    hJob: HANDLE,
    JobObjectInformationClass: JOBOBJECTINFOCLASS,
    lpJobObjectInformation: ?*opaque{},
    cbJobObjectInformationLength: u32,
    lpReturnLength: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn QueryIoRateControlInformationJobObject(
    hJob: HANDLE,
    VolumeName: ?*u16,
    InfoBlocks: ?*?*JOBOBJECT_IO_RATE_CONTROL_INFORMATION,
    InfoBlockCount: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn CreatePrivateNamespaceW(
    lpPrivateNamespaceAttributes: ?*SECURITY_ATTRIBUTES,
    lpBoundaryDescriptor: ?*opaque{},
    lpAliasPrefix: ?*u16,
) callconv(@import("std").os.windows.WINAPI) NamespaceHandle;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn OpenPrivateNamespaceW(
    lpBoundaryDescriptor: ?*opaque{},
    lpAliasPrefix: ?*u16,
) callconv(@import("std").os.windows.WINAPI) NamespaceHandle;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn ClosePrivateNamespace(
    Handle: NamespaceHandle,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) u8;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn CreateBoundaryDescriptorW(
    Name: ?*u16,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) BoundaryDescriptorHandle;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn AddSIDToBoundaryDescriptor(
    BoundaryDescriptor: ?*HANDLE,
    RequiredSid: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn DeleteBoundaryDescriptor(
    BoundaryDescriptor: BoundaryDescriptorHandle,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetNumaHighestNodeNumber(
    HighestNodeNumber: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn GetNumaNodeProcessorMaskEx(
    Node: u16,
    ProcessorMask: ?*GROUP_AFFINITY,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn GetNumaProximityNodeEx(
    ProximityId: u32,
    NodeNumber: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn GetProcessGroupAffinity(
    hProcess: HANDLE,
    GroupCount: ?*u16,
    GroupArray: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn GetThreadGroupAffinity(
    hThread: HANDLE,
    GroupAffinity: ?*GROUP_AFFINITY,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn SetThreadGroupAffinity(
    hThread: HANDLE,
    GroupAffinity: ?*GROUP_AFFINITY,
    PreviousGroupAffinity: ?*GROUP_AFFINITY,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn CreatePipe(
    hReadPipe: ?*?*opaque{},
    hWritePipe: ?*?*opaque{},
    lpPipeAttributes: ?*SECURITY_ATTRIBUTES,
    nSize: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn ConnectNamedPipe(
    hNamedPipe: HANDLE,
    lpOverlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn DisconnectNamedPipe(
    hNamedPipe: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn SetNamedPipeHandleState(
    hNamedPipe: HANDLE,
    lpMode: ?*u32,
    lpMaxCollectionCount: ?*u32,
    lpCollectDataTimeout: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn PeekNamedPipe(
    hNamedPipe: HANDLE,
    lpBuffer: ?*opaque{},
    nBufferSize: u32,
    lpBytesRead: ?*u32,
    lpTotalBytesAvail: ?*u32,
    lpBytesLeftThisMessage: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn TransactNamedPipe(
    hNamedPipe: HANDLE,
    lpInBuffer: ?*opaque{},
    nInBufferSize: u32,
    lpOutBuffer: ?*opaque{},
    nOutBufferSize: u32,
    lpBytesRead: ?*u32,
    lpOverlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn CreateNamedPipeW(
    lpName: ?*u16,
    dwOpenMode: u32,
    dwPipeMode: u32,
    nMaxInstances: u32,
    nOutBufferSize: u32,
    nInBufferSize: u32,
    nDefaultTimeOut: u32,
    lpSecurityAttributes: ?*SECURITY_ATTRIBUTES,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn WaitNamedPipeW(
    lpNamedPipeName: ?*u16,
    nTimeOut: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn GetNamedPipeClientComputerNameW(
    Pipe: HANDLE,
    ClientComputerName: ?*u16,
    ClientComputerNameLength: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetNamedPipeInfo(
    hNamedPipe: HANDLE,
    lpFlags: ?*u32,
    lpOutBufferSize: ?*u32,
    lpInBufferSize: ?*u32,
    lpMaxInstances: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn GetNamedPipeHandleStateW(
    hNamedPipe: HANDLE,
    lpState: ?*u32,
    lpCurInstances: ?*u32,
    lpMaxCollectionCount: ?*u32,
    lpCollectDataTimeout: ?*u32,
    lpUserName: ?*u16,
    nMaxUserNameSize: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn CallNamedPipeW(
    lpNamedPipeName: ?*u16,
    lpInBuffer: ?*opaque{},
    nInBufferSize: u32,
    lpOutBuffer: ?*opaque{},
    nOutBufferSize: u32,
    lpBytesRead: ?*u32,
    nTimeOut: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn HeapCreate(
    flOptions: u32,
    dwInitialSize: ?*opaque{},
    dwMaximumSize: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HeapHandle;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn HeapDestroy(
    hHeap: HeapHandle,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn HeapAlloc(
    hHeap: HeapHandle,
    dwFlags: u32,
    dwBytes: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn HeapReAlloc(
    hHeap: HeapHandle,
    dwFlags: u32,
    lpMem: ?*opaque{},
    dwBytes: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn HeapFree(
    hHeap: HANDLE,
    dwFlags: u32,
    lpMem: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn HeapSize(
    hHeap: HeapHandle,
    dwFlags: u32,
    lpMem: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetProcessHeap(
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn HeapCompact(
    hHeap: HeapHandle,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn HeapSetInformation(
    HeapHandle: HANDLE,
    HeapInformationClass: HEAP_INFORMATION_CLASS,
    HeapInformation: ?*opaque{},
    HeapInformationLength: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn HeapValidate(
    hHeap: HANDLE,
    dwFlags: u32,
    lpMem: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn HeapSummary(
    hHeap: HANDLE,
    dwFlags: u32,
    lpSummary: ?*HEAP_SUMMARY,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetProcessHeaps(
    NumberOfHeaps: u32,
    ProcessHeaps: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn HeapLock(
    hHeap: HeapHandle,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn HeapUnlock(
    hHeap: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn HeapWalk(
    hHeap: HANDLE,
    lpEntry: ?*PROCESS_HEAP_ENTRY,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn HeapQueryInformation(
    HeapHandle: HANDLE,
    HeapInformationClass: HEAP_INFORMATION_CLASS,
    HeapInformation: ?*opaque{},
    HeapInformationLength: ?*opaque{},
    ReturnLength: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn VirtualAlloc(
    lpAddress: ?*opaque{},
    dwSize: ?*opaque{},
    flAllocationType: u32,
    flProtect: u32,
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn VirtualProtect(
    lpAddress: ?*opaque{},
    dwSize: ?*opaque{},
    flNewProtect: u32,
    lpflOldProtect: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn VirtualFree(
    lpAddress: ?*opaque{},
    dwSize: ?*opaque{},
    dwFreeType: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn VirtualQuery(
    lpAddress: ?*opaque{},
    lpBuffer: ?*MEMORY_BASIC_INFORMATION,
    dwLength: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn VirtualAllocEx(
    hProcess: HANDLE,
    lpAddress: ?*opaque{},
    dwSize: ?*opaque{},
    flAllocationType: u32,
    flProtect: u32,
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn VirtualProtectEx(
    hProcess: HANDLE,
    lpAddress: ?*opaque{},
    dwSize: ?*opaque{},
    flNewProtect: u32,
    lpflOldProtect: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn VirtualQueryEx(
    hProcess: HANDLE,
    lpAddress: ?*opaque{},
    lpBuffer: ?*MEMORY_BASIC_INFORMATION,
    dwLength: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn CreateFileMappingW(
    hFile: HANDLE,
    lpFileMappingAttributes: ?*SECURITY_ATTRIBUTES,
    flProtect: u32,
    dwMaximumSizeHigh: u32,
    dwMaximumSizeLow: u32,
    lpName: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn OpenFileMappingW(
    dwDesiredAccess: u32,
    bInheritHandle: BOOL,
    lpName: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn MapViewOfFile(
    hFileMappingObject: HANDLE,
    dwDesiredAccess: u32,
    dwFileOffsetHigh: u32,
    dwFileOffsetLow: u32,
    dwNumberOfBytesToMap: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn MapViewOfFileEx(
    hFileMappingObject: HANDLE,
    dwDesiredAccess: u32,
    dwFileOffsetHigh: u32,
    dwFileOffsetLow: u32,
    dwNumberOfBytesToMap: ?*opaque{},
    lpBaseAddress: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn VirtualFreeEx(
    hProcess: HANDLE,
    lpAddress: ?*opaque{},
    dwSize: ?*opaque{},
    dwFreeType: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn FlushViewOfFile(
    lpBaseAddress: ?*opaque{},
    dwNumberOfBytesToFlush: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn UnmapViewOfFile(
    lpBaseAddress: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn GetLargePageMinimum(
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn GetProcessWorkingSetSizeEx(
    hProcess: HANDLE,
    lpMinimumWorkingSetSize: ?*?*opaque{},
    lpMaximumWorkingSetSize: ?*?*opaque{},
    Flags: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn SetProcessWorkingSetSizeEx(
    hProcess: HANDLE,
    dwMinimumWorkingSetSize: ?*opaque{},
    dwMaximumWorkingSetSize: ?*opaque{},
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn VirtualLock(
    lpAddress: ?*opaque{},
    dwSize: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn VirtualUnlock(
    lpAddress: ?*opaque{},
    dwSize: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn GetWriteWatch(
    dwFlags: u32,
    lpBaseAddress: ?*opaque{},
    dwRegionSize: ?*opaque{},
    lpAddresses: ?*?*opaque{},
    lpdwCount: ?*?*opaque{},
    lpdwGranularity: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn ResetWriteWatch(
    lpBaseAddress: ?*opaque{},
    dwRegionSize: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn CreateMemoryResourceNotification(
    NotificationType: MEMORY_RESOURCE_NOTIFICATION_TYPE,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn QueryMemoryResourceNotification(
    ResourceNotificationHandle: HANDLE,
    ResourceState: ?*i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetSystemFileCacheSize(
    lpMinimumFileCacheSize: ?*?*opaque{},
    lpMaximumFileCacheSize: ?*?*opaque{},
    lpFlags: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn SetSystemFileCacheSize(
    MinimumFileCacheSize: ?*opaque{},
    MaximumFileCacheSize: ?*opaque{},
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn CreateFileMappingNumaW(
    hFile: HANDLE,
    lpFileMappingAttributes: ?*SECURITY_ATTRIBUTES,
    flProtect: u32,
    dwMaximumSizeHigh: u32,
    dwMaximumSizeLow: u32,
    lpName: ?*u16,
    nndPreferred: u32,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn PrefetchVirtualMemory(
    hProcess: HANDLE,
    NumberOfEntries: ?*opaque{},
    VirtualAddresses: ?*WIN32_MEMORY_RANGE_ENTRY,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn CreateFileMappingFromApp(
    hFile: HANDLE,
    SecurityAttributes: ?*SECURITY_ATTRIBUTES,
    PageProtection: u32,
    MaximumSize: u64,
    Name: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn MapViewOfFileFromApp(
    hFileMappingObject: HANDLE,
    DesiredAccess: u32,
    FileOffset: u64,
    NumberOfBytesToMap: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn UnmapViewOfFileEx(
    BaseAddress: ?*opaque{},
    UnmapFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn AllocateUserPhysicalPages(
    hProcess: HANDLE,
    NumberOfPages: ?*u32,
    PageArray: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn FreeUserPhysicalPages(
    hProcess: HANDLE,
    NumberOfPages: ?*u32,
    PageArray: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn MapUserPhysicalPages(
    VirtualAddress: ?*opaque{},
    NumberOfPages: ?*opaque{},
    PageArray: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn AllocateUserPhysicalPagesNuma(
    hProcess: HANDLE,
    NumberOfPages: ?*u32,
    PageArray: ?*u32,
    nndPreferred: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn VirtualAllocExNuma(
    hProcess: HANDLE,
    lpAddress: ?*opaque{},
    dwSize: ?*opaque{},
    flAllocationType: u32,
    flProtect: u32,
    nndPreferred: u32,
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetMemoryErrorHandlingCapabilities(
    Capabilities: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn RegisterBadMemoryNotification(
    Callback: PBAD_MEMORY_CALLBACK_ROUTINE,
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn UnregisterBadMemoryNotification(
    RegistrationHandle: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn OfferVirtualMemory(
    VirtualAddress: ?*opaque{},
    Size: ?*opaque{},
    Priority: OFFER_PRIORITY,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn ReclaimVirtualMemory(
    VirtualAddress: ?*opaque{},
    Size: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn DiscardVirtualMemory(
    VirtualAddress: ?*opaque{},
    Size: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "api-ms-win-core-memory-l1-1-3" fn SetProcessValidCallTargets(
    hProcess: HANDLE,
    VirtualAddress: ?*opaque{},
    RegionSize: ?*opaque{},
    NumberOfOffsets: u32,
    OffsetInformation: ?*CFG_CALL_TARGET_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-core-memory-l1-1-7" fn SetProcessValidCallTargetsForMappedView(
    Process: HANDLE,
    VirtualAddress: ?*opaque{},
    RegionSize: ?*opaque{},
    NumberOfOffsets: u32,
    OffsetInformation: ?*CFG_CALL_TARGET_INFO,
    Section: HANDLE,
    ExpectedFileOffset: u64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "api-ms-win-core-memory-l1-1-3" fn VirtualAllocFromApp(
    BaseAddress: ?*opaque{},
    Size: ?*opaque{},
    AllocationType: u32,
    Protection: u32,
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=True (can and should we use this?)
pub extern "api-ms-win-core-memory-l1-1-3" fn VirtualProtectFromApp(
    Address: ?*opaque{},
    Size: ?*opaque{},
    NewProtection: u32,
    OldProtection: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "api-ms-win-core-memory-l1-1-3" fn OpenFileMappingFromApp(
    DesiredAccess: u32,
    InheritHandle: BOOL,
    Name: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// set_last_errror=True (can and should we use this?)
pub extern "api-ms-win-core-memory-l1-1-4" fn QueryVirtualMemoryInformation(
    Process: HANDLE,
    VirtualAddress: ?*opaque{},
    MemoryInformationClass: WIN32_MEMORY_INFORMATION_CLASS,
    MemoryInformation: ?*opaque{},
    MemoryInformationSize: ?*opaque{},
    ReturnSize: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "api-ms-win-core-memory-l1-1-5" fn MapViewOfFileNuma2(
    FileMappingHandle: HANDLE,
    ProcessHandle: HANDLE,
    Offset: u64,
    BaseAddress: ?*opaque{},
    ViewSize: ?*opaque{},
    AllocationType: u32,
    PageProtection: u32,
    PreferredNode: u32,
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=True (can and should we use this?)
pub extern "api-ms-win-core-memory-l1-1-5" fn UnmapViewOfFile2(
    Process: HANDLE,
    BaseAddress: ?*opaque{},
    UnmapFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-core-memory-l1-1-5" fn VirtualUnlockEx(
    Process: HANDLE,
    Address: ?*opaque{},
    Size: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "api-ms-win-core-memory-l1-1-6" fn VirtualAlloc2(
    Process: HANDLE,
    BaseAddress: ?*opaque{},
    Size: ?*opaque{},
    AllocationType: u32,
    PageProtection: u32,
    ExtendedParameters: ?*MEM_EXTENDED_PARAMETER,
    ParameterCount: u32,
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=True (can and should we use this?)
pub extern "api-ms-win-core-memory-l1-1-6" fn MapViewOfFile3(
    FileMapping: HANDLE,
    Process: HANDLE,
    BaseAddress: ?*opaque{},
    Offset: u64,
    ViewSize: ?*opaque{},
    AllocationType: u32,
    PageProtection: u32,
    ExtendedParameters: ?*MEM_EXTENDED_PARAMETER,
    ParameterCount: u32,
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=True (can and should we use this?)
pub extern "api-ms-win-core-memory-l1-1-6" fn VirtualAlloc2FromApp(
    Process: HANDLE,
    BaseAddress: ?*opaque{},
    Size: ?*opaque{},
    AllocationType: u32,
    PageProtection: u32,
    ExtendedParameters: ?*MEM_EXTENDED_PARAMETER,
    ParameterCount: u32,
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=True (can and should we use this?)
pub extern "api-ms-win-core-memory-l1-1-6" fn MapViewOfFile3FromApp(
    FileMapping: HANDLE,
    Process: HANDLE,
    BaseAddress: ?*opaque{},
    Offset: u64,
    ViewSize: ?*opaque{},
    AllocationType: u32,
    PageProtection: u32,
    ExtendedParameters: ?*MEM_EXTENDED_PARAMETER,
    ParameterCount: u32,
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=True (can and should we use this?)
pub extern "api-ms-win-core-memory-l1-1-7" fn CreateFileMapping2(
    File: HANDLE,
    SecurityAttributes: ?*SECURITY_ATTRIBUTES,
    DesiredAccess: u32,
    PageProtection: u32,
    AllocationAttributes: u32,
    MaximumSize: u64,
    Name: ?*u16,
    ExtendedParameters: ?*MEM_EXTENDED_PARAMETER,
    ParameterCount: u32,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn IsEnclaveTypeSupported(
    flEnclaveType: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn CreateEnclave(
    hProcess: HANDLE,
    lpAddress: ?*opaque{},
    dwSize: ?*opaque{},
    dwInitialCommitment: ?*opaque{},
    flEnclaveType: u32,
    lpEnclaveInformation: ?*opaque{},
    dwInfoLength: u32,
    lpEnclaveError: ?*u32,
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn LoadEnclaveData(
    hProcess: HANDLE,
    lpAddress: ?*opaque{},
    lpBuffer: ?*opaque{},
    nSize: ?*opaque{},
    flProtect: u32,
    lpPageInformation: ?*opaque{},
    dwInfoLength: u32,
    lpNumberOfBytesWritten: ?*?*opaque{},
    lpEnclaveError: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn InitializeEnclave(
    hProcess: HANDLE,
    lpAddress: ?*opaque{},
    lpEnclaveInformation: ?*opaque{},
    dwInfoLength: u32,
    lpEnclaveError: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-core-enclave-l1-1-1" fn LoadEnclaveImageA(
    lpEnclaveAddress: ?*opaque{},
    lpImageName: ?*i8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "api-ms-win-core-enclave-l1-1-1" fn LoadEnclaveImageW(
    lpEnclaveAddress: ?*opaque{},
    lpImageName: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "api-ms-win-core-enclave-l1-1-1" fn CallEnclave(
    lpRoutine: LPENCLAVE_ROUTINE,
    lpParameter: ?*opaque{},
    fWaitForThread: BOOL,
    lpReturnValue: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "api-ms-win-core-enclave-l1-1-1" fn TerminateEnclave(
    lpAddress: ?*opaque{},
    fWait: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "api-ms-win-core-enclave-l1-1-1" fn DeleteEnclave(
    lpAddress: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn DisableThreadLibraryCalls(
    hLibModule: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn FindResourceExW(
    hModule: ?*opaque{},
    lpType: ?*u16,
    lpName: ?*u16,
    wLanguage: u16,
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn FreeLibrary(
    hLibModule: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn FreeLibraryAndExitThread(
    hLibModule: ?*opaque{},
    dwExitCode: u32,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetModuleFileNameA(
    hModule: ?*opaque{},
    lpFilename: ?*i8,
    nSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetModuleFileNameW(
    hModule: ?*opaque{},
    lpFilename: ?*u16,
    nSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetModuleHandleA(
    lpModuleName: ?*i8,
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetModuleHandleW(
    lpModuleName: ?*u16,
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetModuleHandleExA(
    dwFlags: u32,
    lpModuleName: ?*i8,
    phModule: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetModuleHandleExW(
    dwFlags: u32,
    lpModuleName: ?*u16,
    phModule: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetProcAddress(
    hModule: ?*opaque{},
    lpProcName: ?*i8,
) callconv(@import("std").os.windows.WINAPI) FARPROC;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn LoadLibraryExA(
    lpLibFileName: ?*i8,
    hFile: HANDLE,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn LoadLibraryExW(
    lpLibFileName: ?*u16,
    hFile: HANDLE,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn AddDllDirectory(
    NewDirectory: ?*u16,
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn RemoveDllDirectory(
    Cookie: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn SetDefaultDllDirectories(
    DirectoryFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn FindResourceW(
    hModule: ?*opaque{},
    lpName: ?*u16,
    lpType: ?*u16,
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn LoadLibraryA(
    lpLibFileName: ?*i8,
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn LoadLibraryW(
    lpLibFileName: ?*u16,
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn EnumResourceNamesW(
    hModule: ?*opaque{},
    lpType: ?*u16,
    lpEnumFunc: ENUMRESNAMEPROCW,
    lParam: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn AllocConsole(
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn FreeConsole(
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn AttachConsole(
    dwProcessId: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn GetConsoleCP(
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn GetConsoleOutputCP(
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn GetConsoleMode(
    hConsoleHandle: HANDLE,
    lpMode: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn SetConsoleMode(
    hConsoleHandle: HANDLE,
    dwMode: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn GetNumberOfConsoleInputEvents(
    hConsoleInput: HANDLE,
    lpNumberOfEvents: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn ReadConsoleInputA(
    hConsoleInput: HANDLE,
    lpBuffer: ?*INPUT_RECORD,
    nLength: u32,
    lpNumberOfEventsRead: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn ReadConsoleInputW(
    hConsoleInput: HANDLE,
    lpBuffer: ?*INPUT_RECORD,
    nLength: u32,
    lpNumberOfEventsRead: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn PeekConsoleInputA(
    hConsoleInput: HANDLE,
    lpBuffer: ?*INPUT_RECORD,
    nLength: u32,
    lpNumberOfEventsRead: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn PeekConsoleInputW(
    hConsoleInput: HANDLE,
    lpBuffer: ?*INPUT_RECORD,
    nLength: u32,
    lpNumberOfEventsRead: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn ReadConsoleA(
    hConsoleInput: HANDLE,
    lpBuffer: ?*opaque{},
    nNumberOfCharsToRead: u32,
    lpNumberOfCharsRead: ?*u32,
    pInputControl: ?*CONSOLE_READCONSOLE_CONTROL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn ReadConsoleW(
    hConsoleInput: HANDLE,
    lpBuffer: ?*opaque{},
    nNumberOfCharsToRead: u32,
    lpNumberOfCharsRead: ?*u32,
    pInputControl: ?*CONSOLE_READCONSOLE_CONTROL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn WriteConsoleA(
    hConsoleOutput: HANDLE,
    lpBuffer: ?*opaque{},
    nNumberOfCharsToWrite: u32,
    lpNumberOfCharsWritten: ?*u32,
    lpReserved: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn WriteConsoleW(
    hConsoleOutput: HANDLE,
    lpBuffer: ?*opaque{},
    nNumberOfCharsToWrite: u32,
    lpNumberOfCharsWritten: ?*u32,
    lpReserved: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn SetConsoleCtrlHandler(
    HandlerRoutine: PHANDLER_ROUTINE,
    Add: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn CreatePseudoConsole(
    size: COORD,
    hInput: HANDLE,
    hOutput: HANDLE,
    dwFlags: u32,
    phPC: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn ResizePseudoConsole(
    hPC: ?*opaque{},
    size: COORD,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn ClosePseudoConsole(
    hPC: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn FillConsoleOutputCharacterA(
    hConsoleOutput: HANDLE,
    cCharacter: i8,
    nLength: u32,
    dwWriteCoord: COORD,
    lpNumberOfCharsWritten: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn FillConsoleOutputCharacterW(
    hConsoleOutput: HANDLE,
    cCharacter: u16,
    nLength: u32,
    dwWriteCoord: COORD,
    lpNumberOfCharsWritten: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn FillConsoleOutputAttribute(
    hConsoleOutput: HANDLE,
    wAttribute: u16,
    nLength: u32,
    dwWriteCoord: COORD,
    lpNumberOfAttrsWritten: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn GenerateConsoleCtrlEvent(
    dwCtrlEvent: u32,
    dwProcessGroupId: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn CreateConsoleScreenBuffer(
    dwDesiredAccess: u32,
    dwShareMode: u32,
    lpSecurityAttributes: ?*SECURITY_ATTRIBUTES,
    dwFlags: u32,
    lpScreenBufferData: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn SetConsoleActiveScreenBuffer(
    hConsoleOutput: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn FlushConsoleInputBuffer(
    hConsoleInput: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn SetConsoleCP(
    wCodePageID: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn SetConsoleOutputCP(
    wCodePageID: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn GetConsoleCursorInfo(
    hConsoleOutput: HANDLE,
    lpConsoleCursorInfo: ?*CONSOLE_CURSOR_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn SetConsoleCursorInfo(
    hConsoleOutput: HANDLE,
    lpConsoleCursorInfo: ?*CONSOLE_CURSOR_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn GetConsoleScreenBufferInfo(
    hConsoleOutput: HANDLE,
    lpConsoleScreenBufferInfo: ?*CONSOLE_SCREEN_BUFFER_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn GetConsoleScreenBufferInfoEx(
    hConsoleOutput: HANDLE,
    lpConsoleScreenBufferInfoEx: ?*CONSOLE_SCREEN_BUFFER_INFOEX,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn SetConsoleScreenBufferInfoEx(
    hConsoleOutput: HANDLE,
    lpConsoleScreenBufferInfoEx: ?*CONSOLE_SCREEN_BUFFER_INFOEX,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn SetConsoleScreenBufferSize(
    hConsoleOutput: HANDLE,
    dwSize: COORD,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn SetConsoleCursorPosition(
    hConsoleOutput: HANDLE,
    dwCursorPosition: COORD,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn GetLargestConsoleWindowSize(
    hConsoleOutput: HANDLE,
) callconv(@import("std").os.windows.WINAPI) COORD;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn SetConsoleTextAttribute(
    hConsoleOutput: HANDLE,
    wAttributes: u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn SetConsoleWindowInfo(
    hConsoleOutput: HANDLE,
    bAbsolute: BOOL,
    lpConsoleWindow: ?*SMALL_RECT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn WriteConsoleOutputCharacterA(
    hConsoleOutput: HANDLE,
    lpCharacter: ?*i8,
    nLength: u32,
    dwWriteCoord: COORD,
    lpNumberOfCharsWritten: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn WriteConsoleOutputCharacterW(
    hConsoleOutput: HANDLE,
    lpCharacter: ?*u16,
    nLength: u32,
    dwWriteCoord: COORD,
    lpNumberOfCharsWritten: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn WriteConsoleOutputAttribute(
    hConsoleOutput: HANDLE,
    lpAttribute: ?*u16,
    nLength: u32,
    dwWriteCoord: COORD,
    lpNumberOfAttrsWritten: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn ReadConsoleOutputCharacterA(
    hConsoleOutput: HANDLE,
    lpCharacter: ?*i8,
    nLength: u32,
    dwReadCoord: COORD,
    lpNumberOfCharsRead: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn ReadConsoleOutputCharacterW(
    hConsoleOutput: HANDLE,
    lpCharacter: ?*u16,
    nLength: u32,
    dwReadCoord: COORD,
    lpNumberOfCharsRead: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn ReadConsoleOutputAttribute(
    hConsoleOutput: HANDLE,
    lpAttribute: ?*u16,
    nLength: u32,
    dwReadCoord: COORD,
    lpNumberOfAttrsRead: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn WriteConsoleInputA(
    hConsoleInput: HANDLE,
    lpBuffer: ?*INPUT_RECORD,
    nLength: u32,
    lpNumberOfEventsWritten: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn WriteConsoleInputW(
    hConsoleInput: HANDLE,
    lpBuffer: ?*INPUT_RECORD,
    nLength: u32,
    lpNumberOfEventsWritten: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn ScrollConsoleScreenBufferA(
    hConsoleOutput: HANDLE,
    lpScrollRectangle: ?*SMALL_RECT,
    lpClipRectangle: ?*SMALL_RECT,
    dwDestinationOrigin: COORD,
    lpFill: ?*CHAR_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn ScrollConsoleScreenBufferW(
    hConsoleOutput: HANDLE,
    lpScrollRectangle: ?*SMALL_RECT,
    lpClipRectangle: ?*SMALL_RECT,
    dwDestinationOrigin: COORD,
    lpFill: ?*CHAR_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn WriteConsoleOutputA(
    hConsoleOutput: HANDLE,
    lpBuffer: ?*CHAR_INFO,
    dwBufferSize: COORD,
    dwBufferCoord: COORD,
    lpWriteRegion: ?*SMALL_RECT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn WriteConsoleOutputW(
    hConsoleOutput: HANDLE,
    lpBuffer: ?*CHAR_INFO,
    dwBufferSize: COORD,
    dwBufferCoord: COORD,
    lpWriteRegion: ?*SMALL_RECT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn ReadConsoleOutputA(
    hConsoleOutput: HANDLE,
    lpBuffer: ?*CHAR_INFO,
    dwBufferSize: COORD,
    dwBufferCoord: COORD,
    lpReadRegion: ?*SMALL_RECT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn ReadConsoleOutputW(
    hConsoleOutput: HANDLE,
    lpBuffer: ?*CHAR_INFO,
    dwBufferSize: COORD,
    dwBufferCoord: COORD,
    lpReadRegion: ?*SMALL_RECT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn GetConsoleTitleA(
    lpConsoleTitle: ?*i8,
    nSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn GetConsoleTitleW(
    lpConsoleTitle: ?*u16,
    nSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn GetConsoleOriginalTitleA(
    lpConsoleTitle: ?*i8,
    nSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn GetConsoleOriginalTitleW(
    lpConsoleTitle: ?*u16,
    nSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn SetConsoleTitleA(
    lpConsoleTitle: ?*i8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn SetConsoleTitleW(
    lpConsoleTitle: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn GetNumberOfConsoleMouseButtons(
    lpNumberOfMouseButtons: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn GetConsoleFontSize(
    hConsoleOutput: HANDLE,
    nFont: u32,
) callconv(@import("std").os.windows.WINAPI) COORD;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn GetCurrentConsoleFont(
    hConsoleOutput: HANDLE,
    bMaximumWindow: BOOL,
    lpConsoleCurrentFont: ?*CONSOLE_FONT_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn GetCurrentConsoleFontEx(
    hConsoleOutput: HANDLE,
    bMaximumWindow: BOOL,
    lpConsoleCurrentFontEx: ?*CONSOLE_FONT_INFOEX,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn SetCurrentConsoleFontEx(
    hConsoleOutput: HANDLE,
    bMaximumWindow: BOOL,
    lpConsoleCurrentFontEx: ?*CONSOLE_FONT_INFOEX,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn GetConsoleSelectionInfo(
    lpConsoleSelectionInfo: ?*CONSOLE_SELECTION_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn GetConsoleHistoryInfo(
    lpConsoleHistoryInfo: ?*CONSOLE_HISTORY_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn SetConsoleHistoryInfo(
    lpConsoleHistoryInfo: ?*CONSOLE_HISTORY_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn GetConsoleDisplayMode(
    lpModeFlags: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn SetConsoleDisplayMode(
    hConsoleOutput: HANDLE,
    dwFlags: u32,
    lpNewScreenBufferDimensions: ?*COORD,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn GetConsoleWindow(
) callconv(@import("std").os.windows.WINAPI) HWND;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn AddConsoleAliasA(
    Source: ?*i8,
    Target: ?*i8,
    ExeName: ?*i8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn AddConsoleAliasW(
    Source: ?*u16,
    Target: ?*u16,
    ExeName: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn GetConsoleAliasA(
    Source: ?*i8,
    TargetBuffer: ?*i8,
    TargetBufferLength: u32,
    ExeName: ?*i8,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn GetConsoleAliasW(
    Source: ?*u16,
    TargetBuffer: ?*u16,
    TargetBufferLength: u32,
    ExeName: ?*u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn GetConsoleAliasesLengthA(
    ExeName: ?*i8,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn GetConsoleAliasesLengthW(
    ExeName: ?*u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn GetConsoleAliasExesLengthA(
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn GetConsoleAliasExesLengthW(
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn GetConsoleAliasesA(
    AliasBuffer: ?*i8,
    AliasBufferLength: u32,
    ExeName: ?*i8,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn GetConsoleAliasesW(
    AliasBuffer: ?*u16,
    AliasBufferLength: u32,
    ExeName: ?*u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn GetConsoleAliasExesA(
    ExeNameBuffer: ?*i8,
    ExeNameBufferLength: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn GetConsoleAliasExesW(
    ExeNameBuffer: ?*u16,
    ExeNameBufferLength: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn ExpungeConsoleCommandHistoryA(
    ExeName: ?*i8,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn ExpungeConsoleCommandHistoryW(
    ExeName: ?*u16,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn SetConsoleNumberOfCommandsA(
    Number: u32,
    ExeName: ?*i8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn SetConsoleNumberOfCommandsW(
    Number: u32,
    ExeName: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn GetConsoleCommandHistoryLengthA(
    ExeName: ?*i8,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn GetConsoleCommandHistoryLengthW(
    ExeName: ?*u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn GetConsoleCommandHistoryA(
    Commands: ?*i8,
    CommandBufferLength: u32,
    ExeName: ?*i8,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn GetConsoleCommandHistoryW(
    Commands: ?*u16,
    CommandBufferLength: u32,
    ExeName: ?*u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn GetConsoleProcessList(
    lpdwProcessList: ?*u32,
    dwProcessCount: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn timeSetEvent(
    uDelay: u32,
    uResolution: u32,
    fptc: LPTIMECALLBACK,
    dwUser: ?*opaque{},
    fuEvent: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn timeKillEvent(
    uTimerID: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "RPCNS4" fn I_RpcNsGetBuffer(
    Message: ?*RPC_MESSAGE,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "RPCNS4" fn I_RpcNsSendReceive(
    Message: ?*RPC_MESSAGE,
    Handle: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "RPCNS4" fn I_RpcNsRaiseException(
    Message: ?*RPC_MESSAGE,
    Status: i32,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "RPCNS4" fn I_RpcReBindBuffer(
    Message: ?*RPC_MESSAGE,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "WINSPOOL" fn EnumPrintersA(
    Flags: u32,
    Name: ?*i8,
    Level: u32,
    pPrinterEnum: ?*u8,
    cbBuf: u32,
    pcbNeeded: ?*u32,
    pcReturned: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "WINSPOOL" fn EnumPrintersW(
    Flags: u32,
    Name: ?*u16,
    Level: u32,
    pPrinterEnum: ?*u8,
    cbBuf: u32,
    pcbNeeded: ?*u32,
    pcReturned: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "WINSPOOL" fn GetSpoolFileHandle(
    hPrinter: HANDLE,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// set_last_errror=False (can and should we use this?)
pub extern "WINSPOOL" fn CommitSpoolData(
    hPrinter: HANDLE,
    hSpoolFile: HANDLE,
    cbCommit: u32,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// set_last_errror=False (can and should we use this?)
pub extern "WINSPOOL" fn CloseSpoolFileHandle(
    hPrinter: HANDLE,
    hSpoolFile: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "WINSPOOL" fn OpenPrinterA(
    pPrinterName: ?*i8,
    phPrinter: ?*?*opaque{},
    pDefault: ?*PRINTER_DEFAULTSA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "WINSPOOL" fn OpenPrinterW(
    pPrinterName: ?*u16,
    phPrinter: ?*?*opaque{},
    pDefault: ?*PRINTER_DEFAULTSW,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "WINSPOOL" fn ResetPrinterA(
    hPrinter: HANDLE,
    pDefault: ?*PRINTER_DEFAULTSA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SPOOLSS" fn ResetPrinterW(
    hPrinter: HANDLE,
    pDefault: ?*PRINTER_DEFAULTSW,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "WINSPOOL" fn SetJobA(
    hPrinter: HANDLE,
    JobId: u32,
    Level: u32,
    pJob: ?*u8,
    Command: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "WINSPOOL" fn SetJobW(
    hPrinter: HANDLE,
    JobId: u32,
    Level: u32,
    pJob: ?*u8,
    Command: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "WINSPOOL" fn GetJobA(
    hPrinter: HANDLE,
    JobId: u32,
    Level: u32,
    pJob: ?*u8,
    cbBuf: u32,
    pcbNeeded: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "WINSPOOL" fn GetJobW(
    hPrinter: HANDLE,
    JobId: u32,
    Level: u32,
    pJob: ?*u8,
    cbBuf: u32,
    pcbNeeded: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "WINSPOOL" fn EnumJobsA(
    hPrinter: HANDLE,
    FirstJob: u32,
    NoJobs: u32,
    Level: u32,
    pJob: ?*u8,
    cbBuf: u32,
    pcbNeeded: ?*u32,
    pcReturned: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "WINSPOOL" fn EnumJobsW(
    hPrinter: HANDLE,
    FirstJob: u32,
    NoJobs: u32,
    Level: u32,
    pJob: ?*u8,
    cbBuf: u32,
    pcbNeeded: ?*u32,
    pcReturned: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "WINSPOOL" fn AddPrinterA(
    pName: ?*i8,
    Level: u32,
    pPrinter: ?*u8,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// set_last_errror=False (can and should we use this?)
pub extern "WINSPOOL" fn AddPrinterW(
    pName: ?*u16,
    Level: u32,
    pPrinter: ?*u8,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// set_last_errror=False (can and should we use this?)
pub extern "WINSPOOL" fn DeletePrinter(
    hPrinter: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "WINSPOOL" fn SetPrinterA(
    hPrinter: HANDLE,
    Level: u32,
    pPrinter: ?*u8,
    Command: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "WINSPOOL" fn SetPrinterW(
    hPrinter: HANDLE,
    Level: u32,
    pPrinter: ?*u8,
    Command: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "WINSPOOL" fn GetPrinterA(
    hPrinter: HANDLE,
    Level: u32,
    pPrinter: ?*u8,
    cbBuf: u32,
    pcbNeeded: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "WINSPOOL" fn GetPrinterW(
    hPrinter: HANDLE,
    Level: u32,
    pPrinter: ?*u8,
    cbBuf: u32,
    pcbNeeded: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "WINSPOOL" fn AddPrinterDriverA(
    pName: ?*i8,
    Level: u32,
    pDriverInfo: ?*u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SPOOLSS" fn AddPrinterDriverW(
    pName: ?*u16,
    Level: u32,
    pDriverInfo: ?*u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "WINSPOOL" fn AddPrinterDriverExA(
    pName: ?*i8,
    Level: u32,
    lpbDriverInfo: ?*u8,
    dwFileCopyFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SPOOLSS" fn AddPrinterDriverExW(
    pName: ?*u16,
    Level: u32,
    lpbDriverInfo: ?*u8,
    dwFileCopyFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "WINSPOOL" fn EnumPrinterDriversA(
    pName: ?*i8,
    pEnvironment: ?*i8,
    Level: u32,
    pDriverInfo: ?*u8,
    cbBuf: u32,
    pcbNeeded: ?*u32,
    pcReturned: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "WINSPOOL" fn EnumPrinterDriversW(
    pName: ?*u16,
    pEnvironment: ?*u16,
    Level: u32,
    pDriverInfo: ?*u8,
    cbBuf: u32,
    pcbNeeded: ?*u32,
    pcReturned: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "WINSPOOL" fn GetPrinterDriverA(
    hPrinter: HANDLE,
    pEnvironment: ?*i8,
    Level: u32,
    pDriverInfo: ?*u8,
    cbBuf: u32,
    pcbNeeded: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "WINSPOOL" fn GetPrinterDriverW(
    hPrinter: HANDLE,
    pEnvironment: ?*u16,
    Level: u32,
    pDriverInfo: ?*u8,
    cbBuf: u32,
    pcbNeeded: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "WINSPOOL" fn GetPrinterDriverDirectoryA(
    pName: ?*i8,
    pEnvironment: ?*i8,
    Level: u32,
    pDriverDirectory: ?*u8,
    cbBuf: u32,
    pcbNeeded: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "WINSPOOL" fn GetPrinterDriverDirectoryW(
    pName: ?*u16,
    pEnvironment: ?*u16,
    Level: u32,
    pDriverDirectory: ?*u8,
    cbBuf: u32,
    pcbNeeded: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "WINSPOOL" fn DeletePrinterDriverA(
    pName: ?*i8,
    pEnvironment: ?*i8,
    pDriverName: ?*i8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SPOOLSS" fn DeletePrinterDriverW(
    pName: ?*u16,
    pEnvironment: ?*u16,
    pDriverName: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "WINSPOOL" fn DeletePrinterDriverExA(
    pName: ?*i8,
    pEnvironment: ?*i8,
    pDriverName: ?*i8,
    dwDeleteFlag: u32,
    dwVersionFlag: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SPOOLSS" fn DeletePrinterDriverExW(
    pName: ?*u16,
    pEnvironment: ?*u16,
    pDriverName: ?*u16,
    dwDeleteFlag: u32,
    dwVersionFlag: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "WINSPOOL" fn AddPrintProcessorA(
    pName: ?*i8,
    pEnvironment: ?*i8,
    pPathName: ?*i8,
    pPrintProcessorName: ?*i8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SPOOLSS" fn AddPrintProcessorW(
    pName: ?*u16,
    pEnvironment: ?*u16,
    pPathName: ?*u16,
    pPrintProcessorName: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "WINSPOOL" fn EnumPrintProcessorsA(
    pName: ?*i8,
    pEnvironment: ?*i8,
    Level: u32,
    pPrintProcessorInfo: ?*u8,
    cbBuf: u32,
    pcbNeeded: ?*u32,
    pcReturned: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SPOOLSS" fn EnumPrintProcessorsW(
    pName: ?*u16,
    pEnvironment: ?*u16,
    Level: u32,
    pPrintProcessorInfo: ?*u8,
    cbBuf: u32,
    pcbNeeded: ?*u32,
    pcReturned: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "WINSPOOL" fn GetPrintProcessorDirectoryA(
    pName: ?*i8,
    pEnvironment: ?*i8,
    Level: u32,
    pPrintProcessorInfo: ?*u8,
    cbBuf: u32,
    pcbNeeded: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SPOOLSS" fn GetPrintProcessorDirectoryW(
    pName: ?*u16,
    pEnvironment: ?*u16,
    Level: u32,
    pPrintProcessorInfo: ?*u8,
    cbBuf: u32,
    pcbNeeded: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "WINSPOOL" fn EnumPrintProcessorDatatypesA(
    pName: ?*i8,
    pPrintProcessorName: ?*i8,
    Level: u32,
    pDatatypes: ?*u8,
    cbBuf: u32,
    pcbNeeded: ?*u32,
    pcReturned: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SPOOLSS" fn EnumPrintProcessorDatatypesW(
    pName: ?*u16,
    pPrintProcessorName: ?*u16,
    Level: u32,
    pDatatypes: ?*u8,
    cbBuf: u32,
    pcbNeeded: ?*u32,
    pcReturned: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "WINSPOOL" fn DeletePrintProcessorA(
    pName: ?*i8,
    pEnvironment: ?*i8,
    pPrintProcessorName: ?*i8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SPOOLSS" fn DeletePrintProcessorW(
    pName: ?*u16,
    pEnvironment: ?*u16,
    pPrintProcessorName: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "WINSPOOL" fn StartDocPrinterA(
    hPrinter: HANDLE,
    Level: u32,
    pDocInfo: ?*u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINSPOOL" fn StartDocPrinterW(
    hPrinter: HANDLE,
    Level: u32,
    pDocInfo: ?*u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "SPOOLSS" fn StartPagePrinter(
    hPrinter: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "WINSPOOL" fn WritePrinter(
    hPrinter: HANDLE,
    pBuf: ?*opaque{},
    cbBuf: u32,
    pcWritten: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SPOOLSS" fn FlushPrinter(
    hPrinter: HANDLE,
    pBuf: ?*opaque{},
    cbBuf: u32,
    pcWritten: ?*u32,
    cSleep: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SPOOLSS" fn EndPagePrinter(
    hPrinter: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "WINSPOOL" fn AbortPrinter(
    hPrinter: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SPOOLSS" fn ReadPrinter(
    hPrinter: HANDLE,
    pBuf: ?*opaque{},
    cbBuf: u32,
    pNoBytesRead: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "WINSPOOL" fn EndDocPrinter(
    hPrinter: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "WINSPOOL" fn AddJobA(
    hPrinter: HANDLE,
    Level: u32,
    pData: ?*u8,
    cbBuf: u32,
    pcbNeeded: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SPOOLSS" fn AddJobW(
    hPrinter: HANDLE,
    Level: u32,
    pData: ?*u8,
    cbBuf: u32,
    pcbNeeded: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SPOOLSS" fn ScheduleJob(
    hPrinter: HANDLE,
    JobId: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "WINSPOOL" fn PrinterProperties(
    hWnd: HWND,
    hPrinter: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "WINSPOOL" fn DocumentPropertiesA(
    hWnd: HWND,
    hPrinter: HANDLE,
    pDeviceName: ?*i8,
    pDevModeOutput: ?*DEVMODEA,
    pDevModeInput: ?*DEVMODEA,
    fMode: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "WINSPOOL" fn DocumentPropertiesW(
    hWnd: HWND,
    hPrinter: HANDLE,
    pDeviceName: ?*u16,
    pDevModeOutput: ?*DEVMODEW,
    pDevModeInput: ?*DEVMODEW,
    fMode: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "WINSPOOL" fn AdvancedDocumentPropertiesA(
    hWnd: HWND,
    hPrinter: HANDLE,
    pDeviceName: ?*i8,
    pDevModeOutput: ?*DEVMODEA,
    pDevModeInput: ?*DEVMODEA,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "WINSPOOL" fn AdvancedDocumentPropertiesW(
    hWnd: HWND,
    hPrinter: HANDLE,
    pDeviceName: ?*u16,
    pDevModeOutput: ?*DEVMODEW,
    pDevModeInput: ?*DEVMODEW,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "WINSPOOL" fn GetPrinterDataA(
    hPrinter: HANDLE,
    pValueName: ?*i8,
    pType: ?*u32,
    pData: ?*u8,
    nSize: u32,
    pcbNeeded: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINSPOOL" fn GetPrinterDataW(
    hPrinter: HANDLE,
    pValueName: ?*u16,
    pType: ?*u32,
    pData: ?*u8,
    nSize: u32,
    pcbNeeded: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINSPOOL" fn GetPrinterDataExA(
    hPrinter: HANDLE,
    pKeyName: ?*i8,
    pValueName: ?*i8,
    pType: ?*u32,
    pData: ?*u8,
    nSize: u32,
    pcbNeeded: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINSPOOL" fn GetPrinterDataExW(
    hPrinter: HANDLE,
    pKeyName: ?*u16,
    pValueName: ?*u16,
    pType: ?*u32,
    pData: ?*u8,
    nSize: u32,
    pcbNeeded: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINSPOOL" fn EnumPrinterDataA(
    hPrinter: HANDLE,
    dwIndex: u32,
    pValueName: ?*i8,
    cbValueName: u32,
    pcbValueName: ?*u32,
    pType: ?*u32,
    pData: ?*u8,
    cbData: u32,
    pcbData: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "SPOOLSS" fn EnumPrinterDataW(
    hPrinter: HANDLE,
    dwIndex: u32,
    pValueName: ?*u16,
    cbValueName: u32,
    pcbValueName: ?*u32,
    pType: ?*u32,
    pData: ?*u8,
    cbData: u32,
    pcbData: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINSPOOL" fn EnumPrinterDataExA(
    hPrinter: HANDLE,
    pKeyName: ?*i8,
    pEnumValues: ?*u8,
    cbEnumValues: u32,
    pcbEnumValues: ?*u32,
    pnEnumValues: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "SPOOLSS" fn EnumPrinterDataExW(
    hPrinter: HANDLE,
    pKeyName: ?*u16,
    pEnumValues: ?*u8,
    cbEnumValues: u32,
    pcbEnumValues: ?*u32,
    pnEnumValues: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINSPOOL" fn EnumPrinterKeyA(
    hPrinter: HANDLE,
    pKeyName: ?*i8,
    pSubkey: ?*i8,
    cbSubkey: u32,
    pcbSubkey: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "SPOOLSS" fn EnumPrinterKeyW(
    hPrinter: HANDLE,
    pKeyName: ?*u16,
    pSubkey: ?*u16,
    cbSubkey: u32,
    pcbSubkey: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINSPOOL" fn SetPrinterDataA(
    hPrinter: HANDLE,
    pValueName: ?*i8,
    Type: u32,
    pData: ?*u8,
    cbData: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINSPOOL" fn SetPrinterDataW(
    hPrinter: HANDLE,
    pValueName: ?*u16,
    Type: u32,
    pData: ?*u8,
    cbData: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINSPOOL" fn SetPrinterDataExA(
    hPrinter: HANDLE,
    pKeyName: ?*i8,
    pValueName: ?*i8,
    Type: u32,
    pData: ?*u8,
    cbData: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINSPOOL" fn SetPrinterDataExW(
    hPrinter: HANDLE,
    pKeyName: ?*u16,
    pValueName: ?*u16,
    Type: u32,
    pData: ?*u8,
    cbData: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINSPOOL" fn DeletePrinterDataA(
    hPrinter: HANDLE,
    pValueName: ?*i8,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINSPOOL" fn DeletePrinterDataW(
    hPrinter: HANDLE,
    pValueName: ?*u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINSPOOL" fn DeletePrinterDataExA(
    hPrinter: HANDLE,
    pKeyName: ?*i8,
    pValueName: ?*i8,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINSPOOL" fn DeletePrinterDataExW(
    hPrinter: HANDLE,
    pKeyName: ?*u16,
    pValueName: ?*u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINSPOOL" fn DeletePrinterKeyA(
    hPrinter: HANDLE,
    pKeyName: ?*i8,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "SPOOLSS" fn DeletePrinterKeyW(
    hPrinter: HANDLE,
    pKeyName: ?*u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "SPOOLSS" fn WaitForPrinterChange(
    hPrinter: HANDLE,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINSPOOL" fn FindFirstPrinterChangeNotification(
    hPrinter: HANDLE,
    fdwFilter: u32,
    fdwOptions: u32,
    pPrinterNotifyOptions: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// set_last_errror=False (can and should we use this?)
pub extern "WINSPOOL" fn FindNextPrinterChangeNotification(
    hChange: HANDLE,
    pdwChange: ?*u32,
    pvReserved: ?*opaque{},
    ppPrinterNotifyInfo: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "WINSPOOL" fn FreePrinterNotifyInfo(
    pPrinterNotifyInfo: ?*PRINTER_NOTIFY_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SPOOLSS" fn FindClosePrinterChangeNotification(
    hChange: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "WINSPOOL" fn PrinterMessageBoxA(
    hPrinter: HANDLE,
    Error: u32,
    hWnd: HWND,
    pText: ?*i8,
    pCaption: ?*i8,
    dwType: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "SPOOLSS" fn PrinterMessageBoxW(
    hPrinter: HANDLE,
    Error: u32,
    hWnd: HWND,
    pText: ?*u16,
    pCaption: ?*u16,
    dwType: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINSPOOL" fn ClosePrinter(
    hPrinter: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "WINSPOOL" fn AddFormA(
    hPrinter: HANDLE,
    Level: u32,
    pForm: ?*u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SPOOLSS" fn AddFormW(
    hPrinter: HANDLE,
    Level: u32,
    pForm: ?*u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "WINSPOOL" fn DeleteFormA(
    hPrinter: HANDLE,
    pFormName: ?*i8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SPOOLSS" fn DeleteFormW(
    hPrinter: HANDLE,
    pFormName: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "WINSPOOL" fn GetFormA(
    hPrinter: HANDLE,
    pFormName: ?*i8,
    Level: u32,
    pForm: ?*u8,
    cbBuf: u32,
    pcbNeeded: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SPOOLSS" fn GetFormW(
    hPrinter: HANDLE,
    pFormName: ?*u16,
    Level: u32,
    pForm: ?*u8,
    cbBuf: u32,
    pcbNeeded: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "WINSPOOL" fn SetFormA(
    hPrinter: HANDLE,
    pFormName: ?*i8,
    Level: u32,
    pForm: ?*u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SPOOLSS" fn SetFormW(
    hPrinter: HANDLE,
    pFormName: ?*u16,
    Level: u32,
    pForm: ?*u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "WINSPOOL" fn EnumFormsA(
    hPrinter: HANDLE,
    Level: u32,
    pForm: ?*u8,
    cbBuf: u32,
    pcbNeeded: ?*u32,
    pcReturned: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SPOOLSS" fn EnumFormsW(
    hPrinter: HANDLE,
    Level: u32,
    pForm: ?*u8,
    cbBuf: u32,
    pcbNeeded: ?*u32,
    pcReturned: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "WINSPOOL" fn EnumMonitorsA(
    pName: ?*i8,
    Level: u32,
    pMonitor: ?*u8,
    cbBuf: u32,
    pcbNeeded: ?*u32,
    pcReturned: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SPOOLSS" fn EnumMonitorsW(
    pName: ?*u16,
    Level: u32,
    pMonitor: ?*u8,
    cbBuf: u32,
    pcbNeeded: ?*u32,
    pcReturned: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "WINSPOOL" fn AddMonitorA(
    pName: ?*i8,
    Level: u32,
    pMonitors: ?*u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SPOOLSS" fn AddMonitorW(
    pName: ?*u16,
    Level: u32,
    pMonitors: ?*u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "WINSPOOL" fn DeleteMonitorA(
    pName: ?*i8,
    pEnvironment: ?*i8,
    pMonitorName: ?*i8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SPOOLSS" fn DeleteMonitorW(
    pName: ?*u16,
    pEnvironment: ?*u16,
    pMonitorName: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "WINSPOOL" fn EnumPortsA(
    pName: ?*i8,
    Level: u32,
    pPort: ?*u8,
    cbBuf: u32,
    pcbNeeded: ?*u32,
    pcReturned: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "WINSPOOL" fn EnumPortsW(
    pName: ?*u16,
    Level: u32,
    pPort: ?*u8,
    cbBuf: u32,
    pcbNeeded: ?*u32,
    pcReturned: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "WINSPOOL" fn AddPortA(
    pName: ?*i8,
    hWnd: HWND,
    pMonitorName: ?*i8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SPOOLSS" fn AddPortW(
    pName: ?*u16,
    hWnd: HWND,
    pMonitorName: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "WINSPOOL" fn ConfigurePortA(
    pName: ?*i8,
    hWnd: HWND,
    pPortName: ?*i8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SPOOLSS" fn ConfigurePortW(
    pName: ?*u16,
    hWnd: HWND,
    pPortName: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "WINSPOOL" fn DeletePortA(
    pName: ?*i8,
    hWnd: HWND,
    pPortName: ?*i8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SPOOLSS" fn DeletePortW(
    pName: ?*u16,
    hWnd: HWND,
    pPortName: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "WINSPOOL" fn XcvDataW(
    hXcv: HANDLE,
    pszDataName: ?*u16,
    pInputData: ?*u8,
    cbInputData: u32,
    pOutputData: ?*u8,
    cbOutputData: u32,
    pcbOutputNeeded: ?*u32,
    pdwStatus: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "WINSPOOL" fn GetDefaultPrinterA(
    pszBuffer: ?*i8,
    pcchBuffer: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "WINSPOOL" fn GetDefaultPrinterW(
    pszBuffer: ?*u16,
    pcchBuffer: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "WINSPOOL" fn SetDefaultPrinterA(
    pszPrinter: ?*i8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "WINSPOOL" fn SetDefaultPrinterW(
    pszPrinter: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "WINSPOOL" fn SetPortA(
    pName: ?*i8,
    pPortName: ?*i8,
    dwLevel: u32,
    pPortInfo: ?*u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SPOOLSS" fn SetPortW(
    pName: ?*u16,
    pPortName: ?*u16,
    dwLevel: u32,
    pPortInfo: ?*u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "WINSPOOL" fn AddPrinterConnectionA(
    pName: ?*i8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "WINSPOOL" fn AddPrinterConnectionW(
    pName: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "WINSPOOL" fn DeletePrinterConnectionA(
    pName: ?*i8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "WINSPOOL" fn DeletePrinterConnectionW(
    pName: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "WINSPOOL" fn ConnectToPrinterDlg(
    hwnd: HWND,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// set_last_errror=False (can and should we use this?)
pub extern "WINSPOOL" fn AddPrintProvidorA(
    pName: ?*i8,
    Level: u32,
    pProvidorInfo: ?*u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SPOOLSS" fn AddPrintProvidorW(
    pName: ?*u16,
    Level: u32,
    pProvidorInfo: ?*u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "WINSPOOL" fn DeletePrintProvidorA(
    pName: ?*i8,
    pEnvironment: ?*i8,
    pPrintProvidorName: ?*i8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SPOOLSS" fn DeletePrintProvidorW(
    pName: ?*u16,
    pEnvironment: ?*u16,
    pPrintProvidorName: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "WINSPOOL" fn IsValidDevmodeA(
    pDevmode: ?*DEVMODEA,
    DevmodeSize: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "WINSPOOL" fn IsValidDevmodeW(
    pDevmode: ?*DEVMODEW,
    DevmodeSize: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "WINSPOOL" fn OpenPrinter2A(
    pPrinterName: ?*i8,
    phPrinter: ?*?*opaque{},
    pDefault: ?*PRINTER_DEFAULTSA,
    pOptions: ?*PRINTER_OPTIONSA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SPOOLSS" fn OpenPrinter2W(
    pPrinterName: ?*u16,
    phPrinter: ?*?*opaque{},
    pDefault: ?*PRINTER_DEFAULTSW,
    pOptions: ?*PRINTER_OPTIONSW,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "WINSPOOL" fn AddPrinterConnection2A(
    hWnd: HWND,
    pszName: ?*i8,
    dwLevel: u32,
    pConnectionInfo: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "WINSPOOL" fn AddPrinterConnection2W(
    hWnd: HWND,
    pszName: ?*u16,
    dwLevel: u32,
    pConnectionInfo: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "WINSPOOL" fn InstallPrinterDriverFromPackageA(
    pszServer: ?*i8,
    pszInfPath: ?*i8,
    pszDriverName: ?*i8,
    pszEnvironment: ?*i8,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "WINSPOOL" fn InstallPrinterDriverFromPackageW(
    pszServer: ?*u16,
    pszInfPath: ?*u16,
    pszDriverName: ?*u16,
    pszEnvironment: ?*u16,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "WINSPOOL" fn UploadPrinterDriverPackageA(
    pszServer: ?*i8,
    pszInfPath: ?*i8,
    pszEnvironment: ?*i8,
    dwFlags: u32,
    hwnd: HWND,
    pszDestInfPath: ?*i8,
    pcchDestInfPath: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "WINSPOOL" fn UploadPrinterDriverPackageW(
    pszServer: ?*u16,
    pszInfPath: ?*u16,
    pszEnvironment: ?*u16,
    dwFlags: u32,
    hwnd: HWND,
    pszDestInfPath: ?*u16,
    pcchDestInfPath: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "WINSPOOL" fn GetCorePrinterDriversA(
    pszServer: ?*i8,
    pszEnvironment: ?*i8,
    pszzCoreDriverDependencies: ?*i8,
    cCorePrinterDrivers: u32,
    pCorePrinterDrivers: ?*CORE_PRINTER_DRIVERA,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "WINSPOOL" fn GetCorePrinterDriversW(
    pszServer: ?*u16,
    pszEnvironment: ?*u16,
    pszzCoreDriverDependencies: ?*u16,
    cCorePrinterDrivers: u32,
    pCorePrinterDrivers: ?*CORE_PRINTER_DRIVERW,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "WINSPOOL" fn CorePrinterDriverInstalledA(
    pszServer: ?*i8,
    pszEnvironment: ?*i8,
    CoreDriverGUID: Guid,
    ftDriverDate: FILETIME,
    dwlDriverVersion: u64,
    pbDriverInstalled: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "WINSPOOL" fn CorePrinterDriverInstalledW(
    pszServer: ?*u16,
    pszEnvironment: ?*u16,
    CoreDriverGUID: Guid,
    ftDriverDate: FILETIME,
    dwlDriverVersion: u64,
    pbDriverInstalled: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "WINSPOOL" fn GetPrinterDriverPackagePathA(
    pszServer: ?*i8,
    pszEnvironment: ?*i8,
    pszLanguage: ?*i8,
    pszPackageID: ?*i8,
    pszDriverPackageCab: ?*i8,
    cchDriverPackageCab: u32,
    pcchRequiredSize: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "WINSPOOL" fn GetPrinterDriverPackagePathW(
    pszServer: ?*u16,
    pszEnvironment: ?*u16,
    pszLanguage: ?*u16,
    pszPackageID: ?*u16,
    pszDriverPackageCab: ?*u16,
    cchDriverPackageCab: u32,
    pcchRequiredSize: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "WINSPOOL" fn DeletePrinterDriverPackageA(
    pszServer: ?*i8,
    pszInfPath: ?*i8,
    pszEnvironment: ?*i8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "WINSPOOL" fn DeletePrinterDriverPackageW(
    pszServer: ?*u16,
    pszInfPath: ?*u16,
    pszEnvironment: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "WINSPOOL" fn ReportJobProcessingProgress(
    printerHandle: HANDLE,
    jobId: u32,
    jobOperation: EPrintXPSJobOperation,
    jobProgress: EPrintXPSJobProgress,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "WINSPOOL" fn GetPrinterDriver2A(
    hWnd: HWND,
    hPrinter: HANDLE,
    pEnvironment: ?*i8,
    Level: u32,
    pDriverInfo: ?*u8,
    cbBuf: u32,
    pcbNeeded: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "WINSPOOL" fn GetPrinterDriver2W(
    hWnd: HWND,
    hPrinter: HANDLE,
    pEnvironment: ?*u16,
    Level: u32,
    pDriverInfo: ?*u8,
    cbBuf: u32,
    pcbNeeded: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "WINSPOOL" fn GetPrintExecutionData(
    pData: ?*PRINT_EXECUTION_DATA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SPOOLSS" fn GetJobNamedPropertyValue(
    hPrinter: HANDLE,
    JobId: u32,
    pszName: ?*u16,
    pValue: ?*PrintPropertyValue,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "SPOOLSS" fn FreePrintPropertyValue(
    pValue: ?*PrintPropertyValue,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "WINSPOOL" fn FreePrintNamedPropertyArray(
    cProperties: u32,
    ppProperties: ?*?*PrintNamedProperty,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "WINSPOOL" fn SetJobNamedProperty(
    hPrinter: HANDLE,
    JobId: u32,
    pProperty: ?*PrintNamedProperty,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "SPOOLSS" fn DeleteJobNamedProperty(
    hPrinter: HANDLE,
    JobId: u32,
    pszName: ?*u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINSPOOL" fn EnumJobNamedProperties(
    hPrinter: HANDLE,
    JobId: u32,
    pcProperties: ?*u32,
    ppProperties: ?*?*PrintNamedProperty,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINSPOOL" fn GetPrintOutputInfo(
    hWnd: HWND,
    pszPrinter: ?*u16,
    phFile: ?*HANDLE,
    ppszOutputFile: ?*?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "CoreMessaging" fn CreateDispatcherQueueController(
    options: DispatcherQueueOptions,
    dispatcherQueueController: ?**opaque{ pub const actual_type = "Windows.System"; },
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "VSSAPI" fn CreateVssExpressWriterInternal(
    ppWriter: ?*IVssExpressWriter,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "GDI32" fn EngQueryEMFInfo(
    hdev: ?*HDEV__,
    pEMFInfo: ?*EMFINFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "api-ms-win-core-libraryloader-l2-1-0" fn QueryOptionalDelayLoadedAPI(
    hParentModule: ?*opaque{},
    lpDllName: ?*i8,
    lpProcName: ?*i8,
    Reserved: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "vertdll" fn EnclaveGetAttestationReport(
    EnclaveData: ?*u8,
    Report: ?*opaque{},
    BufferSize: u32,
    OutputSize: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "vertdll" fn EnclaveVerifyAttestationReport(
    EnclaveType: u32,
    Report: ?*opaque{},
    ReportSize: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "vertdll" fn EnclaveSealData(
    DataToEncrypt: ?*opaque{},
    DataToEncryptSize: u32,
    IdentityPolicy: ENCLAVE_SEALING_IDENTITY_POLICY,
    RuntimePolicy: u32,
    ProtectedBlob: ?*opaque{},
    BufferSize: u32,
    ProtectedBlobSize: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "vertdll" fn EnclaveUnsealData(
    ProtectedBlob: ?*opaque{},
    ProtectedBlobSize: u32,
    DecryptedData: ?*opaque{},
    BufferSize: u32,
    DecryptedDataSize: ?*u32,
    SealingIdentity: ?*ENCLAVE_IDENTITY,
    UnsealingFlags: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "vertdll" fn EnclaveGetEnclaveInformation(
    InformationSize: u32,
    EnclaveInformation: ?*ENCLAVE_INFORMATION,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "POWRPROF" fn CallNtPowerInformation(
    InformationLevel: POWER_INFORMATION_LEVEL,
    InputBuffer: ?*opaque{},
    InputBufferLength: u32,
    OutputBuffer: ?*opaque{},
    OutputBufferLength: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// set_last_errror=True (can and should we use this?)
pub extern "api-ms-win-power-base-l1-1-0" fn GetPwrCapabilities(
    lpspc: ?*SYSTEM_POWER_CAPABILITIES,
) callconv(@import("std").os.windows.WINAPI) u8;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-power-base-l1-1-0" fn PowerDeterminePlatformRoleEx(
    Version: u32,
) callconv(@import("std").os.windows.WINAPI) POWER_PLATFORM_ROLE;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-power-base-l1-1-0" fn PowerRegisterSuspendResumeNotification(
    Flags: u32,
    Recipient: HANDLE,
    RegistrationHandle: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-power-base-l1-1-0" fn PowerUnregisterSuspendResumeNotification(
    RegistrationHandle: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-power-setting-l1-1-0" fn PowerReadACValue(
    RootPowerKey: HKEY,
    SchemeGuid: ?*Guid,
    SubGroupOfPowerSettingsGuid: ?*Guid,
    PowerSettingGuid: ?*Guid,
    Type: ?*u32,
    Buffer: ?*u8,
    BufferSize: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-power-setting-l1-1-0" fn PowerReadDCValue(
    RootPowerKey: HKEY,
    SchemeGuid: ?*Guid,
    SubGroupOfPowerSettingsGuid: ?*Guid,
    PowerSettingGuid: ?*Guid,
    Type: ?*u32,
    Buffer: ?*u8,
    BufferSize: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-power-setting-l1-1-0" fn PowerGetActiveScheme(
    UserRootPowerKey: HKEY,
    ActivePolicyGuid: ?*?*Guid,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-power-setting-l1-1-0" fn PowerSetActiveScheme(
    UserRootPowerKey: HKEY,
    SchemeGuid: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-power-setting-l1-1-0" fn PowerSettingRegisterNotification(
    SettingGuid: ?*Guid,
    Flags: u32,
    Recipient: HANDLE,
    RegistrationHandle: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-power-setting-l1-1-0" fn PowerSettingUnregisterNotification(
    RegistrationHandle: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-power-setting-l1-1-1" fn PowerRegisterForEffectivePowerModeNotifications(
    Version: u32,
    Callback: ?*EFFECTIVE_POWER_MODE_CALLBACK,
    Context: ?*opaque{},
    RegistrationHandle: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-power-setting-l1-1-1" fn PowerUnregisterFromEffectivePowerModeNotifications(
    RegistrationHandle: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=True (can and should we use this?)
pub extern "POWRPROF" fn GetPwrDiskSpindownRange(
    puiMax: ?*u32,
    puiMin: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u8;

// set_last_errror=True (can and should we use this?)
pub extern "POWRPROF" fn EnumPwrSchemes(
    lpfn: PWRSCHEMESENUMPROC,
    lParam: LPARAM,
) callconv(@import("std").os.windows.WINAPI) u8;

// set_last_errror=True (can and should we use this?)
pub extern "POWRPROF" fn ReadGlobalPwrPolicy(
    pGlobalPowerPolicy: ?*GLOBAL_POWER_POLICY,
) callconv(@import("std").os.windows.WINAPI) u8;

// set_last_errror=True (can and should we use this?)
pub extern "POWRPROF" fn ReadPwrScheme(
    uiID: u32,
    pPowerPolicy: ?*POWER_POLICY,
) callconv(@import("std").os.windows.WINAPI) u8;

// set_last_errror=True (can and should we use this?)
pub extern "POWRPROF" fn WritePwrScheme(
    puiID: ?*u32,
    lpszSchemeName: ?*u16,
    lpszDescription: ?*u16,
    lpScheme: ?*POWER_POLICY,
) callconv(@import("std").os.windows.WINAPI) u8;

// set_last_errror=True (can and should we use this?)
pub extern "POWRPROF" fn WriteGlobalPwrPolicy(
    pGlobalPowerPolicy: ?*GLOBAL_POWER_POLICY,
) callconv(@import("std").os.windows.WINAPI) u8;

// set_last_errror=True (can and should we use this?)
pub extern "POWRPROF" fn DeletePwrScheme(
    uiID: u32,
) callconv(@import("std").os.windows.WINAPI) u8;

// set_last_errror=True (can and should we use this?)
pub extern "POWRPROF" fn GetActivePwrScheme(
    puiID: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u8;

// set_last_errror=True (can and should we use this?)
pub extern "POWRPROF" fn SetActivePwrScheme(
    uiID: u32,
    pGlobalPowerPolicy: ?*GLOBAL_POWER_POLICY,
    pPowerPolicy: ?*POWER_POLICY,
) callconv(@import("std").os.windows.WINAPI) u8;

// set_last_errror=False (can and should we use this?)
pub extern "POWRPROF" fn IsPwrSuspendAllowed(
) callconv(@import("std").os.windows.WINAPI) u8;

// set_last_errror=False (can and should we use this?)
pub extern "POWRPROF" fn IsPwrHibernateAllowed(
) callconv(@import("std").os.windows.WINAPI) u8;

// set_last_errror=False (can and should we use this?)
pub extern "POWRPROF" fn IsPwrShutdownAllowed(
) callconv(@import("std").os.windows.WINAPI) u8;

// set_last_errror=False (can and should we use this?)
pub extern "POWRPROF" fn IsAdminOverrideActive(
    papp: ?*ADMINISTRATOR_POWER_POLICY,
) callconv(@import("std").os.windows.WINAPI) u8;

// set_last_errror=True (can and should we use this?)
pub extern "POWRPROF" fn SetSuspendState(
    bHibernate: u8,
    bForce: u8,
    bWakeupEventsDisabled: u8,
) callconv(@import("std").os.windows.WINAPI) u8;

// set_last_errror=True (can and should we use this?)
pub extern "POWRPROF" fn GetCurrentPowerPolicies(
    pGlobalPowerPolicy: ?*GLOBAL_POWER_POLICY,
    pPowerPolicy: ?*POWER_POLICY,
) callconv(@import("std").os.windows.WINAPI) u8;

// set_last_errror=True (can and should we use this?)
pub extern "POWRPROF" fn CanUserWritePwrScheme(
) callconv(@import("std").os.windows.WINAPI) u8;

// set_last_errror=True (can and should we use this?)
pub extern "POWRPROF" fn ReadProcessorPwrScheme(
    uiID: u32,
    pMachineProcessorPowerPolicy: ?*MACHINE_PROCESSOR_POWER_POLICY,
) callconv(@import("std").os.windows.WINAPI) u8;

// set_last_errror=True (can and should we use this?)
pub extern "POWRPROF" fn WriteProcessorPwrScheme(
    uiID: u32,
    pMachineProcessorPowerPolicy: ?*MACHINE_PROCESSOR_POWER_POLICY,
) callconv(@import("std").os.windows.WINAPI) u8;

// set_last_errror=False (can and should we use this?)
pub extern "POWRPROF" fn ValidatePowerPolicies(
    pGlobalPowerPolicy: ?*GLOBAL_POWER_POLICY,
    pPowerPolicy: ?*POWER_POLICY,
) callconv(@import("std").os.windows.WINAPI) u8;

// set_last_errror=False (can and should we use this?)
pub extern "POWRPROF" fn PowerIsSettingRangeDefined(
    SubKeyGuid: ?*Guid,
    SettingGuid: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) u8;

// set_last_errror=False (can and should we use this?)
pub extern "POWRPROF" fn PowerSettingAccessCheckEx(
    AccessFlags: POWER_DATA_ACCESSOR,
    PowerGuid: ?*Guid,
    AccessType: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "POWRPROF" fn PowerSettingAccessCheck(
    AccessFlags: POWER_DATA_ACCESSOR,
    PowerGuid: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "POWRPROF" fn PowerReadFriendlyName(
    RootPowerKey: HKEY,
    SchemeGuid: ?*Guid,
    SubGroupOfPowerSettingsGuid: ?*Guid,
    PowerSettingGuid: ?*Guid,
    Buffer: ?*u8,
    BufferSize: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "POWRPROF" fn PowerReadDescription(
    RootPowerKey: HKEY,
    SchemeGuid: ?*Guid,
    SubGroupOfPowerSettingsGuid: ?*Guid,
    PowerSettingGuid: ?*Guid,
    Buffer: ?*u8,
    BufferSize: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "POWRPROF" fn PowerReadPossibleValue(
    RootPowerKey: HKEY,
    SubGroupOfPowerSettingsGuid: ?*Guid,
    PowerSettingGuid: ?*Guid,
    Type: ?*u32,
    PossibleSettingIndex: u32,
    Buffer: ?*u8,
    BufferSize: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "POWRPROF" fn PowerReadPossibleFriendlyName(
    RootPowerKey: HKEY,
    SubGroupOfPowerSettingsGuid: ?*Guid,
    PowerSettingGuid: ?*Guid,
    PossibleSettingIndex: u32,
    Buffer: ?*u8,
    BufferSize: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "POWRPROF" fn PowerReadPossibleDescription(
    RootPowerKey: HKEY,
    SubGroupOfPowerSettingsGuid: ?*Guid,
    PowerSettingGuid: ?*Guid,
    PossibleSettingIndex: u32,
    Buffer: ?*u8,
    BufferSize: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "POWRPROF" fn PowerReadValueMin(
    RootPowerKey: HKEY,
    SubGroupOfPowerSettingsGuid: ?*Guid,
    PowerSettingGuid: ?*Guid,
    ValueMinimum: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "POWRPROF" fn PowerReadValueMax(
    RootPowerKey: HKEY,
    SubGroupOfPowerSettingsGuid: ?*Guid,
    PowerSettingGuid: ?*Guid,
    ValueMaximum: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "POWRPROF" fn PowerReadValueIncrement(
    RootPowerKey: HKEY,
    SubGroupOfPowerSettingsGuid: ?*Guid,
    PowerSettingGuid: ?*Guid,
    ValueIncrement: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "POWRPROF" fn PowerReadValueUnitsSpecifier(
    RootPowerKey: HKEY,
    SubGroupOfPowerSettingsGuid: ?*Guid,
    PowerSettingGuid: ?*Guid,
    Buffer: ?*u8,
    BufferSize: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "POWRPROF" fn PowerReadIconResourceSpecifier(
    RootPowerKey: HKEY,
    SchemeGuid: ?*Guid,
    SubGroupOfPowerSettingsGuid: ?*Guid,
    PowerSettingGuid: ?*Guid,
    Buffer: ?*u8,
    BufferSize: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "POWRPROF" fn PowerReadSettingAttributes(
    SubGroupGuid: ?*Guid,
    PowerSettingGuid: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "POWRPROF" fn PowerWriteFriendlyName(
    RootPowerKey: HKEY,
    SchemeGuid: ?*Guid,
    SubGroupOfPowerSettingsGuid: ?*Guid,
    PowerSettingGuid: ?*Guid,
    Buffer: ?*u8,
    BufferSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "POWRPROF" fn PowerWriteDescription(
    RootPowerKey: HKEY,
    SchemeGuid: ?*Guid,
    SubGroupOfPowerSettingsGuid: ?*Guid,
    PowerSettingGuid: ?*Guid,
    Buffer: ?*u8,
    BufferSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "POWRPROF" fn PowerWritePossibleValue(
    RootPowerKey: HKEY,
    SubGroupOfPowerSettingsGuid: ?*Guid,
    PowerSettingGuid: ?*Guid,
    Type: u32,
    PossibleSettingIndex: u32,
    Buffer: ?*u8,
    BufferSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "POWRPROF" fn PowerWritePossibleFriendlyName(
    RootPowerKey: HKEY,
    SubGroupOfPowerSettingsGuid: ?*Guid,
    PowerSettingGuid: ?*Guid,
    PossibleSettingIndex: u32,
    Buffer: ?*u8,
    BufferSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "POWRPROF" fn PowerWritePossibleDescription(
    RootPowerKey: HKEY,
    SubGroupOfPowerSettingsGuid: ?*Guid,
    PowerSettingGuid: ?*Guid,
    PossibleSettingIndex: u32,
    Buffer: ?*u8,
    BufferSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "POWRPROF" fn PowerWriteValueMin(
    RootPowerKey: HKEY,
    SubGroupOfPowerSettingsGuid: ?*Guid,
    PowerSettingGuid: ?*Guid,
    ValueMinimum: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "POWRPROF" fn PowerWriteValueMax(
    RootPowerKey: HKEY,
    SubGroupOfPowerSettingsGuid: ?*Guid,
    PowerSettingGuid: ?*Guid,
    ValueMaximum: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "POWRPROF" fn PowerWriteValueIncrement(
    RootPowerKey: HKEY,
    SubGroupOfPowerSettingsGuid: ?*Guid,
    PowerSettingGuid: ?*Guid,
    ValueIncrement: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "POWRPROF" fn PowerWriteValueUnitsSpecifier(
    RootPowerKey: HKEY,
    SubGroupOfPowerSettingsGuid: ?*Guid,
    PowerSettingGuid: ?*Guid,
    Buffer: ?*u8,
    BufferSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "POWRPROF" fn PowerWriteIconResourceSpecifier(
    RootPowerKey: HKEY,
    SchemeGuid: ?*Guid,
    SubGroupOfPowerSettingsGuid: ?*Guid,
    PowerSettingGuid: ?*Guid,
    Buffer: ?*u8,
    BufferSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "POWRPROF" fn PowerWriteSettingAttributes(
    SubGroupGuid: ?*Guid,
    PowerSettingGuid: ?*Guid,
    Attributes: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "POWRPROF" fn PowerDuplicateScheme(
    RootPowerKey: HKEY,
    SourceSchemeGuid: ?*Guid,
    DestinationSchemeGuid: ?*?*Guid,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "POWRPROF" fn PowerImportPowerScheme(
    RootPowerKey: HKEY,
    ImportFileNamePath: ?*u16,
    DestinationSchemeGuid: ?*?*Guid,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "POWRPROF" fn PowerDeleteScheme(
    RootPowerKey: HKEY,
    SchemeGuid: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "POWRPROF" fn PowerRemovePowerSetting(
    PowerSettingSubKeyGuid: ?*Guid,
    PowerSettingGuid: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "POWRPROF" fn PowerCreateSetting(
    RootSystemPowerKey: HKEY,
    SubGroupOfPowerSettingsGuid: ?*Guid,
    PowerSettingGuid: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "POWRPROF" fn PowerCreatePossibleSetting(
    RootSystemPowerKey: HKEY,
    SubGroupOfPowerSettingsGuid: ?*Guid,
    PowerSettingGuid: ?*Guid,
    PossibleSettingIndex: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "POWRPROF" fn PowerEnumerate(
    RootPowerKey: HKEY,
    SchemeGuid: ?*Guid,
    SubGroupOfPowerSettingsGuid: ?*Guid,
    AccessFlags: POWER_DATA_ACCESSOR,
    Index: u32,
    Buffer: ?*u8,
    BufferSize: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "POWRPROF" fn PowerOpenUserPowerKey(
    phUserPowerKey: ?*HKEY,
    Access: u32,
    OpenExisting: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "POWRPROF" fn PowerOpenSystemPowerKey(
    phSystemPowerKey: ?*HKEY,
    Access: u32,
    OpenExisting: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "POWRPROF" fn PowerCanRestoreIndividualDefaultPowerScheme(
    SchemeGuid: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "POWRPROF" fn PowerRestoreIndividualDefaultPowerScheme(
    SchemeGuid: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "POWRPROF" fn PowerRestoreDefaultPowerSchemes(
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "POWRPROF" fn PowerReplaceDefaultPowerSchemes(
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "POWRPROF" fn PowerDeterminePlatformRole(
) callconv(@import("std").os.windows.WINAPI) POWER_PLATFORM_ROLE;

// set_last_errror=False (can and should we use this?)
pub extern "POWRPROF" fn DevicePowerEnumDevices(
    QueryIndex: u32,
    QueryInterpretationFlags: u32,
    QueryFlags: u32,
    pReturnBuffer: ?*u8,
    pBufferSize: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u8;

// set_last_errror=True (can and should we use this?)
pub extern "POWRPROF" fn DevicePowerSetDeviceState(
    DeviceDescription: ?*u16,
    SetFlags: u32,
    SetData: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "POWRPROF" fn DevicePowerOpen(
    DebugMask: u32,
) callconv(@import("std").os.windows.WINAPI) u8;

// set_last_errror=False (can and should we use this?)
pub extern "POWRPROF" fn DevicePowerClose(
) callconv(@import("std").os.windows.WINAPI) u8;

// set_last_errror=False (can and should we use this?)
pub extern "POWRPROF" fn PowerReportThermalEvent(
    Event: ?*THERMAL_EVENT,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn DeviceIoControl(
    hDevice: HANDLE,
    dwIoControlCode: u32,
    lpInBuffer: ?*opaque{},
    nInBufferSize: u32,
    lpOutBuffer: ?*opaque{},
    nOutBufferSize: u32,
    lpBytesReturned: ?*u32,
    lpOverlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetOverlappedResult(
    hFile: HANDLE,
    lpOverlapped: ?*OVERLAPPED,
    lpNumberOfBytesTransferred: ?*u32,
    bWait: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetOverlappedResultEx(
    hFile: HANDLE,
    lpOverlapped: ?*OVERLAPPED,
    lpNumberOfBytesTransferred: ?*u32,
    dwMilliseconds: u32,
    bAlertable: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn IsWow64Process(
    hProcess: HANDLE,
    Wow64Process: ?*i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn IsWow64Process2(
    hProcess: HANDLE,
    pProcessMachine: ?*u16,
    pNativeMachine: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn GetCommandLineA(
) callconv(@import("std").os.windows.WINAPI) ?*i8;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn GetCommandLineW(
) callconv(@import("std").os.windows.WINAPI) ?*u16;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn GetEnvironmentStrings(
) callconv(@import("std").os.windows.WINAPI) ?*i8;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn GetEnvironmentStringsW(
) callconv(@import("std").os.windows.WINAPI) ?*u16;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn FreeEnvironmentStringsA(
    penv: ?*i8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn FreeEnvironmentStringsW(
    penv: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetEnvironmentVariableA(
    lpName: ?*i8,
    lpBuffer: ?*i8,
    nSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetEnvironmentVariableW(
    lpName: ?*u16,
    lpBuffer: ?*u16,
    nSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn SetEnvironmentVariableA(
    lpName: ?*i8,
    lpValue: ?*i8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn SetEnvironmentVariableW(
    lpName: ?*u16,
    lpValue: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn NeedCurrentDirectoryForExePathA(
    ExeName: ?*i8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn NeedCurrentDirectoryForExePathW(
    ExeName: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn QueueUserAPC(
    pfnAPC: PAPCFUNC,
    hThread: HANDLE,
    dwData: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetProcessTimes(
    hProcess: HANDLE,
    lpCreationTime: ?*FILETIME,
    lpExitTime: ?*FILETIME,
    lpKernelTime: ?*FILETIME,
    lpUserTime: ?*FILETIME,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn GetCurrentProcess(
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn GetCurrentProcessId(
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn ExitProcess(
    uExitCode: u32,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn TerminateProcess(
    hProcess: HANDLE,
    uExitCode: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetExitCodeProcess(
    hProcess: HANDLE,
    lpExitCode: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn SwitchToThread(
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn CreateThread(
    lpThreadAttributes: ?*SECURITY_ATTRIBUTES,
    dwStackSize: ?*opaque{},
    lpStartAddress: LPTHREAD_START_ROUTINE,
    lpParameter: ?*opaque{},
    dwCreationFlags: u32,
    lpThreadId: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn CreateRemoteThread(
    hProcess: HANDLE,
    lpThreadAttributes: ?*SECURITY_ATTRIBUTES,
    dwStackSize: ?*opaque{},
    lpStartAddress: LPTHREAD_START_ROUTINE,
    lpParameter: ?*opaque{},
    dwCreationFlags: u32,
    lpThreadId: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn GetCurrentThread(
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn GetCurrentThreadId(
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn OpenThread(
    dwDesiredAccess: u32,
    bInheritHandle: BOOL,
    dwThreadId: u32,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn SetThreadPriority(
    hThread: HANDLE,
    nPriority: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn SetThreadPriorityBoost(
    hThread: HANDLE,
    bDisablePriorityBoost: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetThreadPriorityBoost(
    hThread: HANDLE,
    pDisablePriorityBoost: ?*i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetThreadPriority(
    hThread: HANDLE,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn ExitThread(
    dwExitCode: u32,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn TerminateThread(
    hThread: HANDLE,
    dwExitCode: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetExitCodeThread(
    hThread: HANDLE,
    lpExitCode: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn SuspendThread(
    hThread: HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn ResumeThread(
    hThread: HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn TlsAlloc(
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn TlsGetValue(
    dwTlsIndex: u32,
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn TlsSetValue(
    dwTlsIndex: u32,
    lpTlsValue: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn TlsFree(
    dwTlsIndex: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn CreateProcessA(
    lpApplicationName: ?*i8,
    lpCommandLine: ?*i8,
    lpProcessAttributes: ?*SECURITY_ATTRIBUTES,
    lpThreadAttributes: ?*SECURITY_ATTRIBUTES,
    bInheritHandles: BOOL,
    dwCreationFlags: PROCESS_CREATION_FLAGS,
    lpEnvironment: ?*opaque{},
    lpCurrentDirectory: ?*i8,
    lpStartupInfo: ?*STARTUPINFOA,
    lpProcessInformation: ?*PROCESS_INFORMATION,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn CreateProcessW(
    lpApplicationName: ?*u16,
    lpCommandLine: ?*u16,
    lpProcessAttributes: ?*SECURITY_ATTRIBUTES,
    lpThreadAttributes: ?*SECURITY_ATTRIBUTES,
    bInheritHandles: BOOL,
    dwCreationFlags: PROCESS_CREATION_FLAGS,
    lpEnvironment: ?*opaque{},
    lpCurrentDirectory: ?*u16,
    lpStartupInfo: ?*STARTUPINFOW,
    lpProcessInformation: ?*PROCESS_INFORMATION,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn SetProcessShutdownParameters(
    dwLevel: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetProcessVersion(
    ProcessId: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn GetStartupInfoW(
    lpStartupInfo: ?*STARTUPINFOW,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=True (can and should we use this?)
pub extern "ADVAPI32" fn CreateProcessAsUserW(
    hToken: HANDLE,
    lpApplicationName: ?*u16,
    lpCommandLine: ?*u16,
    lpProcessAttributes: ?*SECURITY_ATTRIBUTES,
    lpThreadAttributes: ?*SECURITY_ATTRIBUTES,
    bInheritHandles: BOOL,
    dwCreationFlags: u32,
    lpEnvironment: ?*opaque{},
    lpCurrentDirectory: ?*u16,
    lpStartupInfo: ?*STARTUPINFOW,
    lpProcessInformation: ?*PROCESS_INFORMATION,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn SetPriorityClass(
    hProcess: HANDLE,
    dwPriorityClass: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetPriorityClass(
    hProcess: HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn SetThreadStackGuarantee(
    StackSizeInBytes: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetProcessId(
    Process: HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetThreadId(
    Thread: HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn FlushProcessWriteBuffers(
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetProcessIdOfThread(
    Thread: HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn InitializeProcThreadAttributeList(
    lpAttributeList: ?*opaque{},
    dwAttributeCount: u32,
    dwFlags: u32,
    lpSize: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn DeleteProcThreadAttributeList(
    lpAttributeList: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn UpdateProcThreadAttribute(
    lpAttributeList: ?*opaque{},
    dwFlags: u32,
    Attribute: ?*opaque{},
    lpValue: ?*opaque{},
    cbSize: ?*opaque{},
    lpPreviousValue: ?*opaque{},
    lpReturnSize: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn SetProcessAffinityUpdateMode(
    hProcess: HANDLE,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn QueryProcessAffinityUpdateMode(
    hProcess: HANDLE,
    lpdwFlags: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn CreateRemoteThreadEx(
    hProcess: HANDLE,
    lpThreadAttributes: ?*SECURITY_ATTRIBUTES,
    dwStackSize: ?*opaque{},
    lpStartAddress: LPTHREAD_START_ROUTINE,
    lpParameter: ?*opaque{},
    dwCreationFlags: u32,
    lpAttributeList: ?*opaque{},
    lpThreadId: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn GetCurrentThreadStackLimits(
    LowLimit: ?*u32,
    HighLimit: ?*u32,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetProcessMitigationPolicy(
    hProcess: HANDLE,
    MitigationPolicy: PROCESS_MITIGATION_POLICY,
    lpBuffer: ?*opaque{},
    dwLength: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn SetProcessMitigationPolicy(
    MitigationPolicy: PROCESS_MITIGATION_POLICY,
    lpBuffer: ?*opaque{},
    dwLength: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetThreadTimes(
    hThread: HANDLE,
    lpCreationTime: ?*FILETIME,
    lpExitTime: ?*FILETIME,
    lpKernelTime: ?*FILETIME,
    lpUserTime: ?*FILETIME,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn OpenProcess(
    dwDesiredAccess: u32,
    bInheritHandle: BOOL,
    dwProcessId: u32,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetProcessHandleCount(
    hProcess: HANDLE,
    pdwHandleCount: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn GetCurrentProcessorNumber(
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn SetThreadIdealProcessorEx(
    hThread: HANDLE,
    lpIdealProcessor: ?*PROCESSOR_NUMBER,
    lpPreviousIdealProcessor: ?*PROCESSOR_NUMBER,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetThreadIdealProcessorEx(
    hThread: HANDLE,
    lpIdealProcessor: ?*PROCESSOR_NUMBER,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn GetCurrentProcessorNumberEx(
    ProcNumber: ?*PROCESSOR_NUMBER,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetProcessPriorityBoost(
    hProcess: HANDLE,
    pDisablePriorityBoost: ?*i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn SetProcessPriorityBoost(
    hProcess: HANDLE,
    bDisablePriorityBoost: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetThreadIOPendingFlag(
    hThread: HANDLE,
    lpIOIsPending: ?*i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetThreadInformation(
    hThread: HANDLE,
    ThreadInformationClass: THREAD_INFORMATION_CLASS,
    ThreadInformation: ?*opaque{},
    ThreadInformationSize: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn SetThreadInformation(
    hThread: HANDLE,
    ThreadInformationClass: THREAD_INFORMATION_CLASS,
    ThreadInformation: ?*opaque{},
    ThreadInformationSize: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn IsProcessCritical(
    hProcess: HANDLE,
    Critical: ?*i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn SetProtectedPolicy(
    PolicyGuid: ?*Guid,
    PolicyValue: ?*opaque{},
    OldPolicyValue: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn QueryProtectedPolicy(
    PolicyGuid: ?*Guid,
    PolicyValue: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn SetThreadIdealProcessor(
    hThread: HANDLE,
    dwIdealProcessor: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn SetProcessInformation(
    hProcess: HANDLE,
    ProcessInformationClass: PROCESS_INFORMATION_CLASS,
    ProcessInformation: ?*opaque{},
    ProcessInformationSize: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetProcessInformation(
    hProcess: HANDLE,
    ProcessInformationClass: PROCESS_INFORMATION_CLASS,
    ProcessInformation: ?*opaque{},
    ProcessInformationSize: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "ADVAPI32" fn CreateProcessAsUserA(
    hToken: HANDLE,
    lpApplicationName: ?*i8,
    lpCommandLine: ?*i8,
    lpProcessAttributes: ?*SECURITY_ATTRIBUTES,
    lpThreadAttributes: ?*SECURITY_ATTRIBUTES,
    bInheritHandles: BOOL,
    dwCreationFlags: u32,
    lpEnvironment: ?*opaque{},
    lpCurrentDirectory: ?*i8,
    lpStartupInfo: ?*STARTUPINFOA,
    lpProcessInformation: ?*PROCESS_INFORMATION,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetProcessShutdownParameters(
    lpdwLevel: ?*u32,
    lpdwFlags: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn SetThreadDescription(
    hThread: HANDLE,
    lpThreadDescription: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn GetThreadDescription(
    hThread: HANDLE,
    ppszThreadDescription: ?*?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GlobalMemoryStatusEx(
    lpBuffer: ?*MEMORYSTATUSEX,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetLogicalProcessorInformation(
    Buffer: ?*SYSTEM_LOGICAL_PROCESSOR_INFORMATION,
    ReturnedLength: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetLogicalProcessorInformationEx(
    RelationshipType: LOGICAL_PROCESSOR_RELATIONSHIP,
    Buffer: ?*SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX,
    ReturnedLength: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetPhysicallyInstalledSystemMemory(
    TotalMemoryInKilobytes: ?*u64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetProcessorSystemCycleTime(
    Group: u16,
    Buffer: ?*SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION,
    ReturnedLength: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn QueryThreadCycleTime(
    ThreadHandle: HANDLE,
    CycleTime: ?*u64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn QueryProcessCycleTime(
    ProcessHandle: HANDLE,
    CycleTime: ?*u64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn QueryIdleProcessorCycleTime(
    BufferLength: ?*u32,
    ProcessorIdleCycleTime: ?*u64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn QueryIdleProcessorCycleTimeEx(
    Group: u16,
    BufferLength: ?*u32,
    ProcessorIdleCycleTime: ?*u64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GlobalAlloc(
    uFlags: u32,
    dwBytes: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GlobalReAlloc(
    hMem: ?*opaque{},
    dwBytes: ?*opaque{},
    uFlags: u32,
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GlobalSize(
    hMem: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GlobalUnlock(
    hMem: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GlobalLock(
    hMem: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GlobalFlags(
    hMem: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GlobalHandle(
    pMem: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GlobalFree(
    hMem: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn GlobalMemoryStatus(
    lpBuffer: ?*MEMORYSTATUS,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn LocalAlloc(
    uFlags: u32,
    uBytes: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn LocalReAlloc(
    hMem: ?*opaque{},
    uBytes: ?*opaque{},
    uFlags: u32,
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn LocalLock(
    hMem: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn LocalHandle(
    pMem: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn LocalUnlock(
    hMem: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn LocalSize(
    hMem: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn LocalFlags(
    hMem: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn LocalFree(
    hMem: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetProcessAffinityMask(
    hProcess: HANDLE,
    lpProcessAffinityMask: ?*?*opaque{},
    lpSystemAffinityMask: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn SetProcessAffinityMask(
    hProcess: HANDLE,
    dwProcessAffinityMask: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetProcessIoCounters(
    hProcess: HANDLE,
    lpIoCounters: ?*IO_COUNTERS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetProcessWorkingSetSize(
    hProcess: HANDLE,
    lpMinimumWorkingSetSize: ?*?*opaque{},
    lpMaximumWorkingSetSize: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn SetProcessWorkingSetSize(
    hProcess: HANDLE,
    dwMinimumWorkingSetSize: ?*opaque{},
    dwMaximumWorkingSetSize: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn SwitchToFiber(
    lpFiber: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn DeleteFiber(
    lpFiber: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn ConvertFiberToThread(
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn CreateFiberEx(
    dwStackCommitSize: ?*opaque{},
    dwStackReserveSize: ?*opaque{},
    dwFlags: u32,
    lpStartAddress: LPFIBER_START_ROUTINE,
    lpParameter: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn ConvertThreadToFiberEx(
    lpParameter: ?*opaque{},
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn CreateFiber(
    dwStackSize: ?*opaque{},
    lpStartAddress: LPFIBER_START_ROUTINE,
    lpParameter: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn ConvertThreadToFiber(
    lpParameter: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn CreateUmsCompletionList(
    UmsCompletionList: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn DequeueUmsCompletionListItems(
    UmsCompletionList: ?*opaque{},
    WaitTimeOut: u32,
    UmsThreadList: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetUmsCompletionListEvent(
    UmsCompletionList: ?*opaque{},
    UmsCompletionEvent: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn ExecuteUmsThread(
    UmsThread: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn UmsThreadYield(
    SchedulerParam: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn DeleteUmsCompletionList(
    UmsCompletionList: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetCurrentUmsThread(
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetNextUmsListItem(
    UmsContext: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn QueryUmsThreadInformation(
    UmsThread: ?*opaque{},
    UmsThreadInfoClass: RTL_UMS_THREAD_INFO_CLASS,
    UmsThreadInformation: ?*opaque{},
    UmsThreadInformationLength: u32,
    ReturnLength: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn SetUmsThreadInformation(
    UmsThread: ?*opaque{},
    UmsThreadInfoClass: RTL_UMS_THREAD_INFO_CLASS,
    UmsThreadInformation: ?*opaque{},
    UmsThreadInformationLength: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn DeleteUmsThreadContext(
    UmsThread: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn CreateUmsThreadContext(
    lpUmsThread: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn EnterUmsSchedulingMode(
    SchedulerStartupInfo: ?*UMS_SCHEDULER_STARTUP_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn GetUmsSystemThreadInformation(
    ThreadHandle: HANDLE,
    SystemThreadInfo: ?*UMS_SYSTEM_THREAD_INFORMATION,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn SetThreadAffinityMask(
    hThread: HANDLE,
    dwThreadAffinityMask: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn SetProcessDEPPolicy(
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetProcessDEPPolicy(
    hProcess: HANDLE,
    lpFlags: ?*u32,
    lpPermanent: ?*i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn RequestWakeupLatency(
    latency: LATENCY_TIME,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn IsSystemResumeAutomatic(
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn SetThreadExecutionState(
    esFlags: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn PowerCreateRequest(
    Context: ?*REASON_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn PowerSetRequest(
    PowerRequest: HANDLE,
    RequestType: POWER_REQUEST_TYPE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn PowerClearRequest(
    PowerRequest: HANDLE,
    RequestType: POWER_REQUEST_TYPE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn PulseEvent(
    hEvent: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn GetDevicePowerState(
    hDevice: HANDLE,
    pfOn: ?*i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn LoadModule(
    lpModuleName: ?*i8,
    lpParameterBlock: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn WinExec(
    lpCmdLine: ?*i8,
    uCmdShow: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn ClearCommBreak(
    hFile: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn ClearCommError(
    hFile: HANDLE,
    lpErrors: ?*u32,
    lpStat: ?*COMSTAT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn SetupComm(
    hFile: HANDLE,
    dwInQueue: u32,
    dwOutQueue: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn EscapeCommFunction(
    hFile: HANDLE,
    dwFunc: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetCommConfig(
    hCommDev: HANDLE,
    lpCC: ?*COMMCONFIG,
    lpdwSize: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetCommMask(
    hFile: HANDLE,
    lpEvtMask: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetCommProperties(
    hFile: HANDLE,
    lpCommProp: ?*COMMPROP,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetCommModemStatus(
    hFile: HANDLE,
    lpModemStat: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetCommState(
    hFile: HANDLE,
    lpDCB: ?*DCB,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetCommTimeouts(
    hFile: HANDLE,
    lpCommTimeouts: ?*COMMTIMEOUTS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn PurgeComm(
    hFile: HANDLE,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn SetCommBreak(
    hFile: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn SetCommConfig(
    hCommDev: HANDLE,
    lpCC: ?*COMMCONFIG,
    dwSize: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn SetCommMask(
    hFile: HANDLE,
    dwEvtMask: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn SetCommState(
    hFile: HANDLE,
    lpDCB: ?*DCB,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn SetCommTimeouts(
    hFile: HANDLE,
    lpCommTimeouts: ?*COMMTIMEOUTS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn TransmitCommChar(
    hFile: HANDLE,
    cChar: i8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn WaitCommEvent(
    hFile: HANDLE,
    lpEvtMask: ?*u32,
    lpOverlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-core-comm-l1-1-1" fn OpenCommPort(
    uPortNumber: u32,
    dwDesiredAccess: u32,
    dwFlagsAndAttributes: u32,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-core-comm-l1-1-2" fn GetCommPorts(
    lpPortNumbers: ?*u32,
    uPortNumbersCount: u32,
    puPortNumbersFound: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn SetTapePosition(
    hDevice: HANDLE,
    dwPositionMethod: u32,
    dwPartition: u32,
    dwOffsetLow: u32,
    dwOffsetHigh: u32,
    bImmediate: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn GetTapePosition(
    hDevice: HANDLE,
    dwPositionType: u32,
    lpdwPartition: ?*u32,
    lpdwOffsetLow: ?*u32,
    lpdwOffsetHigh: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn PrepareTape(
    hDevice: HANDLE,
    dwOperation: u32,
    bImmediate: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn EraseTape(
    hDevice: HANDLE,
    dwEraseType: u32,
    bImmediate: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn CreateTapePartition(
    hDevice: HANDLE,
    dwPartitionMethod: u32,
    dwCount: u32,
    dwSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn WriteTapemark(
    hDevice: HANDLE,
    dwTapemarkType: u32,
    dwTapemarkCount: u32,
    bImmediate: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn GetTapeStatus(
    hDevice: HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn GetTapeParameters(
    hDevice: HANDLE,
    dwOperation: u32,
    lpdwSize: ?*u32,
    lpTapeInformation: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn SetTapeParameters(
    hDevice: HANDLE,
    dwOperation: u32,
    lpTapeInformation: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn GetSystemDEPPolicy(
) callconv(@import("std").os.windows.WINAPI) DEP_SYSTEM_POLICY_TYPE;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn CreateMailslotA(
    lpName: ?*i8,
    nMaxMessageSize: u32,
    lReadTimeout: u32,
    lpSecurityAttributes: ?*SECURITY_ATTRIBUTES,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn CreateMailslotW(
    lpName: ?*u16,
    nMaxMessageSize: u32,
    lReadTimeout: u32,
    lpSecurityAttributes: ?*SECURITY_ATTRIBUTES,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetMailslotInfo(
    hMailslot: HANDLE,
    lpMaxMessageSize: ?*u32,
    lpNextSize: ?*u32,
    lpMessageCount: ?*u32,
    lpReadTimeout: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn SetMailslotInfo(
    hMailslot: HANDLE,
    lReadTimeout: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn SignalObjectAndWait(
    hObjectToSignal: HANDLE,
    hObjectToWaitOn: HANDLE,
    dwMilliseconds: u32,
    bAlertable: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn BackupRead(
    hFile: HANDLE,
    lpBuffer: ?*u8,
    nNumberOfBytesToRead: u32,
    lpNumberOfBytesRead: ?*u32,
    bAbort: BOOL,
    bProcessSecurity: BOOL,
    lpContext: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn BackupSeek(
    hFile: HANDLE,
    dwLowBytesToSeek: u32,
    dwHighBytesToSeek: u32,
    lpdwLowByteSeeked: ?*u32,
    lpdwHighByteSeeked: ?*u32,
    lpContext: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn BackupWrite(
    hFile: HANDLE,
    lpBuffer: ?*u8,
    nNumberOfBytesToWrite: u32,
    lpNumberOfBytesWritten: ?*u32,
    bAbort: BOOL,
    bProcessSecurity: BOOL,
    lpContext: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn CreateSemaphoreA(
    lpSemaphoreAttributes: ?*SECURITY_ATTRIBUTES,
    lInitialCount: i32,
    lMaximumCount: i32,
    lpName: ?*i8,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn CreateSemaphoreExA(
    lpSemaphoreAttributes: ?*SECURITY_ATTRIBUTES,
    lInitialCount: i32,
    lMaximumCount: i32,
    lpName: ?*i8,
    dwFlags: u32,
    dwDesiredAccess: u32,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn CreateFileMappingA(
    hFile: HANDLE,
    lpFileMappingAttributes: ?*SECURITY_ATTRIBUTES,
    flProtect: u32,
    dwMaximumSizeHigh: u32,
    dwMaximumSizeLow: u32,
    lpName: ?*i8,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn CreateFileMappingNumaA(
    hFile: HANDLE,
    lpFileMappingAttributes: ?*SECURITY_ATTRIBUTES,
    flProtect: u32,
    dwMaximumSizeHigh: u32,
    dwMaximumSizeLow: u32,
    lpName: ?*i8,
    nndPreferred: u32,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn OpenFileMappingA(
    dwDesiredAccess: u32,
    bInheritHandle: BOOL,
    lpName: ?*i8,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn LoadPackagedLibrary(
    lpwLibFileName: ?*u16,
    Reserved: u32,
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn QueryFullProcessImageNameA(
    hProcess: HANDLE,
    dwFlags: u32,
    lpExeName: ?*i8,
    lpdwSize: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn QueryFullProcessImageNameW(
    hProcess: HANDLE,
    dwFlags: u32,
    lpExeName: ?*u16,
    lpdwSize: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn SetDllDirectoryA(
    lpPathName: ?*i8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn SetDllDirectoryW(
    lpPathName: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetDllDirectoryA(
    nBufferLength: u32,
    lpBuffer: ?*i8,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetDllDirectoryW(
    nBufferLength: u32,
    lpBuffer: ?*u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetNamedPipeHandleStateA(
    hNamedPipe: HANDLE,
    lpState: ?*u32,
    lpCurInstances: ?*u32,
    lpMaxCollectionCount: ?*u32,
    lpCollectDataTimeout: ?*u32,
    lpUserName: ?*i8,
    nMaxUserNameSize: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn CallNamedPipeA(
    lpNamedPipeName: ?*i8,
    lpInBuffer: ?*opaque{},
    nInBufferSize: u32,
    lpOutBuffer: ?*opaque{},
    nOutBufferSize: u32,
    lpBytesRead: ?*u32,
    nTimeOut: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetNamedPipeClientComputerNameA(
    Pipe: HANDLE,
    ClientComputerName: ?*i8,
    ClientComputerNameLength: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetNamedPipeClientProcessId(
    Pipe: HANDLE,
    ClientProcessId: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetNamedPipeClientSessionId(
    Pipe: HANDLE,
    ClientSessionId: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetNamedPipeServerProcessId(
    Pipe: HANDLE,
    ServerProcessId: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetNamedPipeServerSessionId(
    Pipe: HANDLE,
    ServerSessionId: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "ADVAPI32" fn ClearEventLogA(
    hEventLog: HANDLE,
    lpBackupFileName: ?*i8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "ADVAPI32" fn ClearEventLogW(
    hEventLog: HANDLE,
    lpBackupFileName: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "ADVAPI32" fn BackupEventLogA(
    hEventLog: HANDLE,
    lpBackupFileName: ?*i8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "ADVAPI32" fn BackupEventLogW(
    hEventLog: HANDLE,
    lpBackupFileName: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "ADVAPI32" fn CloseEventLog(
    hEventLog: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "ADVAPI32" fn DeregisterEventSource(
    hEventLog: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "ADVAPI32" fn NotifyChangeEventLog(
    hEventLog: HANDLE,
    hEvent: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "ADVAPI32" fn GetNumberOfEventLogRecords(
    hEventLog: HANDLE,
    NumberOfRecords: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "ADVAPI32" fn GetOldestEventLogRecord(
    hEventLog: HANDLE,
    OldestRecord: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "ADVAPI32" fn OpenEventLogA(
    lpUNCServerName: ?*i8,
    lpSourceName: ?*i8,
) callconv(@import("std").os.windows.WINAPI) EventLogHandle;

// set_last_errror=True (can and should we use this?)
pub extern "ADVAPI32" fn OpenEventLogW(
    lpUNCServerName: ?*u16,
    lpSourceName: ?*u16,
) callconv(@import("std").os.windows.WINAPI) EventLogHandle;

// set_last_errror=True (can and should we use this?)
pub extern "ADVAPI32" fn RegisterEventSourceA(
    lpUNCServerName: ?*i8,
    lpSourceName: ?*i8,
) callconv(@import("std").os.windows.WINAPI) EventSourceHandle;

// set_last_errror=True (can and should we use this?)
pub extern "ADVAPI32" fn RegisterEventSourceW(
    lpUNCServerName: ?*u16,
    lpSourceName: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// set_last_errror=True (can and should we use this?)
pub extern "ADVAPI32" fn OpenBackupEventLogA(
    lpUNCServerName: ?*i8,
    lpFileName: ?*i8,
) callconv(@import("std").os.windows.WINAPI) EventLogHandle;

// set_last_errror=True (can and should we use this?)
pub extern "ADVAPI32" fn OpenBackupEventLogW(
    lpUNCServerName: ?*u16,
    lpFileName: ?*u16,
) callconv(@import("std").os.windows.WINAPI) EventLogHandle;

// set_last_errror=True (can and should we use this?)
pub extern "ADVAPI32" fn ReadEventLogA(
    hEventLog: HANDLE,
    dwReadFlags: u32,
    dwRecordOffset: u32,
    lpBuffer: ?*opaque{},
    nNumberOfBytesToRead: u32,
    pnBytesRead: ?*u32,
    pnMinNumberOfBytesNeeded: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "ADVAPI32" fn ReadEventLogW(
    hEventLog: HANDLE,
    dwReadFlags: u32,
    dwRecordOffset: u32,
    lpBuffer: ?*opaque{},
    nNumberOfBytesToRead: u32,
    pnBytesRead: ?*u32,
    pnMinNumberOfBytesNeeded: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "ADVAPI32" fn ReportEventA(
    hEventLog: HANDLE,
    wType: u16,
    wCategory: u16,
    dwEventID: u32,
    lpUserSid: ?*opaque{},
    wNumStrings: u16,
    dwDataSize: u32,
    lpStrings: ?*?*i8,
    lpRawData: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "ADVAPI32" fn ReportEventW(
    hEventLog: HANDLE,
    wType: u16,
    wCategory: u16,
    dwEventID: u32,
    lpUserSid: ?*opaque{},
    wNumStrings: u16,
    dwDataSize: u32,
    lpStrings: ?*?*u16,
    lpRawData: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "ADVAPI32" fn GetEventLogInformation(
    hEventLog: HANDLE,
    dwInfoLevel: u32,
    lpBuffer: ?*opaque{},
    cbBufSize: u32,
    pcbBytesNeeded: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn MapViewOfFileExNuma(
    hFileMappingObject: HANDLE,
    dwDesiredAccess: u32,
    dwFileOffsetHigh: u32,
    dwFileOffsetLow: u32,
    dwNumberOfBytesToMap: ?*opaque{},
    lpBaseAddress: ?*opaque{},
    nndPreferred: u32,
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn IsBadReadPtr(
    lp: ?*opaque{},
    ucb: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn IsBadWritePtr(
    lp: ?*opaque{},
    ucb: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn IsBadCodePtr(
    lpfn: FARPROC,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn IsBadStringPtrA(
    lpsz: ?*i8,
    ucchMax: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn IsBadStringPtrW(
    lpsz: ?*u16,
    ucchMax: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn BuildCommDCBA(
    lpDef: ?*i8,
    lpDCB: ?*DCB,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn BuildCommDCBW(
    lpDef: ?*u16,
    lpDCB: ?*DCB,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn BuildCommDCBAndTimeoutsA(
    lpDef: ?*i8,
    lpDCB: ?*DCB,
    lpCommTimeouts: ?*COMMTIMEOUTS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn BuildCommDCBAndTimeoutsW(
    lpDef: ?*u16,
    lpDCB: ?*DCB,
    lpCommTimeouts: ?*COMMTIMEOUTS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn CommConfigDialogA(
    lpszName: ?*i8,
    hWnd: HWND,
    lpCC: ?*COMMCONFIG,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn CommConfigDialogW(
    lpszName: ?*u16,
    hWnd: HWND,
    lpCC: ?*COMMCONFIG,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetDefaultCommConfigA(
    lpszName: ?*i8,
    lpCC: ?*COMMCONFIG,
    lpdwSize: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetDefaultCommConfigW(
    lpszName: ?*u16,
    lpCC: ?*COMMCONFIG,
    lpdwSize: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn SetDefaultCommConfigA(
    lpszName: ?*i8,
    lpCC: ?*COMMCONFIG,
    dwSize: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn SetDefaultCommConfigW(
    lpszName: ?*u16,
    lpCC: ?*COMMCONFIG,
    dwSize: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "ADVAPI32" fn CreateProcessWithLogonW(
    lpUsername: ?*u16,
    lpDomain: ?*u16,
    lpPassword: ?*u16,
    dwLogonFlags: u32,
    lpApplicationName: ?*u16,
    lpCommandLine: ?*u16,
    dwCreationFlags: u32,
    lpEnvironment: ?*opaque{},
    lpCurrentDirectory: ?*u16,
    lpStartupInfo: ?*STARTUPINFOW,
    lpProcessInformation: ?*PROCESS_INFORMATION,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "ADVAPI32" fn CreateProcessWithTokenW(
    hToken: HANDLE,
    dwLogonFlags: u32,
    lpApplicationName: ?*u16,
    lpCommandLine: ?*u16,
    dwCreationFlags: u32,
    lpEnvironment: ?*opaque{},
    lpCurrentDirectory: ?*u16,
    lpStartupInfo: ?*STARTUPINFOW,
    lpProcessInformation: ?*PROCESS_INFORMATION,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn RegisterWaitForSingleObject(
    phNewWaitObject: ?*?*opaque{},
    hObject: HANDLE,
    Callback: WAITORTIMERCALLBACK,
    Context: ?*opaque{},
    dwMilliseconds: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn UnregisterWait(
    WaitHandle: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn BindIoCompletionCallback(
    FileHandle: HANDLE,
    Function: LPOVERLAPPED_COMPLETION_ROUTINE,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn DeleteTimerQueue(
    TimerQueue: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn CreateBoundaryDescriptorA(
    Name: ?*i8,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) BoundaryDescriptorHandle;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn AddIntegrityLabelToBoundaryDescriptor(
    BoundaryDescriptor: ?*HANDLE,
    IntegrityLabel: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn SetSystemPowerState(
    fSuspend: BOOL,
    fForce: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetSystemPowerStatus(
    lpSystemPowerStatus: ?*SYSTEM_POWER_STATUS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn MapUserPhysicalPagesScatter(
    VirtualAddresses: ?*?*opaque{},
    NumberOfPages: ?*opaque{},
    PageArray: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn CreateJobObjectA(
    lpJobAttributes: ?*SECURITY_ATTRIBUTES,
    lpName: ?*i8,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn OpenJobObjectA(
    dwDesiredAccess: u32,
    bInheritHandle: BOOL,
    lpName: ?*i8,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn GetActiveProcessorGroupCount(
) callconv(@import("std").os.windows.WINAPI) u16;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn GetMaximumProcessorGroupCount(
) callconv(@import("std").os.windows.WINAPI) u16;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetActiveProcessorCount(
    GroupNumber: u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetMaximumProcessorCount(
    GroupNumber: u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetNumaProcessorNode(
    Processor: u8,
    NodeNumber: ?*u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetNumaNodeNumberFromHandle(
    hFile: HANDLE,
    NodeNumber: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetNumaProcessorNodeEx(
    Processor: ?*PROCESSOR_NUMBER,
    NodeNumber: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetNumaNodeProcessorMask(
    Node: u8,
    ProcessorMask: ?*u64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetNumaAvailableMemoryNode(
    Node: u8,
    AvailableBytes: ?*u64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetNumaAvailableMemoryNodeEx(
    Node: u16,
    AvailableBytes: ?*u64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetNumaProximityNode(
    ProximityId: u32,
    NodeNumber: ?*u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn AddSecureMemoryCacheCallback(
    pfnCallBack: PSECURE_MEMORY_CACHE_CALLBACK,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn RemoveSecureMemoryCacheCallback(
    pfnCallBack: PSECURE_MEMORY_CACHE_CALLBACK,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "ADVAPI32" fn InitiateSystemShutdownA(
    lpMachineName: ?*i8,
    lpMessage: ?*i8,
    dwTimeout: u32,
    bForceAppsClosed: BOOL,
    bRebootAfterShutdown: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "ADVAPI32" fn InitiateSystemShutdownW(
    lpMachineName: ?*u16,
    lpMessage: ?*u16,
    dwTimeout: u32,
    bForceAppsClosed: BOOL,
    bRebootAfterShutdown: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "ADVAPI32" fn AbortSystemShutdownA(
    lpMachineName: ?*i8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "ADVAPI32" fn AbortSystemShutdownW(
    lpMachineName: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "ADVAPI32" fn InitiateSystemShutdownExA(
    lpMachineName: ?*i8,
    lpMessage: ?*i8,
    dwTimeout: u32,
    bForceAppsClosed: BOOL,
    bRebootAfterShutdown: BOOL,
    dwReason: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "ADVAPI32" fn InitiateSystemShutdownExW(
    lpMachineName: ?*u16,
    lpMessage: ?*u16,
    dwTimeout: u32,
    bForceAppsClosed: BOOL,
    bRebootAfterShutdown: BOOL,
    dwReason: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "ADVAPI32" fn InitiateShutdownA(
    lpMachineName: ?*i8,
    lpMessage: ?*i8,
    dwGracePeriod: u32,
    dwShutdownFlags: u32,
    dwReason: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "ADVAPI32" fn InitiateShutdownW(
    lpMachineName: ?*u16,
    lpMessage: ?*u16,
    dwGracePeriod: u32,
    dwShutdownFlags: u32,
    dwReason: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "ntdll" fn NtQueryInformationProcess(
    ProcessHandle: HANDLE,
    ProcessInformationClass: PROCESSINFOCLASS,
    ProcessInformation: ?*opaque{},
    ProcessInformationLength: u32,
    ReturnLength: ?*u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "ntdll" fn NtQueryInformationThread(
    ThreadHandle: HANDLE,
    ThreadInformationClass: THREADINFOCLASS,
    ThreadInformation: ?*opaque{},
    ThreadInformationLength: u32,
    ReturnLength: ?*u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

//
// Unicode Symbol Aliases
//
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {
        pub const ENUMRESLANGPROC = ENUMRESLANGPROCA;
        pub const PGET_MODULE_HANDLE_EX = PGET_MODULE_HANDLE_EXA;
        pub const PRINTER_INFO_1 = PRINTER_INFO_1A;
        pub const PRINTER_INFO_2 = PRINTER_INFO_2A;
        pub const PRINTER_INFO_4 = PRINTER_INFO_4A;
        pub const PRINTER_INFO_5 = PRINTER_INFO_5A;
        pub const PRINTER_INFO_7 = PRINTER_INFO_7A;
        pub const PRINTER_INFO_8 = PRINTER_INFO_8A;
        pub const PRINTER_INFO_9 = PRINTER_INFO_9A;
        pub const JOB_INFO_1 = JOB_INFO_1A;
        pub const JOB_INFO_2 = JOB_INFO_2A;
        pub const JOB_INFO_4 = JOB_INFO_4A;
        pub const ADDJOB_INFO_1 = ADDJOB_INFO_1A;
        pub const DRIVER_INFO_1 = DRIVER_INFO_1A;
        pub const DRIVER_INFO_2 = DRIVER_INFO_2A;
        pub const DRIVER_INFO_3 = DRIVER_INFO_3A;
        pub const DRIVER_INFO_4 = DRIVER_INFO_4A;
        pub const DRIVER_INFO_5 = DRIVER_INFO_5A;
        pub const DRIVER_INFO_6 = DRIVER_INFO_6A;
        pub const DRIVER_INFO_8 = DRIVER_INFO_8A;
        pub const DOC_INFO_1 = DOC_INFO_1A;
        pub const FORM_INFO_1 = FORM_INFO_1A;
        pub const FORM_INFO_2 = FORM_INFO_2A;
        pub const DOC_INFO_2 = DOC_INFO_2A;
        pub const DOC_INFO_3 = DOC_INFO_3A;
        pub const PRINTPROCESSOR_INFO_1 = PRINTPROCESSOR_INFO_1A;
        pub const PORT_INFO_1 = PORT_INFO_1A;
        pub const PORT_INFO_2 = PORT_INFO_2A;
        pub const PORT_INFO_3 = PORT_INFO_3A;
        pub const MONITOR_INFO_1 = MONITOR_INFO_1A;
        pub const MONITOR_INFO_2 = MONITOR_INFO_2A;
        pub const DATATYPES_INFO_1 = DATATYPES_INFO_1A;
        pub const PRINTER_DEFAULTS = PRINTER_DEFAULTSA;
        pub const PRINTER_ENUM_VALUES = PRINTER_ENUM_VALUESA;
        pub const PROVIDOR_INFO_1 = PROVIDOR_INFO_1A;
        pub const PROVIDOR_INFO_2 = PROVIDOR_INFO_2A;
        pub const PRINTER_OPTIONS = PRINTER_OPTIONSA;
        pub const PRINTER_CONNECTION_INFO_1 = PRINTER_CONNECTION_INFO_1A;
        pub const CORE_PRINTER_DRIVER = CORE_PRINTER_DRIVERA;
        pub const DEV_BROADCAST_PORT_ = DEV_BROADCAST_PORT_A;
        pub const DEV_BROADCAST_DEVICEINTERFACE_ = DEV_BROADCAST_DEVICEINTERFACE_A;
        pub const STARTUPINFO = STARTUPINFOA;
        pub const STARTUPINFOEX = STARTUPINFOEXA;
        pub const RegisterDeviceNotification = RegisterDeviceNotificationA;
        pub const CreateMutex = CreateMutexA;
        pub const CreateEvent = CreateEventA;
        pub const OpenEvent = OpenEventA;
        pub const CreateMutexEx = CreateMutexExA;
        pub const CreateEventEx = CreateEventExA;
        pub const CreateSemaphoreEx = CreateSemaphoreExA;
        pub const CreateSemaphore = CreateSemaphoreA;
        pub const CreateJobObject = CreateJobObjectA;
        pub const OpenJobObject = OpenJobObjectA;
        pub const CreateBoundaryDescriptor = CreateBoundaryDescriptorA;
        pub const GetNamedPipeClientComputerName = GetNamedPipeClientComputerNameA;
        pub const GetNamedPipeHandleState = GetNamedPipeHandleStateA;
        pub const CallNamedPipe = CallNamedPipeA;
        pub const CreateFileMapping = CreateFileMappingA;
        pub const OpenFileMapping = OpenFileMappingA;
        pub const CreateFileMappingNuma = CreateFileMappingNumaA;
        pub const LoadEnclaveImage = LoadEnclaveImageA;
        pub const GetModuleFileName = GetModuleFileNameA;
        pub const GetModuleHandle = GetModuleHandleA;
        pub const GetModuleHandleEx = GetModuleHandleExA;
        pub const LoadLibraryEx = LoadLibraryExA;
        pub const LoadLibrary = LoadLibraryA;
        pub const ReadConsoleInput = ReadConsoleInputA;
        pub const PeekConsoleInput = PeekConsoleInputA;
        pub const ReadConsole = ReadConsoleA;
        pub const WriteConsole = WriteConsoleA;
        pub const FillConsoleOutputCharacter = FillConsoleOutputCharacterA;
        pub const WriteConsoleOutputCharacter = WriteConsoleOutputCharacterA;
        pub const ReadConsoleOutputCharacter = ReadConsoleOutputCharacterA;
        pub const WriteConsoleInput = WriteConsoleInputA;
        pub const ScrollConsoleScreenBuffer = ScrollConsoleScreenBufferA;
        pub const WriteConsoleOutput = WriteConsoleOutputA;
        pub const ReadConsoleOutput = ReadConsoleOutputA;
        pub const GetConsoleTitle = GetConsoleTitleA;
        pub const GetConsoleOriginalTitle = GetConsoleOriginalTitleA;
        pub const SetConsoleTitle = SetConsoleTitleA;
        pub const AddConsoleAlias = AddConsoleAliasA;
        pub const GetConsoleAlias = GetConsoleAliasA;
        pub const GetConsoleAliasesLength = GetConsoleAliasesLengthA;
        pub const GetConsoleAliasExesLength = GetConsoleAliasExesLengthA;
        pub const GetConsoleAliases = GetConsoleAliasesA;
        pub const GetConsoleAliasExes = GetConsoleAliasExesA;
        pub const ExpungeConsoleCommandHistory = ExpungeConsoleCommandHistoryA;
        pub const SetConsoleNumberOfCommands = SetConsoleNumberOfCommandsA;
        pub const GetConsoleCommandHistoryLength = GetConsoleCommandHistoryLengthA;
        pub const GetConsoleCommandHistory = GetConsoleCommandHistoryA;
        pub const EnumPrinters = EnumPrintersA;
        pub const OpenPrinter = OpenPrinterA;
        pub const ResetPrinter = ResetPrinterA;
        pub const SetJob = SetJobA;
        pub const GetJob = GetJobA;
        pub const EnumJobs = EnumJobsA;
        pub const AddPrinter = AddPrinterA;
        pub const SetPrinter = SetPrinterA;
        pub const GetPrinter = GetPrinterA;
        pub const AddPrinterDriver = AddPrinterDriverA;
        pub const AddPrinterDriverEx = AddPrinterDriverExA;
        pub const EnumPrinterDrivers = EnumPrinterDriversA;
        pub const GetPrinterDriver = GetPrinterDriverA;
        pub const GetPrinterDriverDirectory = GetPrinterDriverDirectoryA;
        pub const DeletePrinterDriver = DeletePrinterDriverA;
        pub const DeletePrinterDriverEx = DeletePrinterDriverExA;
        pub const AddPrintProcessor = AddPrintProcessorA;
        pub const EnumPrintProcessors = EnumPrintProcessorsA;
        pub const GetPrintProcessorDirectory = GetPrintProcessorDirectoryA;
        pub const EnumPrintProcessorDatatypes = EnumPrintProcessorDatatypesA;
        pub const DeletePrintProcessor = DeletePrintProcessorA;
        pub const StartDocPrinter = StartDocPrinterA;
        pub const AddJob = AddJobA;
        pub const DocumentProperties = DocumentPropertiesA;
        pub const AdvancedDocumentProperties = AdvancedDocumentPropertiesA;
        pub const GetPrinterData = GetPrinterDataA;
        pub const GetPrinterDataEx = GetPrinterDataExA;
        pub const EnumPrinterData = EnumPrinterDataA;
        pub const EnumPrinterDataEx = EnumPrinterDataExA;
        pub const EnumPrinterKey = EnumPrinterKeyA;
        pub const SetPrinterData = SetPrinterDataA;
        pub const SetPrinterDataEx = SetPrinterDataExA;
        pub const DeletePrinterData = DeletePrinterDataA;
        pub const DeletePrinterDataEx = DeletePrinterDataExA;
        pub const DeletePrinterKey = DeletePrinterKeyA;
        pub const PrinterMessageBox = PrinterMessageBoxA;
        pub const AddForm = AddFormA;
        pub const DeleteForm = DeleteFormA;
        pub const GetForm = GetFormA;
        pub const SetForm = SetFormA;
        pub const EnumForms = EnumFormsA;
        pub const EnumMonitors = EnumMonitorsA;
        pub const AddMonitor = AddMonitorA;
        pub const DeleteMonitor = DeleteMonitorA;
        pub const EnumPorts = EnumPortsA;
        pub const AddPort = AddPortA;
        pub const ConfigurePort = ConfigurePortA;
        pub const DeletePort = DeletePortA;
        pub const GetDefaultPrinter = GetDefaultPrinterA;
        pub const SetDefaultPrinter = SetDefaultPrinterA;
        pub const SetPort = SetPortA;
        pub const AddPrinterConnection = AddPrinterConnectionA;
        pub const DeletePrinterConnection = DeletePrinterConnectionA;
        pub const AddPrintProvidor = AddPrintProvidorA;
        pub const DeletePrintProvidor = DeletePrintProvidorA;
        pub const IsValidDevmode = IsValidDevmodeA;
        pub const OpenPrinter2 = OpenPrinter2A;
        pub const AddPrinterConnection2 = AddPrinterConnection2A;
        pub const InstallPrinterDriverFromPackage = InstallPrinterDriverFromPackageA;
        pub const UploadPrinterDriverPackage = UploadPrinterDriverPackageA;
        pub const GetCorePrinterDrivers = GetCorePrinterDriversA;
        pub const CorePrinterDriverInstalled = CorePrinterDriverInstalledA;
        pub const GetPrinterDriverPackagePath = GetPrinterDriverPackagePathA;
        pub const DeletePrinterDriverPackage = DeletePrinterDriverPackageA;
        pub const GetPrinterDriver2 = GetPrinterDriver2A;
        pub const GetCommandLine = GetCommandLineA;
        pub const FreeEnvironmentStrings = FreeEnvironmentStringsA;
        pub const GetEnvironmentVariable = GetEnvironmentVariableA;
        pub const SetEnvironmentVariable = SetEnvironmentVariableA;
        pub const NeedCurrentDirectoryForExePath = NeedCurrentDirectoryForExePathA;
        pub const CreateProcess = CreateProcessA;
        pub const CreateProcessAsUser = CreateProcessAsUserA;
        pub const CreateMailslot = CreateMailslotA;
        pub const QueryFullProcessImageName = QueryFullProcessImageNameA;
        pub const SetDllDirectory = SetDllDirectoryA;
        pub const GetDllDirectory = GetDllDirectoryA;
        pub const ClearEventLog = ClearEventLogA;
        pub const BackupEventLog = BackupEventLogA;
        pub const OpenEventLog = OpenEventLogA;
        pub const RegisterEventSource = RegisterEventSourceA;
        pub const OpenBackupEventLog = OpenBackupEventLogA;
        pub const ReadEventLog = ReadEventLogA;
        pub const ReportEvent = ReportEventA;
        pub const IsBadStringPtr = IsBadStringPtrA;
        pub const BuildCommDCB = BuildCommDCBA;
        pub const BuildCommDCBAndTimeouts = BuildCommDCBAndTimeoutsA;
        pub const CommConfigDialog = CommConfigDialogA;
        pub const GetDefaultCommConfig = GetDefaultCommConfigA;
        pub const SetDefaultCommConfig = SetDefaultCommConfigA;
        pub const InitiateSystemShutdown = InitiateSystemShutdownA;
        pub const AbortSystemShutdown = AbortSystemShutdownA;
        pub const InitiateSystemShutdownEx = InitiateSystemShutdownExA;
        pub const InitiateShutdown = InitiateShutdownA;
    },
    .wide => struct {
        pub const ENUMRESLANGPROC = ENUMRESLANGPROCW;
        pub const PGET_MODULE_HANDLE_EX = PGET_MODULE_HANDLE_EXW;
        pub const PRINTER_INFO_1 = PRINTER_INFO_1W;
        pub const PRINTER_INFO_2 = PRINTER_INFO_2W;
        pub const PRINTER_INFO_4 = PRINTER_INFO_4W;
        pub const PRINTER_INFO_5 = PRINTER_INFO_5W;
        pub const PRINTER_INFO_7 = PRINTER_INFO_7W;
        pub const PRINTER_INFO_8 = PRINTER_INFO_8W;
        pub const PRINTER_INFO_9 = PRINTER_INFO_9W;
        pub const JOB_INFO_1 = JOB_INFO_1W;
        pub const JOB_INFO_2 = JOB_INFO_2W;
        pub const JOB_INFO_4 = JOB_INFO_4W;
        pub const ADDJOB_INFO_1 = ADDJOB_INFO_1W;
        pub const DRIVER_INFO_1 = DRIVER_INFO_1W;
        pub const DRIVER_INFO_2 = DRIVER_INFO_2W;
        pub const DRIVER_INFO_3 = DRIVER_INFO_3W;
        pub const DRIVER_INFO_4 = DRIVER_INFO_4W;
        pub const DRIVER_INFO_5 = DRIVER_INFO_5W;
        pub const DRIVER_INFO_6 = DRIVER_INFO_6W;
        pub const DRIVER_INFO_8 = DRIVER_INFO_8W;
        pub const DOC_INFO_1 = DOC_INFO_1W;
        pub const FORM_INFO_1 = FORM_INFO_1W;
        pub const FORM_INFO_2 = FORM_INFO_2W;
        pub const DOC_INFO_2 = DOC_INFO_2W;
        pub const DOC_INFO_3 = DOC_INFO_3W;
        pub const PRINTPROCESSOR_INFO_1 = PRINTPROCESSOR_INFO_1W;
        pub const PORT_INFO_1 = PORT_INFO_1W;
        pub const PORT_INFO_2 = PORT_INFO_2W;
        pub const PORT_INFO_3 = PORT_INFO_3W;
        pub const MONITOR_INFO_1 = MONITOR_INFO_1W;
        pub const MONITOR_INFO_2 = MONITOR_INFO_2W;
        pub const DATATYPES_INFO_1 = DATATYPES_INFO_1W;
        pub const PRINTER_DEFAULTS = PRINTER_DEFAULTSW;
        pub const PRINTER_ENUM_VALUES = PRINTER_ENUM_VALUESW;
        pub const PROVIDOR_INFO_1 = PROVIDOR_INFO_1W;
        pub const PROVIDOR_INFO_2 = PROVIDOR_INFO_2W;
        pub const PRINTER_OPTIONS = PRINTER_OPTIONSW;
        pub const PRINTER_CONNECTION_INFO_1 = PRINTER_CONNECTION_INFO_1W;
        pub const CORE_PRINTER_DRIVER = CORE_PRINTER_DRIVERW;
        pub const DEV_BROADCAST_PORT_ = DEV_BROADCAST_PORT_W;
        pub const DEV_BROADCAST_DEVICEINTERFACE_ = DEV_BROADCAST_DEVICEINTERFACE_W;
        pub const STARTUPINFO = STARTUPINFOW;
        pub const STARTUPINFOEX = STARTUPINFOEXW;
        pub const RegisterDeviceNotification = RegisterDeviceNotificationW;
        pub const CreateMutex = CreateMutexW;
        pub const CreateEvent = CreateEventW;
        pub const OpenEvent = OpenEventW;
        pub const CreateMutexEx = CreateMutexExW;
        pub const CreateEventEx = CreateEventExW;
        pub const CreateSemaphoreEx = CreateSemaphoreExW;
        pub const CreateSemaphore = CreateSemaphoreW;
        pub const CreateJobObject = CreateJobObjectW;
        pub const OpenJobObject = OpenJobObjectW;
        pub const CreateBoundaryDescriptor = CreateBoundaryDescriptorW;
        pub const GetNamedPipeClientComputerName = GetNamedPipeClientComputerNameW;
        pub const GetNamedPipeHandleState = GetNamedPipeHandleStateW;
        pub const CallNamedPipe = CallNamedPipeW;
        pub const CreateFileMapping = CreateFileMappingW;
        pub const OpenFileMapping = OpenFileMappingW;
        pub const CreateFileMappingNuma = CreateFileMappingNumaW;
        pub const LoadEnclaveImage = LoadEnclaveImageW;
        pub const GetModuleFileName = GetModuleFileNameW;
        pub const GetModuleHandle = GetModuleHandleW;
        pub const GetModuleHandleEx = GetModuleHandleExW;
        pub const LoadLibraryEx = LoadLibraryExW;
        pub const LoadLibrary = LoadLibraryW;
        pub const ReadConsoleInput = ReadConsoleInputW;
        pub const PeekConsoleInput = PeekConsoleInputW;
        pub const ReadConsole = ReadConsoleW;
        pub const WriteConsole = WriteConsoleW;
        pub const FillConsoleOutputCharacter = FillConsoleOutputCharacterW;
        pub const WriteConsoleOutputCharacter = WriteConsoleOutputCharacterW;
        pub const ReadConsoleOutputCharacter = ReadConsoleOutputCharacterW;
        pub const WriteConsoleInput = WriteConsoleInputW;
        pub const ScrollConsoleScreenBuffer = ScrollConsoleScreenBufferW;
        pub const WriteConsoleOutput = WriteConsoleOutputW;
        pub const ReadConsoleOutput = ReadConsoleOutputW;
        pub const GetConsoleTitle = GetConsoleTitleW;
        pub const GetConsoleOriginalTitle = GetConsoleOriginalTitleW;
        pub const SetConsoleTitle = SetConsoleTitleW;
        pub const AddConsoleAlias = AddConsoleAliasW;
        pub const GetConsoleAlias = GetConsoleAliasW;
        pub const GetConsoleAliasesLength = GetConsoleAliasesLengthW;
        pub const GetConsoleAliasExesLength = GetConsoleAliasExesLengthW;
        pub const GetConsoleAliases = GetConsoleAliasesW;
        pub const GetConsoleAliasExes = GetConsoleAliasExesW;
        pub const ExpungeConsoleCommandHistory = ExpungeConsoleCommandHistoryW;
        pub const SetConsoleNumberOfCommands = SetConsoleNumberOfCommandsW;
        pub const GetConsoleCommandHistoryLength = GetConsoleCommandHistoryLengthW;
        pub const GetConsoleCommandHistory = GetConsoleCommandHistoryW;
        pub const EnumPrinters = EnumPrintersW;
        pub const OpenPrinter = OpenPrinterW;
        pub const ResetPrinter = ResetPrinterW;
        pub const SetJob = SetJobW;
        pub const GetJob = GetJobW;
        pub const EnumJobs = EnumJobsW;
        pub const AddPrinter = AddPrinterW;
        pub const SetPrinter = SetPrinterW;
        pub const GetPrinter = GetPrinterW;
        pub const AddPrinterDriver = AddPrinterDriverW;
        pub const AddPrinterDriverEx = AddPrinterDriverExW;
        pub const EnumPrinterDrivers = EnumPrinterDriversW;
        pub const GetPrinterDriver = GetPrinterDriverW;
        pub const GetPrinterDriverDirectory = GetPrinterDriverDirectoryW;
        pub const DeletePrinterDriver = DeletePrinterDriverW;
        pub const DeletePrinterDriverEx = DeletePrinterDriverExW;
        pub const AddPrintProcessor = AddPrintProcessorW;
        pub const EnumPrintProcessors = EnumPrintProcessorsW;
        pub const GetPrintProcessorDirectory = GetPrintProcessorDirectoryW;
        pub const EnumPrintProcessorDatatypes = EnumPrintProcessorDatatypesW;
        pub const DeletePrintProcessor = DeletePrintProcessorW;
        pub const StartDocPrinter = StartDocPrinterW;
        pub const AddJob = AddJobW;
        pub const DocumentProperties = DocumentPropertiesW;
        pub const AdvancedDocumentProperties = AdvancedDocumentPropertiesW;
        pub const GetPrinterData = GetPrinterDataW;
        pub const GetPrinterDataEx = GetPrinterDataExW;
        pub const EnumPrinterData = EnumPrinterDataW;
        pub const EnumPrinterDataEx = EnumPrinterDataExW;
        pub const EnumPrinterKey = EnumPrinterKeyW;
        pub const SetPrinterData = SetPrinterDataW;
        pub const SetPrinterDataEx = SetPrinterDataExW;
        pub const DeletePrinterData = DeletePrinterDataW;
        pub const DeletePrinterDataEx = DeletePrinterDataExW;
        pub const DeletePrinterKey = DeletePrinterKeyW;
        pub const PrinterMessageBox = PrinterMessageBoxW;
        pub const AddForm = AddFormW;
        pub const DeleteForm = DeleteFormW;
        pub const GetForm = GetFormW;
        pub const SetForm = SetFormW;
        pub const EnumForms = EnumFormsW;
        pub const EnumMonitors = EnumMonitorsW;
        pub const AddMonitor = AddMonitorW;
        pub const DeleteMonitor = DeleteMonitorW;
        pub const EnumPorts = EnumPortsW;
        pub const AddPort = AddPortW;
        pub const ConfigurePort = ConfigurePortW;
        pub const DeletePort = DeletePortW;
        pub const GetDefaultPrinter = GetDefaultPrinterW;
        pub const SetDefaultPrinter = SetDefaultPrinterW;
        pub const SetPort = SetPortW;
        pub const AddPrinterConnection = AddPrinterConnectionW;
        pub const DeletePrinterConnection = DeletePrinterConnectionW;
        pub const AddPrintProvidor = AddPrintProvidorW;
        pub const DeletePrintProvidor = DeletePrintProvidorW;
        pub const IsValidDevmode = IsValidDevmodeW;
        pub const OpenPrinter2 = OpenPrinter2W;
        pub const AddPrinterConnection2 = AddPrinterConnection2W;
        pub const InstallPrinterDriverFromPackage = InstallPrinterDriverFromPackageW;
        pub const UploadPrinterDriverPackage = UploadPrinterDriverPackageW;
        pub const GetCorePrinterDrivers = GetCorePrinterDriversW;
        pub const CorePrinterDriverInstalled = CorePrinterDriverInstalledW;
        pub const GetPrinterDriverPackagePath = GetPrinterDriverPackagePathW;
        pub const DeletePrinterDriverPackage = DeletePrinterDriverPackageW;
        pub const GetPrinterDriver2 = GetPrinterDriver2W;
        pub const GetCommandLine = GetCommandLineW;
        pub const FreeEnvironmentStrings = FreeEnvironmentStringsW;
        pub const GetEnvironmentVariable = GetEnvironmentVariableW;
        pub const SetEnvironmentVariable = SetEnvironmentVariableW;
        pub const NeedCurrentDirectoryForExePath = NeedCurrentDirectoryForExePathW;
        pub const CreateProcess = CreateProcessW;
        pub const CreateProcessAsUser = CreateProcessAsUserW;
        pub const CreateMailslot = CreateMailslotW;
        pub const QueryFullProcessImageName = QueryFullProcessImageNameW;
        pub const SetDllDirectory = SetDllDirectoryW;
        pub const GetDllDirectory = GetDllDirectoryW;
        pub const ClearEventLog = ClearEventLogW;
        pub const BackupEventLog = BackupEventLogW;
        pub const OpenEventLog = OpenEventLogW;
        pub const RegisterEventSource = RegisterEventSourceW;
        pub const OpenBackupEventLog = OpenBackupEventLogW;
        pub const ReadEventLog = ReadEventLogW;
        pub const ReportEvent = ReportEventW;
        pub const IsBadStringPtr = IsBadStringPtrW;
        pub const BuildCommDCB = BuildCommDCBW;
        pub const BuildCommDCBAndTimeouts = BuildCommDCBAndTimeoutsW;
        pub const CommConfigDialog = CommConfigDialogW;
        pub const GetDefaultCommConfig = GetDefaultCommConfigW;
        pub const SetDefaultCommConfig = SetDefaultCommConfigW;
        pub const InitiateSystemShutdown = InitiateSystemShutdownW;
        pub const AbortSystemShutdown = AbortSystemShutdownW;
        pub const InitiateSystemShutdownEx = InitiateSystemShutdownExW;
        pub const InitiateShutdown = InitiateShutdownW;
    },
    else => if (@import("builtin").is_test) struct {
        pub const ENUMRESLANGPROC = *opaque{};
        pub const PGET_MODULE_HANDLE_EX = *opaque{};
        pub const PRINTER_INFO_1 = *opaque{};
        pub const PRINTER_INFO_2 = *opaque{};
        pub const PRINTER_INFO_4 = *opaque{};
        pub const PRINTER_INFO_5 = *opaque{};
        pub const PRINTER_INFO_7 = *opaque{};
        pub const PRINTER_INFO_8 = *opaque{};
        pub const PRINTER_INFO_9 = *opaque{};
        pub const JOB_INFO_1 = *opaque{};
        pub const JOB_INFO_2 = *opaque{};
        pub const JOB_INFO_4 = *opaque{};
        pub const ADDJOB_INFO_1 = *opaque{};
        pub const DRIVER_INFO_1 = *opaque{};
        pub const DRIVER_INFO_2 = *opaque{};
        pub const DRIVER_INFO_3 = *opaque{};
        pub const DRIVER_INFO_4 = *opaque{};
        pub const DRIVER_INFO_5 = *opaque{};
        pub const DRIVER_INFO_6 = *opaque{};
        pub const DRIVER_INFO_8 = *opaque{};
        pub const DOC_INFO_1 = *opaque{};
        pub const FORM_INFO_1 = *opaque{};
        pub const FORM_INFO_2 = *opaque{};
        pub const DOC_INFO_2 = *opaque{};
        pub const DOC_INFO_3 = *opaque{};
        pub const PRINTPROCESSOR_INFO_1 = *opaque{};
        pub const PORT_INFO_1 = *opaque{};
        pub const PORT_INFO_2 = *opaque{};
        pub const PORT_INFO_3 = *opaque{};
        pub const MONITOR_INFO_1 = *opaque{};
        pub const MONITOR_INFO_2 = *opaque{};
        pub const DATATYPES_INFO_1 = *opaque{};
        pub const PRINTER_DEFAULTS = *opaque{};
        pub const PRINTER_ENUM_VALUES = *opaque{};
        pub const PROVIDOR_INFO_1 = *opaque{};
        pub const PROVIDOR_INFO_2 = *opaque{};
        pub const PRINTER_OPTIONS = *opaque{};
        pub const PRINTER_CONNECTION_INFO_1 = *opaque{};
        pub const CORE_PRINTER_DRIVER = *opaque{};
        pub const DEV_BROADCAST_PORT_ = *opaque{};
        pub const DEV_BROADCAST_DEVICEINTERFACE_ = *opaque{};
        pub const STARTUPINFO = *opaque{};
        pub const STARTUPINFOEX = *opaque{};
        pub const RegisterDeviceNotification = *opaque{};
        pub const CreateMutex = *opaque{};
        pub const CreateEvent = *opaque{};
        pub const OpenEvent = *opaque{};
        pub const CreateMutexEx = *opaque{};
        pub const CreateEventEx = *opaque{};
        pub const CreateSemaphoreEx = *opaque{};
        pub const CreateSemaphore = *opaque{};
        pub const CreateJobObject = *opaque{};
        pub const OpenJobObject = *opaque{};
        pub const CreateBoundaryDescriptor = *opaque{};
        pub const GetNamedPipeClientComputerName = *opaque{};
        pub const GetNamedPipeHandleState = *opaque{};
        pub const CallNamedPipe = *opaque{};
        pub const CreateFileMapping = *opaque{};
        pub const OpenFileMapping = *opaque{};
        pub const CreateFileMappingNuma = *opaque{};
        pub const LoadEnclaveImage = *opaque{};
        pub const GetModuleFileName = *opaque{};
        pub const GetModuleHandle = *opaque{};
        pub const GetModuleHandleEx = *opaque{};
        pub const LoadLibraryEx = *opaque{};
        pub const LoadLibrary = *opaque{};
        pub const ReadConsoleInput = *opaque{};
        pub const PeekConsoleInput = *opaque{};
        pub const ReadConsole = *opaque{};
        pub const WriteConsole = *opaque{};
        pub const FillConsoleOutputCharacter = *opaque{};
        pub const WriteConsoleOutputCharacter = *opaque{};
        pub const ReadConsoleOutputCharacter = *opaque{};
        pub const WriteConsoleInput = *opaque{};
        pub const ScrollConsoleScreenBuffer = *opaque{};
        pub const WriteConsoleOutput = *opaque{};
        pub const ReadConsoleOutput = *opaque{};
        pub const GetConsoleTitle = *opaque{};
        pub const GetConsoleOriginalTitle = *opaque{};
        pub const SetConsoleTitle = *opaque{};
        pub const AddConsoleAlias = *opaque{};
        pub const GetConsoleAlias = *opaque{};
        pub const GetConsoleAliasesLength = *opaque{};
        pub const GetConsoleAliasExesLength = *opaque{};
        pub const GetConsoleAliases = *opaque{};
        pub const GetConsoleAliasExes = *opaque{};
        pub const ExpungeConsoleCommandHistory = *opaque{};
        pub const SetConsoleNumberOfCommands = *opaque{};
        pub const GetConsoleCommandHistoryLength = *opaque{};
        pub const GetConsoleCommandHistory = *opaque{};
        pub const EnumPrinters = *opaque{};
        pub const OpenPrinter = *opaque{};
        pub const ResetPrinter = *opaque{};
        pub const SetJob = *opaque{};
        pub const GetJob = *opaque{};
        pub const EnumJobs = *opaque{};
        pub const AddPrinter = *opaque{};
        pub const SetPrinter = *opaque{};
        pub const GetPrinter = *opaque{};
        pub const AddPrinterDriver = *opaque{};
        pub const AddPrinterDriverEx = *opaque{};
        pub const EnumPrinterDrivers = *opaque{};
        pub const GetPrinterDriver = *opaque{};
        pub const GetPrinterDriverDirectory = *opaque{};
        pub const DeletePrinterDriver = *opaque{};
        pub const DeletePrinterDriverEx = *opaque{};
        pub const AddPrintProcessor = *opaque{};
        pub const EnumPrintProcessors = *opaque{};
        pub const GetPrintProcessorDirectory = *opaque{};
        pub const EnumPrintProcessorDatatypes = *opaque{};
        pub const DeletePrintProcessor = *opaque{};
        pub const StartDocPrinter = *opaque{};
        pub const AddJob = *opaque{};
        pub const DocumentProperties = *opaque{};
        pub const AdvancedDocumentProperties = *opaque{};
        pub const GetPrinterData = *opaque{};
        pub const GetPrinterDataEx = *opaque{};
        pub const EnumPrinterData = *opaque{};
        pub const EnumPrinterDataEx = *opaque{};
        pub const EnumPrinterKey = *opaque{};
        pub const SetPrinterData = *opaque{};
        pub const SetPrinterDataEx = *opaque{};
        pub const DeletePrinterData = *opaque{};
        pub const DeletePrinterDataEx = *opaque{};
        pub const DeletePrinterKey = *opaque{};
        pub const PrinterMessageBox = *opaque{};
        pub const AddForm = *opaque{};
        pub const DeleteForm = *opaque{};
        pub const GetForm = *opaque{};
        pub const SetForm = *opaque{};
        pub const EnumForms = *opaque{};
        pub const EnumMonitors = *opaque{};
        pub const AddMonitor = *opaque{};
        pub const DeleteMonitor = *opaque{};
        pub const EnumPorts = *opaque{};
        pub const AddPort = *opaque{};
        pub const ConfigurePort = *opaque{};
        pub const DeletePort = *opaque{};
        pub const GetDefaultPrinter = *opaque{};
        pub const SetDefaultPrinter = *opaque{};
        pub const SetPort = *opaque{};
        pub const AddPrinterConnection = *opaque{};
        pub const DeletePrinterConnection = *opaque{};
        pub const AddPrintProvidor = *opaque{};
        pub const DeletePrintProvidor = *opaque{};
        pub const IsValidDevmode = *opaque{};
        pub const OpenPrinter2 = *opaque{};
        pub const AddPrinterConnection2 = *opaque{};
        pub const InstallPrinterDriverFromPackage = *opaque{};
        pub const UploadPrinterDriverPackage = *opaque{};
        pub const GetCorePrinterDrivers = *opaque{};
        pub const CorePrinterDriverInstalled = *opaque{};
        pub const GetPrinterDriverPackagePath = *opaque{};
        pub const DeletePrinterDriverPackage = *opaque{};
        pub const GetPrinterDriver2 = *opaque{};
        pub const GetCommandLine = *opaque{};
        pub const FreeEnvironmentStrings = *opaque{};
        pub const GetEnvironmentVariable = *opaque{};
        pub const SetEnvironmentVariable = *opaque{};
        pub const NeedCurrentDirectoryForExePath = *opaque{};
        pub const CreateProcess = *opaque{};
        pub const CreateProcessAsUser = *opaque{};
        pub const CreateMailslot = *opaque{};
        pub const QueryFullProcessImageName = *opaque{};
        pub const SetDllDirectory = *opaque{};
        pub const GetDllDirectory = *opaque{};
        pub const ClearEventLog = *opaque{};
        pub const BackupEventLog = *opaque{};
        pub const OpenEventLog = *opaque{};
        pub const RegisterEventSource = *opaque{};
        pub const OpenBackupEventLog = *opaque{};
        pub const ReadEventLog = *opaque{};
        pub const ReportEvent = *opaque{};
        pub const IsBadStringPtr = *opaque{};
        pub const BuildCommDCB = *opaque{};
        pub const BuildCommDCBAndTimeouts = *opaque{};
        pub const CommConfigDialog = *opaque{};
        pub const GetDefaultCommConfig = *opaque{};
        pub const SetDefaultCommConfig = *opaque{};
        pub const InitiateSystemShutdown = *opaque{};
        pub const AbortSystemShutdown = *opaque{};
        pub const InitiateSystemShutdownEx = *opaque{};
        pub const InitiateShutdown = *opaque{};
    } else struct {
        pub const ENUMRESLANGPROC = @compileError("'ENUMRESLANGPROC' requires that UNICODE be set to true or false in the root module");
        pub const PGET_MODULE_HANDLE_EX = @compileError("'PGET_MODULE_HANDLE_EX' requires that UNICODE be set to true or false in the root module");
        pub const PRINTER_INFO_1 = @compileError("'PRINTER_INFO_1' requires that UNICODE be set to true or false in the root module");
        pub const PRINTER_INFO_2 = @compileError("'PRINTER_INFO_2' requires that UNICODE be set to true or false in the root module");
        pub const PRINTER_INFO_4 = @compileError("'PRINTER_INFO_4' requires that UNICODE be set to true or false in the root module");
        pub const PRINTER_INFO_5 = @compileError("'PRINTER_INFO_5' requires that UNICODE be set to true or false in the root module");
        pub const PRINTER_INFO_7 = @compileError("'PRINTER_INFO_7' requires that UNICODE be set to true or false in the root module");
        pub const PRINTER_INFO_8 = @compileError("'PRINTER_INFO_8' requires that UNICODE be set to true or false in the root module");
        pub const PRINTER_INFO_9 = @compileError("'PRINTER_INFO_9' requires that UNICODE be set to true or false in the root module");
        pub const JOB_INFO_1 = @compileError("'JOB_INFO_1' requires that UNICODE be set to true or false in the root module");
        pub const JOB_INFO_2 = @compileError("'JOB_INFO_2' requires that UNICODE be set to true or false in the root module");
        pub const JOB_INFO_4 = @compileError("'JOB_INFO_4' requires that UNICODE be set to true or false in the root module");
        pub const ADDJOB_INFO_1 = @compileError("'ADDJOB_INFO_1' requires that UNICODE be set to true or false in the root module");
        pub const DRIVER_INFO_1 = @compileError("'DRIVER_INFO_1' requires that UNICODE be set to true or false in the root module");
        pub const DRIVER_INFO_2 = @compileError("'DRIVER_INFO_2' requires that UNICODE be set to true or false in the root module");
        pub const DRIVER_INFO_3 = @compileError("'DRIVER_INFO_3' requires that UNICODE be set to true or false in the root module");
        pub const DRIVER_INFO_4 = @compileError("'DRIVER_INFO_4' requires that UNICODE be set to true or false in the root module");
        pub const DRIVER_INFO_5 = @compileError("'DRIVER_INFO_5' requires that UNICODE be set to true or false in the root module");
        pub const DRIVER_INFO_6 = @compileError("'DRIVER_INFO_6' requires that UNICODE be set to true or false in the root module");
        pub const DRIVER_INFO_8 = @compileError("'DRIVER_INFO_8' requires that UNICODE be set to true or false in the root module");
        pub const DOC_INFO_1 = @compileError("'DOC_INFO_1' requires that UNICODE be set to true or false in the root module");
        pub const FORM_INFO_1 = @compileError("'FORM_INFO_1' requires that UNICODE be set to true or false in the root module");
        pub const FORM_INFO_2 = @compileError("'FORM_INFO_2' requires that UNICODE be set to true or false in the root module");
        pub const DOC_INFO_2 = @compileError("'DOC_INFO_2' requires that UNICODE be set to true or false in the root module");
        pub const DOC_INFO_3 = @compileError("'DOC_INFO_3' requires that UNICODE be set to true or false in the root module");
        pub const PRINTPROCESSOR_INFO_1 = @compileError("'PRINTPROCESSOR_INFO_1' requires that UNICODE be set to true or false in the root module");
        pub const PORT_INFO_1 = @compileError("'PORT_INFO_1' requires that UNICODE be set to true or false in the root module");
        pub const PORT_INFO_2 = @compileError("'PORT_INFO_2' requires that UNICODE be set to true or false in the root module");
        pub const PORT_INFO_3 = @compileError("'PORT_INFO_3' requires that UNICODE be set to true or false in the root module");
        pub const MONITOR_INFO_1 = @compileError("'MONITOR_INFO_1' requires that UNICODE be set to true or false in the root module");
        pub const MONITOR_INFO_2 = @compileError("'MONITOR_INFO_2' requires that UNICODE be set to true or false in the root module");
        pub const DATATYPES_INFO_1 = @compileError("'DATATYPES_INFO_1' requires that UNICODE be set to true or false in the root module");
        pub const PRINTER_DEFAULTS = @compileError("'PRINTER_DEFAULTS' requires that UNICODE be set to true or false in the root module");
        pub const PRINTER_ENUM_VALUES = @compileError("'PRINTER_ENUM_VALUES' requires that UNICODE be set to true or false in the root module");
        pub const PROVIDOR_INFO_1 = @compileError("'PROVIDOR_INFO_1' requires that UNICODE be set to true or false in the root module");
        pub const PROVIDOR_INFO_2 = @compileError("'PROVIDOR_INFO_2' requires that UNICODE be set to true or false in the root module");
        pub const PRINTER_OPTIONS = @compileError("'PRINTER_OPTIONS' requires that UNICODE be set to true or false in the root module");
        pub const PRINTER_CONNECTION_INFO_1 = @compileError("'PRINTER_CONNECTION_INFO_1' requires that UNICODE be set to true or false in the root module");
        pub const CORE_PRINTER_DRIVER = @compileError("'CORE_PRINTER_DRIVER' requires that UNICODE be set to true or false in the root module");
        pub const DEV_BROADCAST_PORT_ = @compileError("'DEV_BROADCAST_PORT_' requires that UNICODE be set to true or false in the root module");
        pub const DEV_BROADCAST_DEVICEINTERFACE_ = @compileError("'DEV_BROADCAST_DEVICEINTERFACE_' requires that UNICODE be set to true or false in the root module");
        pub const STARTUPINFO = @compileError("'STARTUPINFO' requires that UNICODE be set to true or false in the root module");
        pub const STARTUPINFOEX = @compileError("'STARTUPINFOEX' requires that UNICODE be set to true or false in the root module");
        pub const RegisterDeviceNotification = @compileError("'RegisterDeviceNotification' requires that UNICODE be set to true or false in the root module");
        pub const CreateMutex = @compileError("'CreateMutex' requires that UNICODE be set to true or false in the root module");
        pub const CreateEvent = @compileError("'CreateEvent' requires that UNICODE be set to true or false in the root module");
        pub const OpenEvent = @compileError("'OpenEvent' requires that UNICODE be set to true or false in the root module");
        pub const CreateMutexEx = @compileError("'CreateMutexEx' requires that UNICODE be set to true or false in the root module");
        pub const CreateEventEx = @compileError("'CreateEventEx' requires that UNICODE be set to true or false in the root module");
        pub const CreateSemaphoreEx = @compileError("'CreateSemaphoreEx' requires that UNICODE be set to true or false in the root module");
        pub const CreateSemaphore = @compileError("'CreateSemaphore' requires that UNICODE be set to true or false in the root module");
        pub const CreateJobObject = @compileError("'CreateJobObject' requires that UNICODE be set to true or false in the root module");
        pub const OpenJobObject = @compileError("'OpenJobObject' requires that UNICODE be set to true or false in the root module");
        pub const CreateBoundaryDescriptor = @compileError("'CreateBoundaryDescriptor' requires that UNICODE be set to true or false in the root module");
        pub const GetNamedPipeClientComputerName = @compileError("'GetNamedPipeClientComputerName' requires that UNICODE be set to true or false in the root module");
        pub const GetNamedPipeHandleState = @compileError("'GetNamedPipeHandleState' requires that UNICODE be set to true or false in the root module");
        pub const CallNamedPipe = @compileError("'CallNamedPipe' requires that UNICODE be set to true or false in the root module");
        pub const CreateFileMapping = @compileError("'CreateFileMapping' requires that UNICODE be set to true or false in the root module");
        pub const OpenFileMapping = @compileError("'OpenFileMapping' requires that UNICODE be set to true or false in the root module");
        pub const CreateFileMappingNuma = @compileError("'CreateFileMappingNuma' requires that UNICODE be set to true or false in the root module");
        pub const LoadEnclaveImage = @compileError("'LoadEnclaveImage' requires that UNICODE be set to true or false in the root module");
        pub const GetModuleFileName = @compileError("'GetModuleFileName' requires that UNICODE be set to true or false in the root module");
        pub const GetModuleHandle = @compileError("'GetModuleHandle' requires that UNICODE be set to true or false in the root module");
        pub const GetModuleHandleEx = @compileError("'GetModuleHandleEx' requires that UNICODE be set to true or false in the root module");
        pub const LoadLibraryEx = @compileError("'LoadLibraryEx' requires that UNICODE be set to true or false in the root module");
        pub const LoadLibrary = @compileError("'LoadLibrary' requires that UNICODE be set to true or false in the root module");
        pub const ReadConsoleInput = @compileError("'ReadConsoleInput' requires that UNICODE be set to true or false in the root module");
        pub const PeekConsoleInput = @compileError("'PeekConsoleInput' requires that UNICODE be set to true or false in the root module");
        pub const ReadConsole = @compileError("'ReadConsole' requires that UNICODE be set to true or false in the root module");
        pub const WriteConsole = @compileError("'WriteConsole' requires that UNICODE be set to true or false in the root module");
        pub const FillConsoleOutputCharacter = @compileError("'FillConsoleOutputCharacter' requires that UNICODE be set to true or false in the root module");
        pub const WriteConsoleOutputCharacter = @compileError("'WriteConsoleOutputCharacter' requires that UNICODE be set to true or false in the root module");
        pub const ReadConsoleOutputCharacter = @compileError("'ReadConsoleOutputCharacter' requires that UNICODE be set to true or false in the root module");
        pub const WriteConsoleInput = @compileError("'WriteConsoleInput' requires that UNICODE be set to true or false in the root module");
        pub const ScrollConsoleScreenBuffer = @compileError("'ScrollConsoleScreenBuffer' requires that UNICODE be set to true or false in the root module");
        pub const WriteConsoleOutput = @compileError("'WriteConsoleOutput' requires that UNICODE be set to true or false in the root module");
        pub const ReadConsoleOutput = @compileError("'ReadConsoleOutput' requires that UNICODE be set to true or false in the root module");
        pub const GetConsoleTitle = @compileError("'GetConsoleTitle' requires that UNICODE be set to true or false in the root module");
        pub const GetConsoleOriginalTitle = @compileError("'GetConsoleOriginalTitle' requires that UNICODE be set to true or false in the root module");
        pub const SetConsoleTitle = @compileError("'SetConsoleTitle' requires that UNICODE be set to true or false in the root module");
        pub const AddConsoleAlias = @compileError("'AddConsoleAlias' requires that UNICODE be set to true or false in the root module");
        pub const GetConsoleAlias = @compileError("'GetConsoleAlias' requires that UNICODE be set to true or false in the root module");
        pub const GetConsoleAliasesLength = @compileError("'GetConsoleAliasesLength' requires that UNICODE be set to true or false in the root module");
        pub const GetConsoleAliasExesLength = @compileError("'GetConsoleAliasExesLength' requires that UNICODE be set to true or false in the root module");
        pub const GetConsoleAliases = @compileError("'GetConsoleAliases' requires that UNICODE be set to true or false in the root module");
        pub const GetConsoleAliasExes = @compileError("'GetConsoleAliasExes' requires that UNICODE be set to true or false in the root module");
        pub const ExpungeConsoleCommandHistory = @compileError("'ExpungeConsoleCommandHistory' requires that UNICODE be set to true or false in the root module");
        pub const SetConsoleNumberOfCommands = @compileError("'SetConsoleNumberOfCommands' requires that UNICODE be set to true or false in the root module");
        pub const GetConsoleCommandHistoryLength = @compileError("'GetConsoleCommandHistoryLength' requires that UNICODE be set to true or false in the root module");
        pub const GetConsoleCommandHistory = @compileError("'GetConsoleCommandHistory' requires that UNICODE be set to true or false in the root module");
        pub const EnumPrinters = @compileError("'EnumPrinters' requires that UNICODE be set to true or false in the root module");
        pub const OpenPrinter = @compileError("'OpenPrinter' requires that UNICODE be set to true or false in the root module");
        pub const ResetPrinter = @compileError("'ResetPrinter' requires that UNICODE be set to true or false in the root module");
        pub const SetJob = @compileError("'SetJob' requires that UNICODE be set to true or false in the root module");
        pub const GetJob = @compileError("'GetJob' requires that UNICODE be set to true or false in the root module");
        pub const EnumJobs = @compileError("'EnumJobs' requires that UNICODE be set to true or false in the root module");
        pub const AddPrinter = @compileError("'AddPrinter' requires that UNICODE be set to true or false in the root module");
        pub const SetPrinter = @compileError("'SetPrinter' requires that UNICODE be set to true or false in the root module");
        pub const GetPrinter = @compileError("'GetPrinter' requires that UNICODE be set to true or false in the root module");
        pub const AddPrinterDriver = @compileError("'AddPrinterDriver' requires that UNICODE be set to true or false in the root module");
        pub const AddPrinterDriverEx = @compileError("'AddPrinterDriverEx' requires that UNICODE be set to true or false in the root module");
        pub const EnumPrinterDrivers = @compileError("'EnumPrinterDrivers' requires that UNICODE be set to true or false in the root module");
        pub const GetPrinterDriver = @compileError("'GetPrinterDriver' requires that UNICODE be set to true or false in the root module");
        pub const GetPrinterDriverDirectory = @compileError("'GetPrinterDriverDirectory' requires that UNICODE be set to true or false in the root module");
        pub const DeletePrinterDriver = @compileError("'DeletePrinterDriver' requires that UNICODE be set to true or false in the root module");
        pub const DeletePrinterDriverEx = @compileError("'DeletePrinterDriverEx' requires that UNICODE be set to true or false in the root module");
        pub const AddPrintProcessor = @compileError("'AddPrintProcessor' requires that UNICODE be set to true or false in the root module");
        pub const EnumPrintProcessors = @compileError("'EnumPrintProcessors' requires that UNICODE be set to true or false in the root module");
        pub const GetPrintProcessorDirectory = @compileError("'GetPrintProcessorDirectory' requires that UNICODE be set to true or false in the root module");
        pub const EnumPrintProcessorDatatypes = @compileError("'EnumPrintProcessorDatatypes' requires that UNICODE be set to true or false in the root module");
        pub const DeletePrintProcessor = @compileError("'DeletePrintProcessor' requires that UNICODE be set to true or false in the root module");
        pub const StartDocPrinter = @compileError("'StartDocPrinter' requires that UNICODE be set to true or false in the root module");
        pub const AddJob = @compileError("'AddJob' requires that UNICODE be set to true or false in the root module");
        pub const DocumentProperties = @compileError("'DocumentProperties' requires that UNICODE be set to true or false in the root module");
        pub const AdvancedDocumentProperties = @compileError("'AdvancedDocumentProperties' requires that UNICODE be set to true or false in the root module");
        pub const GetPrinterData = @compileError("'GetPrinterData' requires that UNICODE be set to true or false in the root module");
        pub const GetPrinterDataEx = @compileError("'GetPrinterDataEx' requires that UNICODE be set to true or false in the root module");
        pub const EnumPrinterData = @compileError("'EnumPrinterData' requires that UNICODE be set to true or false in the root module");
        pub const EnumPrinterDataEx = @compileError("'EnumPrinterDataEx' requires that UNICODE be set to true or false in the root module");
        pub const EnumPrinterKey = @compileError("'EnumPrinterKey' requires that UNICODE be set to true or false in the root module");
        pub const SetPrinterData = @compileError("'SetPrinterData' requires that UNICODE be set to true or false in the root module");
        pub const SetPrinterDataEx = @compileError("'SetPrinterDataEx' requires that UNICODE be set to true or false in the root module");
        pub const DeletePrinterData = @compileError("'DeletePrinterData' requires that UNICODE be set to true or false in the root module");
        pub const DeletePrinterDataEx = @compileError("'DeletePrinterDataEx' requires that UNICODE be set to true or false in the root module");
        pub const DeletePrinterKey = @compileError("'DeletePrinterKey' requires that UNICODE be set to true or false in the root module");
        pub const PrinterMessageBox = @compileError("'PrinterMessageBox' requires that UNICODE be set to true or false in the root module");
        pub const AddForm = @compileError("'AddForm' requires that UNICODE be set to true or false in the root module");
        pub const DeleteForm = @compileError("'DeleteForm' requires that UNICODE be set to true or false in the root module");
        pub const GetForm = @compileError("'GetForm' requires that UNICODE be set to true or false in the root module");
        pub const SetForm = @compileError("'SetForm' requires that UNICODE be set to true or false in the root module");
        pub const EnumForms = @compileError("'EnumForms' requires that UNICODE be set to true or false in the root module");
        pub const EnumMonitors = @compileError("'EnumMonitors' requires that UNICODE be set to true or false in the root module");
        pub const AddMonitor = @compileError("'AddMonitor' requires that UNICODE be set to true or false in the root module");
        pub const DeleteMonitor = @compileError("'DeleteMonitor' requires that UNICODE be set to true or false in the root module");
        pub const EnumPorts = @compileError("'EnumPorts' requires that UNICODE be set to true or false in the root module");
        pub const AddPort = @compileError("'AddPort' requires that UNICODE be set to true or false in the root module");
        pub const ConfigurePort = @compileError("'ConfigurePort' requires that UNICODE be set to true or false in the root module");
        pub const DeletePort = @compileError("'DeletePort' requires that UNICODE be set to true or false in the root module");
        pub const GetDefaultPrinter = @compileError("'GetDefaultPrinter' requires that UNICODE be set to true or false in the root module");
        pub const SetDefaultPrinter = @compileError("'SetDefaultPrinter' requires that UNICODE be set to true or false in the root module");
        pub const SetPort = @compileError("'SetPort' requires that UNICODE be set to true or false in the root module");
        pub const AddPrinterConnection = @compileError("'AddPrinterConnection' requires that UNICODE be set to true or false in the root module");
        pub const DeletePrinterConnection = @compileError("'DeletePrinterConnection' requires that UNICODE be set to true or false in the root module");
        pub const AddPrintProvidor = @compileError("'AddPrintProvidor' requires that UNICODE be set to true or false in the root module");
        pub const DeletePrintProvidor = @compileError("'DeletePrintProvidor' requires that UNICODE be set to true or false in the root module");
        pub const IsValidDevmode = @compileError("'IsValidDevmode' requires that UNICODE be set to true or false in the root module");
        pub const OpenPrinter2 = @compileError("'OpenPrinter2' requires that UNICODE be set to true or false in the root module");
        pub const AddPrinterConnection2 = @compileError("'AddPrinterConnection2' requires that UNICODE be set to true or false in the root module");
        pub const InstallPrinterDriverFromPackage = @compileError("'InstallPrinterDriverFromPackage' requires that UNICODE be set to true or false in the root module");
        pub const UploadPrinterDriverPackage = @compileError("'UploadPrinterDriverPackage' requires that UNICODE be set to true or false in the root module");
        pub const GetCorePrinterDrivers = @compileError("'GetCorePrinterDrivers' requires that UNICODE be set to true or false in the root module");
        pub const CorePrinterDriverInstalled = @compileError("'CorePrinterDriverInstalled' requires that UNICODE be set to true or false in the root module");
        pub const GetPrinterDriverPackagePath = @compileError("'GetPrinterDriverPackagePath' requires that UNICODE be set to true or false in the root module");
        pub const DeletePrinterDriverPackage = @compileError("'DeletePrinterDriverPackage' requires that UNICODE be set to true or false in the root module");
        pub const GetPrinterDriver2 = @compileError("'GetPrinterDriver2' requires that UNICODE be set to true or false in the root module");
        pub const GetCommandLine = @compileError("'GetCommandLine' requires that UNICODE be set to true or false in the root module");
        pub const FreeEnvironmentStrings = @compileError("'FreeEnvironmentStrings' requires that UNICODE be set to true or false in the root module");
        pub const GetEnvironmentVariable = @compileError("'GetEnvironmentVariable' requires that UNICODE be set to true or false in the root module");
        pub const SetEnvironmentVariable = @compileError("'SetEnvironmentVariable' requires that UNICODE be set to true or false in the root module");
        pub const NeedCurrentDirectoryForExePath = @compileError("'NeedCurrentDirectoryForExePath' requires that UNICODE be set to true or false in the root module");
        pub const CreateProcess = @compileError("'CreateProcess' requires that UNICODE be set to true or false in the root module");
        pub const CreateProcessAsUser = @compileError("'CreateProcessAsUser' requires that UNICODE be set to true or false in the root module");
        pub const CreateMailslot = @compileError("'CreateMailslot' requires that UNICODE be set to true or false in the root module");
        pub const QueryFullProcessImageName = @compileError("'QueryFullProcessImageName' requires that UNICODE be set to true or false in the root module");
        pub const SetDllDirectory = @compileError("'SetDllDirectory' requires that UNICODE be set to true or false in the root module");
        pub const GetDllDirectory = @compileError("'GetDllDirectory' requires that UNICODE be set to true or false in the root module");
        pub const ClearEventLog = @compileError("'ClearEventLog' requires that UNICODE be set to true or false in the root module");
        pub const BackupEventLog = @compileError("'BackupEventLog' requires that UNICODE be set to true or false in the root module");
        pub const OpenEventLog = @compileError("'OpenEventLog' requires that UNICODE be set to true or false in the root module");
        pub const RegisterEventSource = @compileError("'RegisterEventSource' requires that UNICODE be set to true or false in the root module");
        pub const OpenBackupEventLog = @compileError("'OpenBackupEventLog' requires that UNICODE be set to true or false in the root module");
        pub const ReadEventLog = @compileError("'ReadEventLog' requires that UNICODE be set to true or false in the root module");
        pub const ReportEvent = @compileError("'ReportEvent' requires that UNICODE be set to true or false in the root module");
        pub const IsBadStringPtr = @compileError("'IsBadStringPtr' requires that UNICODE be set to true or false in the root module");
        pub const BuildCommDCB = @compileError("'BuildCommDCB' requires that UNICODE be set to true or false in the root module");
        pub const BuildCommDCBAndTimeouts = @compileError("'BuildCommDCBAndTimeouts' requires that UNICODE be set to true or false in the root module");
        pub const CommConfigDialog = @compileError("'CommConfigDialog' requires that UNICODE be set to true or false in the root module");
        pub const GetDefaultCommConfig = @compileError("'GetDefaultCommConfig' requires that UNICODE be set to true or false in the root module");
        pub const SetDefaultCommConfig = @compileError("'SetDefaultCommConfig' requires that UNICODE be set to true or false in the root module");
        pub const InitiateSystemShutdown = @compileError("'InitiateSystemShutdown' requires that UNICODE be set to true or false in the root module");
        pub const AbortSystemShutdown = @compileError("'AbortSystemShutdown' requires that UNICODE be set to true or false in the root module");
        pub const InitiateSystemShutdownEx = @compileError("'InitiateSystemShutdownEx' requires that UNICODE be set to true or false in the root module");
        pub const InitiateShutdown = @compileError("'InitiateShutdown' requires that UNICODE be set to true or false in the root module");
    },
};

//
// type imports
//
const Guid = @import("../zig.zig").Guid;
const WOW64_LDT_ENTRY = @import("debug.zig").WOW64_LDT_ENTRY;
const ACE_HEADER = @import("security.zig").ACE_HEADER;
const GENERIC_MAPPING = @import("security.zig").GENERIC_MAPPING;
const OBJECT_TYPE_LIST = @import("security.zig").OBJECT_TYPE_LIST;
const PRIVILEGE_SET = @import("security.zig").PRIVILEGE_SET;
const SECURITY_IMPERSONATION_LEVEL = @import("security.zig").SECURITY_IMPERSONATION_LEVEL;
const EXCEPTION_ROUTINE = @import("kernel.zig").EXCEPTION_ROUTINE;
const TOKEN_GROUPS = @import("security.zig").TOKEN_GROUPS;
const TOKEN_PRIVILEGES = @import("security.zig").TOKEN_PRIVILEGES;
const IMAGE_DATA_DIRECTORY = @import("debug.zig").IMAGE_DATA_DIRECTORY;
const IMAGE_FILE_HEADER = @import("debug.zig").IMAGE_FILE_HEADER;
const SINGLE_LIST_ENTRY = @import("kernel.zig").SINGLE_LIST_ENTRY;
const LIST_ENTRY = @import("kernel.zig").LIST_ENTRY;
const RPC_BINDING_VECTOR = @import("rpc.zig").RPC_BINDING_VECTOR;
const STORAGE_PROPERTY_ID = @import("filesystem.zig").STORAGE_PROPERTY_ID;
const STORAGE_PROTOCOL_TYPE = @import("filesystem.zig").STORAGE_PROTOCOL_TYPE;
const PARTITION_STYLE = @import("filesystem.zig").PARTITION_STYLE;
const VIRTUAL_STORAGE_TYPE = @import("virtualstorage.zig").VIRTUAL_STORAGE_TYPE;
const FILE_ID_128 = @import("filesystem.zig").FILE_ID_128;
const DEVMODEA = @import("xps.zig").DEVMODEA;
const DEVMODEW = @import("displaydevices.zig").DEVMODEW;
const SYSTEMTIME = @import("windowsprogramming.zig").SYSTEMTIME;
const FILETIME = @import("windowsprogramming.zig").FILETIME;
const SIZE = @import("displaydevices.zig").SIZE;
const RECTL = @import("displaydevices.zig").RECTL;
const IUnknown = @import("com.zig").IUnknown;
const DDVIDEOPORTCONNECT = @import("coreaudio.zig").DDVIDEOPORTCONNECT;
const DDSCAPS = @import("directdraw.zig").DDSCAPS;
const VIDEOMEMORYINFO = @import("displaydevices.zig").VIDEOMEMORYINFO;
const PDD_GETDRIVERINFO = @import("displaydevices.zig").PDD_GETDRIVERINFO;
const DD_DIRECTDRAW_GLOBAL = @import("displaydevices.zig").DD_DIRECTDRAW_GLOBAL;
const DD_SURFACE_LOCAL = @import("displaydevices.zig").DD_SURFACE_LOCAL;
const HRESULT = @import("com.zig").HRESULT;
const DDCOLORKEY = @import("directshow.zig").DDCOLORKEY;
const DD_DIRECTDRAW_LOCAL = @import("displaydevices.zig").DD_DIRECTDRAW_LOCAL;
const DXGI_RGBA = @import("dxgi.zig").DXGI_RGBA;
const DDSURFACEDESC = @import("directdraw.zig").DDSURFACEDESC;
const D3DMATRIX = @import("direct3d9.zig").D3DMATRIX;
const POINT = @import("displaydevices.zig").POINT;
const RECT = @import("displaydevices.zig").RECT;
const HDC = @import("gdi.zig").HDC;
const SURFOBJ = @import("displaydevices.zig").SURFOBJ;
const LUID = @import("kernel.zig").LUID;
const PUMS_SCHEDULER_ENTRY_POINT = @import("windowsprogramming.zig").PUMS_SCHEDULER_ENTRY_POINT;
const UNICODE_STRING = @import("security.zig").UNICODE_STRING;
const PPS_POST_PROCESS_INIT_ROUTINE = @import("windowsprogramming.zig").PPS_POST_PROCESS_INIT_ROUTINE;
const HWND = @import("windowsandmessaging.zig").HWND;
const OSVERSIONINFOEXW = @import("windowsprogramming.zig").OSVERSIONINFOEXW;
const HeapHandle = @import("windowsprogramming.zig").HeapHandle;
const ENUMRESNAMEPROCW = @import("menusandresources.zig").ENUMRESNAMEPROCW;
const RPC_MESSAGE = @import("rpc.zig").RPC_MESSAGE;
const HKEY = @import("windowsprogramming.zig").HKEY;
const LPARAM = @import("windowsandmessaging.zig").LPARAM;
const PROCESS_CREATION_FLAGS = @import("windowsprogramming.zig").PROCESS_CREATION_FLAGS;
const THREAD_INFORMATION_CLASS = @import("windowsprogramming.zig").THREAD_INFORMATION_CLASS;
const PROCESS_INFORMATION_CLASS = @import("security.zig").PROCESS_INFORMATION_CLASS;
const LPFIBER_START_ROUTINE = @import("windowsprogramming.zig").LPFIBER_START_ROUTINE;
const DEP_SYSTEM_POLICY_TYPE = @import("windowsprogramming.zig").DEP_SYSTEM_POLICY_TYPE;
const EventLogHandle = @import("windowsprogramming.zig").EventLogHandle;
const EventSourceHandle = @import("windowsprogramming.zig").EventSourceHandle;
const LPOVERLAPPED_COMPLETION_ROUTINE = @import("filesystem.zig").LPOVERLAPPED_COMPLETION_ROUTINE;
const PROCESSINFOCLASS = @import("windowsprogramming.zig").PROCESSINFOCLASS;
const THREADINFOCLASS = @import("windowsprogramming.zig").THREADINFOCLASS;

test "" {
    const constant_export_count = 9883;
    const type_export_count = 1603;
    const func_count = 918;
    const unicode_alias_count = 183;
    const type_import_count = 64;
    @setEvalBranchQuota(0
        + constant_export_count
        + type_export_count
        + func_count
        + unicode_alias_count
        + type_import_count
        + 2 // TODO: why do I need these extra 2?
    );
    @import("std").testing.refAllDecls(@This());
}
