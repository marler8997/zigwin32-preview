//! NOTE: this source file is autogenerated, DO NOT MODIFY

//
// constants
//

//
// types
//
// --------------------------------------------------------
// Type: WNDPROC
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const WNDPROC = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: WNDENUMPROC
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const WNDENUMPROC = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PROPENUMPROC
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PROPENUMPROC = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PROPENUMPROCEX
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PROPENUMPROCEX = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: EDITWORDBREAKPROC
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const EDITWORDBREAKPROC = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: NAMEENUMPROCA
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const NAMEENUMPROCA = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: NAMEENUMPROCW
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const NAMEENUMPROCW = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: WINSTAENUMPROCA
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const WINSTAENUMPROCA = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: DESKTOPENUMPROCA
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const DESKTOPENUMPROCA = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: WINSTAENUMPROCW
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const WINSTAENUMPROCW = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: DESKTOPENUMPROCW
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const DESKTOPENUMPROCW = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: WINSTAENUMPROC
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const WINSTAENUMPROC = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: DESKTOPENUMPROC
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const DESKTOPENUMPROC = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: SHELLHOOKINFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SHELLHOOKINFO = extern struct {
    hwnd: HWND,
    rc: RECT,
};
// --------------------------------------------------------
// Type: HARDWAREHOOKSTRUCT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HARDWAREHOOKSTRUCT = extern struct {
    hwnd: HWND,
    message: u32,
    wParam: WPARAM,
    lParam: LPARAM,
};
// --------------------------------------------------------
// Type: MDINEXTMENU
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const MDINEXTMENU = extern struct {
    hmenuIn: HMENU,
    hmenuNext: HMENU,
    hwndNext: HWND,
};
// --------------------------------------------------------
// Type: ACCEL
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const ACCEL = extern struct {
    fVirt: u8,
    key: u16,
    cmd: u16,
};
// --------------------------------------------------------
// Type: PREGISTERCLASSNAMEW
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PREGISTERCLASSNAMEW = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: HTOUCHINPUT__
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HTOUCHINPUT__ = extern struct {
    unused: i32,
};
// --------------------------------------------------------
// Type: POINTER_INPUT_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const POINTER_INPUT_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: HSYNTHETICPOINTERDEVICE__
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HSYNTHETICPOINTERDEVICE__ = extern struct {
    unused: i32,
};
// --------------------------------------------------------
// Type: TPMPARAMS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TPMPARAMS = extern struct {
    cbSize: u32,
    rcExclude: RECT,
};
// --------------------------------------------------------
// Type: MENUINFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const MENUINFO = extern struct {
    cbSize: u32,
    fMask: u32,
    dwStyle: u32,
    cyMax: u32,
    hbrBack: HBRUSH,
    dwContextHelpID: u32,
    dwMenuData: ?*opaque{},
};
// --------------------------------------------------------
// Type: MENUGETOBJECTINFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const MENUGETOBJECTINFO = extern struct {
    dwFlags: u32,
    uPos: u32,
    hmenu: HMENU,
    riid: ?*opaque{},
    pvObj: ?*opaque{},
};
// --------------------------------------------------------
// Type: MENUITEMINFOA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const MENUITEMINFOA = extern struct {
    cbSize: u32,
    fMask: u32,
    fType: u32,
    fState: u32,
    wID: u32,
    hSubMenu: HMENU,
    hbmpChecked: HBITMAP,
    hbmpUnchecked: HBITMAP,
    dwItemData: ?*opaque{},
    dwTypeData: ?*i8,
    cch: u32,
    hbmpItem: HBITMAP,
};
// --------------------------------------------------------
// Type: MENUITEMINFOW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const MENUITEMINFOW = extern struct {
    cbSize: u32,
    fMask: u32,
    fType: u32,
    fState: u32,
    wID: u32,
    hSubMenu: HMENU,
    hbmpChecked: HBITMAP,
    hbmpUnchecked: HBITMAP,
    dwItemData: ?*opaque{},
    dwTypeData: ?*u16,
    cch: u32,
    hbmpItem: HBITMAP,
};
// --------------------------------------------------------
// Type: DROPSTRUCT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DROPSTRUCT = extern struct {
    hwndSource: HWND,
    hwndSink: HWND,
    wFmt: u32,
    dwData: ?*opaque{},
    ptDrop: POINT,
    dwControlData: u32,
};
// --------------------------------------------------------
// Type: MSGBOXCALLBACK
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const MSGBOXCALLBACK = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: MENUITEMTEMPLATEHEADER
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const MENUITEMTEMPLATEHEADER = extern struct {
    versionNumber: u16,
    offset: u16,
};
// --------------------------------------------------------
// Type: MENUITEMTEMPLATE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const MENUITEMTEMPLATE = extern struct {
    mtOption: u16,
    mtID: u16,
    mtString: ?[*]u16,
};
// --------------------------------------------------------
// Type: ICONINFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const ICONINFO = extern struct {
    fIcon: BOOL,
    xHotspot: u32,
    yHotspot: u32,
    hbmMask: HBITMAP,
    hbmColor: HBITMAP,
};
// --------------------------------------------------------
// Type: CURSORSHAPE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CURSORSHAPE = extern struct {
    xHotSpot: i32,
    yHotSpot: i32,
    cx: i32,
    cy: i32,
    cbWidth: i32,
    Planes: u8,
    BitsPixel: u8,
};
// --------------------------------------------------------
// Type: ICONINFOEXA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const ICONINFOEXA = extern struct {
    cbSize: u32,
    fIcon: BOOL,
    xHotspot: u32,
    yHotspot: u32,
    hbmMask: HBITMAP,
    hbmColor: HBITMAP,
    wResID: u16,
    szModName: ?[*]i8,
    szResName: ?[*]i8,
};
// --------------------------------------------------------
// Type: ICONINFOEXW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const ICONINFOEXW = extern struct {
    cbSize: u32,
    fIcon: BOOL,
    xHotspot: u32,
    yHotspot: u32,
    hbmMask: HBITMAP,
    hbmColor: HBITMAP,
    wResID: u16,
    szModName: ?[*]u16,
    szResName: ?[*]u16,
};
// --------------------------------------------------------
// Type: EDIT_CONTROL_FEATURE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const EDIT_CONTROL_FEATURE = *opaque{
};
// --------------------------------------------------------
// Type: TouchPredictionParameters
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TouchPredictionParameters = extern struct {
    cbSize: u32,
    dwLatency: u32,
    dwSampleTime: u32,
    bUseHWTimeStamp: u32,
};
// --------------------------------------------------------
// Type: HANDEDNESS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const HANDEDNESS = *opaque{
};
// --------------------------------------------------------
// Type: ICONMETRICSA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const ICONMETRICSA = extern struct {
    cbSize: u32,
    iHorzSpacing: i32,
    iVertSpacing: i32,
    iTitleWrap: i32,
    lfFont: LOGFONTA,
};
// --------------------------------------------------------
// Type: ICONMETRICSW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const ICONMETRICSW = extern struct {
    cbSize: u32,
    iHorzSpacing: i32,
    iVertSpacing: i32,
    iTitleWrap: i32,
    lfFont: LOGFONTW,
};
// --------------------------------------------------------
// Type: CURSORINFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CURSORINFO = extern struct {
    cbSize: u32,
    flags: u32,
    hCursor: HCURSOR,
    ptScreenPos: POINT,
};
// --------------------------------------------------------
// Type: MENUBARINFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const MENUBARINFO = extern struct {
    cbSize: u32,
    rcBar: RECT,
    hMenu: HMENU,
    hwndMenu: HWND,
    _bitfield: i32,
};
// --------------------------------------------------------
// Type: HRAWINPUT__
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HRAWINPUT__ = extern struct {
    unused: i32,
};
// --------------------------------------------------------
// Type: HGESTUREINFO__
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HGESTUREINFO__ = extern struct {
    unused: i32,
};
// --------------------------------------------------------
// Type: IndexedResourceQualifier
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const IndexedResourceQualifier = extern struct {
    name: ?*u16,
    value: ?*u16,
};
// --------------------------------------------------------
// Type: MrmPlatformVersion
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const MrmPlatformVersion = *opaque{
};
// --------------------------------------------------------
// Type: MrmResourceIndexerHandle
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const MrmResourceIndexerHandle = extern struct {
    handle: ?*opaque{},
};
// --------------------------------------------------------
// Type: MrmPackagingMode
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const MrmPackagingMode = *opaque{
};
// --------------------------------------------------------
// Type: MrmPackagingOptions
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const MrmPackagingOptions = *opaque{
};
// --------------------------------------------------------
// Type: MrmDumpType
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const MrmDumpType = *opaque{
};
// --------------------------------------------------------
// Type: MrmResourceIndexerMessageSeverity
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const MrmResourceIndexerMessageSeverity = *opaque{
};
// --------------------------------------------------------
// Type: MrmResourceIndexerMessage
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const MrmResourceIndexerMessage = extern struct {
    severity: MrmResourceIndexerMessageSeverity,
    id: u32,
    text: ?*u16,
};
// --------------------------------------------------------
// Type: HACCEL
// TypeLayoutAttr: sequential
// RAIIFree 'DestroyAcceleratorTable' (TODO: can we use this information?)
pub const HACCEL = ?*opaque{};
// --------------------------------------------------------
// Type: HMENU
// TypeLayoutAttr: sequential
// RAIIFree 'DestroyMenu' (TODO: can we use this information?)
pub const HMENU = ?*opaque{};
// --------------------------------------------------------
// Type: MESSAGE_RESOURCE_ENTRY
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const MESSAGE_RESOURCE_ENTRY = extern struct {
    Length: u16,
    Flags: u16,
    Text: ?[*]u8,
};
// --------------------------------------------------------
// Type: MESSAGE_RESOURCE_BLOCK
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const MESSAGE_RESOURCE_BLOCK = extern struct {
    LowId: u32,
    HighId: u32,
    OffsetToEntries: u32,
};
// --------------------------------------------------------
// Type: MESSAGE_RESOURCE_DATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const MESSAGE_RESOURCE_DATA = extern struct {
    NumberOfBlocks: u32,
    Blocks: ?[*]MESSAGE_RESOURCE_BLOCK,
};
// --------------------------------------------------------
// Type: ENUMRESNAMEPROCA
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const ENUMRESNAMEPROCA = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: ENUMRESNAMEPROCW
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const ENUMRESNAMEPROCW = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: ENUMRESTYPEPROCA
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const ENUMRESTYPEPROCA = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: ENUMRESTYPEPROCW
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const ENUMRESTYPEPROCW = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: VS_FIXEDFILEINFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VS_FIXEDFILEINFO = extern struct {
    dwSignature: u32,
    dwStrucVersion: u32,
    dwFileVersionMS: u32,
    dwFileVersionLS: u32,
    dwProductVersionMS: u32,
    dwProductVersionLS: u32,
    dwFileFlagsMask: u32,
    dwFileFlags: u32,
    dwFileOS: u32,
    dwFileType: u32,
    dwFileSubtype: u32,
    dwFileDateMS: u32,
    dwFileDateLS: u32,
};

//
// functions
//

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn wvsprintfA(
    param0: ?*i8,
    param1: ?*i8,
    arglist: ?*i8,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn wvsprintfW(
    param0: ?*u16,
    param1: ?*u16,
    arglist: ?*i8,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn wsprintfA(
    param0: ?*i8,
    param1: ?*i8,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn wsprintfW(
    param0: ?*u16,
    param1: ?*u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn SetMessageQueue(
    cMessagesMax: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn BroadcastSystemMessageA(
    flags: u32,
    lpInfo: ?*u32,
    Msg: u32,
    wParam: WPARAM,
    lParam: LPARAM,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn IsMenu(
    hMenu: HMENU,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn UpdateLayeredWindowIndirect(
    hWnd: HWND,
    pULWInfo: ?*UPDATELAYEREDWINDOWINFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn DefDlgProcA(
    hDlg: HWND,
    Msg: u32,
    wParam: WPARAM,
    lParam: LPARAM,
) callconv(@import("std").os.windows.WINAPI) LRESULT;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn CharToOemA(
    pSrc: ?*i8,
    pDst: ?*i8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn CharToOemW(
    pSrc: ?*u16,
    pDst: ?*i8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn OemToCharA(
    pSrc: ?*i8,
    pDst: ?*i8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn OemToCharW(
    pSrc: ?*i8,
    pDst: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn CharToOemBuffA(
    lpszSrc: ?*i8,
    lpszDst: ?*i8,
    cchDstLength: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn CharToOemBuffW(
    lpszSrc: ?*u16,
    lpszDst: ?*i8,
    cchDstLength: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn OemToCharBuffA(
    lpszSrc: ?*i8,
    lpszDst: ?*i8,
    cchDstLength: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn OemToCharBuffW(
    lpszSrc: ?*i8,
    lpszDst: ?*u16,
    cchDstLength: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn CharUpperA(
    lpsz: ?*i8,
) callconv(@import("std").os.windows.WINAPI) ?*i8;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn CharUpperW(
    lpsz: ?*u16,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn CharUpperBuffA(
    lpsz: ?*i8,
    cchLength: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn CharUpperBuffW(
    lpsz: ?*u16,
    cchLength: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn CharLowerA(
    lpsz: ?*i8,
) callconv(@import("std").os.windows.WINAPI) ?*i8;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn CharLowerW(
    lpsz: ?*u16,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn CharLowerBuffA(
    lpsz: ?*i8,
    cchLength: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn CharLowerBuffW(
    lpsz: ?*u16,
    cchLength: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn CharNextA(
    lpsz: ?*i8,
) callconv(@import("std").os.windows.WINAPI) ?*i8;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn CharNextW(
    lpsz: ?*u16,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn CharPrevA(
    lpszStart: ?*i8,
    lpszCurrent: ?*i8,
) callconv(@import("std").os.windows.WINAPI) ?*i8;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn CharPrevW(
    lpszStart: ?*u16,
    lpszCurrent: ?*u16,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn CharNextExA(
    CodePage: u16,
    lpCurrentChar: ?*i8,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) ?*i8;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn CharPrevExA(
    CodePage: u16,
    lpStart: ?*i8,
    lpCurrentChar: ?*i8,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) ?*i8;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn IsCharAlphaA(
    ch: i8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn IsCharAlphaW(
    ch: u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn IsCharAlphaNumericA(
    ch: i8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn IsCharAlphaNumericW(
    ch: u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn IsCharUpperA(
    ch: i8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn IsCharUpperW(
    ch: u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn IsCharLowerA(
    ch: i8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn LoadAcceleratorsA(
    hInstance: HINSTANCE,
    lpTableName: ?*i8,
) callconv(@import("std").os.windows.WINAPI) HACCEL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn LoadAcceleratorsW(
    hInstance: HINSTANCE,
    lpTableName: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HACCEL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn CreateAcceleratorTableA(
    paccel: ?*ACCEL,
    cAccel: i32,
) callconv(@import("std").os.windows.WINAPI) HACCEL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn CreateAcceleratorTableW(
    paccel: ?*ACCEL,
    cAccel: i32,
) callconv(@import("std").os.windows.WINAPI) HACCEL;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn DestroyAcceleratorTable(
    hAccel: HACCEL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn CopyAcceleratorTableA(
    hAccelSrc: HACCEL,
    lpAccelDst: ?*ACCEL,
    cAccelEntries: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn CopyAcceleratorTableW(
    hAccelSrc: HACCEL,
    lpAccelDst: ?*ACCEL,
    cAccelEntries: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn TranslateAcceleratorA(
    hWnd: HWND,
    hAccTable: HACCEL,
    lpMsg: ?*MSG,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn TranslateAcceleratorW(
    hWnd: HWND,
    hAccTable: HACCEL,
    lpMsg: ?*MSG,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn LoadMenuA(
    hInstance: HINSTANCE,
    lpMenuName: ?*i8,
) callconv(@import("std").os.windows.WINAPI) HMENU;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn LoadMenuW(
    hInstance: HINSTANCE,
    lpMenuName: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HMENU;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn LoadMenuIndirectA(
    lpMenuTemplate: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HMENU;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn LoadMenuIndirectW(
    lpMenuTemplate: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HMENU;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn GetMenu(
    hWnd: HWND,
) callconv(@import("std").os.windows.WINAPI) HMENU;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn SetMenu(
    hWnd: HWND,
    hMenu: HMENU,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn ChangeMenuA(
    hMenu: HMENU,
    cmd: u32,
    lpszNewItem: ?*i8,
    cmdInsert: u32,
    flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn ChangeMenuW(
    hMenu: HMENU,
    cmd: u32,
    lpszNewItem: ?*u16,
    cmdInsert: u32,
    flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn HiliteMenuItem(
    hWnd: HWND,
    hMenu: HMENU,
    uIDHiliteItem: u32,
    uHilite: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn GetMenuStringA(
    hMenu: HMENU,
    uIDItem: u32,
    lpString: ?*i8,
    cchMax: i32,
    flags: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn GetMenuStringW(
    hMenu: HMENU,
    uIDItem: u32,
    lpString: ?*u16,
    cchMax: i32,
    flags: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn GetMenuState(
    hMenu: HMENU,
    uId: u32,
    uFlags: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn DrawMenuBar(
    hWnd: HWND,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn GetSystemMenu(
    hWnd: HWND,
    bRevert: BOOL,
) callconv(@import("std").os.windows.WINAPI) HMENU;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn CreateMenu(
) callconv(@import("std").os.windows.WINAPI) HMENU;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn CreatePopupMenu(
) callconv(@import("std").os.windows.WINAPI) HMENU;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn DestroyMenu(
    hMenu: HMENU,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn CheckMenuItem(
    hMenu: HMENU,
    uIDCheckItem: u32,
    uCheck: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn EnableMenuItem(
    hMenu: HMENU,
    uIDEnableItem: u32,
    uEnable: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn GetSubMenu(
    hMenu: HMENU,
    nPos: i32,
) callconv(@import("std").os.windows.WINAPI) HMENU;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn GetMenuItemID(
    hMenu: HMENU,
    nPos: i32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn GetMenuItemCount(
    hMenu: HMENU,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn InsertMenuA(
    hMenu: HMENU,
    uPosition: u32,
    uFlags: u32,
    uIDNewItem: ?*opaque{},
    lpNewItem: ?*i8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn InsertMenuW(
    hMenu: HMENU,
    uPosition: u32,
    uFlags: u32,
    uIDNewItem: ?*opaque{},
    lpNewItem: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn AppendMenuA(
    hMenu: HMENU,
    uFlags: u32,
    uIDNewItem: ?*opaque{},
    lpNewItem: ?*i8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn AppendMenuW(
    hMenu: HMENU,
    uFlags: u32,
    uIDNewItem: ?*opaque{},
    lpNewItem: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn ModifyMenuA(
    hMnu: HMENU,
    uPosition: u32,
    uFlags: u32,
    uIDNewItem: ?*opaque{},
    lpNewItem: ?*i8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn ModifyMenuW(
    hMnu: HMENU,
    uPosition: u32,
    uFlags: u32,
    uIDNewItem: ?*opaque{},
    lpNewItem: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn RemoveMenu(
    hMenu: HMENU,
    uPosition: u32,
    uFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn DeleteMenu(
    hMenu: HMENU,
    uPosition: u32,
    uFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn SetMenuItemBitmaps(
    hMenu: HMENU,
    uPosition: u32,
    uFlags: u32,
    hBitmapUnchecked: HBITMAP,
    hBitmapChecked: HBITMAP,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn GetMenuCheckMarkDimensions(
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn TrackPopupMenu(
    hMenu: HMENU,
    uFlags: u32,
    x: i32,
    y: i32,
    nReserved: i32,
    hWnd: HWND,
    prcRect: ?*RECT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn TrackPopupMenuEx(
    hMenu: HMENU,
    uFlags: u32,
    x: i32,
    y: i32,
    hwnd: HWND,
    lptpm: ?*TPMPARAMS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn GetMenuInfo(
    param0: HMENU,
    param1: ?*MENUINFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn SetMenuInfo(
    param0: HMENU,
    param1: ?*MENUINFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn EndMenu(
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn InsertMenuItemA(
    hmenu: HMENU,
    item: u32,
    fByPosition: BOOL,
    lpmi: ?*MENUITEMINFOA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn InsertMenuItemW(
    hmenu: HMENU,
    item: u32,
    fByPosition: BOOL,
    lpmi: ?*MENUITEMINFOW,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn GetMenuItemInfoA(
    hmenu: HMENU,
    item: u32,
    fByPosition: BOOL,
    lpmii: ?*MENUITEMINFOA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn GetMenuItemInfoW(
    hmenu: HMENU,
    item: u32,
    fByPosition: BOOL,
    lpmii: ?*MENUITEMINFOW,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn SetMenuItemInfoA(
    hmenu: HMENU,
    item: u32,
    fByPositon: BOOL,
    lpmii: ?*MENUITEMINFOA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn SetMenuItemInfoW(
    hmenu: HMENU,
    item: u32,
    fByPositon: BOOL,
    lpmii: ?*MENUITEMINFOW,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn GetMenuDefaultItem(
    hMenu: HMENU,
    fByPos: u32,
    gmdiFlags: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn SetMenuDefaultItem(
    hMenu: HMENU,
    uItem: u32,
    fByPos: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn GetMenuItemRect(
    hWnd: HWND,
    hMenu: HMENU,
    uItem: u32,
    lprcItem: ?*RECT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn MenuItemFromPoint(
    hWnd: HWND,
    hMenu: HMENU,
    ptScreen: POINT,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn DragObject(
    hwndParent: HWND,
    hwndFrom: HWND,
    fmt: u32,
    data: ?*opaque{},
    hcur: HCURSOR,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn DrawIcon(
    hDC: HDC,
    X: i32,
    Y: i32,
    hIcon: HICON,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn ShowCursor(
    bShow: BOOL,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn SetCursorPos(
    X: i32,
    Y: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn SetPhysicalCursorPos(
    X: i32,
    Y: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn SetCursor(
    hCursor: HCURSOR,
) callconv(@import("std").os.windows.WINAPI) HCURSOR;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn GetCursorPos(
    lpPoint: ?*POINT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn GetPhysicalCursorPos(
    lpPoint: ?*POINT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn GetClipCursor(
    lpRect: ?*RECT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn GetCursor(
) callconv(@import("std").os.windows.WINAPI) HCURSOR;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn CreateCaret(
    hWnd: HWND,
    hBitmap: HBITMAP,
    nWidth: i32,
    nHeight: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn GetCaretBlinkTime(
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn SetCaretBlinkTime(
    uMSeconds: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn DestroyCaret(
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn HideCaret(
    hWnd: HWND,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn ShowCaret(
    hWnd: HWND,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn SetCaretPos(
    X: i32,
    Y: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn GetCaretPos(
    lpPoint: ?*POINT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn ClipCursor(
    lpRect: ?*RECT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn GetWindowWord(
    hWnd: HWND,
    nIndex: i32,
) callconv(@import("std").os.windows.WINAPI) u16;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn SetWindowWord(
    hWnd: HWND,
    nIndex: i32,
    wNewWord: u16,
) callconv(@import("std").os.windows.WINAPI) u16;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn SetWindowsHookA(
    nFilterType: i32,
    pfnFilterProc: HOOKPROC,
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn SetWindowsHookW(
    nFilterType: i32,
    pfnFilterProc: HOOKPROC,
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn UnhookWindowsHook(
    nCode: i32,
    pfnFilterProc: HOOKPROC,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn CheckMenuRadioItem(
    hmenu: HMENU,
    first: u32,
    last: u32,
    check: u32,
    flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn LoadCursorA(
    hInstance: HINSTANCE,
    lpCursorName: ?*i8,
) callconv(@import("std").os.windows.WINAPI) HCURSOR;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn LoadCursorW(
    hInstance: HINSTANCE,
    lpCursorName: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HCURSOR;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn LoadCursorFromFileA(
    lpFileName: ?*i8,
) callconv(@import("std").os.windows.WINAPI) HCURSOR;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn LoadCursorFromFileW(
    lpFileName: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HCURSOR;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn CreateCursor(
    hInst: HINSTANCE,
    xHotSpot: i32,
    yHotSpot: i32,
    nWidth: i32,
    nHeight: i32,
    pvANDPlane: ?*opaque{},
    pvXORPlane: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HCURSOR;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn DestroyCursor(
    hCursor: HCURSOR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn SetSystemCursor(
    hcur: HCURSOR,
    id: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn LoadIconA(
    hInstance: HINSTANCE,
    lpIconName: ?*i8,
) callconv(@import("std").os.windows.WINAPI) HICON;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn LoadIconW(
    hInstance: HINSTANCE,
    lpIconName: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HICON;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn PrivateExtractIconsA(
    szFileName: ?*i8,
    nIconIndex: i32,
    cxIcon: i32,
    cyIcon: i32,
    phicon: ?*HICON,
    piconid: ?*u32,
    nIcons: u32,
    flags: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn PrivateExtractIconsW(
    szFileName: ?*u16,
    nIconIndex: i32,
    cxIcon: i32,
    cyIcon: i32,
    phicon: ?*HICON,
    piconid: ?*u32,
    nIcons: u32,
    flags: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn CreateIcon(
    hInstance: HINSTANCE,
    nWidth: i32,
    nHeight: i32,
    cPlanes: u8,
    cBitsPixel: u8,
    lpbANDbits: ?*u8,
    lpbXORbits: ?*u8,
) callconv(@import("std").os.windows.WINAPI) HICON;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn DestroyIcon(
    hIcon: HICON,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn LookupIconIdFromDirectory(
    presbits: ?*u8,
    fIcon: BOOL,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn LookupIconIdFromDirectoryEx(
    presbits: ?*u8,
    fIcon: BOOL,
    cxDesired: i32,
    cyDesired: i32,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn CreateIconFromResource(
    presbits: ?*u8,
    dwResSize: u32,
    fIcon: BOOL,
    dwVer: u32,
) callconv(@import("std").os.windows.WINAPI) HICON;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn CreateIconFromResourceEx(
    presbits: ?*u8,
    dwResSize: u32,
    fIcon: BOOL,
    dwVer: u32,
    cxDesired: i32,
    cyDesired: i32,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) HICON;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn LoadImageA(
    hInst: HINSTANCE,
    name: ?*i8,
    type: u32,
    cx: i32,
    cy: i32,
    fuLoad: u32,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn LoadImageW(
    hInst: HINSTANCE,
    name: ?*u16,
    type: u32,
    cx: i32,
    cy: i32,
    fuLoad: u32,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn CopyImage(
    h: HANDLE,
    type: u32,
    cx: i32,
    cy: i32,
    flags: u32,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn DrawIconEx(
    hdc: HDC,
    xLeft: i32,
    yTop: i32,
    hIcon: HICON,
    cxWidth: i32,
    cyWidth: i32,
    istepIfAniCur: u32,
    hbrFlickerFreeDraw: HBRUSH,
    diFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn CreateIconIndirect(
    piconinfo: ?*ICONINFO,
) callconv(@import("std").os.windows.WINAPI) HICON;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn CopyIcon(
    hIcon: HICON,
) callconv(@import("std").os.windows.WINAPI) HICON;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn GetIconInfo(
    hIcon: HICON,
    piconinfo: ?*ICONINFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn GetIconInfoExA(
    hicon: HICON,
    piconinfo: ?*ICONINFOEXA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn GetIconInfoExW(
    hicon: HICON,
    piconinfo: ?*ICONINFOEXW,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn SetDebugErrorLevel(
    dwLevel: u32,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn CancelShutdown(
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn InheritWindowMonitor(
    hwnd: HWND,
    hwndInherit: HWND,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn GetDpiAwarenessContextForProcess(
    hProcess: HANDLE,
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn GetCursorInfo(
    pci: ?*CURSORINFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn GetMenuBarInfo(
    hwnd: HWND,
    idObject: i32,
    idItem: i32,
    pmbi: ?*MENUBARINFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn RealGetWindowClassA(
    hwnd: HWND,
    ptszClassName: ?*i8,
    cchClassNameMax: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "VERSION" fn VerFindFileA(
    uFlags: u32,
    szFileName: ?*i8,
    szWinDir: ?*i8,
    szAppDir: ?*i8,
    szCurDir: ?*i8,
    puCurDirLen: ?*u32,
    szDestDir: ?*i8,
    puDestDirLen: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "VERSION" fn VerFindFileW(
    uFlags: u32,
    szFileName: ?*u16,
    szWinDir: ?*u16,
    szAppDir: ?*u16,
    szCurDir: ?*u16,
    puCurDirLen: ?*u32,
    szDestDir: ?*u16,
    puDestDirLen: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "VERSION" fn VerInstallFileA(
    uFlags: u32,
    szSrcFileName: ?*i8,
    szDestFileName: ?*i8,
    szSrcDir: ?*i8,
    szDestDir: ?*i8,
    szCurDir: ?*i8,
    szTmpFile: ?*i8,
    puTmpFileLen: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "VERSION" fn VerInstallFileW(
    uFlags: u32,
    szSrcFileName: ?*u16,
    szDestFileName: ?*u16,
    szSrcDir: ?*u16,
    szDestDir: ?*u16,
    szCurDir: ?*u16,
    szTmpFile: ?*u16,
    puTmpFileLen: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "VERSION" fn GetFileVersionInfoSizeA(
    lptstrFilename: ?*i8,
    lpdwHandle: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "VERSION" fn GetFileVersionInfoSizeW(
    lptstrFilename: ?*u16,
    lpdwHandle: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "VERSION" fn GetFileVersionInfoA(
    lptstrFilename: ?*i8,
    dwHandle: u32,
    dwLen: u32,
    lpData: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "VERSION" fn GetFileVersionInfoW(
    lptstrFilename: ?*u16,
    dwHandle: u32,
    dwLen: u32,
    lpData: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "VERSION" fn GetFileVersionInfoSizeExA(
    dwFlags: u32,
    lpwstrFilename: ?*i8,
    lpdwHandle: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "VERSION" fn GetFileVersionInfoSizeExW(
    dwFlags: u32,
    lpwstrFilename: ?*u16,
    lpdwHandle: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "VERSION" fn GetFileVersionInfoExA(
    dwFlags: u32,
    lpwstrFilename: ?*i8,
    dwHandle: u32,
    dwLen: u32,
    lpData: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "VERSION" fn GetFileVersionInfoExW(
    dwFlags: u32,
    lpwstrFilename: ?*u16,
    dwHandle: u32,
    dwLen: u32,
    lpData: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn VerLanguageNameA(
    wLang: u32,
    szLang: ?*i8,
    cchLang: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn VerLanguageNameW(
    wLang: u32,
    szLang: ?*u16,
    cchLang: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "VERSION" fn VerQueryValueA(
    pBlock: ?*opaque{},
    lpSubBlock: ?*i8,
    lplpBuffer: ?*?*opaque{},
    puLen: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "VERSION" fn VerQueryValueW(
    pBlock: ?*opaque{},
    lpSubBlock: ?*u16,
    lplpBuffer: ?*?*opaque{},
    puLen: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "MrmSupport" fn CreateResourceIndexer(
    projectRoot: ?*u16,
    extensionDllPath: ?*u16,
    ppResourceIndexer: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "MrmSupport" fn DestroyResourceIndexer(
    resourceIndexer: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "MrmSupport" fn IndexFilePath(
    resourceIndexer: ?*opaque{},
    filePath: ?*u16,
    ppResourceUri: ?*?*u16,
    pQualifierCount: ?*u32,
    ppQualifiers: ?*?*IndexedResourceQualifier,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "MrmSupport" fn DestroyIndexedResults(
    resourceUri: ?*u16,
    qualifierCount: u32,
    qualifiers: ?*IndexedResourceQualifier,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "MrmSupport" fn MrmCreateResourceIndexer(
    packageFamilyName: ?*u16,
    projectRoot: ?*u16,
    platformVersion: MrmPlatformVersion,
    defaultQualifiers: ?*u16,
    indexer: ?*MrmResourceIndexerHandle,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "MrmSupport" fn MrmCreateResourceIndexerFromPreviousSchemaFile(
    projectRoot: ?*u16,
    platformVersion: MrmPlatformVersion,
    defaultQualifiers: ?*u16,
    schemaFile: ?*u16,
    indexer: ?*MrmResourceIndexerHandle,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "MrmSupport" fn MrmCreateResourceIndexerFromPreviousPriFile(
    projectRoot: ?*u16,
    platformVersion: MrmPlatformVersion,
    defaultQualifiers: ?*u16,
    priFile: ?*u16,
    indexer: ?*MrmResourceIndexerHandle,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "MrmSupport" fn MrmCreateResourceIndexerFromPreviousSchemaData(
    projectRoot: ?*u16,
    platformVersion: MrmPlatformVersion,
    defaultQualifiers: ?*u16,
    schemaXmlData: ?*u8,
    schemaXmlSize: u32,
    indexer: ?*MrmResourceIndexerHandle,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "MrmSupport" fn MrmCreateResourceIndexerFromPreviousPriData(
    projectRoot: ?*u16,
    platformVersion: MrmPlatformVersion,
    defaultQualifiers: ?*u16,
    priData: ?*u8,
    priSize: u32,
    indexer: ?*MrmResourceIndexerHandle,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "MrmSupport" fn MrmIndexString(
    indexer: MrmResourceIndexerHandle,
    resourceUri: ?*u16,
    resourceString: ?*u16,
    qualifiers: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "MrmSupport" fn MrmIndexEmbeddedData(
    indexer: MrmResourceIndexerHandle,
    resourceUri: ?*u16,
    embeddedData: ?*u8,
    embeddedDataSize: u32,
    qualifiers: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "MrmSupport" fn MrmIndexFile(
    indexer: MrmResourceIndexerHandle,
    resourceUri: ?*u16,
    filePath: ?*u16,
    qualifiers: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "MrmSupport" fn MrmIndexFileAutoQualifiers(
    indexer: MrmResourceIndexerHandle,
    filePath: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "MrmSupport" fn MrmIndexResourceContainerAutoQualifiers(
    indexer: MrmResourceIndexerHandle,
    containerPath: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "MrmSupport" fn MrmCreateResourceFile(
    indexer: MrmResourceIndexerHandle,
    packagingMode: MrmPackagingMode,
    packagingOptions: MrmPackagingOptions,
    outputDirectory: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "MrmSupport" fn MrmCreateResourceFileInMemory(
    indexer: MrmResourceIndexerHandle,
    packagingMode: MrmPackagingMode,
    packagingOptions: MrmPackagingOptions,
    outputPriData: ?*?*u8,
    outputPriSize: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "MrmSupport" fn MrmPeekResourceIndexerMessages(
    handle: MrmResourceIndexerHandle,
    messages: ?*?*MrmResourceIndexerMessage,
    numMsgs: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "MrmSupport" fn MrmDestroyIndexerAndMessages(
    indexer: MrmResourceIndexerHandle,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "MrmSupport" fn MrmFreeMemory(
    data: ?*u8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "MrmSupport" fn MrmDumpPriFile(
    indexFileName: ?*u16,
    schemaPriFile: ?*u16,
    dumpType: MrmDumpType,
    outputXmlFile: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "MrmSupport" fn MrmDumpPriFileInMemory(
    indexFileName: ?*u16,
    schemaPriFile: ?*u16,
    dumpType: MrmDumpType,
    outputXmlData: ?*?*u8,
    outputXmlSize: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "MrmSupport" fn MrmDumpPriDataInMemory(
    inputPriData: ?*u8,
    inputPriSize: u32,
    schemaPriData: ?*u8,
    schemaPriSize: u32,
    dumpType: MrmDumpType,
    outputXmlData: ?*?*u8,
    outputXmlSize: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "MrmSupport" fn MrmCreateConfig(
    platformVersion: MrmPlatformVersion,
    defaultQualifiers: ?*u16,
    outputXmlFile: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "MrmSupport" fn MrmCreateConfigInMemory(
    platformVersion: MrmPlatformVersion,
    defaultQualifiers: ?*u16,
    outputXmlData: ?*?*u8,
    outputXmlSize: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn FreeResource(
    hResData: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn LoadResource(
    hModule: ?*opaque{},
    hResInfo: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn LoadStringA(
    hInstance: HINSTANCE,
    uID: u32,
    lpBuffer: ?*i8,
    cchBufferMax: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn LoadStringW(
    hInstance: HINSTANCE,
    uID: u32,
    lpBuffer: ?*u16,
    cchBufferMax: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn LockResource(
    hResData: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn SizeofResource(
    hModule: ?*opaque{},
    hResInfo: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn EnumResourceLanguagesExA(
    hModule: ?*opaque{},
    lpType: ?*i8,
    lpName: ?*i8,
    lpEnumFunc: ENUMRESLANGPROCA,
    lParam: ?*opaque{},
    dwFlags: u32,
    LangId: u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn EnumResourceLanguagesExW(
    hModule: ?*opaque{},
    lpType: ?*u16,
    lpName: ?*u16,
    lpEnumFunc: ENUMRESLANGPROCW,
    lParam: ?*opaque{},
    dwFlags: u32,
    LangId: u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn EnumResourceNamesExA(
    hModule: ?*opaque{},
    lpType: ?*i8,
    lpEnumFunc: ENUMRESNAMEPROCA,
    lParam: ?*opaque{},
    dwFlags: u32,
    LangId: u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn EnumResourceNamesExW(
    hModule: ?*opaque{},
    lpType: ?*u16,
    lpEnumFunc: ENUMRESNAMEPROCW,
    lParam: ?*opaque{},
    dwFlags: u32,
    LangId: u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn EnumResourceTypesExA(
    hModule: ?*opaque{},
    lpEnumFunc: ENUMRESTYPEPROCA,
    lParam: ?*opaque{},
    dwFlags: u32,
    LangId: u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn EnumResourceTypesExW(
    hModule: ?*opaque{},
    lpEnumFunc: ENUMRESTYPEPROCW,
    lParam: ?*opaque{},
    dwFlags: u32,
    LangId: u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn lstrcmpA(
    lpString1: ?*i8,
    lpString2: ?*i8,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn lstrcmpW(
    lpString1: ?*u16,
    lpString2: ?*u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn lstrcmpiA(
    lpString1: ?*i8,
    lpString2: ?*i8,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn lstrcmpiW(
    lpString1: ?*u16,
    lpString2: ?*u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn lstrcpynA(
    lpString1: ?*i8,
    lpString2: ?*i8,
    iMaxLength: i32,
) callconv(@import("std").os.windows.WINAPI) ?*i8;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn lstrcpynW(
    lpString1: ?*u16,
    lpString2: ?*u16,
    iMaxLength: i32,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn lstrcpyA(
    lpString1: ?*i8,
    lpString2: ?*i8,
) callconv(@import("std").os.windows.WINAPI) ?*i8;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn lstrcpyW(
    lpString1: ?*u16,
    lpString2: ?*u16,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn lstrcatA(
    lpString1: ?*i8,
    lpString2: ?*i8,
) callconv(@import("std").os.windows.WINAPI) ?*i8;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn lstrcatW(
    lpString1: ?*u16,
    lpString2: ?*u16,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn lstrlenA(
    lpString: ?*i8,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn lstrlenW(
    lpString: ?*u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn FindResourceA(
    hModule: ?*opaque{},
    lpName: ?*i8,
    lpType: ?*i8,
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn FindResourceExA(
    hModule: ?*opaque{},
    lpType: ?*i8,
    lpName: ?*i8,
    wLanguage: u16,
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn EnumResourceTypesA(
    hModule: ?*opaque{},
    lpEnumFunc: ENUMRESTYPEPROCA,
    lParam: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn EnumResourceTypesW(
    hModule: ?*opaque{},
    lpEnumFunc: ENUMRESTYPEPROCW,
    lParam: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn EnumResourceNamesA(
    hModule: ?*opaque{},
    lpType: ?*i8,
    lpEnumFunc: ENUMRESNAMEPROCA,
    lParam: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn EnumResourceLanguagesA(
    hModule: ?*opaque{},
    lpType: ?*i8,
    lpName: ?*i8,
    lpEnumFunc: ENUMRESLANGPROCA,
    lParam: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn EnumResourceLanguagesW(
    hModule: ?*opaque{},
    lpType: ?*u16,
    lpName: ?*u16,
    lpEnumFunc: ENUMRESLANGPROCW,
    lParam: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn BeginUpdateResourceA(
    pFileName: ?*i8,
    bDeleteExistingResources: BOOL,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn BeginUpdateResourceW(
    pFileName: ?*u16,
    bDeleteExistingResources: BOOL,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn UpdateResourceA(
    hUpdate: HANDLE,
    lpType: ?*i8,
    lpName: ?*i8,
    wLanguage: u16,
    lpData: ?*opaque{},
    cb: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn UpdateResourceW(
    hUpdate: HANDLE,
    lpType: ?*u16,
    lpName: ?*u16,
    wLanguage: u16,
    lpData: ?*opaque{},
    cb: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn EndUpdateResourceA(
    hUpdate: HANDLE,
    fDiscard: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn EndUpdateResourceW(
    hUpdate: HANDLE,
    fDiscard: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

//
// Unicode Symbol Aliases
//
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {
        pub const NAMEENUMPROC = NAMEENUMPROCA;
        pub const MENUITEMINFO = MENUITEMINFOA;
        pub const ICONINFOEX = ICONINFOEXA;
        pub const ICONMETRICS = ICONMETRICSA;
        pub const ENUMRESNAMEPROC = ENUMRESNAMEPROCA;
        pub const ENUMRESTYPEPROC = ENUMRESTYPEPROCA;
        pub const wvsprintf = wvsprintfA;
        pub const wsprintf = wsprintfA;
        pub const CharToOem = CharToOemA;
        pub const OemToChar = OemToCharA;
        pub const CharToOemBuff = CharToOemBuffA;
        pub const OemToCharBuff = OemToCharBuffA;
        pub const CharUpper = CharUpperA;
        pub const CharUpperBuff = CharUpperBuffA;
        pub const CharLower = CharLowerA;
        pub const CharLowerBuff = CharLowerBuffA;
        pub const CharNext = CharNextA;
        pub const CharPrev = CharPrevA;
        pub const IsCharAlpha = IsCharAlphaA;
        pub const IsCharAlphaNumeric = IsCharAlphaNumericA;
        pub const IsCharUpper = IsCharUpperA;
        pub const LoadAccelerators = LoadAcceleratorsA;
        pub const CreateAcceleratorTable = CreateAcceleratorTableA;
        pub const CopyAcceleratorTable = CopyAcceleratorTableA;
        pub const TranslateAccelerator = TranslateAcceleratorA;
        pub const LoadMenu = LoadMenuA;
        pub const LoadMenuIndirect = LoadMenuIndirectA;
        pub const ChangeMenu = ChangeMenuA;
        pub const GetMenuString = GetMenuStringA;
        pub const InsertMenu = InsertMenuA;
        pub const AppendMenu = AppendMenuA;
        pub const ModifyMenu = ModifyMenuA;
        pub const InsertMenuItem = InsertMenuItemA;
        pub const GetMenuItemInfo = GetMenuItemInfoA;
        pub const SetMenuItemInfo = SetMenuItemInfoA;
        pub const SetWindowsHook = SetWindowsHookA;
        pub const LoadCursor = LoadCursorA;
        pub const LoadCursorFromFile = LoadCursorFromFileA;
        pub const LoadIcon = LoadIconA;
        pub const PrivateExtractIcons = PrivateExtractIconsA;
        pub const LoadImage = LoadImageA;
        pub const GetIconInfoEx = GetIconInfoExA;
        pub const VerFindFile = VerFindFileA;
        pub const VerInstallFile = VerInstallFileA;
        pub const GetFileVersionInfoSize = GetFileVersionInfoSizeA;
        pub const GetFileVersionInfo = GetFileVersionInfoA;
        pub const GetFileVersionInfoSizeEx = GetFileVersionInfoSizeExA;
        pub const GetFileVersionInfoEx = GetFileVersionInfoExA;
        pub const VerLanguageName = VerLanguageNameA;
        pub const VerQueryValue = VerQueryValueA;
        pub const LoadString = LoadStringA;
        pub const EnumResourceLanguagesEx = EnumResourceLanguagesExA;
        pub const EnumResourceNamesEx = EnumResourceNamesExA;
        pub const EnumResourceTypesEx = EnumResourceTypesExA;
        pub const lstrcmp = lstrcmpA;
        pub const lstrcmpi = lstrcmpiA;
        pub const lstrcpyn = lstrcpynA;
        pub const lstrcpy = lstrcpyA;
        pub const lstrcat = lstrcatA;
        pub const lstrlen = lstrlenA;
        pub const EnumResourceTypes = EnumResourceTypesA;
        pub const EnumResourceLanguages = EnumResourceLanguagesA;
        pub const BeginUpdateResource = BeginUpdateResourceA;
        pub const UpdateResource = UpdateResourceA;
        pub const EndUpdateResource = EndUpdateResourceA;
    },
    .wide => struct {
        pub const NAMEENUMPROC = NAMEENUMPROCW;
        pub const MENUITEMINFO = MENUITEMINFOW;
        pub const ICONINFOEX = ICONINFOEXW;
        pub const ICONMETRICS = ICONMETRICSW;
        pub const ENUMRESNAMEPROC = ENUMRESNAMEPROCW;
        pub const ENUMRESTYPEPROC = ENUMRESTYPEPROCW;
        pub const wvsprintf = wvsprintfW;
        pub const wsprintf = wsprintfW;
        pub const CharToOem = CharToOemW;
        pub const OemToChar = OemToCharW;
        pub const CharToOemBuff = CharToOemBuffW;
        pub const OemToCharBuff = OemToCharBuffW;
        pub const CharUpper = CharUpperW;
        pub const CharUpperBuff = CharUpperBuffW;
        pub const CharLower = CharLowerW;
        pub const CharLowerBuff = CharLowerBuffW;
        pub const CharNext = CharNextW;
        pub const CharPrev = CharPrevW;
        pub const IsCharAlpha = IsCharAlphaW;
        pub const IsCharAlphaNumeric = IsCharAlphaNumericW;
        pub const IsCharUpper = IsCharUpperW;
        pub const LoadAccelerators = LoadAcceleratorsW;
        pub const CreateAcceleratorTable = CreateAcceleratorTableW;
        pub const CopyAcceleratorTable = CopyAcceleratorTableW;
        pub const TranslateAccelerator = TranslateAcceleratorW;
        pub const LoadMenu = LoadMenuW;
        pub const LoadMenuIndirect = LoadMenuIndirectW;
        pub const ChangeMenu = ChangeMenuW;
        pub const GetMenuString = GetMenuStringW;
        pub const InsertMenu = InsertMenuW;
        pub const AppendMenu = AppendMenuW;
        pub const ModifyMenu = ModifyMenuW;
        pub const InsertMenuItem = InsertMenuItemW;
        pub const GetMenuItemInfo = GetMenuItemInfoW;
        pub const SetMenuItemInfo = SetMenuItemInfoW;
        pub const SetWindowsHook = SetWindowsHookW;
        pub const LoadCursor = LoadCursorW;
        pub const LoadCursorFromFile = LoadCursorFromFileW;
        pub const LoadIcon = LoadIconW;
        pub const PrivateExtractIcons = PrivateExtractIconsW;
        pub const LoadImage = LoadImageW;
        pub const GetIconInfoEx = GetIconInfoExW;
        pub const VerFindFile = VerFindFileW;
        pub const VerInstallFile = VerInstallFileW;
        pub const GetFileVersionInfoSize = GetFileVersionInfoSizeW;
        pub const GetFileVersionInfo = GetFileVersionInfoW;
        pub const GetFileVersionInfoSizeEx = GetFileVersionInfoSizeExW;
        pub const GetFileVersionInfoEx = GetFileVersionInfoExW;
        pub const VerLanguageName = VerLanguageNameW;
        pub const VerQueryValue = VerQueryValueW;
        pub const LoadString = LoadStringW;
        pub const EnumResourceLanguagesEx = EnumResourceLanguagesExW;
        pub const EnumResourceNamesEx = EnumResourceNamesExW;
        pub const EnumResourceTypesEx = EnumResourceTypesExW;
        pub const lstrcmp = lstrcmpW;
        pub const lstrcmpi = lstrcmpiW;
        pub const lstrcpyn = lstrcpynW;
        pub const lstrcpy = lstrcpyW;
        pub const lstrcat = lstrcatW;
        pub const lstrlen = lstrlenW;
        pub const EnumResourceTypes = EnumResourceTypesW;
        pub const EnumResourceLanguages = EnumResourceLanguagesW;
        pub const BeginUpdateResource = BeginUpdateResourceW;
        pub const UpdateResource = UpdateResourceW;
        pub const EndUpdateResource = EndUpdateResourceW;
    },
    else => if (@import("builtin").is_test) struct {
        pub const NAMEENUMPROC = *opaque{};
        pub const MENUITEMINFO = *opaque{};
        pub const ICONINFOEX = *opaque{};
        pub const ICONMETRICS = *opaque{};
        pub const ENUMRESNAMEPROC = *opaque{};
        pub const ENUMRESTYPEPROC = *opaque{};
        pub const wvsprintf = *opaque{};
        pub const wsprintf = *opaque{};
        pub const CharToOem = *opaque{};
        pub const OemToChar = *opaque{};
        pub const CharToOemBuff = *opaque{};
        pub const OemToCharBuff = *opaque{};
        pub const CharUpper = *opaque{};
        pub const CharUpperBuff = *opaque{};
        pub const CharLower = *opaque{};
        pub const CharLowerBuff = *opaque{};
        pub const CharNext = *opaque{};
        pub const CharPrev = *opaque{};
        pub const IsCharAlpha = *opaque{};
        pub const IsCharAlphaNumeric = *opaque{};
        pub const IsCharUpper = *opaque{};
        pub const LoadAccelerators = *opaque{};
        pub const CreateAcceleratorTable = *opaque{};
        pub const CopyAcceleratorTable = *opaque{};
        pub const TranslateAccelerator = *opaque{};
        pub const LoadMenu = *opaque{};
        pub const LoadMenuIndirect = *opaque{};
        pub const ChangeMenu = *opaque{};
        pub const GetMenuString = *opaque{};
        pub const InsertMenu = *opaque{};
        pub const AppendMenu = *opaque{};
        pub const ModifyMenu = *opaque{};
        pub const InsertMenuItem = *opaque{};
        pub const GetMenuItemInfo = *opaque{};
        pub const SetMenuItemInfo = *opaque{};
        pub const SetWindowsHook = *opaque{};
        pub const LoadCursor = *opaque{};
        pub const LoadCursorFromFile = *opaque{};
        pub const LoadIcon = *opaque{};
        pub const PrivateExtractIcons = *opaque{};
        pub const LoadImage = *opaque{};
        pub const GetIconInfoEx = *opaque{};
        pub const VerFindFile = *opaque{};
        pub const VerInstallFile = *opaque{};
        pub const GetFileVersionInfoSize = *opaque{};
        pub const GetFileVersionInfo = *opaque{};
        pub const GetFileVersionInfoSizeEx = *opaque{};
        pub const GetFileVersionInfoEx = *opaque{};
        pub const VerLanguageName = *opaque{};
        pub const VerQueryValue = *opaque{};
        pub const LoadString = *opaque{};
        pub const EnumResourceLanguagesEx = *opaque{};
        pub const EnumResourceNamesEx = *opaque{};
        pub const EnumResourceTypesEx = *opaque{};
        pub const lstrcmp = *opaque{};
        pub const lstrcmpi = *opaque{};
        pub const lstrcpyn = *opaque{};
        pub const lstrcpy = *opaque{};
        pub const lstrcat = *opaque{};
        pub const lstrlen = *opaque{};
        pub const EnumResourceTypes = *opaque{};
        pub const EnumResourceLanguages = *opaque{};
        pub const BeginUpdateResource = *opaque{};
        pub const UpdateResource = *opaque{};
        pub const EndUpdateResource = *opaque{};
    } else struct {
        pub const NAMEENUMPROC = @compileError("'NAMEENUMPROC' requires that UNICODE be set to true or false in the root module");
        pub const MENUITEMINFO = @compileError("'MENUITEMINFO' requires that UNICODE be set to true or false in the root module");
        pub const ICONINFOEX = @compileError("'ICONINFOEX' requires that UNICODE be set to true or false in the root module");
        pub const ICONMETRICS = @compileError("'ICONMETRICS' requires that UNICODE be set to true or false in the root module");
        pub const ENUMRESNAMEPROC = @compileError("'ENUMRESNAMEPROC' requires that UNICODE be set to true or false in the root module");
        pub const ENUMRESTYPEPROC = @compileError("'ENUMRESTYPEPROC' requires that UNICODE be set to true or false in the root module");
        pub const wvsprintf = @compileError("'wvsprintf' requires that UNICODE be set to true or false in the root module");
        pub const wsprintf = @compileError("'wsprintf' requires that UNICODE be set to true or false in the root module");
        pub const CharToOem = @compileError("'CharToOem' requires that UNICODE be set to true or false in the root module");
        pub const OemToChar = @compileError("'OemToChar' requires that UNICODE be set to true or false in the root module");
        pub const CharToOemBuff = @compileError("'CharToOemBuff' requires that UNICODE be set to true or false in the root module");
        pub const OemToCharBuff = @compileError("'OemToCharBuff' requires that UNICODE be set to true or false in the root module");
        pub const CharUpper = @compileError("'CharUpper' requires that UNICODE be set to true or false in the root module");
        pub const CharUpperBuff = @compileError("'CharUpperBuff' requires that UNICODE be set to true or false in the root module");
        pub const CharLower = @compileError("'CharLower' requires that UNICODE be set to true or false in the root module");
        pub const CharLowerBuff = @compileError("'CharLowerBuff' requires that UNICODE be set to true or false in the root module");
        pub const CharNext = @compileError("'CharNext' requires that UNICODE be set to true or false in the root module");
        pub const CharPrev = @compileError("'CharPrev' requires that UNICODE be set to true or false in the root module");
        pub const IsCharAlpha = @compileError("'IsCharAlpha' requires that UNICODE be set to true or false in the root module");
        pub const IsCharAlphaNumeric = @compileError("'IsCharAlphaNumeric' requires that UNICODE be set to true or false in the root module");
        pub const IsCharUpper = @compileError("'IsCharUpper' requires that UNICODE be set to true or false in the root module");
        pub const LoadAccelerators = @compileError("'LoadAccelerators' requires that UNICODE be set to true or false in the root module");
        pub const CreateAcceleratorTable = @compileError("'CreateAcceleratorTable' requires that UNICODE be set to true or false in the root module");
        pub const CopyAcceleratorTable = @compileError("'CopyAcceleratorTable' requires that UNICODE be set to true or false in the root module");
        pub const TranslateAccelerator = @compileError("'TranslateAccelerator' requires that UNICODE be set to true or false in the root module");
        pub const LoadMenu = @compileError("'LoadMenu' requires that UNICODE be set to true or false in the root module");
        pub const LoadMenuIndirect = @compileError("'LoadMenuIndirect' requires that UNICODE be set to true or false in the root module");
        pub const ChangeMenu = @compileError("'ChangeMenu' requires that UNICODE be set to true or false in the root module");
        pub const GetMenuString = @compileError("'GetMenuString' requires that UNICODE be set to true or false in the root module");
        pub const InsertMenu = @compileError("'InsertMenu' requires that UNICODE be set to true or false in the root module");
        pub const AppendMenu = @compileError("'AppendMenu' requires that UNICODE be set to true or false in the root module");
        pub const ModifyMenu = @compileError("'ModifyMenu' requires that UNICODE be set to true or false in the root module");
        pub const InsertMenuItem = @compileError("'InsertMenuItem' requires that UNICODE be set to true or false in the root module");
        pub const GetMenuItemInfo = @compileError("'GetMenuItemInfo' requires that UNICODE be set to true or false in the root module");
        pub const SetMenuItemInfo = @compileError("'SetMenuItemInfo' requires that UNICODE be set to true or false in the root module");
        pub const SetWindowsHook = @compileError("'SetWindowsHook' requires that UNICODE be set to true or false in the root module");
        pub const LoadCursor = @compileError("'LoadCursor' requires that UNICODE be set to true or false in the root module");
        pub const LoadCursorFromFile = @compileError("'LoadCursorFromFile' requires that UNICODE be set to true or false in the root module");
        pub const LoadIcon = @compileError("'LoadIcon' requires that UNICODE be set to true or false in the root module");
        pub const PrivateExtractIcons = @compileError("'PrivateExtractIcons' requires that UNICODE be set to true or false in the root module");
        pub const LoadImage = @compileError("'LoadImage' requires that UNICODE be set to true or false in the root module");
        pub const GetIconInfoEx = @compileError("'GetIconInfoEx' requires that UNICODE be set to true or false in the root module");
        pub const VerFindFile = @compileError("'VerFindFile' requires that UNICODE be set to true or false in the root module");
        pub const VerInstallFile = @compileError("'VerInstallFile' requires that UNICODE be set to true or false in the root module");
        pub const GetFileVersionInfoSize = @compileError("'GetFileVersionInfoSize' requires that UNICODE be set to true or false in the root module");
        pub const GetFileVersionInfo = @compileError("'GetFileVersionInfo' requires that UNICODE be set to true or false in the root module");
        pub const GetFileVersionInfoSizeEx = @compileError("'GetFileVersionInfoSizeEx' requires that UNICODE be set to true or false in the root module");
        pub const GetFileVersionInfoEx = @compileError("'GetFileVersionInfoEx' requires that UNICODE be set to true or false in the root module");
        pub const VerLanguageName = @compileError("'VerLanguageName' requires that UNICODE be set to true or false in the root module");
        pub const VerQueryValue = @compileError("'VerQueryValue' requires that UNICODE be set to true or false in the root module");
        pub const LoadString = @compileError("'LoadString' requires that UNICODE be set to true or false in the root module");
        pub const EnumResourceLanguagesEx = @compileError("'EnumResourceLanguagesEx' requires that UNICODE be set to true or false in the root module");
        pub const EnumResourceNamesEx = @compileError("'EnumResourceNamesEx' requires that UNICODE be set to true or false in the root module");
        pub const EnumResourceTypesEx = @compileError("'EnumResourceTypesEx' requires that UNICODE be set to true or false in the root module");
        pub const lstrcmp = @compileError("'lstrcmp' requires that UNICODE be set to true or false in the root module");
        pub const lstrcmpi = @compileError("'lstrcmpi' requires that UNICODE be set to true or false in the root module");
        pub const lstrcpyn = @compileError("'lstrcpyn' requires that UNICODE be set to true or false in the root module");
        pub const lstrcpy = @compileError("'lstrcpy' requires that UNICODE be set to true or false in the root module");
        pub const lstrcat = @compileError("'lstrcat' requires that UNICODE be set to true or false in the root module");
        pub const lstrlen = @compileError("'lstrlen' requires that UNICODE be set to true or false in the root module");
        pub const EnumResourceTypes = @compileError("'EnumResourceTypes' requires that UNICODE be set to true or false in the root module");
        pub const EnumResourceLanguages = @compileError("'EnumResourceLanguages' requires that UNICODE be set to true or false in the root module");
        pub const BeginUpdateResource = @compileError("'BeginUpdateResource' requires that UNICODE be set to true or false in the root module");
        pub const UpdateResource = @compileError("'UpdateResource' requires that UNICODE be set to true or false in the root module");
        pub const EndUpdateResource = @compileError("'EndUpdateResource' requires that UNICODE be set to true or false in the root module");
    },
};

//
// type imports
//
const HWND = @import("windowsandmessaging.zig").HWND;
const RECT = @import("displaydevices.zig").RECT;
const WPARAM = @import("windowsandmessaging.zig").WPARAM;
const LPARAM = @import("windowsandmessaging.zig").LPARAM;
const HBRUSH = @import("gdi.zig").HBRUSH;
const HBITMAP = @import("gdi.zig").HBITMAP;
const POINT = @import("displaydevices.zig").POINT;
const BOOL = @import("systemservices.zig").BOOL;
const LOGFONTA = @import("shell.zig").LOGFONTA;
const LOGFONTW = @import("shell.zig").LOGFONTW;
const HCURSOR = @import("gdi.zig").HCURSOR;
const UPDATELAYEREDWINDOWINFO = @import("windowsandmessaging.zig").UPDATELAYEREDWINDOWINFO;
const LRESULT = @import("systemservices.zig").LRESULT;
const HINSTANCE = @import("systemservices.zig").HINSTANCE;
const MSG = @import("windowsandmessaging.zig").MSG;
const HDC = @import("gdi.zig").HDC;
const HICON = @import("gdi.zig").HICON;
const HOOKPROC = @import("windowsandmessaging.zig").HOOKPROC;
const HANDLE = @import("systemservices.zig").HANDLE;
const HRESULT = @import("com.zig").HRESULT;
const ENUMRESLANGPROCA = @import("systemservices.zig").ENUMRESLANGPROCA;
const ENUMRESLANGPROCW = @import("systemservices.zig").ENUMRESLANGPROCW;

test "" {
    const constant_export_count = 0;
    const type_export_count = 61;
    const func_count = 229;
    const unicode_alias_count = 65;
    const type_import_count = 22;
    @setEvalBranchQuota(0
        + constant_export_count
        + type_export_count
        + func_count
        + unicode_alias_count
        + type_import_count
        + 2 // TODO: why do I need these extra 2?
    );
    @import("std").testing.refAllDecls(@This());
}
