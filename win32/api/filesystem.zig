//! NOTE: this source file is autogenerated, DO NOT MODIFY

//
// constants
//
pub const ClfsNullRecord : u8 = 0;
pub const ClfsDataRecord : u8 = 1;
pub const ClfsRestartRecord : u8 = 2;
pub const ClfsClientRecord : u8 = 3;
pub const ClsContainerInitializing : u32 = 1;
pub const ClsContainerInactive : u32 = 2;
pub const ClsContainerActive : u32 = 4;
pub const ClsContainerActivePendingDelete : u32 = 8;
pub const ClsContainerPendingArchive : u32 = 16;
pub const ClsContainerPendingArchiveAndDelete : u32 = 32;
pub const ClfsContainerInitializing : u32 = 1;
pub const ClfsContainerInactive : u32 = 2;
pub const ClfsContainerActive : u32 = 4;
pub const ClfsContainerActivePendingDelete : u32 = 8;
pub const ClfsContainerPendingArchive : u32 = 16;
pub const ClfsContainerPendingArchiveAndDelete : u32 = 32;
pub const CLFS_MAX_CONTAINER_INFO : u32 = 256;
pub const CLFS_SCAN_INIT : u8 = 1;
pub const CLFS_SCAN_FORWARD : u8 = 2;
pub const CLFS_SCAN_BACKWARD : u8 = 4;
pub const CLFS_SCAN_CLOSE : u8 = 8;
pub const CLFS_SCAN_INITIALIZED : u8 = 16;
pub const CLFS_SCAN_BUFFERED : u8 = 32;

//
// types
//
// --------------------------------------------------------
// Type: FIND_FIRST_EX_FLAGS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const FIND_FIRST_EX_FLAGS = *opaque{
};
// --------------------------------------------------------
// Type: FILE_NOTIFY_CHANGE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const FILE_NOTIFY_CHANGE = *opaque{
};
// --------------------------------------------------------
// Type: DEFINE_DOS_DEVICE_FLAGS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const DEFINE_DOS_DEVICE_FLAGS = *opaque{
};
// --------------------------------------------------------
// Type: FILE_CREATE_FLAGS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const FILE_CREATE_FLAGS = *opaque{
};
// --------------------------------------------------------
// Type: FILE_SHARE_FLAGS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const FILE_SHARE_FLAGS = *opaque{
};
// --------------------------------------------------------
// Type: FILE_FLAGS_AND_ATTRIBUTES
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const FILE_FLAGS_AND_ATTRIBUTES = *opaque{
};
// --------------------------------------------------------
// Type: FILE_ACCESS_FLAGS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const FILE_ACCESS_FLAGS = *opaque{
};
// --------------------------------------------------------
// Type: FindChangeNotifcationHandle
// TypeLayoutAttr: sequential
// RAIIFree 'FindCloseChangeNotification' (TODO: can we use this information?)
pub const FindChangeNotifcationHandle = ?*opaque{};
// --------------------------------------------------------
// Type: FindFileHandle
// TypeLayoutAttr: sequential
// RAIIFree 'FindClose' (TODO: can we use this information?)
pub const FindFileHandle = ?*opaque{};
// --------------------------------------------------------
// Type: FindFileNameHandle
// TypeLayoutAttr: sequential
// RAIIFree 'FindClose' (TODO: can we use this information?)
pub const FindFileNameHandle = ?*opaque{};
// --------------------------------------------------------
// Type: FindStreamHandle
// TypeLayoutAttr: sequential
// RAIIFree 'FindClose' (TODO: can we use this information?)
pub const FindStreamHandle = ?*opaque{};
// --------------------------------------------------------
// Type: FindVolumeHandle
// TypeLayoutAttr: sequential
// RAIIFree 'FindVolumeClose' (TODO: can we use this information?)
pub const FindVolumeHandle = ?*opaque{};
// --------------------------------------------------------
// Type: FindVolumeMointPointHandle
// TypeLayoutAttr: sequential
// RAIIFree 'FindVolumeMountPointClose' (TODO: can we use this information?)
pub const FindVolumeMointPointHandle = ?*opaque{};
// --------------------------------------------------------
// Type: FILE_ID_128
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const FILE_ID_128 = extern struct {
    Identifier: ?[*]u8,
};
// --------------------------------------------------------
// Type: FILE_NOTIFY_INFORMATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const FILE_NOTIFY_INFORMATION = extern struct {
    NextEntryOffset: u32,
    Action: u32,
    FileNameLength: u32,
    FileName: ?[*]u16,
};
// --------------------------------------------------------
// Type: FILE_NOTIFY_EXTENDED_INFORMATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const FILE_NOTIFY_EXTENDED_INFORMATION = extern struct {
    NextEntryOffset: u32,
    Action: u32,
    CreationTime: LARGE_INTEGER,
    LastModificationTime: LARGE_INTEGER,
    LastChangeTime: LARGE_INTEGER,
    LastAccessTime: LARGE_INTEGER,
    AllocatedLength: LARGE_INTEGER,
    FileSize: LARGE_INTEGER,
    FileAttributes: u32,
    ReparsePointTag: u32,
    FileId: LARGE_INTEGER,
    ParentFileId: LARGE_INTEGER,
    FileNameLength: u32,
    FileName: ?[*]u16,
};
// --------------------------------------------------------
// Type: REPARSE_GUID_DATA_BUFFER
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const REPARSE_GUID_DATA_BUFFER = extern struct {
    ReparseTag: u32,
    ReparseDataLength: u16,
    Reserved: u16,
    ReparseGuid: Guid,
    GenericReparseBuffer: _GenericReparseBuffer_e__Struct,
    // --------------------------------------------------------
    // Type: _GenericReparseBuffer_e__Struct
    // TypeLayoutAttr: sequential
    // TODO: I think this is a struct, but not sure at this point, assuming it is for now
    pub const _GenericReparseBuffer_e__Struct = extern struct {
        DataBuffer: ?[*]u8,
    };
};
// --------------------------------------------------------
// Type: TRANSACTION_OUTCOME
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const TRANSACTION_OUTCOME = *opaque{
};
// --------------------------------------------------------
// Type: OVERLAPPED_ENTRY
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const OVERLAPPED_ENTRY = extern struct {
    lpCompletionKey: ?*opaque{},
    lpOverlapped: ?*OVERLAPPED,
    Internal: ?*opaque{},
    dwNumberOfBytesTransferred: u32,
};
// --------------------------------------------------------
// Type: WIN32_FIND_DATAA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const WIN32_FIND_DATAA = extern struct {
    dwFileAttributes: u32,
    ftCreationTime: FILETIME,
    ftLastAccessTime: FILETIME,
    ftLastWriteTime: FILETIME,
    nFileSizeHigh: u32,
    nFileSizeLow: u32,
    dwReserved0: u32,
    dwReserved1: u32,
    cFileName: ?[*]i8,
    cAlternateFileName: ?[*]i8,
};
// --------------------------------------------------------
// Type: WIN32_FIND_DATAW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const WIN32_FIND_DATAW = extern struct {
    dwFileAttributes: u32,
    ftCreationTime: FILETIME,
    ftLastAccessTime: FILETIME,
    ftLastWriteTime: FILETIME,
    nFileSizeHigh: u32,
    nFileSizeLow: u32,
    dwReserved0: u32,
    dwReserved1: u32,
    cFileName: ?[*]u16,
    cAlternateFileName: ?[*]u16,
};
// --------------------------------------------------------
// Type: FINDEX_INFO_LEVELS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const FINDEX_INFO_LEVELS = *opaque{
};
// --------------------------------------------------------
// Type: FINDEX_SEARCH_OPS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const FINDEX_SEARCH_OPS = *opaque{
};
// --------------------------------------------------------
// Type: READ_DIRECTORY_NOTIFY_INFORMATION_CLASS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const READ_DIRECTORY_NOTIFY_INFORMATION_CLASS = *opaque{
};
// --------------------------------------------------------
// Type: GET_FILEEX_INFO_LEVELS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const GET_FILEEX_INFO_LEVELS = *opaque{
};
// --------------------------------------------------------
// Type: FILE_INFO_BY_HANDLE_CLASS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const FILE_INFO_BY_HANDLE_CLASS = *opaque{
};
// --------------------------------------------------------
// Type: LPOVERLAPPED_COMPLETION_ROUTINE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const LPOVERLAPPED_COMPLETION_ROUTINE = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: STORAGE_QUERY_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const STORAGE_QUERY_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: STORAGE_PROPERTY_ID
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const STORAGE_PROPERTY_ID = *opaque{
};
// --------------------------------------------------------
// Type: STORAGE_PROPERTY_QUERY
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const STORAGE_PROPERTY_QUERY = extern struct {
    PropertyId: STORAGE_PROPERTY_ID,
    QueryType: STORAGE_QUERY_TYPE,
    AdditionalParameters: ?[*]u8,
};
// --------------------------------------------------------
// Type: STORAGE_DESCRIPTOR_HEADER
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const STORAGE_DESCRIPTOR_HEADER = extern struct {
    Version: u32,
    Size: u32,
};
// --------------------------------------------------------
// Type: STORAGE_DEVICE_DESCRIPTOR
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const STORAGE_DEVICE_DESCRIPTOR = extern struct {
    Version: u32,
    Size: u32,
    DeviceType: u8,
    DeviceTypeModifier: u8,
    RemovableMedia: u8,
    CommandQueueing: u8,
    VendorIdOffset: u32,
    ProductIdOffset: u32,
    ProductRevisionOffset: u32,
    SerialNumberOffset: u32,
    BusType: STORAGE_BUS_TYPE,
    RawPropertiesLength: u32,
    RawDeviceProperties: ?[*]u8,
};
// --------------------------------------------------------
// Type: STORAGE_ADAPTER_DESCRIPTOR
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const STORAGE_ADAPTER_DESCRIPTOR = extern struct {
    Version: u32,
    Size: u32,
    MaximumTransferLength: u32,
    MaximumPhysicalPages: u32,
    AlignmentMask: u32,
    AdapterUsesPio: u8,
    AdapterScansDown: u8,
    CommandQueueing: u8,
    AcceleratedTransfer: u8,
    BusType: u8,
    BusMajorVersion: u16,
    BusMinorVersion: u16,
    SrbType: u8,
    AddressType: u8,
};
// --------------------------------------------------------
// Type: STORAGE_ACCESS_ALIGNMENT_DESCRIPTOR
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const STORAGE_ACCESS_ALIGNMENT_DESCRIPTOR = extern struct {
    Version: u32,
    Size: u32,
    BytesPerCacheLine: u32,
    BytesOffsetForCacheAlignment: u32,
    BytesPerLogicalSector: u32,
    BytesPerPhysicalSector: u32,
    BytesOffsetForSectorAlignment: u32,
};
// --------------------------------------------------------
// Type: STORAGE_MEDIUM_PRODUCT_TYPE_DESCRIPTOR
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const STORAGE_MEDIUM_PRODUCT_TYPE_DESCRIPTOR = extern struct {
    Version: u32,
    Size: u32,
    MediumProductType: u32,
};
// --------------------------------------------------------
// Type: STORAGE_PORT_CODE_SET
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const STORAGE_PORT_CODE_SET = *opaque{
};
// --------------------------------------------------------
// Type: STORAGE_MINIPORT_DESCRIPTOR
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const STORAGE_MINIPORT_DESCRIPTOR = extern struct {
    Version: u32,
    Size: u32,
    Portdriver: STORAGE_PORT_CODE_SET,
    LUNResetSupported: u8,
    TargetResetSupported: u8,
    IoTimeoutValue: u16,
    ExtraIoInfoSupported: u8,
    Reserved0: ?[*]u8,
    Reserved1: u32,
};
// --------------------------------------------------------
// Type: STORAGE_DEVICE_ID_DESCRIPTOR
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const STORAGE_DEVICE_ID_DESCRIPTOR = extern struct {
    Version: u32,
    Size: u32,
    NumberOfIdentifiers: u32,
    Identifiers: ?[*]u8,
};
// --------------------------------------------------------
// Type: DEVICE_SEEK_PENALTY_DESCRIPTOR
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DEVICE_SEEK_PENALTY_DESCRIPTOR = extern struct {
    Version: u32,
    Size: u32,
    IncursSeekPenalty: u8,
};
// --------------------------------------------------------
// Type: DEVICE_WRITE_AGGREGATION_DESCRIPTOR
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DEVICE_WRITE_AGGREGATION_DESCRIPTOR = extern struct {
    Version: u32,
    Size: u32,
    BenefitsFromWriteAggregation: u8,
};
// --------------------------------------------------------
// Type: DEVICE_TRIM_DESCRIPTOR
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DEVICE_TRIM_DESCRIPTOR = extern struct {
    Version: u32,
    Size: u32,
    TrimEnabled: u8,
};
// --------------------------------------------------------
// Type: DEVICE_LB_PROVISIONING_DESCRIPTOR
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DEVICE_LB_PROVISIONING_DESCRIPTOR = extern struct {
    Version: u32,
    Size: u32,
    _bitfield: u8,
    Reserved1: ?[*]u8,
    OptimalUnmapGranularity: u64,
    UnmapGranularityAlignment: u64,
    MaxUnmapLbaCount: u32,
    MaxUnmapBlockDescriptorCount: u32,
};
// --------------------------------------------------------
// Type: DEVICE_POWER_DESCRIPTOR
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DEVICE_POWER_DESCRIPTOR = extern struct {
    Version: u32,
    Size: u32,
    DeviceAttentionSupported: u8,
    AsynchronousNotificationSupported: u8,
    IdlePowerManagementEnabled: u8,
    D3ColdEnabled: u8,
    D3ColdSupported: u8,
    NoVerifyDuringIdlePower: u8,
    Reserved: ?[*]u8,
    IdleTimeoutInMS: u32,
};
// --------------------------------------------------------
// Type: DEVICE_COPY_OFFLOAD_DESCRIPTOR
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DEVICE_COPY_OFFLOAD_DESCRIPTOR = extern struct {
    Version: u32,
    Size: u32,
    MaximumTokenLifetime: u32,
    DefaultTokenLifetime: u32,
    MaximumTransferSize: u64,
    OptimalTransferCount: u64,
    MaximumDataDescriptors: u32,
    MaximumTransferLengthPerDescriptor: u32,
    OptimalTransferLengthPerDescriptor: u32,
    OptimalTransferLengthGranularity: u16,
    Reserved: ?[*]u8,
};
// --------------------------------------------------------
// Type: STORAGE_DEVICE_RESILIENCY_DESCRIPTOR
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const STORAGE_DEVICE_RESILIENCY_DESCRIPTOR = extern struct {
    Version: u32,
    Size: u32,
    NameOffset: u32,
    NumberOfLogicalCopies: u32,
    NumberOfPhysicalCopies: u32,
    PhysicalDiskRedundancy: u32,
    NumberOfColumns: u32,
    Interleave: u32,
};
// --------------------------------------------------------
// Type: STORAGE_PROTOCOL_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const STORAGE_PROTOCOL_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: STORAGE_PROTOCOL_NVME_DATA_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const STORAGE_PROTOCOL_NVME_DATA_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: STORAGE_PROTOCOL_ATA_DATA_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const STORAGE_PROTOCOL_ATA_DATA_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: STORAGE_PROTOCOL_SPECIFIC_DATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const STORAGE_PROTOCOL_SPECIFIC_DATA = extern struct {
    ProtocolType: STORAGE_PROTOCOL_TYPE,
    DataType: u32,
    ProtocolDataRequestValue: u32,
    ProtocolDataRequestSubValue: u32,
    ProtocolDataOffset: u32,
    ProtocolDataLength: u32,
    FixedProtocolReturnData: u32,
    ProtocolDataRequestSubValue2: u32,
    ProtocolDataRequestSubValue3: u32,
    Reserved: u32,
};
// --------------------------------------------------------
// Type: STORAGE_PROTOCOL_DATA_DESCRIPTOR
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const STORAGE_PROTOCOL_DATA_DESCRIPTOR = extern struct {
    Version: u32,
    Size: u32,
    ProtocolSpecificData: STORAGE_PROTOCOL_SPECIFIC_DATA,
};
// --------------------------------------------------------
// Type: STORAGE_TEMPERATURE_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const STORAGE_TEMPERATURE_INFO = extern struct {
    Index: u16,
    Temperature: i16,
    OverThreshold: i16,
    UnderThreshold: i16,
    OverThresholdChangable: u8,
    UnderThresholdChangable: u8,
    EventGenerated: u8,
    Reserved0: u8,
    Reserved1: u32,
};
// --------------------------------------------------------
// Type: STORAGE_TEMPERATURE_DATA_DESCRIPTOR
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const STORAGE_TEMPERATURE_DATA_DESCRIPTOR = extern struct {
    Version: u32,
    Size: u32,
    CriticalTemperature: i16,
    WarningTemperature: i16,
    InfoCount: u16,
    Reserved0: ?[*]u8,
    Reserved1: ?[*]u32,
    TemperatureInfo: ?[*]STORAGE_TEMPERATURE_INFO,
};
// --------------------------------------------------------
// Type: STORAGE_TEMPERATURE_THRESHOLD
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const STORAGE_TEMPERATURE_THRESHOLD = extern struct {
    Version: u32,
    Size: u32,
    Flags: u16,
    Index: u16,
    Threshold: i16,
    OverThreshold: u8,
    Reserved: u8,
};
// --------------------------------------------------------
// Type: STORAGE_DEVICE_FORM_FACTOR
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const STORAGE_DEVICE_FORM_FACTOR = *opaque{
};
// --------------------------------------------------------
// Type: STORAGE_COMPONENT_HEALTH_STATUS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const STORAGE_COMPONENT_HEALTH_STATUS = *opaque{
};
// --------------------------------------------------------
// Type: STORAGE_SPEC_VERSION
// TypeLayoutAttr: explicit
// not generating the actual code for this type because it has an explicit layout
pub const STORAGE_SPEC_VERSION = *opaque{
    // --------------------------------------------------------
    // Type: _Anonymous_e__Struct
    // TypeLayoutAttr: sequential
    // TODO: I think this is a struct, but not sure at this point, assuming it is for now
    pub const _Anonymous_e__Struct = extern struct {
        MinorVersion: _MinorVersion_e__Union,
        MajorVersion: u16,
        // --------------------------------------------------------
        // Type: _MinorVersion_e__Union
        // TypeLayoutAttr: explicit
        // not generating the actual code for this type because it has an explicit layout
        pub const _MinorVersion_e__Union = *opaque{
            // --------------------------------------------------------
            // Type: _Anonymous_e__Struct
            // TypeLayoutAttr: sequential
            // TODO: I think this is a struct, but not sure at this point, assuming it is for now
            pub const _Anonymous_e__Struct = extern struct {
                SubMinor: u8,
                Minor: u8,
            };
        };
    };
};
// --------------------------------------------------------
// Type: STORAGE_PHYSICAL_DEVICE_DATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const STORAGE_PHYSICAL_DEVICE_DATA = extern struct {
    DeviceId: u32,
    Role: u32,
    HealthStatus: STORAGE_COMPONENT_HEALTH_STATUS,
    CommandProtocol: STORAGE_PROTOCOL_TYPE,
    SpecVersion: STORAGE_SPEC_VERSION,
    FormFactor: STORAGE_DEVICE_FORM_FACTOR,
    Vendor: ?[*]u8,
    Model: ?[*]u8,
    FirmwareRevision: ?[*]u8,
    Capacity: u64,
    PhysicalLocation: ?[*]u8,
    Reserved: ?[*]u32,
};
// --------------------------------------------------------
// Type: STORAGE_PHYSICAL_ADAPTER_DATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const STORAGE_PHYSICAL_ADAPTER_DATA = extern struct {
    AdapterId: u32,
    HealthStatus: STORAGE_COMPONENT_HEALTH_STATUS,
    CommandProtocol: STORAGE_PROTOCOL_TYPE,
    SpecVersion: STORAGE_SPEC_VERSION,
    Vendor: ?[*]u8,
    Model: ?[*]u8,
    FirmwareRevision: ?[*]u8,
    PhysicalLocation: ?[*]u8,
    ExpanderConnected: u8,
    Reserved0: ?[*]u8,
    Reserved1: ?[*]u32,
};
// --------------------------------------------------------
// Type: STORAGE_PHYSICAL_NODE_DATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const STORAGE_PHYSICAL_NODE_DATA = extern struct {
    NodeId: u32,
    AdapterCount: u32,
    AdapterDataLength: u32,
    AdapterDataOffset: u32,
    DeviceCount: u32,
    DeviceDataLength: u32,
    DeviceDataOffset: u32,
    Reserved: ?[*]u32,
};
// --------------------------------------------------------
// Type: STORAGE_PHYSICAL_TOPOLOGY_DESCRIPTOR
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const STORAGE_PHYSICAL_TOPOLOGY_DESCRIPTOR = extern struct {
    Version: u32,
    Size: u32,
    NodeCount: u32,
    Reserved: u32,
    Node: ?[*]STORAGE_PHYSICAL_NODE_DATA,
};
// --------------------------------------------------------
// Type: STORAGE_DEVICE_IO_CAPABILITY_DESCRIPTOR
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const STORAGE_DEVICE_IO_CAPABILITY_DESCRIPTOR = extern struct {
    Version: u32,
    Size: u32,
    LunMaxIoCount: u32,
    AdapterMaxIoCount: u32,
};
// --------------------------------------------------------
// Type: STORAGE_DEVICE_ATTRIBUTES_DESCRIPTOR
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const STORAGE_DEVICE_ATTRIBUTES_DESCRIPTOR = extern struct {
    Version: u32,
    Size: u32,
    Attributes: u64,
};
// --------------------------------------------------------
// Type: STORAGE_ADAPTER_SERIAL_NUMBER
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const STORAGE_ADAPTER_SERIAL_NUMBER = extern struct {
    Version: u32,
    Size: u32,
    SerialNumber: ?[*]u16,
};
// --------------------------------------------------------
// Type: WRITE_CACHE_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const WRITE_CACHE_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: WRITE_CACHE_ENABLE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const WRITE_CACHE_ENABLE = *opaque{
};
// --------------------------------------------------------
// Type: WRITE_CACHE_CHANGE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const WRITE_CACHE_CHANGE = *opaque{
};
// --------------------------------------------------------
// Type: WRITE_THROUGH
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const WRITE_THROUGH = *opaque{
};
// --------------------------------------------------------
// Type: STORAGE_WRITE_CACHE_PROPERTY
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const STORAGE_WRITE_CACHE_PROPERTY = extern struct {
    Version: u32,
    Size: u32,
    WriteCacheType: WRITE_CACHE_TYPE,
    WriteCacheEnabled: WRITE_CACHE_ENABLE,
    WriteCacheChangeable: WRITE_CACHE_CHANGE,
    WriteThroughSupported: WRITE_THROUGH,
    FlushCacheSupported: u8,
    UserDefinedPowerProtection: u8,
    NVCacheEnabled: u8,
};
// --------------------------------------------------------
// Type: STORAGE_DEVICE_POWER_CAP_UNITS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const STORAGE_DEVICE_POWER_CAP_UNITS = *opaque{
};
// --------------------------------------------------------
// Type: STORAGE_DEVICE_POWER_CAP
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const STORAGE_DEVICE_POWER_CAP = extern struct {
    Version: u32,
    Size: u32,
    Units: STORAGE_DEVICE_POWER_CAP_UNITS,
    MaxPower: u64,
};
// --------------------------------------------------------
// Type: STORAGE_HW_FIRMWARE_DOWNLOAD
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const STORAGE_HW_FIRMWARE_DOWNLOAD = extern struct {
    Version: u32,
    Size: u32,
    Flags: u32,
    Slot: u8,
    Reserved: ?[*]u8,
    Offset: u64,
    BufferSize: u64,
    ImageBuffer: ?[*]u8,
};
// --------------------------------------------------------
// Type: STORAGE_HW_FIRMWARE_ACTIVATE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const STORAGE_HW_FIRMWARE_ACTIVATE = extern struct {
    Version: u32,
    Size: u32,
    Flags: u32,
    Slot: u8,
    Reserved0: ?[*]u8,
};
// --------------------------------------------------------
// Type: STORAGE_PROTOCOL_COMMAND
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const STORAGE_PROTOCOL_COMMAND = extern struct {
    Version: u32,
    Length: u32,
    ProtocolType: STORAGE_PROTOCOL_TYPE,
    Flags: u32,
    ReturnStatus: u32,
    ErrorCode: u32,
    CommandLength: u32,
    ErrorInfoLength: u32,
    DataToDeviceTransferLength: u32,
    DataFromDeviceTransferLength: u32,
    TimeOutValue: u32,
    ErrorInfoOffset: u32,
    DataToDeviceBufferOffset: u32,
    DataFromDeviceBufferOffset: u32,
    CommandSpecific: u32,
    Reserved0: u32,
    FixedProtocolReturnData: u32,
    Reserved1: ?[*]u32,
    Command: ?[*]u8,
};
// --------------------------------------------------------
// Type: MEDIA_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const MEDIA_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: FORMAT_PARAMETERS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const FORMAT_PARAMETERS = extern struct {
    MediaType: MEDIA_TYPE,
    StartCylinderNumber: u32,
    EndCylinderNumber: u32,
    StartHeadNumber: u32,
    EndHeadNumber: u32,
};
// --------------------------------------------------------
// Type: FORMAT_EX_PARAMETERS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const FORMAT_EX_PARAMETERS = extern struct {
    MediaType: MEDIA_TYPE,
    StartCylinderNumber: u32,
    EndCylinderNumber: u32,
    StartHeadNumber: u32,
    EndHeadNumber: u32,
    FormatGapLength: u16,
    SectorsPerTrack: u16,
    SectorNumber: ?[*]u16,
};
// --------------------------------------------------------
// Type: DISK_GEOMETRY
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DISK_GEOMETRY = extern struct {
    Cylinders: LARGE_INTEGER,
    MediaType: MEDIA_TYPE,
    TracksPerCylinder: u32,
    SectorsPerTrack: u32,
    BytesPerSector: u32,
};
// --------------------------------------------------------
// Type: PARTITION_INFORMATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PARTITION_INFORMATION = extern struct {
    StartingOffset: LARGE_INTEGER,
    PartitionLength: LARGE_INTEGER,
    HiddenSectors: u32,
    PartitionNumber: u32,
    PartitionType: u8,
    BootIndicator: u8,
    RecognizedPartition: u8,
    RewritePartition: u8,
};
// --------------------------------------------------------
// Type: SET_PARTITION_INFORMATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SET_PARTITION_INFORMATION = extern struct {
    PartitionType: u8,
};
// --------------------------------------------------------
// Type: DRIVE_LAYOUT_INFORMATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DRIVE_LAYOUT_INFORMATION = extern struct {
    PartitionCount: u32,
    Signature: u32,
    PartitionEntry: ?[*]PARTITION_INFORMATION,
};
// --------------------------------------------------------
// Type: VERIFY_INFORMATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VERIFY_INFORMATION = extern struct {
    StartingOffset: LARGE_INTEGER,
    Length: u32,
};
// --------------------------------------------------------
// Type: REASSIGN_BLOCKS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const REASSIGN_BLOCKS = extern struct {
    Reserved: u16,
    Count: u16,
    BlockNumber: ?[*]u32,
};
// --------------------------------------------------------
// Type: REASSIGN_BLOCKS_EX
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const REASSIGN_BLOCKS_EX = *opaque{
};
// --------------------------------------------------------
// Type: PARTITION_STYLE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PARTITION_STYLE = *opaque{
};
// --------------------------------------------------------
// Type: PARTITION_INFORMATION_GPT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PARTITION_INFORMATION_GPT = extern struct {
    PartitionType: Guid,
    PartitionId: Guid,
    Attributes: u64,
    Name: ?[*]u16,
};
// --------------------------------------------------------
// Type: PARTITION_INFORMATION_MBR
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PARTITION_INFORMATION_MBR = extern struct {
    PartitionType: u8,
    BootIndicator: u8,
    RecognizedPartition: u8,
    HiddenSectors: u32,
    PartitionId: Guid,
};
// --------------------------------------------------------
// Type: CREATE_DISK_GPT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CREATE_DISK_GPT = extern struct {
    DiskId: Guid,
    MaxPartitionCount: u32,
};
// --------------------------------------------------------
// Type: CREATE_DISK_MBR
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CREATE_DISK_MBR = extern struct {
    Signature: u32,
};
// --------------------------------------------------------
// Type: CREATE_DISK
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CREATE_DISK = extern struct {
    PartitionStyle: PARTITION_STYLE,
    Anonymous: _Anonymous_e__Union,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: GET_LENGTH_INFORMATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const GET_LENGTH_INFORMATION = extern struct {
    Length: LARGE_INTEGER,
};
// --------------------------------------------------------
// Type: PARTITION_INFORMATION_EX
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PARTITION_INFORMATION_EX = extern struct {
    PartitionStyle: PARTITION_STYLE,
    StartingOffset: LARGE_INTEGER,
    PartitionLength: LARGE_INTEGER,
    PartitionNumber: u32,
    RewritePartition: u8,
    IsServicePartition: u8,
    Anonymous: _Anonymous_e__Union,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: DRIVE_LAYOUT_INFORMATION_GPT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DRIVE_LAYOUT_INFORMATION_GPT = extern struct {
    DiskId: Guid,
    StartingUsableOffset: LARGE_INTEGER,
    UsableLength: LARGE_INTEGER,
    MaxPartitionCount: u32,
};
// --------------------------------------------------------
// Type: DRIVE_LAYOUT_INFORMATION_MBR
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DRIVE_LAYOUT_INFORMATION_MBR = extern struct {
    Signature: u32,
    CheckSum: u32,
};
// --------------------------------------------------------
// Type: DRIVE_LAYOUT_INFORMATION_EX
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DRIVE_LAYOUT_INFORMATION_EX = extern struct {
    PartitionStyle: u32,
    PartitionCount: u32,
    Anonymous: _Anonymous_e__Union,
    PartitionEntry: ?[*]PARTITION_INFORMATION_EX,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: DISK_INT13_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DISK_INT13_INFO = extern struct {
    DriveSelect: u16,
    MaxCylinders: u32,
    SectorsPerTrack: u16,
    MaxHeads: u16,
    NumberDrives: u16,
};
// --------------------------------------------------------
// Type: DISK_EX_INT13_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DISK_EX_INT13_INFO = extern struct {
    ExBufferSize: u16,
    ExFlags: u16,
    ExCylinders: u32,
    ExHeads: u32,
    ExSectorsPerTrack: u32,
    ExSectorsPerDrive: u64,
    ExSectorSize: u16,
    ExReserved: u16,
};
// --------------------------------------------------------
// Type: DISK_DETECTION_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DISK_DETECTION_INFO = extern struct {
    SizeOfDetectInfo: u32,
    DetectionType: DETECTION_TYPE,
    Anonymous: _Anonymous_e__Union,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
        // --------------------------------------------------------
        // Type: _Anonymous_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _Anonymous_e__Struct = extern struct {
            Int13: DISK_INT13_INFO,
            ExInt13: DISK_EX_INT13_INFO,
        };
    };
};
// --------------------------------------------------------
// Type: DISK_PARTITION_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DISK_PARTITION_INFO = extern struct {
    SizeOfPartitionInfo: u32,
    PartitionStyle: PARTITION_STYLE,
    Anonymous: _Anonymous_e__Union,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
        // --------------------------------------------------------
        // Type: _Mbr_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _Mbr_e__Struct = extern struct {
            Signature: u32,
            CheckSum: u32,
        };
        // --------------------------------------------------------
        // Type: _Gpt_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _Gpt_e__Struct = extern struct {
            DiskId: Guid,
        };
    };
};
// --------------------------------------------------------
// Type: DISK_GEOMETRY_EX
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DISK_GEOMETRY_EX = extern struct {
    Geometry: DISK_GEOMETRY,
    DiskSize: LARGE_INTEGER,
    Data: ?[*]u8,
};
// --------------------------------------------------------
// Type: DISK_CACHE_INFORMATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DISK_CACHE_INFORMATION = extern struct {
    ParametersSavable: u8,
    ReadCacheEnabled: u8,
    WriteCacheEnabled: u8,
    ReadRetentionPriority: DISK_CACHE_RETENTION_PRIORITY,
    WriteRetentionPriority: DISK_CACHE_RETENTION_PRIORITY,
    DisablePrefetchTransferLength: u16,
    PrefetchScalar: u8,
    Anonymous: _Anonymous_e__Union,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
        // --------------------------------------------------------
        // Type: _ScalarPrefetch_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _ScalarPrefetch_e__Struct = extern struct {
            Minimum: u16,
            Maximum: u16,
            MaximumBlocks: u16,
        };
        // --------------------------------------------------------
        // Type: _BlockPrefetch_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _BlockPrefetch_e__Struct = extern struct {
            Minimum: u16,
            Maximum: u16,
        };
    };
};
// --------------------------------------------------------
// Type: DISK_GROW_PARTITION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DISK_GROW_PARTITION = extern struct {
    PartitionNumber: u32,
    BytesToGrow: LARGE_INTEGER,
};
// --------------------------------------------------------
// Type: DISK_PERFORMANCE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DISK_PERFORMANCE = extern struct {
    BytesRead: LARGE_INTEGER,
    BytesWritten: LARGE_INTEGER,
    ReadTime: LARGE_INTEGER,
    WriteTime: LARGE_INTEGER,
    IdleTime: LARGE_INTEGER,
    ReadCount: u32,
    WriteCount: u32,
    QueueDepth: u32,
    SplitCount: u32,
    QueryTime: LARGE_INTEGER,
    StorageDeviceNumber: u32,
    StorageManagerName: ?[*]u16,
};
// --------------------------------------------------------
// Type: GET_DISK_ATTRIBUTES
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const GET_DISK_ATTRIBUTES = extern struct {
    Version: u32,
    Reserved1: u32,
    Attributes: u64,
};
// --------------------------------------------------------
// Type: SET_DISK_ATTRIBUTES
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SET_DISK_ATTRIBUTES = extern struct {
    Version: u32,
    Persist: u8,
    Reserved1: ?[*]u8,
    Attributes: u64,
    AttributesMask: u64,
    Reserved2: ?[*]u32,
};
// --------------------------------------------------------
// Type: NTFS_VOLUME_DATA_BUFFER
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NTFS_VOLUME_DATA_BUFFER = extern struct {
    VolumeSerialNumber: LARGE_INTEGER,
    NumberSectors: LARGE_INTEGER,
    TotalClusters: LARGE_INTEGER,
    FreeClusters: LARGE_INTEGER,
    TotalReserved: LARGE_INTEGER,
    BytesPerSector: u32,
    BytesPerCluster: u32,
    BytesPerFileRecordSegment: u32,
    ClustersPerFileRecordSegment: u32,
    MftValidDataLength: LARGE_INTEGER,
    MftStartLcn: LARGE_INTEGER,
    Mft2StartLcn: LARGE_INTEGER,
    MftZoneStart: LARGE_INTEGER,
    MftZoneEnd: LARGE_INTEGER,
};
// --------------------------------------------------------
// Type: NTFS_EXTENDED_VOLUME_DATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NTFS_EXTENDED_VOLUME_DATA = extern struct {
    ByteCount: u32,
    MajorVersion: u16,
    MinorVersion: u16,
    BytesPerPhysicalSector: u32,
    LfsMajorVersion: u16,
    LfsMinorVersion: u16,
    MaxDeviceTrimExtentCount: u32,
    MaxDeviceTrimByteCount: u32,
    MaxVolumeTrimExtentCount: u32,
    MaxVolumeTrimByteCount: u32,
};
// --------------------------------------------------------
// Type: STARTING_LCN_INPUT_BUFFER
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const STARTING_LCN_INPUT_BUFFER = extern struct {
    StartingLcn: LARGE_INTEGER,
};
// --------------------------------------------------------
// Type: VOLUME_BITMAP_BUFFER
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VOLUME_BITMAP_BUFFER = extern struct {
    StartingLcn: LARGE_INTEGER,
    BitmapSize: LARGE_INTEGER,
    Buffer: ?[*]u8,
};
// --------------------------------------------------------
// Type: STARTING_VCN_INPUT_BUFFER
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const STARTING_VCN_INPUT_BUFFER = extern struct {
    StartingVcn: LARGE_INTEGER,
};
// --------------------------------------------------------
// Type: RETRIEVAL_POINTERS_BUFFER
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const RETRIEVAL_POINTERS_BUFFER = extern struct {
    ExtentCount: u32,
    StartingVcn: LARGE_INTEGER,
    Extents: ?[*]_Anonymous_e__Struct,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Struct
    // TypeLayoutAttr: sequential
    // TODO: I think this is a struct, but not sure at this point, assuming it is for now
    pub const _Anonymous_e__Struct = extern struct {
        NextVcn: LARGE_INTEGER,
        Lcn: LARGE_INTEGER,
    };
};
// --------------------------------------------------------
// Type: NTFS_FILE_RECORD_INPUT_BUFFER
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NTFS_FILE_RECORD_INPUT_BUFFER = extern struct {
    FileReferenceNumber: LARGE_INTEGER,
};
// --------------------------------------------------------
// Type: NTFS_FILE_RECORD_OUTPUT_BUFFER
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NTFS_FILE_RECORD_OUTPUT_BUFFER = extern struct {
    FileReferenceNumber: LARGE_INTEGER,
    FileRecordLength: u32,
    FileRecordBuffer: ?[*]u8,
};
// --------------------------------------------------------
// Type: MOVE_FILE_DATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const MOVE_FILE_DATA = extern struct {
    FileHandle: HANDLE,
    StartingVcn: LARGE_INTEGER,
    StartingLcn: LARGE_INTEGER,
    ClusterCount: u32,
};
// --------------------------------------------------------
// Type: FIND_BY_SID_DATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const FIND_BY_SID_DATA = extern struct {
    Restart: u32,
    Sid: SID,
};
// --------------------------------------------------------
// Type: FIND_BY_SID_OUTPUT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const FIND_BY_SID_OUTPUT = extern struct {
    NextEntryOffset: u32,
    FileIndex: u32,
    FileNameLength: u32,
    FileName: ?[*]u16,
};
// --------------------------------------------------------
// Type: MFT_ENUM_DATA_V0
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const MFT_ENUM_DATA_V0 = extern struct {
    StartFileReferenceNumber: u64,
    LowUsn: i64,
    HighUsn: i64,
};
// --------------------------------------------------------
// Type: MFT_ENUM_DATA_V1
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const MFT_ENUM_DATA_V1 = extern struct {
    StartFileReferenceNumber: u64,
    LowUsn: i64,
    HighUsn: i64,
    MinMajorVersion: u16,
    MaxMajorVersion: u16,
};
// --------------------------------------------------------
// Type: CREATE_USN_JOURNAL_DATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CREATE_USN_JOURNAL_DATA = extern struct {
    MaximumSize: u64,
    AllocationDelta: u64,
};
// --------------------------------------------------------
// Type: READ_FILE_USN_DATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const READ_FILE_USN_DATA = extern struct {
    MinMajorVersion: u16,
    MaxMajorVersion: u16,
};
// --------------------------------------------------------
// Type: READ_USN_JOURNAL_DATA_V0
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const READ_USN_JOURNAL_DATA_V0 = extern struct {
    StartUsn: i64,
    ReasonMask: u32,
    ReturnOnlyOnClose: u32,
    Timeout: u64,
    BytesToWaitFor: u64,
    UsnJournalID: u64,
};
// --------------------------------------------------------
// Type: READ_USN_JOURNAL_DATA_V1
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const READ_USN_JOURNAL_DATA_V1 = extern struct {
    StartUsn: i64,
    ReasonMask: u32,
    ReturnOnlyOnClose: u32,
    Timeout: u64,
    BytesToWaitFor: u64,
    UsnJournalID: u64,
    MinMajorVersion: u16,
    MaxMajorVersion: u16,
};
// --------------------------------------------------------
// Type: USN_TRACK_MODIFIED_RANGES
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const USN_TRACK_MODIFIED_RANGES = extern struct {
    Flags: u32,
    Unused: u32,
    ChunkSize: u64,
    FileSizeThreshold: i64,
};
// --------------------------------------------------------
// Type: USN_RANGE_TRACK_OUTPUT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const USN_RANGE_TRACK_OUTPUT = extern struct {
    Usn: i64,
};
// --------------------------------------------------------
// Type: USN_RECORD_V2
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const USN_RECORD_V2 = extern struct {
    RecordLength: u32,
    MajorVersion: u16,
    MinorVersion: u16,
    FileReferenceNumber: u64,
    ParentFileReferenceNumber: u64,
    Usn: i64,
    TimeStamp: LARGE_INTEGER,
    Reason: u32,
    SourceInfo: u32,
    SecurityId: u32,
    FileAttributes: u32,
    FileNameLength: u16,
    FileNameOffset: u16,
    FileName: ?[*]u16,
};
// --------------------------------------------------------
// Type: USN_RECORD_V3
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const USN_RECORD_V3 = extern struct {
    RecordLength: u32,
    MajorVersion: u16,
    MinorVersion: u16,
    FileReferenceNumber: FILE_ID_128,
    ParentFileReferenceNumber: FILE_ID_128,
    Usn: i64,
    TimeStamp: LARGE_INTEGER,
    Reason: u32,
    SourceInfo: u32,
    SecurityId: u32,
    FileAttributes: u32,
    FileNameLength: u16,
    FileNameOffset: u16,
    FileName: ?[*]u16,
};
// --------------------------------------------------------
// Type: USN_RECORD_COMMON_HEADER
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const USN_RECORD_COMMON_HEADER = extern struct {
    RecordLength: u32,
    MajorVersion: u16,
    MinorVersion: u16,
};
// --------------------------------------------------------
// Type: USN_RECORD_EXTENT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const USN_RECORD_EXTENT = extern struct {
    Offset: i64,
    Length: i64,
};
// --------------------------------------------------------
// Type: USN_RECORD_V4
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const USN_RECORD_V4 = extern struct {
    Header: USN_RECORD_COMMON_HEADER,
    FileReferenceNumber: FILE_ID_128,
    ParentFileReferenceNumber: FILE_ID_128,
    Usn: i64,
    Reason: u32,
    SourceInfo: u32,
    RemainingExtents: u32,
    NumberOfExtents: u16,
    ExtentSize: u16,
    Extents: ?[*]USN_RECORD_EXTENT,
};
// --------------------------------------------------------
// Type: USN_JOURNAL_DATA_V0
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const USN_JOURNAL_DATA_V0 = extern struct {
    UsnJournalID: u64,
    FirstUsn: i64,
    NextUsn: i64,
    LowestValidUsn: i64,
    MaxUsn: i64,
    MaximumSize: u64,
    AllocationDelta: u64,
};
// --------------------------------------------------------
// Type: USN_JOURNAL_DATA_V1
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const USN_JOURNAL_DATA_V1 = extern struct {
    UsnJournalID: u64,
    FirstUsn: i64,
    NextUsn: i64,
    LowestValidUsn: i64,
    MaxUsn: i64,
    MaximumSize: u64,
    AllocationDelta: u64,
    MinSupportedMajorVersion: u16,
    MaxSupportedMajorVersion: u16,
};
// --------------------------------------------------------
// Type: USN_JOURNAL_DATA_V2
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const USN_JOURNAL_DATA_V2 = extern struct {
    UsnJournalID: u64,
    FirstUsn: i64,
    NextUsn: i64,
    LowestValidUsn: i64,
    MaxUsn: i64,
    MaximumSize: u64,
    AllocationDelta: u64,
    MinSupportedMajorVersion: u16,
    MaxSupportedMajorVersion: u16,
    Flags: u32,
    RangeTrackChunkSize: u64,
    RangeTrackFileSizeThreshold: i64,
};
// --------------------------------------------------------
// Type: DELETE_USN_JOURNAL_DATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DELETE_USN_JOURNAL_DATA = extern struct {
    UsnJournalID: u64,
    DeleteFlags: u32,
};
// --------------------------------------------------------
// Type: MARK_HANDLE_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const MARK_HANDLE_INFO = extern struct {
    Anonymous: _Anonymous_e__Union,
    VolumeHandle: HANDLE,
    HandleInfo: u32,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: FILESYSTEM_STATISTICS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const FILESYSTEM_STATISTICS = extern struct {
    FileSystemType: u16,
    Version: u16,
    SizeOfCompleteStructure: u32,
    UserFileReads: u32,
    UserFileReadBytes: u32,
    UserDiskReads: u32,
    UserFileWrites: u32,
    UserFileWriteBytes: u32,
    UserDiskWrites: u32,
    MetaDataReads: u32,
    MetaDataReadBytes: u32,
    MetaDataDiskReads: u32,
    MetaDataWrites: u32,
    MetaDataWriteBytes: u32,
    MetaDataDiskWrites: u32,
};
// --------------------------------------------------------
// Type: FAT_STATISTICS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const FAT_STATISTICS = extern struct {
    CreateHits: u32,
    SuccessfulCreates: u32,
    FailedCreates: u32,
    NonCachedReads: u32,
    NonCachedReadBytes: u32,
    NonCachedWrites: u32,
    NonCachedWriteBytes: u32,
    NonCachedDiskReads: u32,
    NonCachedDiskWrites: u32,
};
// --------------------------------------------------------
// Type: EXFAT_STATISTICS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const EXFAT_STATISTICS = extern struct {
    CreateHits: u32,
    SuccessfulCreates: u32,
    FailedCreates: u32,
    NonCachedReads: u32,
    NonCachedReadBytes: u32,
    NonCachedWrites: u32,
    NonCachedWriteBytes: u32,
    NonCachedDiskReads: u32,
    NonCachedDiskWrites: u32,
};
// --------------------------------------------------------
// Type: NTFS_STATISTICS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NTFS_STATISTICS = extern struct {
    LogFileFullExceptions: u32,
    OtherExceptions: u32,
    MftReads: u32,
    MftReadBytes: u32,
    MftWrites: u32,
    MftWriteBytes: u32,
    MftWritesUserLevel: _MftWritesUserLevel_e__Struct,
    MftWritesFlushForLogFileFull: u16,
    MftWritesLazyWriter: u16,
    MftWritesUserRequest: u16,
    Mft2Writes: u32,
    Mft2WriteBytes: u32,
    Mft2WritesUserLevel: _Mft2WritesUserLevel_e__Struct,
    Mft2WritesFlushForLogFileFull: u16,
    Mft2WritesLazyWriter: u16,
    Mft2WritesUserRequest: u16,
    RootIndexReads: u32,
    RootIndexReadBytes: u32,
    RootIndexWrites: u32,
    RootIndexWriteBytes: u32,
    BitmapReads: u32,
    BitmapReadBytes: u32,
    BitmapWrites: u32,
    BitmapWriteBytes: u32,
    BitmapWritesFlushForLogFileFull: u16,
    BitmapWritesLazyWriter: u16,
    BitmapWritesUserRequest: u16,
    BitmapWritesUserLevel: _BitmapWritesUserLevel_e__Struct,
    MftBitmapReads: u32,
    MftBitmapReadBytes: u32,
    MftBitmapWrites: u32,
    MftBitmapWriteBytes: u32,
    MftBitmapWritesFlushForLogFileFull: u16,
    MftBitmapWritesLazyWriter: u16,
    MftBitmapWritesUserRequest: u16,
    MftBitmapWritesUserLevel: _MftBitmapWritesUserLevel_e__Struct,
    UserIndexReads: u32,
    UserIndexReadBytes: u32,
    UserIndexWrites: u32,
    UserIndexWriteBytes: u32,
    LogFileReads: u32,
    LogFileReadBytes: u32,
    LogFileWrites: u32,
    LogFileWriteBytes: u32,
    Allocate: _Allocate_e__Struct,
    DiskResourcesExhausted: u32,
    // --------------------------------------------------------
    // Type: _Allocate_e__Struct
    // TypeLayoutAttr: sequential
    // TODO: I think this is a struct, but not sure at this point, assuming it is for now
    pub const _Allocate_e__Struct = extern struct {
        Calls: u32,
        Clusters: u32,
        Hints: u32,
        RunsReturned: u32,
        HintsHonored: u32,
        HintsClusters: u32,
        Cache: u32,
        CacheClusters: u32,
        CacheMiss: u32,
        CacheMissClusters: u32,
    };
    // --------------------------------------------------------
    // Type: _BitmapWritesUserLevel_e__Struct
    // TypeLayoutAttr: sequential
    // TODO: I think this is a struct, but not sure at this point, assuming it is for now
    pub const _BitmapWritesUserLevel_e__Struct = extern struct {
        Write: u16,
        Create: u16,
        SetInfo: u16,
    };
    // --------------------------------------------------------
    // Type: _MftWritesUserLevel_e__Struct
    // TypeLayoutAttr: sequential
    // TODO: I think this is a struct, but not sure at this point, assuming it is for now
    pub const _MftWritesUserLevel_e__Struct = extern struct {
        Write: u16,
        Create: u16,
        SetInfo: u16,
        Flush: u16,
    };
    // --------------------------------------------------------
    // Type: _MftBitmapWritesUserLevel_e__Struct
    // TypeLayoutAttr: sequential
    // TODO: I think this is a struct, but not sure at this point, assuming it is for now
    pub const _MftBitmapWritesUserLevel_e__Struct = extern struct {
        Write: u16,
        Create: u16,
        SetInfo: u16,
        Flush: u16,
    };
    // --------------------------------------------------------
    // Type: _Mft2WritesUserLevel_e__Struct
    // TypeLayoutAttr: sequential
    // TODO: I think this is a struct, but not sure at this point, assuming it is for now
    pub const _Mft2WritesUserLevel_e__Struct = extern struct {
        Write: u16,
        Create: u16,
        SetInfo: u16,
        Flush: u16,
    };
};
// --------------------------------------------------------
// Type: FILESYSTEM_STATISTICS_EX
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const FILESYSTEM_STATISTICS_EX = extern struct {
    FileSystemType: u16,
    Version: u16,
    SizeOfCompleteStructure: u32,
    UserFileReads: u64,
    UserFileReadBytes: u64,
    UserDiskReads: u64,
    UserFileWrites: u64,
    UserFileWriteBytes: u64,
    UserDiskWrites: u64,
    MetaDataReads: u64,
    MetaDataReadBytes: u64,
    MetaDataDiskReads: u64,
    MetaDataWrites: u64,
    MetaDataWriteBytes: u64,
    MetaDataDiskWrites: u64,
};
// --------------------------------------------------------
// Type: NTFS_STATISTICS_EX
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NTFS_STATISTICS_EX = extern struct {
    LogFileFullExceptions: u32,
    OtherExceptions: u32,
    MftReads: u64,
    MftReadBytes: u64,
    MftWrites: u64,
    MftWriteBytes: u64,
    MftWritesUserLevel: _MftWritesUserLevel_e__Struct,
    MftWritesFlushForLogFileFull: u32,
    MftWritesLazyWriter: u32,
    MftWritesUserRequest: u32,
    Mft2Writes: u64,
    Mft2WriteBytes: u64,
    Mft2WritesUserLevel: _Mft2WritesUserLevel_e__Struct,
    Mft2WritesFlushForLogFileFull: u32,
    Mft2WritesLazyWriter: u32,
    Mft2WritesUserRequest: u32,
    RootIndexReads: u64,
    RootIndexReadBytes: u64,
    RootIndexWrites: u64,
    RootIndexWriteBytes: u64,
    BitmapReads: u64,
    BitmapReadBytes: u64,
    BitmapWrites: u64,
    BitmapWriteBytes: u64,
    BitmapWritesFlushForLogFileFull: u32,
    BitmapWritesLazyWriter: u32,
    BitmapWritesUserRequest: u32,
    BitmapWritesUserLevel: _BitmapWritesUserLevel_e__Struct,
    MftBitmapReads: u64,
    MftBitmapReadBytes: u64,
    MftBitmapWrites: u64,
    MftBitmapWriteBytes: u64,
    MftBitmapWritesFlushForLogFileFull: u32,
    MftBitmapWritesLazyWriter: u32,
    MftBitmapWritesUserRequest: u32,
    MftBitmapWritesUserLevel: _MftBitmapWritesUserLevel_e__Struct,
    UserIndexReads: u64,
    UserIndexReadBytes: u64,
    UserIndexWrites: u64,
    UserIndexWriteBytes: u64,
    LogFileReads: u64,
    LogFileReadBytes: u64,
    LogFileWrites: u64,
    LogFileWriteBytes: u64,
    Allocate: _Allocate_e__Struct,
    DiskResourcesExhausted: u32,
    VolumeTrimCount: u64,
    VolumeTrimTime: u64,
    VolumeTrimByteCount: u64,
    FileLevelTrimCount: u64,
    FileLevelTrimTime: u64,
    FileLevelTrimByteCount: u64,
    VolumeTrimSkippedCount: u64,
    VolumeTrimSkippedByteCount: u64,
    NtfsFillStatInfoFromMftRecordCalledCount: u64,
    NtfsFillStatInfoFromMftRecordBailedBecauseOfAttributeListCount: u64,
    NtfsFillStatInfoFromMftRecordBailedBecauseOfNonResReparsePointCount: u64,
    // --------------------------------------------------------
    // Type: _MftBitmapWritesUserLevel_e__Struct
    // TypeLayoutAttr: sequential
    // TODO: I think this is a struct, but not sure at this point, assuming it is for now
    pub const _MftBitmapWritesUserLevel_e__Struct = extern struct {
        Write: u32,
        Create: u32,
        SetInfo: u32,
        Flush: u32,
    };
    // --------------------------------------------------------
    // Type: _Mft2WritesUserLevel_e__Struct
    // TypeLayoutAttr: sequential
    // TODO: I think this is a struct, but not sure at this point, assuming it is for now
    pub const _Mft2WritesUserLevel_e__Struct = extern struct {
        Write: u32,
        Create: u32,
        SetInfo: u32,
        Flush: u32,
    };
    // --------------------------------------------------------
    // Type: _BitmapWritesUserLevel_e__Struct
    // TypeLayoutAttr: sequential
    // TODO: I think this is a struct, but not sure at this point, assuming it is for now
    pub const _BitmapWritesUserLevel_e__Struct = extern struct {
        Write: u32,
        Create: u32,
        SetInfo: u32,
        Flush: u32,
    };
    // --------------------------------------------------------
    // Type: _Allocate_e__Struct
    // TypeLayoutAttr: sequential
    // TODO: I think this is a struct, but not sure at this point, assuming it is for now
    pub const _Allocate_e__Struct = extern struct {
        Calls: u32,
        RunsReturned: u32,
        Hints: u32,
        HintsHonored: u32,
        Cache: u32,
        CacheMiss: u32,
        Clusters: u64,
        HintsClusters: u64,
        CacheClusters: u64,
        CacheMissClusters: u64,
    };
    // --------------------------------------------------------
    // Type: _MftWritesUserLevel_e__Struct
    // TypeLayoutAttr: sequential
    // TODO: I think this is a struct, but not sure at this point, assuming it is for now
    pub const _MftWritesUserLevel_e__Struct = extern struct {
        Write: u32,
        Create: u32,
        SetInfo: u32,
        Flush: u32,
    };
};
// --------------------------------------------------------
// Type: FILE_OBJECTID_BUFFER
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const FILE_OBJECTID_BUFFER = extern struct {
    ObjectId: ?[*]u8,
    Anonymous: _Anonymous_e__Union,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
        // --------------------------------------------------------
        // Type: _Anonymous_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _Anonymous_e__Struct = extern struct {
            BirthVolumeId: ?[*]u8,
            BirthObjectId: ?[*]u8,
            DomainId: ?[*]u8,
        };
    };
};
// --------------------------------------------------------
// Type: FILE_SET_SPARSE_BUFFER
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const FILE_SET_SPARSE_BUFFER = extern struct {
    SetSparse: u8,
};
// --------------------------------------------------------
// Type: FILE_ZERO_DATA_INFORMATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const FILE_ZERO_DATA_INFORMATION = extern struct {
    FileOffset: LARGE_INTEGER,
    BeyondFinalZero: LARGE_INTEGER,
};
// --------------------------------------------------------
// Type: FILE_ALLOCATED_RANGE_BUFFER
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const FILE_ALLOCATED_RANGE_BUFFER = extern struct {
    FileOffset: LARGE_INTEGER,
    Length: LARGE_INTEGER,
};
// --------------------------------------------------------
// Type: PLEX_READ_DATA_REQUEST
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PLEX_READ_DATA_REQUEST = extern struct {
    ByteOffset: LARGE_INTEGER,
    ByteLength: u32,
    PlexNumber: u32,
};
// --------------------------------------------------------
// Type: FILE_MAKE_COMPATIBLE_BUFFER
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const FILE_MAKE_COMPATIBLE_BUFFER = extern struct {
    CloseDisc: u8,
};
// --------------------------------------------------------
// Type: FILE_SET_DEFECT_MGMT_BUFFER
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const FILE_SET_DEFECT_MGMT_BUFFER = extern struct {
    Disable: u8,
};
// --------------------------------------------------------
// Type: FILE_QUERY_SPARING_BUFFER
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const FILE_QUERY_SPARING_BUFFER = extern struct {
    SparingUnitBytes: u32,
    SoftwareSparing: u8,
    TotalSpareBlocks: u32,
    FreeSpareBlocks: u32,
};
// --------------------------------------------------------
// Type: FILE_QUERY_ON_DISK_VOL_INFO_BUFFER
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const FILE_QUERY_ON_DISK_VOL_INFO_BUFFER = extern struct {
    DirectoryCount: LARGE_INTEGER,
    FileCount: LARGE_INTEGER,
    FsFormatMajVersion: u16,
    FsFormatMinVersion: u16,
    FsFormatName: ?[*]u16,
    FormatTime: LARGE_INTEGER,
    LastUpdateTime: LARGE_INTEGER,
    CopyrightInfo: ?[*]u16,
    AbstractInfo: ?[*]u16,
    FormattingImplementationInfo: ?[*]u16,
    LastModifyingImplementationInfo: ?[*]u16,
};
// --------------------------------------------------------
// Type: SHRINK_VOLUME_INFORMATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SHRINK_VOLUME_INFORMATION = extern struct {
    ShrinkRequestType: SHRINK_VOLUME_REQUEST_TYPES,
    Flags: u64,
    NewNumberOfSectors: i64,
};
// --------------------------------------------------------
// Type: TXFS_MODIFY_RM
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TXFS_MODIFY_RM = extern struct {
    Flags: u32,
    LogContainerCountMax: u32,
    LogContainerCountMin: u32,
    LogContainerCount: u32,
    LogGrowthIncrement: u32,
    LogAutoShrinkPercentage: u32,
    Reserved: u64,
    LoggingMode: u16,
};
// --------------------------------------------------------
// Type: TXFS_QUERY_RM_INFORMATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TXFS_QUERY_RM_INFORMATION = extern struct {
    BytesRequired: u32,
    TailLsn: u64,
    CurrentLsn: u64,
    ArchiveTailLsn: u64,
    LogContainerSize: u64,
    HighestVirtualClock: LARGE_INTEGER,
    LogContainerCount: u32,
    LogContainerCountMax: u32,
    LogContainerCountMin: u32,
    LogGrowthIncrement: u32,
    LogAutoShrinkPercentage: u32,
    Flags: u32,
    LoggingMode: u16,
    Reserved: u16,
    RmState: u32,
    LogCapacity: u64,
    LogFree: u64,
    TopsSize: u64,
    TopsUsed: u64,
    TransactionCount: u64,
    OnePCCount: u64,
    TwoPCCount: u64,
    NumberLogFileFull: u64,
    OldestTransactionAge: u64,
    RMName: Guid,
    TmLogPathOffset: u32,
};
// --------------------------------------------------------
// Type: TXFS_GET_METADATA_INFO_OUT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TXFS_GET_METADATA_INFO_OUT = extern struct {
    TxfFileId: _TxfFileId_e__Struct,
    LockingTransaction: Guid,
    LastLsn: u64,
    TransactionState: u32,
    // --------------------------------------------------------
    // Type: _TxfFileId_e__Struct
    // TypeLayoutAttr: sequential
    // TODO: I think this is a struct, but not sure at this point, assuming it is for now
    pub const _TxfFileId_e__Struct = extern struct {
        LowPart: i64,
        HighPart: i64,
    };
};
// --------------------------------------------------------
// Type: TXFS_LIST_TRANSACTION_LOCKED_FILES_ENTRY
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TXFS_LIST_TRANSACTION_LOCKED_FILES_ENTRY = extern struct {
    Offset: u64,
    NameFlags: u32,
    FileId: i64,
    Reserved1: u32,
    Reserved2: u32,
    Reserved3: i64,
    FileName: ?[*]u16,
};
// --------------------------------------------------------
// Type: TXFS_LIST_TRANSACTION_LOCKED_FILES
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TXFS_LIST_TRANSACTION_LOCKED_FILES = extern struct {
    KtmTransaction: Guid,
    NumberOfFiles: u64,
    BufferSizeRequired: u64,
    Offset: u64,
};
// --------------------------------------------------------
// Type: TXFS_LIST_TRANSACTIONS_ENTRY
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TXFS_LIST_TRANSACTIONS_ENTRY = extern struct {
    TransactionId: Guid,
    TransactionState: u32,
    Reserved1: u32,
    Reserved2: u32,
    Reserved3: i64,
};
// --------------------------------------------------------
// Type: TXFS_LIST_TRANSACTIONS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TXFS_LIST_TRANSACTIONS = extern struct {
    NumberOfTransactions: u64,
    BufferSizeRequired: u64,
};
// --------------------------------------------------------
// Type: TXFS_READ_BACKUP_INFORMATION_OUT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TXFS_READ_BACKUP_INFORMATION_OUT = extern struct {
    Anonymous: _Anonymous_e__Union,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: TXFS_WRITE_BACKUP_INFORMATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TXFS_WRITE_BACKUP_INFORMATION = extern struct {
    Buffer: ?[*]u8,
};
// --------------------------------------------------------
// Type: TXFS_GET_TRANSACTED_VERSION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TXFS_GET_TRANSACTED_VERSION = extern struct {
    ThisBaseVersion: u32,
    LatestVersion: u32,
    ThisMiniVersion: u16,
    FirstMiniVersion: u16,
    LatestMiniVersion: u16,
};
// --------------------------------------------------------
// Type: TXFS_SAVEPOINT_INFORMATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TXFS_SAVEPOINT_INFORMATION = extern struct {
    KtmTransaction: HANDLE,
    ActionCode: u32,
    SavepointId: u32,
};
// --------------------------------------------------------
// Type: TXFS_CREATE_MINIVERSION_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TXFS_CREATE_MINIVERSION_INFO = extern struct {
    StructureVersion: u16,
    StructureLength: u16,
    BaseVersion: u32,
    MiniVersion: u16,
};
// --------------------------------------------------------
// Type: TXFS_TRANSACTION_ACTIVE_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TXFS_TRANSACTION_ACTIVE_INFO = extern struct {
    TransactionsActiveAtSnapshot: u8,
};
// --------------------------------------------------------
// Type: BOOT_AREA_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const BOOT_AREA_INFO = extern struct {
    BootSectorCount: u32,
    BootSectors: ?[*]_Anonymous_e__Struct,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Struct
    // TypeLayoutAttr: sequential
    // TODO: I think this is a struct, but not sure at this point, assuming it is for now
    pub const _Anonymous_e__Struct = extern struct {
        Offset: LARGE_INTEGER,
    };
};
// --------------------------------------------------------
// Type: RETRIEVAL_POINTER_BASE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const RETRIEVAL_POINTER_BASE = extern struct {
    FileAreaOffset: LARGE_INTEGER,
};
// --------------------------------------------------------
// Type: FILE_SYSTEM_RECOGNITION_INFORMATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const FILE_SYSTEM_RECOGNITION_INFORMATION = extern struct {
    FileSystem: ?[*]i8,
};
// --------------------------------------------------------
// Type: REQUEST_OPLOCK_INPUT_BUFFER
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const REQUEST_OPLOCK_INPUT_BUFFER = extern struct {
    StructureVersion: u16,
    StructureLength: u16,
    RequestedOplockLevel: u32,
    Flags: u32,
};
// --------------------------------------------------------
// Type: REQUEST_OPLOCK_OUTPUT_BUFFER
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const REQUEST_OPLOCK_OUTPUT_BUFFER = extern struct {
    StructureVersion: u16,
    StructureLength: u16,
    OriginalOplockLevel: u32,
    NewOplockLevel: u32,
    Flags: u32,
    AccessMode: u32,
    ShareMode: u16,
};
// --------------------------------------------------------
// Type: LOOKUP_STREAM_FROM_CLUSTER_INPUT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const LOOKUP_STREAM_FROM_CLUSTER_INPUT = extern struct {
    Flags: u32,
    NumberOfClusters: u32,
    Cluster: ?[*]LARGE_INTEGER,
};
// --------------------------------------------------------
// Type: LOOKUP_STREAM_FROM_CLUSTER_OUTPUT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const LOOKUP_STREAM_FROM_CLUSTER_OUTPUT = extern struct {
    Offset: u32,
    NumberOfMatches: u32,
    BufferSizeRequired: u32,
};
// --------------------------------------------------------
// Type: LOOKUP_STREAM_FROM_CLUSTER_ENTRY
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const LOOKUP_STREAM_FROM_CLUSTER_ENTRY = extern struct {
    OffsetToNext: u32,
    Flags: u32,
    Reserved: LARGE_INTEGER,
    Cluster: LARGE_INTEGER,
    FileName: ?[*]u16,
};
// --------------------------------------------------------
// Type: CSV_NAMESPACE_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CSV_NAMESPACE_INFO = extern struct {
    Version: u32,
    DeviceNumber: u32,
    StartingOffset: LARGE_INTEGER,
    SectorSize: u32,
};
// --------------------------------------------------------
// Type: CSV_CONTROL_OP
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const CSV_CONTROL_OP = *opaque{
};
// --------------------------------------------------------
// Type: CSV_CONTROL_PARAM
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CSV_CONTROL_PARAM = extern struct {
    Operation: CSV_CONTROL_OP,
    Unused: i64,
};
// --------------------------------------------------------
// Type: CSV_QUERY_REDIRECT_STATE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CSV_QUERY_REDIRECT_STATE = extern struct {
    MdsNodeId: u32,
    DsNodeId: u32,
    FileRedirected: u8,
};
// --------------------------------------------------------
// Type: CSV_QUERY_FILE_REVISION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CSV_QUERY_FILE_REVISION = extern struct {
    FileId: i64,
    FileRevision: ?[*]i64,
};
// --------------------------------------------------------
// Type: CSV_QUERY_MDS_PATH
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CSV_QUERY_MDS_PATH = extern struct {
    MdsNodeId: u32,
    DsNodeId: u32,
    PathLength: u32,
    Path: ?[*]u16,
};
// --------------------------------------------------------
// Type: CSV_QUERY_VETO_FILE_DIRECT_IO_OUTPUT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CSV_QUERY_VETO_FILE_DIRECT_IO_OUTPUT = extern struct {
    VetoedFromAltitudeIntegral: u64,
    VetoedFromAltitudeDecimal: u64,
    Reason: ?[*]u16,
};
// --------------------------------------------------------
// Type: CSV_IS_OWNED_BY_CSVFS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CSV_IS_OWNED_BY_CSVFS = extern struct {
    OwnedByCSVFS: u8,
};
// --------------------------------------------------------
// Type: FILE_LEVEL_TRIM_RANGE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const FILE_LEVEL_TRIM_RANGE = extern struct {
    Offset: u64,
    Length: u64,
};
// --------------------------------------------------------
// Type: FILE_LEVEL_TRIM
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const FILE_LEVEL_TRIM = extern struct {
    Key: u32,
    NumRanges: u32,
    Ranges: ?[*]FILE_LEVEL_TRIM_RANGE,
};
// --------------------------------------------------------
// Type: FILE_LEVEL_TRIM_OUTPUT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const FILE_LEVEL_TRIM_OUTPUT = extern struct {
    NumRangesProcessed: u32,
};
// --------------------------------------------------------
// Type: FSCTL_GET_INTEGRITY_INFORMATION_BUFFER
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const FSCTL_GET_INTEGRITY_INFORMATION_BUFFER = extern struct {
    ChecksumAlgorithm: u16,
    Reserved: u16,
    Flags: u32,
    ChecksumChunkSizeInBytes: u32,
    ClusterSizeInBytes: u32,
};
// --------------------------------------------------------
// Type: FSCTL_SET_INTEGRITY_INFORMATION_BUFFER
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const FSCTL_SET_INTEGRITY_INFORMATION_BUFFER = extern struct {
    ChecksumAlgorithm: u16,
    Reserved: u16,
    Flags: u32,
};
// --------------------------------------------------------
// Type: REPAIR_COPIES_INPUT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const REPAIR_COPIES_INPUT = extern struct {
    Size: u32,
    Flags: u32,
    FileOffset: LARGE_INTEGER,
    Length: u32,
    SourceCopy: u32,
    NumberOfRepairCopies: u32,
    RepairCopies: ?[*]u32,
};
// --------------------------------------------------------
// Type: REPAIR_COPIES_OUTPUT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const REPAIR_COPIES_OUTPUT = extern struct {
    Size: u32,
    Status: u32,
    ResumeFileOffset: LARGE_INTEGER,
};
// --------------------------------------------------------
// Type: FILE_STORAGE_TIER_MEDIA_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const FILE_STORAGE_TIER_MEDIA_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: FILE_STORAGE_TIER
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const FILE_STORAGE_TIER = extern struct {
    Id: Guid,
    Name: ?[*]u16,
    Description: ?[*]u16,
    Flags: u64,
    ProvisionedCapacity: u64,
    MediaType: FILE_STORAGE_TIER_MEDIA_TYPE,
    Class: FILE_STORAGE_TIER_CLASS,
};
// --------------------------------------------------------
// Type: FSCTL_QUERY_STORAGE_CLASSES_OUTPUT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const FSCTL_QUERY_STORAGE_CLASSES_OUTPUT = extern struct {
    Version: u32,
    Size: u32,
    Flags: u32,
    TotalNumberOfTiers: u32,
    NumberOfTiersReturned: u32,
    Tiers: ?[*]FILE_STORAGE_TIER,
};
// --------------------------------------------------------
// Type: FSCTL_QUERY_REGION_INFO_INPUT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const FSCTL_QUERY_REGION_INFO_INPUT = extern struct {
    Version: u32,
    Size: u32,
    Flags: u32,
    NumberOfTierIds: u32,
    TierIds: ?[*]Guid,
};
// --------------------------------------------------------
// Type: FILE_STORAGE_TIER_REGION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const FILE_STORAGE_TIER_REGION = extern struct {
    TierId: Guid,
    Offset: u64,
    Length: u64,
};
// --------------------------------------------------------
// Type: FSCTL_QUERY_REGION_INFO_OUTPUT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const FSCTL_QUERY_REGION_INFO_OUTPUT = extern struct {
    Version: u32,
    Size: u32,
    Flags: u32,
    Reserved: u32,
    Alignment: u64,
    TotalNumberOfRegions: u32,
    NumberOfRegionsReturned: u32,
    Regions: ?[*]FILE_STORAGE_TIER_REGION,
};
// --------------------------------------------------------
// Type: DUPLICATE_EXTENTS_DATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DUPLICATE_EXTENTS_DATA = extern struct {
    FileHandle: HANDLE,
    SourceFileOffset: LARGE_INTEGER,
    TargetFileOffset: LARGE_INTEGER,
    ByteCount: LARGE_INTEGER,
};
// --------------------------------------------------------
// Type: DISK_EXTENT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DISK_EXTENT = extern struct {
    DiskNumber: u32,
    StartingOffset: LARGE_INTEGER,
    ExtentLength: LARGE_INTEGER,
};
// --------------------------------------------------------
// Type: VOLUME_DISK_EXTENTS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VOLUME_DISK_EXTENTS = extern struct {
    NumberOfDiskExtents: u32,
    Extents: ?[*]DISK_EXTENT,
};
// --------------------------------------------------------
// Type: VOLUME_GET_GPT_ATTRIBUTES_INFORMATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VOLUME_GET_GPT_ATTRIBUTES_INFORMATION = extern struct {
    GptAttributes: u64,
};
// --------------------------------------------------------
// Type: TRANSACTION_NOTIFICATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TRANSACTION_NOTIFICATION = extern struct {
    TransactionKey: ?*opaque{},
    TransactionNotification: u32,
    TmVirtualClock: LARGE_INTEGER,
    ArgumentLength: u32,
};
// --------------------------------------------------------
// Type: TRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT = extern struct {
    EnlistmentId: Guid,
    UOW: Guid,
};
// --------------------------------------------------------
// Type: TRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT = extern struct {
    TmIdentity: Guid,
    Flags: u32,
};
// --------------------------------------------------------
// Type: TRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT = extern struct {
    SavepointId: u32,
};
// --------------------------------------------------------
// Type: TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT = extern struct {
    PropagationCookie: u32,
    UOW: Guid,
    TmIdentity: Guid,
    BufferLength: u32,
};
// --------------------------------------------------------
// Type: TRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT = extern struct {
    MarshalCookie: u32,
    UOW: Guid,
};
// --------------------------------------------------------
// Type: KCRM_MARSHAL_HEADER
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const KCRM_MARSHAL_HEADER = extern struct {
    VersionMajor: u32,
    VersionMinor: u32,
    NumProtocols: u32,
    Unused: u32,
};
// --------------------------------------------------------
// Type: KCRM_TRANSACTION_BLOB
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const KCRM_TRANSACTION_BLOB = extern struct {
    UOW: Guid,
    TmIdentity: Guid,
    IsolationLevel: u32,
    IsolationFlags: u32,
    Timeout: u32,
    Description: ?[*]u16,
};
// --------------------------------------------------------
// Type: KCRM_PROTOCOL_BLOB
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const KCRM_PROTOCOL_BLOB = extern struct {
    ProtocolId: Guid,
    StaticInfoLength: u32,
    TransactionIdInfoLength: u32,
    Unused1: u32,
    Unused2: u32,
};
// --------------------------------------------------------
// Type: DISK_SPACE_INFORMATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DISK_SPACE_INFORMATION = extern struct {
    ActualTotalAllocationUnits: u64,
    ActualAvailableAllocationUnits: u64,
    ActualPoolUnavailableAllocationUnits: u64,
    CallerTotalAllocationUnits: u64,
    CallerAvailableAllocationUnits: u64,
    CallerPoolUnavailableAllocationUnits: u64,
    UsedAllocationUnits: u64,
    TotalReservedAllocationUnits: u64,
    VolumeStorageReserveAllocationUnits: u64,
    AvailableCommittedAllocationUnits: u64,
    PoolAvailableAllocationUnits: u64,
    SectorsPerAllocationUnit: u32,
    BytesPerSector: u32,
};
// --------------------------------------------------------
// Type: WIN32_FILE_ATTRIBUTE_DATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const WIN32_FILE_ATTRIBUTE_DATA = extern struct {
    dwFileAttributes: u32,
    ftCreationTime: FILETIME,
    ftLastAccessTime: FILETIME,
    ftLastWriteTime: FILETIME,
    nFileSizeHigh: u32,
    nFileSizeLow: u32,
};
// --------------------------------------------------------
// Type: BY_HANDLE_FILE_INFORMATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const BY_HANDLE_FILE_INFORMATION = extern struct {
    dwFileAttributes: u32,
    ftCreationTime: FILETIME,
    ftLastAccessTime: FILETIME,
    ftLastWriteTime: FILETIME,
    dwVolumeSerialNumber: u32,
    nFileSizeHigh: u32,
    nFileSizeLow: u32,
    nNumberOfLinks: u32,
    nFileIndexHigh: u32,
    nFileIndexLow: u32,
};
// --------------------------------------------------------
// Type: CREATEFILE2_EXTENDED_PARAMETERS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CREATEFILE2_EXTENDED_PARAMETERS = extern struct {
    dwSize: u32,
    dwFileAttributes: u32,
    dwFileFlags: u32,
    dwSecurityQosFlags: u32,
    lpSecurityAttributes: ?*SECURITY_ATTRIBUTES,
    hTemplateFile: HANDLE,
};
// --------------------------------------------------------
// Type: STREAM_INFO_LEVELS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const STREAM_INFO_LEVELS = *opaque{
};
// --------------------------------------------------------
// Type: WIN32_FIND_STREAM_DATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const WIN32_FIND_STREAM_DATA = extern struct {
    StreamSize: LARGE_INTEGER,
    cStreamName: ?[*]u16,
};
// --------------------------------------------------------
// Type: EFS_CERTIFICATE_BLOB
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const EFS_CERTIFICATE_BLOB = extern struct {
    dwCertEncodingType: u32,
    cbData: u32,
    pbData: ?*u8,
};
// --------------------------------------------------------
// Type: EFS_HASH_BLOB
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const EFS_HASH_BLOB = extern struct {
    cbData: u32,
    pbData: ?*u8,
};
// --------------------------------------------------------
// Type: EFS_RPC_BLOB
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const EFS_RPC_BLOB = extern struct {
    cbData: u32,
    pbData: ?*u8,
};
// --------------------------------------------------------
// Type: EFS_PIN_BLOB
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const EFS_PIN_BLOB = extern struct {
    cbPadding: u32,
    cbData: u32,
    pbData: ?*u8,
};
// --------------------------------------------------------
// Type: EFS_KEY_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const EFS_KEY_INFO = extern struct {
    dwVersion: u32,
    Entropy: u32,
    Algorithm: u32,
    KeyLength: u32,
};
// --------------------------------------------------------
// Type: EFS_COMPATIBILITY_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const EFS_COMPATIBILITY_INFO = extern struct {
    EfsVersion: u32,
};
// --------------------------------------------------------
// Type: EFS_VERSION_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const EFS_VERSION_INFO = extern struct {
    EfsVersion: u32,
    SubVersion: u32,
};
// --------------------------------------------------------
// Type: EFS_DECRYPTION_STATUS_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const EFS_DECRYPTION_STATUS_INFO = extern struct {
    dwDecryptionError: u32,
    dwHashOffset: u32,
    cbHash: u32,
};
// --------------------------------------------------------
// Type: EFS_ENCRYPTION_STATUS_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const EFS_ENCRYPTION_STATUS_INFO = extern struct {
    bHasCurrentKey: BOOL,
    dwEncryptionError: u32,
};
// --------------------------------------------------------
// Type: ENCRYPTION_CERTIFICATE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const ENCRYPTION_CERTIFICATE = extern struct {
    cbTotalLength: u32,
    pUserSid: ?*SID,
    pCertBlob: ?*EFS_CERTIFICATE_BLOB,
};
// --------------------------------------------------------
// Type: ENCRYPTION_CERTIFICATE_HASH
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const ENCRYPTION_CERTIFICATE_HASH = extern struct {
    cbTotalLength: u32,
    pUserSid: ?*SID,
    pHash: ?*EFS_HASH_BLOB,
    lpDisplayInformation: ?*u16,
};
// --------------------------------------------------------
// Type: ENCRYPTION_CERTIFICATE_HASH_LIST
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const ENCRYPTION_CERTIFICATE_HASH_LIST = extern struct {
    nCert_Hash: u32,
    pUsers: ?*?*ENCRYPTION_CERTIFICATE_HASH,
};
// --------------------------------------------------------
// Type: ENCRYPTION_CERTIFICATE_LIST
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const ENCRYPTION_CERTIFICATE_LIST = extern struct {
    nUsers: u32,
    pUsers: ?*?*ENCRYPTION_CERTIFICATE,
};
// --------------------------------------------------------
// Type: ENCRYPTED_FILE_METADATA_SIGNATURE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const ENCRYPTED_FILE_METADATA_SIGNATURE = extern struct {
    dwEfsAccessType: u32,
    pCertificatesAdded: ?*ENCRYPTION_CERTIFICATE_HASH_LIST,
    pEncryptionCertificate: ?*ENCRYPTION_CERTIFICATE,
    pEfsStreamSignature: ?*EFS_RPC_BLOB,
};
// --------------------------------------------------------
// Type: ENCRYPTION_PROTECTOR
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const ENCRYPTION_PROTECTOR = extern struct {
    cbTotalLength: u32,
    pUserSid: ?*SID,
    lpProtectorDescriptor: ?*u16,
};
// --------------------------------------------------------
// Type: ENCRYPTION_PROTECTOR_LIST
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const ENCRYPTION_PROTECTOR_LIST = extern struct {
    nProtectors: u32,
    pProtectors: ?*?*ENCRYPTION_PROTECTOR,
};
// --------------------------------------------------------
// Type: NtmsObjectsTypes
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const NtmsObjectsTypes = *opaque{
};
// --------------------------------------------------------
// Type: NTMS_ASYNC_IO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NTMS_ASYNC_IO = extern struct {
    OperationId: Guid,
    EventId: Guid,
    dwOperationType: u32,
    dwResult: u32,
    dwAsyncState: u32,
    hEvent: HANDLE,
    bOnStateChange: BOOL,
};
// --------------------------------------------------------
// Type: NtmsAsyncStatus
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const NtmsAsyncStatus = *opaque{
};
// --------------------------------------------------------
// Type: NtmsAsyncOperations
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const NtmsAsyncOperations = *opaque{
};
// --------------------------------------------------------
// Type: NtmsSessionOptions
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const NtmsSessionOptions = *opaque{
};
// --------------------------------------------------------
// Type: NtmsMountOptions
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const NtmsMountOptions = *opaque{
};
// --------------------------------------------------------
// Type: NtmsDismountOptions
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const NtmsDismountOptions = *opaque{
};
// --------------------------------------------------------
// Type: NtmsMountPriority
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const NtmsMountPriority = *opaque{
};
// --------------------------------------------------------
// Type: NTMS_MOUNT_INFORMATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NTMS_MOUNT_INFORMATION = extern struct {
    dwSize: u32,
    lpReserved: ?*opaque{},
};
// --------------------------------------------------------
// Type: NtmsAllocateOptions
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const NtmsAllocateOptions = *opaque{
};
// --------------------------------------------------------
// Type: NTMS_ALLOCATION_INFORMATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NTMS_ALLOCATION_INFORMATION = extern struct {
    dwSize: u32,
    lpReserved: ?*opaque{},
    AllocatedFrom: Guid,
};
// --------------------------------------------------------
// Type: NtmsCreateOptions
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const NtmsCreateOptions = *opaque{
};
// --------------------------------------------------------
// Type: NtmsDriveState
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const NtmsDriveState = *opaque{
};
// --------------------------------------------------------
// Type: NTMS_DRIVEINFORMATIONA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NTMS_DRIVEINFORMATIONA = extern struct {
    Number: u32,
    State: u32,
    DriveType: Guid,
    szDeviceName: ?[*]i8,
    szSerialNumber: ?[*]i8,
    szRevision: ?[*]i8,
    ScsiPort: u16,
    ScsiBus: u16,
    ScsiTarget: u16,
    ScsiLun: u16,
    dwMountCount: u32,
    LastCleanedTs: SYSTEMTIME,
    SavedPartitionId: Guid,
    Library: Guid,
    Reserved: Guid,
    dwDeferDismountDelay: u32,
};
// --------------------------------------------------------
// Type: NTMS_DRIVEINFORMATIONW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NTMS_DRIVEINFORMATIONW = extern struct {
    Number: u32,
    State: u32,
    DriveType: Guid,
    szDeviceName: ?[*]u16,
    szSerialNumber: ?[*]u16,
    szRevision: ?[*]u16,
    ScsiPort: u16,
    ScsiBus: u16,
    ScsiTarget: u16,
    ScsiLun: u16,
    dwMountCount: u32,
    LastCleanedTs: SYSTEMTIME,
    SavedPartitionId: Guid,
    Library: Guid,
    Reserved: Guid,
    dwDeferDismountDelay: u32,
};
// --------------------------------------------------------
// Type: NtmsLibraryType
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const NtmsLibraryType = *opaque{
};
// --------------------------------------------------------
// Type: NtmsLibraryFlags
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const NtmsLibraryFlags = *opaque{
};
// --------------------------------------------------------
// Type: NtmsInventoryMethod
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const NtmsInventoryMethod = *opaque{
};
// --------------------------------------------------------
// Type: NTMS_LIBRARYINFORMATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NTMS_LIBRARYINFORMATION = extern struct {
    LibraryType: u32,
    CleanerSlot: Guid,
    CleanerSlotDefault: Guid,
    LibrarySupportsDriveCleaning: BOOL,
    BarCodeReaderInstalled: BOOL,
    InventoryMethod: u32,
    dwCleanerUsesRemaining: u32,
    FirstDriveNumber: u32,
    dwNumberOfDrives: u32,
    FirstSlotNumber: u32,
    dwNumberOfSlots: u32,
    FirstDoorNumber: u32,
    dwNumberOfDoors: u32,
    FirstPortNumber: u32,
    dwNumberOfPorts: u32,
    FirstChangerNumber: u32,
    dwNumberOfChangers: u32,
    dwNumberOfMedia: u32,
    dwNumberOfMediaTypes: u32,
    dwNumberOfLibRequests: u32,
    Reserved: Guid,
    AutoRecovery: BOOL,
    dwFlags: u32,
};
// --------------------------------------------------------
// Type: NTMS_CHANGERINFORMATIONA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NTMS_CHANGERINFORMATIONA = extern struct {
    Number: u32,
    ChangerType: Guid,
    szSerialNumber: ?[*]i8,
    szRevision: ?[*]i8,
    szDeviceName: ?[*]i8,
    ScsiPort: u16,
    ScsiBus: u16,
    ScsiTarget: u16,
    ScsiLun: u16,
    Library: Guid,
};
// --------------------------------------------------------
// Type: NTMS_CHANGERINFORMATIONW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NTMS_CHANGERINFORMATIONW = extern struct {
    Number: u32,
    ChangerType: Guid,
    szSerialNumber: ?[*]u16,
    szRevision: ?[*]u16,
    szDeviceName: ?[*]u16,
    ScsiPort: u16,
    ScsiBus: u16,
    ScsiTarget: u16,
    ScsiLun: u16,
    Library: Guid,
};
// --------------------------------------------------------
// Type: NtmsSlotState
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const NtmsSlotState = *opaque{
};
// --------------------------------------------------------
// Type: NTMS_STORAGESLOTINFORMATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NTMS_STORAGESLOTINFORMATION = extern struct {
    Number: u32,
    State: u32,
    Library: Guid,
};
// --------------------------------------------------------
// Type: NtmsDoorState
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const NtmsDoorState = *opaque{
};
// --------------------------------------------------------
// Type: NTMS_IEDOORINFORMATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NTMS_IEDOORINFORMATION = extern struct {
    Number: u32,
    State: u32,
    MaxOpenSecs: u16,
    Library: Guid,
};
// --------------------------------------------------------
// Type: NtmsPortPosition
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const NtmsPortPosition = *opaque{
};
// --------------------------------------------------------
// Type: NtmsPortContent
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const NtmsPortContent = *opaque{
};
// --------------------------------------------------------
// Type: NTMS_IEPORTINFORMATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NTMS_IEPORTINFORMATION = extern struct {
    Number: u32,
    Content: u32,
    Position: u32,
    MaxExtendSecs: u16,
    Library: Guid,
};
// --------------------------------------------------------
// Type: NtmsBarCodeState
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const NtmsBarCodeState = *opaque{
};
// --------------------------------------------------------
// Type: NtmsMediaState
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const NtmsMediaState = *opaque{
};
// --------------------------------------------------------
// Type: NTMS_PMIDINFORMATIONA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NTMS_PMIDINFORMATIONA = extern struct {
    CurrentLibrary: Guid,
    MediaPool: Guid,
    Location: Guid,
    LocationType: u32,
    MediaType: Guid,
    HomeSlot: Guid,
    szBarCode: ?[*]i8,
    BarCodeState: u32,
    szSequenceNumber: ?[*]i8,
    MediaState: u32,
    dwNumberOfPartitions: u32,
    dwMediaTypeCode: u32,
    dwDensityCode: u32,
    MountedPartition: Guid,
};
// --------------------------------------------------------
// Type: NTMS_PMIDINFORMATIONW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NTMS_PMIDINFORMATIONW = extern struct {
    CurrentLibrary: Guid,
    MediaPool: Guid,
    Location: Guid,
    LocationType: u32,
    MediaType: Guid,
    HomeSlot: Guid,
    szBarCode: ?[*]u16,
    BarCodeState: u32,
    szSequenceNumber: ?[*]u16,
    MediaState: u32,
    dwNumberOfPartitions: u32,
    dwMediaTypeCode: u32,
    dwDensityCode: u32,
    MountedPartition: Guid,
};
// --------------------------------------------------------
// Type: NTMS_LMIDINFORMATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NTMS_LMIDINFORMATION = extern struct {
    MediaPool: Guid,
    dwNumberOfPartitions: u32,
};
// --------------------------------------------------------
// Type: NtmsPartitionState
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const NtmsPartitionState = *opaque{
};
// --------------------------------------------------------
// Type: NTMS_PARTITIONINFORMATIONA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NTMS_PARTITIONINFORMATIONA = extern struct {
    PhysicalMedia: Guid,
    LogicalMedia: Guid,
    State: u32,
    Side: u16,
    dwOmidLabelIdLength: u32,
    OmidLabelId: ?[*]u8,
    szOmidLabelType: ?[*]i8,
    szOmidLabelInfo: ?[*]i8,
    dwMountCount: u32,
    dwAllocateCount: u32,
    Capacity: LARGE_INTEGER,
};
// --------------------------------------------------------
// Type: NTMS_PARTITIONINFORMATIONW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NTMS_PARTITIONINFORMATIONW = extern struct {
    PhysicalMedia: Guid,
    LogicalMedia: Guid,
    State: u32,
    Side: u16,
    dwOmidLabelIdLength: u32,
    OmidLabelId: ?[*]u8,
    szOmidLabelType: ?[*]u16,
    szOmidLabelInfo: ?[*]u16,
    dwMountCount: u32,
    dwAllocateCount: u32,
    Capacity: LARGE_INTEGER,
};
// --------------------------------------------------------
// Type: NtmsPoolType
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const NtmsPoolType = *opaque{
};
// --------------------------------------------------------
// Type: NtmsAllocationPolicy
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const NtmsAllocationPolicy = *opaque{
};
// --------------------------------------------------------
// Type: NtmsDeallocationPolicy
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const NtmsDeallocationPolicy = *opaque{
};
// --------------------------------------------------------
// Type: NTMS_MEDIAPOOLINFORMATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NTMS_MEDIAPOOLINFORMATION = extern struct {
    PoolType: u32,
    MediaType: Guid,
    Parent: Guid,
    AllocationPolicy: u32,
    DeallocationPolicy: u32,
    dwMaxAllocates: u32,
    dwNumberOfPhysicalMedia: u32,
    dwNumberOfLogicalMedia: u32,
    dwNumberOfMediaPools: u32,
};
// --------------------------------------------------------
// Type: NtmsReadWriteCharacteristics
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const NtmsReadWriteCharacteristics = *opaque{
};
// --------------------------------------------------------
// Type: NTMS_MEDIATYPEINFORMATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NTMS_MEDIATYPEINFORMATION = extern struct {
    MediaType: u32,
    NumberOfSides: u32,
    ReadWriteCharacteristics: u32,
    DeviceType: u32,
};
// --------------------------------------------------------
// Type: NTMS_DRIVETYPEINFORMATIONA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NTMS_DRIVETYPEINFORMATIONA = extern struct {
    szVendor: ?[*]i8,
    szProduct: ?[*]i8,
    NumberOfHeads: u32,
    DeviceType: u32,
};
// --------------------------------------------------------
// Type: NTMS_DRIVETYPEINFORMATIONW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NTMS_DRIVETYPEINFORMATIONW = extern struct {
    szVendor: ?[*]u16,
    szProduct: ?[*]u16,
    NumberOfHeads: u32,
    DeviceType: u32,
};
// --------------------------------------------------------
// Type: NTMS_CHANGERTYPEINFORMATIONA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NTMS_CHANGERTYPEINFORMATIONA = extern struct {
    szVendor: ?[*]i8,
    szProduct: ?[*]i8,
    DeviceType: u32,
};
// --------------------------------------------------------
// Type: NTMS_CHANGERTYPEINFORMATIONW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NTMS_CHANGERTYPEINFORMATIONW = extern struct {
    szVendor: ?[*]u16,
    szProduct: ?[*]u16,
    DeviceType: u32,
};
// --------------------------------------------------------
// Type: NtmsLmOperation
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const NtmsLmOperation = *opaque{
};
// --------------------------------------------------------
// Type: NtmsLmState
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const NtmsLmState = *opaque{
};
// --------------------------------------------------------
// Type: NTMS_LIBREQUESTINFORMATIONA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NTMS_LIBREQUESTINFORMATIONA = extern struct {
    OperationCode: u32,
    OperationOption: u32,
    State: u32,
    PartitionId: Guid,
    DriveId: Guid,
    PhysMediaId: Guid,
    Library: Guid,
    SlotId: Guid,
    TimeQueued: SYSTEMTIME,
    TimeCompleted: SYSTEMTIME,
    szApplication: ?[*]i8,
    szUser: ?[*]i8,
    szComputer: ?[*]i8,
    dwErrorCode: u32,
    WorkItemId: Guid,
    dwPriority: u32,
};
// --------------------------------------------------------
// Type: NTMS_LIBREQUESTINFORMATIONW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NTMS_LIBREQUESTINFORMATIONW = extern struct {
    OperationCode: u32,
    OperationOption: u32,
    State: u32,
    PartitionId: Guid,
    DriveId: Guid,
    PhysMediaId: Guid,
    Library: Guid,
    SlotId: Guid,
    TimeQueued: SYSTEMTIME,
    TimeCompleted: SYSTEMTIME,
    szApplication: ?[*]u16,
    szUser: ?[*]u16,
    szComputer: ?[*]u16,
    dwErrorCode: u32,
    WorkItemId: Guid,
    dwPriority: u32,
};
// --------------------------------------------------------
// Type: NtmsOpreqCommand
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const NtmsOpreqCommand = *opaque{
};
// --------------------------------------------------------
// Type: NtmsOpreqState
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const NtmsOpreqState = *opaque{
};
// --------------------------------------------------------
// Type: NTMS_OPREQUESTINFORMATIONA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NTMS_OPREQUESTINFORMATIONA = extern struct {
    Request: u32,
    Submitted: SYSTEMTIME,
    State: u32,
    szMessage: ?[*]i8,
    Arg1Type: u32,
    Arg1: Guid,
    Arg2Type: u32,
    Arg2: Guid,
    szApplication: ?[*]i8,
    szUser: ?[*]i8,
    szComputer: ?[*]i8,
};
// --------------------------------------------------------
// Type: NTMS_OPREQUESTINFORMATIONW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NTMS_OPREQUESTINFORMATIONW = extern struct {
    Request: u32,
    Submitted: SYSTEMTIME,
    State: u32,
    szMessage: ?[*]u16,
    Arg1Type: u32,
    Arg1: Guid,
    Arg2Type: u32,
    Arg2: Guid,
    szApplication: ?[*]u16,
    szUser: ?[*]u16,
    szComputer: ?[*]u16,
};
// --------------------------------------------------------
// Type: NTMS_COMPUTERINFORMATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NTMS_COMPUTERINFORMATION = extern struct {
    dwLibRequestPurgeTime: u32,
    dwOpRequestPurgeTime: u32,
    dwLibRequestFlags: u32,
    dwOpRequestFlags: u32,
    dwMediaPoolPolicy: u32,
};
// --------------------------------------------------------
// Type: NtmsLibRequestFlags
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const NtmsLibRequestFlags = *opaque{
};
// --------------------------------------------------------
// Type: NtmsOpRequestFlags
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const NtmsOpRequestFlags = *opaque{
};
// --------------------------------------------------------
// Type: NtmsMediaPoolPolicy
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const NtmsMediaPoolPolicy = *opaque{
};
// --------------------------------------------------------
// Type: NtmsOperationalState
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const NtmsOperationalState = *opaque{
};
// --------------------------------------------------------
// Type: NTMS_OBJECTINFORMATIONA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NTMS_OBJECTINFORMATIONA = extern struct {
    dwSize: u32,
    dwType: u32,
    Created: SYSTEMTIME,
    Modified: SYSTEMTIME,
    ObjectGuid: Guid,
    Enabled: BOOL,
    dwOperationalState: u32,
    szName: ?[*]i8,
    szDescription: ?[*]i8,
    Info: _Info_e__Union,
    // --------------------------------------------------------
    // Type: _Info_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Info_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: NTMS_OBJECTINFORMATIONW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NTMS_OBJECTINFORMATIONW = extern struct {
    dwSize: u32,
    dwType: u32,
    Created: SYSTEMTIME,
    Modified: SYSTEMTIME,
    ObjectGuid: Guid,
    Enabled: BOOL,
    dwOperationalState: u32,
    szName: ?[*]u16,
    szDescription: ?[*]u16,
    Info: _Info_e__Union,
    // --------------------------------------------------------
    // Type: _Info_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Info_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: NTMS_I1_LIBRARYINFORMATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NTMS_I1_LIBRARYINFORMATION = extern struct {
    LibraryType: u32,
    CleanerSlot: Guid,
    CleanerSlotDefault: Guid,
    LibrarySupportsDriveCleaning: BOOL,
    BarCodeReaderInstalled: BOOL,
    InventoryMethod: u32,
    dwCleanerUsesRemaining: u32,
    FirstDriveNumber: u32,
    dwNumberOfDrives: u32,
    FirstSlotNumber: u32,
    dwNumberOfSlots: u32,
    FirstDoorNumber: u32,
    dwNumberOfDoors: u32,
    FirstPortNumber: u32,
    dwNumberOfPorts: u32,
    FirstChangerNumber: u32,
    dwNumberOfChangers: u32,
    dwNumberOfMedia: u32,
    dwNumberOfMediaTypes: u32,
    dwNumberOfLibRequests: u32,
    Reserved: Guid,
};
// --------------------------------------------------------
// Type: NTMS_I1_LIBREQUESTINFORMATIONA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NTMS_I1_LIBREQUESTINFORMATIONA = extern struct {
    OperationCode: u32,
    OperationOption: u32,
    State: u32,
    PartitionId: Guid,
    DriveId: Guid,
    PhysMediaId: Guid,
    Library: Guid,
    SlotId: Guid,
    TimeQueued: SYSTEMTIME,
    TimeCompleted: SYSTEMTIME,
    szApplication: ?[*]i8,
    szUser: ?[*]i8,
    szComputer: ?[*]i8,
};
// --------------------------------------------------------
// Type: NTMS_I1_LIBREQUESTINFORMATIONW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NTMS_I1_LIBREQUESTINFORMATIONW = extern struct {
    OperationCode: u32,
    OperationOption: u32,
    State: u32,
    PartitionId: Guid,
    DriveId: Guid,
    PhysMediaId: Guid,
    Library: Guid,
    SlotId: Guid,
    TimeQueued: SYSTEMTIME,
    TimeCompleted: SYSTEMTIME,
    szApplication: ?[*]u16,
    szUser: ?[*]u16,
    szComputer: ?[*]u16,
};
// --------------------------------------------------------
// Type: NTMS_I1_PMIDINFORMATIONA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NTMS_I1_PMIDINFORMATIONA = extern struct {
    CurrentLibrary: Guid,
    MediaPool: Guid,
    Location: Guid,
    LocationType: u32,
    MediaType: Guid,
    HomeSlot: Guid,
    szBarCode: ?[*]i8,
    BarCodeState: u32,
    szSequenceNumber: ?[*]i8,
    MediaState: u32,
    dwNumberOfPartitions: u32,
};
// --------------------------------------------------------
// Type: NTMS_I1_PMIDINFORMATIONW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NTMS_I1_PMIDINFORMATIONW = extern struct {
    CurrentLibrary: Guid,
    MediaPool: Guid,
    Location: Guid,
    LocationType: u32,
    MediaType: Guid,
    HomeSlot: Guid,
    szBarCode: ?[*]u16,
    BarCodeState: u32,
    szSequenceNumber: ?[*]u16,
    MediaState: u32,
    dwNumberOfPartitions: u32,
};
// --------------------------------------------------------
// Type: NTMS_I1_PARTITIONINFORMATIONA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NTMS_I1_PARTITIONINFORMATIONA = extern struct {
    PhysicalMedia: Guid,
    LogicalMedia: Guid,
    State: u32,
    Side: u16,
    dwOmidLabelIdLength: u32,
    OmidLabelId: ?[*]u8,
    szOmidLabelType: ?[*]i8,
    szOmidLabelInfo: ?[*]i8,
    dwMountCount: u32,
    dwAllocateCount: u32,
};
// --------------------------------------------------------
// Type: NTMS_I1_PARTITIONINFORMATIONW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NTMS_I1_PARTITIONINFORMATIONW = extern struct {
    PhysicalMedia: Guid,
    LogicalMedia: Guid,
    State: u32,
    Side: u16,
    dwOmidLabelIdLength: u32,
    OmidLabelId: ?[*]u8,
    szOmidLabelType: ?[*]u16,
    szOmidLabelInfo: ?[*]u16,
    dwMountCount: u32,
    dwAllocateCount: u32,
};
// --------------------------------------------------------
// Type: NTMS_I1_OPREQUESTINFORMATIONA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NTMS_I1_OPREQUESTINFORMATIONA = extern struct {
    Request: u32,
    Submitted: SYSTEMTIME,
    State: u32,
    szMessage: ?[*]i8,
    Arg1Type: u32,
    Arg1: Guid,
    Arg2Type: u32,
    Arg2: Guid,
    szApplication: ?[*]i8,
    szUser: ?[*]i8,
    szComputer: ?[*]i8,
};
// --------------------------------------------------------
// Type: NTMS_I1_OPREQUESTINFORMATIONW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NTMS_I1_OPREQUESTINFORMATIONW = extern struct {
    Request: u32,
    Submitted: SYSTEMTIME,
    State: u32,
    szMessage: ?[*]u16,
    Arg1Type: u32,
    Arg1: Guid,
    Arg2Type: u32,
    Arg2: Guid,
    szApplication: ?[*]u16,
    szUser: ?[*]u16,
    szComputer: ?[*]u16,
};
// --------------------------------------------------------
// Type: NTMS_I1_OBJECTINFORMATIONA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NTMS_I1_OBJECTINFORMATIONA = extern struct {
    dwSize: u32,
    dwType: u32,
    Created: SYSTEMTIME,
    Modified: SYSTEMTIME,
    ObjectGuid: Guid,
    Enabled: BOOL,
    dwOperationalState: u32,
    szName: ?[*]i8,
    szDescription: ?[*]i8,
    Info: _Info_e__Union,
    // --------------------------------------------------------
    // Type: _Info_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Info_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: NTMS_I1_OBJECTINFORMATIONW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NTMS_I1_OBJECTINFORMATIONW = extern struct {
    dwSize: u32,
    dwType: u32,
    Created: SYSTEMTIME,
    Modified: SYSTEMTIME,
    ObjectGuid: Guid,
    Enabled: BOOL,
    dwOperationalState: u32,
    szName: ?[*]u16,
    szDescription: ?[*]u16,
    Info: _Info_e__Union,
    // --------------------------------------------------------
    // Type: _Info_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Info_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: NtmsCreateNtmsMediaOptions
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const NtmsCreateNtmsMediaOptions = *opaque{
};
// --------------------------------------------------------
// Type: NtmsEnumerateOption
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const NtmsEnumerateOption = *opaque{
};
// --------------------------------------------------------
// Type: NtmsEjectOperation
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const NtmsEjectOperation = *opaque{
};
// --------------------------------------------------------
// Type: NtmsInjectOperation
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const NtmsInjectOperation = *opaque{
};
// --------------------------------------------------------
// Type: NTMS_FILESYSTEM_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NTMS_FILESYSTEM_INFO = extern struct {
    FileSystemType: ?[*]u16,
    VolumeName: ?[*]u16,
    SerialNumber: u32,
};
// --------------------------------------------------------
// Type: NtmsDriveType
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const NtmsDriveType = *opaque{
};
// --------------------------------------------------------
// Type: NtmsAccessMask
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const NtmsAccessMask = *opaque{
};
// --------------------------------------------------------
// Type: NtmsUITypes
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const NtmsUITypes = *opaque{
};
// --------------------------------------------------------
// Type: NtmsUIOperations
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const NtmsUIOperations = *opaque{
};
// --------------------------------------------------------
// Type: NtmsNotificationOperations
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const NtmsNotificationOperations = *opaque{
};
// --------------------------------------------------------
// Type: NTMS_NOTIFICATIONINFORMATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NTMS_NOTIFICATIONINFORMATION = extern struct {
    dwOperation: u32,
    ObjectId: Guid,
};
// --------------------------------------------------------
// Type: MediaLabelInfo
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const MediaLabelInfo = extern struct {
    LabelType: ?[*]u16,
    LabelIDSize: u32,
    LabelID: ?[*]u8,
    LabelAppDescr: ?[*]u16,
};
// --------------------------------------------------------
// Type: MAXMEDIALABEL
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const MAXMEDIALABEL = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: CLAIMMEDIALABEL
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const CLAIMMEDIALABEL = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: CLAIMMEDIALABELEX
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const CLAIMMEDIALABELEX = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: CLS_LSN
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CLS_LSN = extern struct {
    Internal: u64,
};
// --------------------------------------------------------
// Type: CLS_CONTEXT_MODE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const CLS_CONTEXT_MODE = *opaque{
};
// --------------------------------------------------------
// Type: CLFS_CONTEXT_MODE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const CLFS_CONTEXT_MODE = *opaque{
};
// --------------------------------------------------------
// Type: CLFS_NODE_ID
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CLFS_NODE_ID = extern struct {
    cType: u32,
    cbNode: u32,
};
// --------------------------------------------------------
// Type: CLS_WRITE_ENTRY
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CLS_WRITE_ENTRY = extern struct {
    Buffer: ?*opaque{},
    ByteLength: u32,
};
// --------------------------------------------------------
// Type: CLS_INFORMATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CLS_INFORMATION = extern struct {
    TotalAvailable: i64,
    CurrentAvailable: i64,
    TotalReservation: i64,
    BaseFileSize: u64,
    ContainerSize: u64,
    TotalContainers: u32,
    FreeContainers: u32,
    TotalClients: u32,
    Attributes: u32,
    FlushThreshold: u32,
    SectorSize: u32,
    MinArchiveTailLsn: CLS_LSN,
    BaseLsn: CLS_LSN,
    LastFlushedLsn: CLS_LSN,
    LastLsn: CLS_LSN,
    RestartLsn: CLS_LSN,
    Identity: Guid,
};
// --------------------------------------------------------
// Type: CLFS_LOG_NAME_INFORMATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CLFS_LOG_NAME_INFORMATION = extern struct {
    NameLengthInBytes: u16,
    Name: ?[*]u16,
};
// --------------------------------------------------------
// Type: CLFS_STREAM_ID_INFORMATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CLFS_STREAM_ID_INFORMATION = extern struct {
    StreamIdentifier: u8,
};
// --------------------------------------------------------
// Type: CLFS_PHYSICAL_LSN_INFORMATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CLFS_PHYSICAL_LSN_INFORMATION = extern struct {
    StreamIdentifier: u8,
    VirtualLsn: CLS_LSN,
    PhysicalLsn: CLS_LSN,
};
// --------------------------------------------------------
// Type: CLS_CONTAINER_INFORMATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CLS_CONTAINER_INFORMATION = extern struct {
    FileAttributes: u32,
    CreationTime: u64,
    LastAccessTime: u64,
    LastWriteTime: u64,
    ContainerSize: i64,
    FileNameActualLength: u32,
    FileNameLength: u32,
    FileName: ?[*]u16,
    State: u32,
    PhysicalContainerId: u32,
    LogicalContainerId: u32,
};
// --------------------------------------------------------
// Type: CLS_LOG_INFORMATION_CLASS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const CLS_LOG_INFORMATION_CLASS = *opaque{
};
// --------------------------------------------------------
// Type: CLS_IOSTATS_CLASS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const CLS_IOSTATS_CLASS = *opaque{
};
// --------------------------------------------------------
// Type: CLFS_IOSTATS_CLASS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const CLFS_IOSTATS_CLASS = *opaque{
};
// --------------------------------------------------------
// Type: CLS_IO_STATISTICS_HEADER
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CLS_IO_STATISTICS_HEADER = extern struct {
    ubMajorVersion: u8,
    ubMinorVersion: u8,
    eStatsClass: CLFS_IOSTATS_CLASS,
    cbLength: u16,
    coffData: u32,
};
// --------------------------------------------------------
// Type: CLS_IO_STATISTICS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CLS_IO_STATISTICS = extern struct {
    hdrIoStats: CLS_IO_STATISTICS_HEADER,
    cFlush: u64,
    cbFlush: u64,
    cMetaFlush: u64,
    cbMetaFlush: u64,
};
// --------------------------------------------------------
// Type: CLS_SCAN_CONTEXT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CLS_SCAN_CONTEXT = extern struct {
    cidNode: CLFS_NODE_ID,
    hLog: HANDLE,
    cIndex: u32,
    cContainers: u32,
    cContainersReturned: u32,
    eScanMode: u8,
    pinfoContainer: ?*CLS_CONTAINER_INFORMATION,
};
// --------------------------------------------------------
// Type: CLS_ARCHIVE_DESCRIPTOR
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CLS_ARCHIVE_DESCRIPTOR = extern struct {
    coffLow: u64,
    coffHigh: u64,
    infoContainer: CLS_CONTAINER_INFORMATION,
};
// --------------------------------------------------------
// Type: CLFS_BLOCK_ALLOCATION
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const CLFS_BLOCK_ALLOCATION = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: CLFS_BLOCK_DEALLOCATION
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const CLFS_BLOCK_DEALLOCATION = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: CLFS_LOG_ARCHIVE_MODE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const CLFS_LOG_ARCHIVE_MODE = *opaque{
};
// --------------------------------------------------------
// Type: PCLFS_COMPLETION_ROUTINE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PCLFS_COMPLETION_ROUTINE = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: CLFS_MGMT_POLICY_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const CLFS_MGMT_POLICY_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: CLFS_MGMT_POLICY
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CLFS_MGMT_POLICY = extern struct {
    Version: u32,
    LengthInBytes: u32,
    PolicyFlags: u32,
    PolicyType: CLFS_MGMT_POLICY_TYPE,
    PolicyParameters: _PolicyParameters_e__Union,
    // --------------------------------------------------------
    // Type: _PolicyParameters_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _PolicyParameters_e__Union = *opaque{
        // --------------------------------------------------------
        // Type: _NewContainerSuffix_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _NewContainerSuffix_e__Struct = extern struct {
            NextContainerSuffix: u64,
        };
        // --------------------------------------------------------
        // Type: _AutoGrow_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _AutoGrow_e__Struct = extern struct {
            Enabled: u32,
        };
        // --------------------------------------------------------
        // Type: _LogTail_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _LogTail_e__Struct = extern struct {
            MinimumAvailablePercentage: u32,
            MinimumAvailableContainers: u32,
        };
        // --------------------------------------------------------
        // Type: _NewContainerSize_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _NewContainerSize_e__Struct = extern struct {
            SizeInBytes: u32,
        };
        // --------------------------------------------------------
        // Type: _MaximumSize_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _MaximumSize_e__Struct = extern struct {
            Containers: u32,
        };
        // --------------------------------------------------------
        // Type: _NewContainerExtension_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _NewContainerExtension_e__Struct = extern struct {
            ExtensionLengthInBytes: u16,
            ExtensionString: ?[*]u16,
        };
        // --------------------------------------------------------
        // Type: _AutoShrink_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _AutoShrink_e__Struct = extern struct {
            Percentage: u32,
        };
        // --------------------------------------------------------
        // Type: _MinimumSize_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _MinimumSize_e__Struct = extern struct {
            Containers: u32,
        };
        // --------------------------------------------------------
        // Type: _NewContainerPrefix_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _NewContainerPrefix_e__Struct = extern struct {
            PrefixLengthInBytes: u16,
            PrefixString: ?[*]u16,
        };
        // --------------------------------------------------------
        // Type: _GrowthRate_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _GrowthRate_e__Struct = extern struct {
            AbsoluteGrowthInContainers: u32,
            RelativeGrowthPercentage: u32,
        };
    };
};
// --------------------------------------------------------
// Type: CLFS_MGMT_NOTIFICATION_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const CLFS_MGMT_NOTIFICATION_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: CLFS_MGMT_NOTIFICATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CLFS_MGMT_NOTIFICATION = extern struct {
    Notification: CLFS_MGMT_NOTIFICATION_TYPE,
    Lsn: CLS_LSN,
    LogIsPinned: u16,
};
// --------------------------------------------------------
// Type: PLOG_TAIL_ADVANCE_CALLBACK
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PLOG_TAIL_ADVANCE_CALLBACK = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PLOG_FULL_HANDLER_CALLBACK
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PLOG_FULL_HANDLER_CALLBACK = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PLOG_UNPINNED_CALLBACK
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PLOG_UNPINNED_CALLBACK = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: LOG_MANAGEMENT_CALLBACKS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const LOG_MANAGEMENT_CALLBACKS = extern struct {
    CallbackContext: ?*opaque{},
    AdvanceTailCallback: PLOG_TAIL_ADVANCE_CALLBACK,
    LogFullHandlerCallback: PLOG_FULL_HANDLER_CALLBACK,
    LogUnpinnedCallback: PLOG_UNPINNED_CALLBACK,
};
// --------------------------------------------------------
// Type: DISKQUOTA_USER_INFORMATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DISKQUOTA_USER_INFORMATION = extern struct {
    QuotaUsed: i64,
    QuotaThreshold: i64,
    QuotaLimit: i64,
};
// --------------------------------------------------------
// Type: IDiskQuotaUser
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IDiskQuotaUser = *opaque{
    // TODO: Method 'GetID'
    // TODO: Method 'GetName'
    // TODO: Method 'GetSidLength'
    // TODO: Method 'GetSid'
    // TODO: Method 'GetQuotaThreshold'
    // TODO: Method 'GetQuotaThresholdText'
    // TODO: Method 'GetQuotaLimit'
    // TODO: Method 'GetQuotaLimitText'
    // TODO: Method 'GetQuotaUsed'
    // TODO: Method 'GetQuotaUsedText'
    // TODO: Method 'GetQuotaInformation'
    // TODO: Method 'SetQuotaThreshold'
    // TODO: Method 'SetQuotaLimit'
    // TODO: Method 'Invalidate'
    // TODO: Method 'GetAccountStatus'
};
// --------------------------------------------------------
// Type: IEnumDiskQuotaUsers
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IEnumDiskQuotaUsers = *opaque{
    // TODO: Method 'Next'
    // TODO: Method 'Skip'
    // TODO: Method 'Reset'
    // TODO: Method 'Clone'
};
// --------------------------------------------------------
// Type: IDiskQuotaUserBatch
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IDiskQuotaUserBatch = *opaque{
    // TODO: Method 'Add'
    // TODO: Method 'Remove'
    // TODO: Method 'RemoveAll'
    // TODO: Method 'FlushToDisk'
};
// --------------------------------------------------------
// Type: IDiskQuotaControl
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IDiskQuotaControl = *opaque{
    // TODO: Method 'Initialize'
    // TODO: Method 'SetQuotaState'
    // TODO: Method 'GetQuotaState'
    // TODO: Method 'SetQuotaLogFlags'
    // TODO: Method 'GetQuotaLogFlags'
    // TODO: Method 'SetDefaultQuotaThreshold'
    // TODO: Method 'GetDefaultQuotaThreshold'
    // TODO: Method 'GetDefaultQuotaThresholdText'
    // TODO: Method 'SetDefaultQuotaLimit'
    // TODO: Method 'GetDefaultQuotaLimit'
    // TODO: Method 'GetDefaultQuotaLimitText'
    // TODO: Method 'AddUserSid'
    // TODO: Method 'AddUserName'
    // TODO: Method 'DeleteUser'
    // TODO: Method 'FindUserSid'
    // TODO: Method 'FindUserName'
    // TODO: Method 'CreateEnumUsers'
    // TODO: Method 'CreateUserBatch'
    // TODO: Method 'InvalidateSidNameCache'
    // TODO: Method 'GiveUserNameResolutionPriority'
    // TODO: Method 'ShutdownNameResolution'
};
// --------------------------------------------------------
// Type: IDiskQuotaEvents
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IDiskQuotaEvents = *opaque{
    // TODO: Method 'OnUserNameChanged'
};
// --------------------------------------------------------
// Type: WofEnumEntryProc
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const WofEnumEntryProc = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: WofEnumFilesProc
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const WofEnumFilesProc = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: WIM_ENTRY_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const WIM_ENTRY_INFO = extern struct {
    WimEntryInfoSize: u32,
    WimType: u32,
    DataSourceId: LARGE_INTEGER,
    WimGuid: Guid,
    WimPath: ?*u16,
    WimIndex: u32,
    Flags: u32,
};
// --------------------------------------------------------
// Type: WIM_EXTERNAL_FILE_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const WIM_EXTERNAL_FILE_INFO = extern struct {
    DataSourceId: LARGE_INTEGER,
    ResourceHash: ?[*]u8,
    Flags: u32,
};
// --------------------------------------------------------
// Type: WOF_FILE_COMPRESSION_INFO_V0
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const WOF_FILE_COMPRESSION_INFO_V0 = extern struct {
    Algorithm: u32,
};
// --------------------------------------------------------
// Type: WOF_FILE_COMPRESSION_INFO_V1
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const WOF_FILE_COMPRESSION_INFO_V1 = extern struct {
    Algorithm: u32,
    Flags: u32,
};
// --------------------------------------------------------
// Type: TXF_ID
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TXF_ID = extern struct {
    Anonymous: _Anonymous_e__Struct,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Struct
    // TypeLayoutAttr: sequential
    // not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=4 Size=0
    pub const _Anonymous_e__Struct = *opaque{
    };
};
// --------------------------------------------------------
// Type: TXF_LOG_RECORD_BASE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TXF_LOG_RECORD_BASE = extern struct {
    Version: u16,
    RecordType: u16,
    RecordLength: u32,
};
// --------------------------------------------------------
// Type: TXF_LOG_RECORD_WRITE
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=4 Size=0
pub const TXF_LOG_RECORD_WRITE = *opaque{
};
// --------------------------------------------------------
// Type: TXF_LOG_RECORD_TRUNCATE
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=4 Size=0
pub const TXF_LOG_RECORD_TRUNCATE = *opaque{
};
// --------------------------------------------------------
// Type: TXF_LOG_RECORD_AFFECTED_FILE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TXF_LOG_RECORD_AFFECTED_FILE = extern struct {
    Version: u16,
    RecordLength: u32,
    Flags: u32,
    TxfFileId: TXF_ID,
    KtmGuid: Guid,
    FileNameLength: u32,
    FileNameByteOffsetInStructure: u32,
};
// --------------------------------------------------------
// Type: VOLUME_FAILOVER_SET
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VOLUME_FAILOVER_SET = extern struct {
    NumberOfDisks: u32,
    DiskNumbers: ?[*]u32,
};
// --------------------------------------------------------
// Type: VOLUME_NUMBER
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VOLUME_NUMBER = extern struct {
    VolumeNumber: u32,
    VolumeManagerName: ?[*]u16,
};
// --------------------------------------------------------
// Type: VOLUME_LOGICAL_OFFSET
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VOLUME_LOGICAL_OFFSET = extern struct {
    LogicalOffset: i64,
};
// --------------------------------------------------------
// Type: VOLUME_PHYSICAL_OFFSET
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VOLUME_PHYSICAL_OFFSET = extern struct {
    DiskNumber: u32,
    Offset: i64,
};
// --------------------------------------------------------
// Type: VOLUME_PHYSICAL_OFFSETS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VOLUME_PHYSICAL_OFFSETS = extern struct {
    NumberOfPhysicalOffsets: u32,
    PhysicalOffset: ?[*]VOLUME_PHYSICAL_OFFSET,
};
// --------------------------------------------------------
// Type: VOLUME_READ_PLEX_INPUT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VOLUME_READ_PLEX_INPUT = extern struct {
    ByteOffset: LARGE_INTEGER,
    Length: u32,
    PlexNumber: u32,
};
// --------------------------------------------------------
// Type: VOLUME_SET_GPT_ATTRIBUTES_INFORMATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VOLUME_SET_GPT_ATTRIBUTES_INFORMATION = extern struct {
    GptAttributes: u64,
    RevertOnClose: u8,
    ApplyToAllConnectedVolumes: u8,
    Reserved1: u16,
    Reserved2: u32,
};
// --------------------------------------------------------
// Type: VOLUME_GET_BC_PROPERTIES_INPUT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VOLUME_GET_BC_PROPERTIES_INPUT = extern struct {
    Version: u32,
    Reserved1: u32,
    LowestByteOffset: u64,
    HighestByteOffset: u64,
    AccessType: u32,
    AccessMode: u32,
};
// --------------------------------------------------------
// Type: VOLUME_GET_BC_PROPERTIES_OUTPUT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VOLUME_GET_BC_PROPERTIES_OUTPUT = extern struct {
    MaximumRequestsPerPeriod: u32,
    MinimumPeriod: u32,
    MaximumRequestSize: u64,
    EstimatedTimePerRequest: u32,
    NumOutStandingRequests: u32,
    RequestSize: u64,
};
// --------------------------------------------------------
// Type: VOLUME_ALLOCATE_BC_STREAM_INPUT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VOLUME_ALLOCATE_BC_STREAM_INPUT = extern struct {
    Version: u32,
    RequestsPerPeriod: u32,
    Period: u32,
    RetryFailures: u8,
    Discardable: u8,
    Reserved1: ?[*]u8,
    LowestByteOffset: u64,
    HighestByteOffset: u64,
    AccessType: u32,
    AccessMode: u32,
};
// --------------------------------------------------------
// Type: VOLUME_ALLOCATE_BC_STREAM_OUTPUT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VOLUME_ALLOCATE_BC_STREAM_OUTPUT = extern struct {
    RequestSize: u64,
    NumOutStandingRequests: u32,
};
// --------------------------------------------------------
// Type: FILE_EXTENT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const FILE_EXTENT = extern struct {
    VolumeOffset: u64,
    ExtentLength: u64,
};
// --------------------------------------------------------
// Type: VOLUME_CRITICAL_IO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VOLUME_CRITICAL_IO = extern struct {
    AccessType: u32,
    ExtentsCount: u32,
    Extents: ?[*]FILE_EXTENT,
};
// --------------------------------------------------------
// Type: VOLUME_ALLOCATION_HINT_INPUT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VOLUME_ALLOCATION_HINT_INPUT = extern struct {
    ClusterSize: u32,
    NumberOfClusters: u32,
    StartingClusterNumber: i64,
};
// --------------------------------------------------------
// Type: VOLUME_ALLOCATION_HINT_OUTPUT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VOLUME_ALLOCATION_HINT_OUTPUT = extern struct {
    Bitmap: ?[*]u32,
};
// --------------------------------------------------------
// Type: VOLUME_SHRINK_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VOLUME_SHRINK_INFO = extern struct {
    VolumeSize: u64,
};
// --------------------------------------------------------
// Type: SHARE_INFO_0
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SHARE_INFO_0 = extern struct {
    shi0_netname: ?*u16,
};
// --------------------------------------------------------
// Type: SHARE_INFO_1
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SHARE_INFO_1 = extern struct {
    shi1_netname: ?*u16,
    shi1_type: u32,
    shi1_remark: ?*u16,
};
// --------------------------------------------------------
// Type: SHARE_INFO_2
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SHARE_INFO_2 = extern struct {
    shi2_netname: ?*u16,
    shi2_type: u32,
    shi2_remark: ?*u16,
    shi2_permissions: u32,
    shi2_max_uses: u32,
    shi2_current_uses: u32,
    shi2_path: ?*u16,
    shi2_passwd: ?*u16,
};
// --------------------------------------------------------
// Type: SHARE_INFO_501
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SHARE_INFO_501 = extern struct {
    shi501_netname: ?*u16,
    shi501_type: u32,
    shi501_remark: ?*u16,
    shi501_flags: u32,
};
// --------------------------------------------------------
// Type: SHARE_INFO_502
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SHARE_INFO_502 = extern struct {
    shi502_netname: ?*u16,
    shi502_type: u32,
    shi502_remark: ?*u16,
    shi502_permissions: u32,
    shi502_max_uses: u32,
    shi502_current_uses: u32,
    shi502_path: ?*u16,
    shi502_passwd: ?*u16,
    shi502_reserved: u32,
    shi502_security_descriptor: ?*opaque{},
};
// --------------------------------------------------------
// Type: SHARE_INFO_503
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SHARE_INFO_503 = extern struct {
    shi503_netname: ?*u16,
    shi503_type: u32,
    shi503_remark: ?*u16,
    shi503_permissions: u32,
    shi503_max_uses: u32,
    shi503_current_uses: u32,
    shi503_path: ?*u16,
    shi503_passwd: ?*u16,
    shi503_servername: ?*u16,
    shi503_reserved: u32,
    shi503_security_descriptor: ?*opaque{},
};
// --------------------------------------------------------
// Type: SHARE_INFO_1004
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SHARE_INFO_1004 = extern struct {
    shi1004_remark: ?*u16,
};
// --------------------------------------------------------
// Type: SHARE_INFO_1005
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SHARE_INFO_1005 = extern struct {
    shi1005_flags: u32,
};
// --------------------------------------------------------
// Type: SHARE_INFO_1006
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SHARE_INFO_1006 = extern struct {
    shi1006_max_uses: u32,
};
// --------------------------------------------------------
// Type: SHARE_INFO_1501
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SHARE_INFO_1501 = extern struct {
    shi1501_reserved: u32,
    shi1501_security_descriptor: ?*opaque{},
};
// --------------------------------------------------------
// Type: SHARE_INFO_1503
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SHARE_INFO_1503 = extern struct {
    shi1503_sharefilter: Guid,
};
// --------------------------------------------------------
// Type: SERVER_ALIAS_INFO_0
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SERVER_ALIAS_INFO_0 = extern struct {
    srvai0_alias: ?*u16,
    srvai0_target: ?*u16,
    srvai0_default: u8,
    srvai0_reserved: u32,
};
// --------------------------------------------------------
// Type: SESSION_INFO_0
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SESSION_INFO_0 = extern struct {
    sesi0_cname: ?*u16,
};
// --------------------------------------------------------
// Type: SESSION_INFO_1
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SESSION_INFO_1 = extern struct {
    sesi1_cname: ?*u16,
    sesi1_username: ?*u16,
    sesi1_num_opens: u32,
    sesi1_time: u32,
    sesi1_idle_time: u32,
    sesi1_user_flags: u32,
};
// --------------------------------------------------------
// Type: SESSION_INFO_2
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SESSION_INFO_2 = extern struct {
    sesi2_cname: ?*u16,
    sesi2_username: ?*u16,
    sesi2_num_opens: u32,
    sesi2_time: u32,
    sesi2_idle_time: u32,
    sesi2_user_flags: u32,
    sesi2_cltype_name: ?*u16,
};
// --------------------------------------------------------
// Type: SESSION_INFO_10
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SESSION_INFO_10 = extern struct {
    sesi10_cname: ?*u16,
    sesi10_username: ?*u16,
    sesi10_time: u32,
    sesi10_idle_time: u32,
};
// --------------------------------------------------------
// Type: SESSION_INFO_502
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SESSION_INFO_502 = extern struct {
    sesi502_cname: ?*u16,
    sesi502_username: ?*u16,
    sesi502_num_opens: u32,
    sesi502_time: u32,
    sesi502_idle_time: u32,
    sesi502_user_flags: u32,
    sesi502_cltype_name: ?*u16,
    sesi502_transport: ?*u16,
};
// --------------------------------------------------------
// Type: CONNECTION_INFO_0
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CONNECTION_INFO_0 = extern struct {
    coni0_id: u32,
};
// --------------------------------------------------------
// Type: CONNECTION_INFO_1
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CONNECTION_INFO_1 = extern struct {
    coni1_id: u32,
    coni1_type: u32,
    coni1_num_opens: u32,
    coni1_num_users: u32,
    coni1_time: u32,
    coni1_username: ?*u16,
    coni1_netname: ?*u16,
};
// --------------------------------------------------------
// Type: FILE_INFO_2
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const FILE_INFO_2 = extern struct {
    fi2_id: u32,
};
// --------------------------------------------------------
// Type: FILE_INFO_3
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const FILE_INFO_3 = extern struct {
    fi3_id: u32,
    fi3_permissions: u32,
    fi3_num_locks: u32,
    fi3_pathname: ?*u16,
    fi3_username: ?*u16,
};
// --------------------------------------------------------
// Type: SERVER_CERTIFICATE_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const SERVER_CERTIFICATE_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: SERVER_CERTIFICATE_INFO_0
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SERVER_CERTIFICATE_INFO_0 = extern struct {
    srvci0_name: ?*u16,
    srvci0_subject: ?*u16,
    srvci0_issuer: ?*u16,
    srvci0_thumbprint: ?*u16,
    srvci0_friendlyname: ?*u16,
    srvci0_notbefore: ?*u16,
    srvci0_notafter: ?*u16,
    srvci0_storelocation: ?*u16,
    srvci0_storename: ?*u16,
    srvci0_type: u32,
};
// --------------------------------------------------------
// Type: STAT_WORKSTATION_0
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const STAT_WORKSTATION_0 = extern struct {
    StatisticsStartTime: LARGE_INTEGER,
    BytesReceived: LARGE_INTEGER,
    SmbsReceived: LARGE_INTEGER,
    PagingReadBytesRequested: LARGE_INTEGER,
    NonPagingReadBytesRequested: LARGE_INTEGER,
    CacheReadBytesRequested: LARGE_INTEGER,
    NetworkReadBytesRequested: LARGE_INTEGER,
    BytesTransmitted: LARGE_INTEGER,
    SmbsTransmitted: LARGE_INTEGER,
    PagingWriteBytesRequested: LARGE_INTEGER,
    NonPagingWriteBytesRequested: LARGE_INTEGER,
    CacheWriteBytesRequested: LARGE_INTEGER,
    NetworkWriteBytesRequested: LARGE_INTEGER,
    InitiallyFailedOperations: u32,
    FailedCompletionOperations: u32,
    ReadOperations: u32,
    RandomReadOperations: u32,
    ReadSmbs: u32,
    LargeReadSmbs: u32,
    SmallReadSmbs: u32,
    WriteOperations: u32,
    RandomWriteOperations: u32,
    WriteSmbs: u32,
    LargeWriteSmbs: u32,
    SmallWriteSmbs: u32,
    RawReadsDenied: u32,
    RawWritesDenied: u32,
    NetworkErrors: u32,
    Sessions: u32,
    FailedSessions: u32,
    Reconnects: u32,
    CoreConnects: u32,
    Lanman20Connects: u32,
    Lanman21Connects: u32,
    LanmanNtConnects: u32,
    ServerDisconnects: u32,
    HungSessions: u32,
    UseCount: u32,
    FailedUseCount: u32,
    CurrentCommands: u32,
};
// --------------------------------------------------------
// Type: STAT_SERVER_0
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const STAT_SERVER_0 = extern struct {
    sts0_start: u32,
    sts0_fopens: u32,
    sts0_devopens: u32,
    sts0_jobsqueued: u32,
    sts0_sopens: u32,
    sts0_stimedout: u32,
    sts0_serrorout: u32,
    sts0_pwerrors: u32,
    sts0_permerrors: u32,
    sts0_syserrors: u32,
    sts0_bytessent_low: u32,
    sts0_bytessent_high: u32,
    sts0_bytesrcvd_low: u32,
    sts0_bytesrcvd_high: u32,
    sts0_avresponse: u32,
    sts0_reqbufneed: u32,
    sts0_bigbufneed: u32,
};
// --------------------------------------------------------
// Type: OFSTRUCT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const OFSTRUCT = extern struct {
    cBytes: u8,
    fFixedDisk: u8,
    nErrCode: u16,
    Reserved1: u16,
    Reserved2: u16,
    szPathName: ?[*]i8,
};
// --------------------------------------------------------
// Type: PFE_EXPORT_FUNC
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFE_EXPORT_FUNC = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PFE_IMPORT_FUNC
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFE_IMPORT_FUNC = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: LPPROGRESS_ROUTINE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const LPPROGRESS_ROUTINE = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: COPYFILE2_MESSAGE_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const COPYFILE2_MESSAGE_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: COPYFILE2_MESSAGE_ACTION
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const COPYFILE2_MESSAGE_ACTION = *opaque{
};
// --------------------------------------------------------
// Type: COPYFILE2_COPY_PHASE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const COPYFILE2_COPY_PHASE = *opaque{
};
// --------------------------------------------------------
// Type: COPYFILE2_MESSAGE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const COPYFILE2_MESSAGE = extern struct {
    Type: COPYFILE2_MESSAGE_TYPE,
    dwPadding: u32,
    Info: _Info_e__Union,
    // --------------------------------------------------------
    // Type: _Info_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Info_e__Union = *opaque{
        // --------------------------------------------------------
        // Type: _Error_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _Error_e__Struct = extern struct {
            CopyPhase: COPYFILE2_COPY_PHASE,
            dwStreamNumber: u32,
            hrFailure: HRESULT,
            dwReserved: u32,
            uliChunkNumber: ULARGE_INTEGER,
            uliStreamSize: ULARGE_INTEGER,
            uliStreamBytesTransferred: ULARGE_INTEGER,
            uliTotalFileSize: ULARGE_INTEGER,
            uliTotalBytesTransferred: ULARGE_INTEGER,
        };
        // --------------------------------------------------------
        // Type: _StreamFinished_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _StreamFinished_e__Struct = extern struct {
            dwStreamNumber: u32,
            dwReserved: u32,
            hSourceFile: HANDLE,
            hDestinationFile: HANDLE,
            uliStreamSize: ULARGE_INTEGER,
            uliStreamBytesTransferred: ULARGE_INTEGER,
            uliTotalFileSize: ULARGE_INTEGER,
            uliTotalBytesTransferred: ULARGE_INTEGER,
        };
        // --------------------------------------------------------
        // Type: _ChunkFinished_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _ChunkFinished_e__Struct = extern struct {
            dwStreamNumber: u32,
            dwFlags: u32,
            hSourceFile: HANDLE,
            hDestinationFile: HANDLE,
            uliChunkNumber: ULARGE_INTEGER,
            uliChunkSize: ULARGE_INTEGER,
            uliStreamSize: ULARGE_INTEGER,
            uliStreamBytesTransferred: ULARGE_INTEGER,
            uliTotalFileSize: ULARGE_INTEGER,
            uliTotalBytesTransferred: ULARGE_INTEGER,
        };
        // --------------------------------------------------------
        // Type: _PollContinue_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _PollContinue_e__Struct = extern struct {
            dwReserved: u32,
        };
        // --------------------------------------------------------
        // Type: _ChunkStarted_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _ChunkStarted_e__Struct = extern struct {
            dwStreamNumber: u32,
            dwReserved: u32,
            hSourceFile: HANDLE,
            hDestinationFile: HANDLE,
            uliChunkNumber: ULARGE_INTEGER,
            uliChunkSize: ULARGE_INTEGER,
            uliStreamSize: ULARGE_INTEGER,
            uliTotalFileSize: ULARGE_INTEGER,
        };
        // --------------------------------------------------------
        // Type: _StreamStarted_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _StreamStarted_e__Struct = extern struct {
            dwStreamNumber: u32,
            dwReserved: u32,
            hSourceFile: HANDLE,
            hDestinationFile: HANDLE,
            uliStreamSize: ULARGE_INTEGER,
            uliTotalFileSize: ULARGE_INTEGER,
        };
    };
};
// --------------------------------------------------------
// Type: PCOPYFILE2_PROGRESS_ROUTINE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PCOPYFILE2_PROGRESS_ROUTINE = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: COPYFILE2_EXTENDED_PARAMETERS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const COPYFILE2_EXTENDED_PARAMETERS = extern struct {
    dwSize: u32,
    dwCopyFlags: u32,
    pfCancel: ?*i32,
    pProgressRoutine: PCOPYFILE2_PROGRESS_ROUTINE,
    pvCallbackContext: ?*opaque{},
};
// --------------------------------------------------------
// Type: FILE_BASIC_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const FILE_BASIC_INFO = extern struct {
    CreationTime: LARGE_INTEGER,
    LastAccessTime: LARGE_INTEGER,
    LastWriteTime: LARGE_INTEGER,
    ChangeTime: LARGE_INTEGER,
    FileAttributes: u32,
};
// --------------------------------------------------------
// Type: FILE_STANDARD_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const FILE_STANDARD_INFO = extern struct {
    AllocationSize: LARGE_INTEGER,
    EndOfFile: LARGE_INTEGER,
    NumberOfLinks: u32,
    DeletePending: u8,
    Directory: u8,
};
// --------------------------------------------------------
// Type: FILE_NAME_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const FILE_NAME_INFO = extern struct {
    FileNameLength: u32,
    FileName: ?[*]u16,
};
// --------------------------------------------------------
// Type: FILE_RENAME_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const FILE_RENAME_INFO = extern struct {
    Anonymous: _Anonymous_e__Union,
    RootDirectory: HANDLE,
    FileNameLength: u32,
    FileName: ?[*]u16,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: FILE_ALLOCATION_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const FILE_ALLOCATION_INFO = extern struct {
    AllocationSize: LARGE_INTEGER,
};
// --------------------------------------------------------
// Type: FILE_END_OF_FILE_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const FILE_END_OF_FILE_INFO = extern struct {
    EndOfFile: LARGE_INTEGER,
};
// --------------------------------------------------------
// Type: FILE_STREAM_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const FILE_STREAM_INFO = extern struct {
    NextEntryOffset: u32,
    StreamNameLength: u32,
    StreamSize: LARGE_INTEGER,
    StreamAllocationSize: LARGE_INTEGER,
    StreamName: ?[*]u16,
};
// --------------------------------------------------------
// Type: FILE_COMPRESSION_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const FILE_COMPRESSION_INFO = extern struct {
    CompressedFileSize: LARGE_INTEGER,
    CompressionFormat: u16,
    CompressionUnitShift: u8,
    ChunkShift: u8,
    ClusterShift: u8,
    Reserved: ?[*]u8,
};
// --------------------------------------------------------
// Type: FILE_ATTRIBUTE_TAG_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const FILE_ATTRIBUTE_TAG_INFO = extern struct {
    FileAttributes: u32,
    ReparseTag: u32,
};
// --------------------------------------------------------
// Type: FILE_DISPOSITION_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const FILE_DISPOSITION_INFO = extern struct {
    DeleteFileA: u8,
};
// --------------------------------------------------------
// Type: FILE_ID_BOTH_DIR_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const FILE_ID_BOTH_DIR_INFO = extern struct {
    NextEntryOffset: u32,
    FileIndex: u32,
    CreationTime: LARGE_INTEGER,
    LastAccessTime: LARGE_INTEGER,
    LastWriteTime: LARGE_INTEGER,
    ChangeTime: LARGE_INTEGER,
    EndOfFile: LARGE_INTEGER,
    AllocationSize: LARGE_INTEGER,
    FileAttributes: u32,
    FileNameLength: u32,
    EaSize: u32,
    ShortNameLength: i8,
    ShortName: ?[*]u16,
    FileId: LARGE_INTEGER,
    FileName: ?[*]u16,
};
// --------------------------------------------------------
// Type: FILE_FULL_DIR_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const FILE_FULL_DIR_INFO = extern struct {
    NextEntryOffset: u32,
    FileIndex: u32,
    CreationTime: LARGE_INTEGER,
    LastAccessTime: LARGE_INTEGER,
    LastWriteTime: LARGE_INTEGER,
    ChangeTime: LARGE_INTEGER,
    EndOfFile: LARGE_INTEGER,
    AllocationSize: LARGE_INTEGER,
    FileAttributes: u32,
    FileNameLength: u32,
    EaSize: u32,
    FileName: ?[*]u16,
};
// --------------------------------------------------------
// Type: PRIORITY_HINT
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PRIORITY_HINT = *opaque{
};
// --------------------------------------------------------
// Type: FILE_IO_PRIORITY_HINT_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const FILE_IO_PRIORITY_HINT_INFO = extern struct {
    PriorityHint: PRIORITY_HINT,
};
// --------------------------------------------------------
// Type: FILE_ALIGNMENT_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const FILE_ALIGNMENT_INFO = extern struct {
    AlignmentRequirement: u32,
};
// --------------------------------------------------------
// Type: FILE_STORAGE_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const FILE_STORAGE_INFO = extern struct {
    LogicalBytesPerSector: u32,
    PhysicalBytesPerSectorForAtomicity: u32,
    PhysicalBytesPerSectorForPerformance: u32,
    FileSystemEffectivePhysicalBytesPerSectorForAtomicity: u32,
    Flags: u32,
    ByteOffsetForSectorAlignment: u32,
    ByteOffsetForPartitionAlignment: u32,
};
// --------------------------------------------------------
// Type: FILE_ID_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const FILE_ID_INFO = extern struct {
    VolumeSerialNumber: u64,
    FileId: FILE_ID_128,
};
// --------------------------------------------------------
// Type: FILE_ID_EXTD_DIR_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const FILE_ID_EXTD_DIR_INFO = extern struct {
    NextEntryOffset: u32,
    FileIndex: u32,
    CreationTime: LARGE_INTEGER,
    LastAccessTime: LARGE_INTEGER,
    LastWriteTime: LARGE_INTEGER,
    ChangeTime: LARGE_INTEGER,
    EndOfFile: LARGE_INTEGER,
    AllocationSize: LARGE_INTEGER,
    FileAttributes: u32,
    FileNameLength: u32,
    EaSize: u32,
    ReparsePointTag: u32,
    FileId: FILE_ID_128,
    FileName: ?[*]u16,
};
// --------------------------------------------------------
// Type: FILE_REMOTE_PROTOCOL_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const FILE_REMOTE_PROTOCOL_INFO = extern struct {
    StructureVersion: u16,
    StructureSize: u16,
    Protocol: u32,
    ProtocolMajorVersion: u16,
    ProtocolMinorVersion: u16,
    ProtocolRevision: u16,
    Reserved: u16,
    Flags: u32,
    GenericReserved: _GenericReserved_e__Struct,
    ProtocolSpecific: _ProtocolSpecific_e__Union,
    // --------------------------------------------------------
    // Type: _ProtocolSpecific_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _ProtocolSpecific_e__Union = *opaque{
        // --------------------------------------------------------
        // Type: _Smb2_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _Smb2_e__Struct = extern struct {
            Server: _Server_e__Struct,
            Share: _Share_e__Struct,
            // --------------------------------------------------------
            // Type: _Server_e__Struct
            // TypeLayoutAttr: sequential
            // TODO: I think this is a struct, but not sure at this point, assuming it is for now
            pub const _Server_e__Struct = extern struct {
                Capabilities: u32,
            };
            // --------------------------------------------------------
            // Type: _Share_e__Struct
            // TypeLayoutAttr: sequential
            // TODO: I think this is a struct, but not sure at this point, assuming it is for now
            pub const _Share_e__Struct = extern struct {
                Capabilities: u32,
                CachingFlags: u32,
            };
        };
    };
    // --------------------------------------------------------
    // Type: _GenericReserved_e__Struct
    // TypeLayoutAttr: sequential
    // TODO: I think this is a struct, but not sure at this point, assuming it is for now
    pub const _GenericReserved_e__Struct = extern struct {
        Reserved: ?[*]u32,
    };
};
// --------------------------------------------------------
// Type: FILE_ID_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const FILE_ID_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: FILE_ID_DESCRIPTOR
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const FILE_ID_DESCRIPTOR = extern struct {
    dwSize: u32,
    Type: FILE_ID_TYPE,
    Anonymous: _Anonymous_e__Union,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
    };
};

//
// functions
//

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn CreateDirectoryA(
    lpPathName: ?*i8,
    lpSecurityAttributes: ?*SECURITY_ATTRIBUTES,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn CreateDirectoryW(
    lpPathName: ?*u16,
    lpSecurityAttributes: ?*SECURITY_ATTRIBUTES,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn CreateFileA(
    lpFileName: ?*i8,
    dwDesiredAccess: FILE_ACCESS_FLAGS,
    dwShareMode: FILE_SHARE_FLAGS,
    lpSecurityAttributes: ?*SECURITY_ATTRIBUTES,
    dwCreationDisposition: FILE_CREATE_FLAGS,
    dwFlagsAndAttributes: FILE_FLAGS_AND_ATTRIBUTES,
    hTemplateFile: HANDLE,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn CreateFileW(
    lpFileName: ?*u16,
    dwDesiredAccess: FILE_ACCESS_FLAGS,
    dwShareMode: FILE_SHARE_FLAGS,
    lpSecurityAttributes: ?*SECURITY_ATTRIBUTES,
    dwCreationDisposition: FILE_CREATE_FLAGS,
    dwFlagsAndAttributes: FILE_FLAGS_AND_ATTRIBUTES,
    hTemplateFile: HANDLE,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn DefineDosDeviceW(
    dwFlags: DEFINE_DOS_DEVICE_FLAGS,
    lpDeviceName: ?*u16,
    lpTargetPath: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn DeleteFileA(
    lpFileName: ?*i8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn DeleteFileW(
    lpFileName: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn DeleteVolumeMountPointW(
    lpszVolumeMountPoint: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn FindClose(
    hFindFile: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn FindCloseChangeNotification(
    hChangeHandle: FindChangeNotifcationHandle,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn FindFirstChangeNotificationA(
    lpPathName: ?*i8,
    bWatchSubtree: BOOL,
    dwNotifyFilter: FILE_NOTIFY_CHANGE,
) callconv(@import("std").os.windows.WINAPI) FindChangeNotifcationHandle;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn FindFirstChangeNotificationW(
    lpPathName: ?*u16,
    bWatchSubtree: BOOL,
    dwNotifyFilter: u32,
) callconv(@import("std").os.windows.WINAPI) FindChangeNotifcationHandle;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn FindFirstFileA(
    lpFileName: ?*i8,
    lpFindFileData: ?*WIN32_FIND_DATAA,
) callconv(@import("std").os.windows.WINAPI) FindFileHandle;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn FindFirstFileW(
    lpFileName: ?*u16,
    lpFindFileData: ?*WIN32_FIND_DATAW,
) callconv(@import("std").os.windows.WINAPI) FindFileHandle;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn FindFirstFileExA(
    lpFileName: ?*i8,
    fInfoLevelId: FINDEX_INFO_LEVELS,
    lpFindFileData: ?*opaque{},
    fSearchOp: FINDEX_SEARCH_OPS,
    lpSearchFilter: ?*opaque{},
    dwAdditionalFlags: FIND_FIRST_EX_FLAGS,
) callconv(@import("std").os.windows.WINAPI) FindFileHandle;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn FindFirstFileExW(
    lpFileName: ?*u16,
    fInfoLevelId: FINDEX_INFO_LEVELS,
    lpFindFileData: ?*opaque{},
    fSearchOp: FINDEX_SEARCH_OPS,
    lpSearchFilter: ?*opaque{},
    dwAdditionalFlags: FIND_FIRST_EX_FLAGS,
) callconv(@import("std").os.windows.WINAPI) FindFileHandle;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn FindFirstVolumeW(
    lpszVolumeName: ?*u16,
    cchBufferLength: u32,
) callconv(@import("std").os.windows.WINAPI) FindVolumeHandle;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn FindNextChangeNotification(
    hChangeHandle: FindChangeNotifcationHandle,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn FindNextFileA(
    hFindFile: FindFileHandle,
    lpFindFileData: ?*WIN32_FIND_DATAA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn FindNextFileW(
    hFindFile: HANDLE,
    lpFindFileData: ?*WIN32_FIND_DATAW,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn FindNextVolumeW(
    hFindVolume: FindVolumeHandle,
    lpszVolumeName: ?*u16,
    cchBufferLength: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn FindVolumeClose(
    hFindVolume: FindVolumeHandle,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn FlushFileBuffers(
    hFile: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetDiskFreeSpaceA(
    lpRootPathName: ?*i8,
    lpSectorsPerCluster: ?*u32,
    lpBytesPerSector: ?*u32,
    lpNumberOfFreeClusters: ?*u32,
    lpTotalNumberOfClusters: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetDiskFreeSpaceW(
    lpRootPathName: ?*u16,
    lpSectorsPerCluster: ?*u32,
    lpBytesPerSector: ?*u32,
    lpNumberOfFreeClusters: ?*u32,
    lpTotalNumberOfClusters: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetDiskFreeSpaceExA(
    lpDirectoryName: ?*i8,
    lpFreeBytesAvailableToCaller: ?*ULARGE_INTEGER,
    lpTotalNumberOfBytes: ?*ULARGE_INTEGER,
    lpTotalNumberOfFreeBytes: ?*ULARGE_INTEGER,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetDiskFreeSpaceExW(
    lpDirectoryName: ?*u16,
    lpFreeBytesAvailableToCaller: ?*ULARGE_INTEGER,
    lpTotalNumberOfBytes: ?*ULARGE_INTEGER,
    lpTotalNumberOfFreeBytes: ?*ULARGE_INTEGER,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn GetDiskSpaceInformationA(
    rootPath: ?*i8,
    diskSpaceInfo: ?*DISK_SPACE_INFORMATION,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn GetDiskSpaceInformationW(
    rootPath: ?*u16,
    diskSpaceInfo: ?*DISK_SPACE_INFORMATION,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn GetDriveTypeA(
    lpRootPathName: ?*i8,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn GetDriveTypeW(
    lpRootPathName: ?*u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetFileAttributesA(
    lpFileName: ?*i8,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetFileAttributesW(
    lpFileName: ?*u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetFileAttributesExA(
    lpFileName: ?*i8,
    fInfoLevelId: GET_FILEEX_INFO_LEVELS,
    lpFileInformation: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetFileAttributesExW(
    lpFileName: ?*u16,
    fInfoLevelId: GET_FILEEX_INFO_LEVELS,
    lpFileInformation: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetFileInformationByHandle(
    hFile: HANDLE,
    lpFileInformation: ?*BY_HANDLE_FILE_INFORMATION,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetFileSize(
    hFile: HANDLE,
    lpFileSizeHigh: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetFileSizeEx(
    hFile: HANDLE,
    lpFileSize: ?*LARGE_INTEGER,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetFileType(
    hFile: HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetFinalPathNameByHandleA(
    hFile: HANDLE,
    lpszFilePath: ?*i8,
    cchFilePath: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetFinalPathNameByHandleW(
    hFile: HANDLE,
    lpszFilePath: ?*u16,
    cchFilePath: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetFullPathNameW(
    lpFileName: ?*u16,
    nBufferLength: u32,
    lpBuffer: ?*u16,
    lpFilePart: ?*?*u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetFullPathNameA(
    lpFileName: ?*i8,
    nBufferLength: u32,
    lpBuffer: ?*i8,
    lpFilePart: ?*?*i8,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetLogicalDrives(
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetLogicalDriveStringsW(
    nBufferLength: u32,
    lpBuffer: ?*u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetLongPathNameA(
    lpszShortPath: ?*i8,
    lpszLongPath: ?*i8,
    cchBuffer: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetLongPathNameW(
    lpszShortPath: ?*u16,
    lpszLongPath: ?*u16,
    cchBuffer: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetShortPathNameW(
    lpszLongPath: ?*u16,
    lpszShortPath: ?*u16,
    cchBuffer: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetTempFileNameW(
    lpPathName: ?*u16,
    lpPrefixString: ?*u16,
    uUnique: u32,
    lpTempFileName: ?*u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetVolumeInformationByHandleW(
    hFile: HANDLE,
    lpVolumeNameBuffer: ?*u16,
    nVolumeNameSize: u32,
    lpVolumeSerialNumber: ?*u32,
    lpMaximumComponentLength: ?*u32,
    lpFileSystemFlags: ?*u32,
    lpFileSystemNameBuffer: ?*u16,
    nFileSystemNameSize: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetVolumeInformationW(
    lpRootPathName: ?*u16,
    lpVolumeNameBuffer: ?*u16,
    nVolumeNameSize: u32,
    lpVolumeSerialNumber: ?*u32,
    lpMaximumComponentLength: ?*u32,
    lpFileSystemFlags: ?*u32,
    lpFileSystemNameBuffer: ?*u16,
    nFileSystemNameSize: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetVolumePathNameW(
    lpszFileName: ?*u16,
    lpszVolumePathName: ?*u16,
    cchBufferLength: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn LockFile(
    hFile: HANDLE,
    dwFileOffsetLow: u32,
    dwFileOffsetHigh: u32,
    nNumberOfBytesToLockLow: u32,
    nNumberOfBytesToLockHigh: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn LockFileEx(
    hFile: HANDLE,
    dwFlags: u32,
    dwReserved: u32,
    nNumberOfBytesToLockLow: u32,
    nNumberOfBytesToLockHigh: u32,
    lpOverlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn QueryDosDeviceW(
    lpDeviceName: ?*u16,
    lpTargetPath: ?*u16,
    ucchMax: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn ReadFile(
    hFile: HANDLE,
    lpBuffer: ?*opaque{},
    nNumberOfBytesToRead: u32,
    lpNumberOfBytesRead: ?*u32,
    lpOverlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn ReadFileEx(
    hFile: HANDLE,
    lpBuffer: ?*opaque{},
    nNumberOfBytesToRead: u32,
    lpOverlapped: ?*OVERLAPPED,
    lpCompletionRoutine: LPOVERLAPPED_COMPLETION_ROUTINE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn ReadFileScatter(
    hFile: HANDLE,
    aSegmentArray: ?*FILE_SEGMENT_ELEMENT,
    nNumberOfBytesToRead: u32,
    lpReserved: ?*u32,
    lpOverlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn RemoveDirectoryA(
    lpPathName: ?*i8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn RemoveDirectoryW(
    lpPathName: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn SetEndOfFile(
    hFile: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn SetFileAttributesA(
    lpFileName: ?*i8,
    dwFileAttributes: FILE_FLAGS_AND_ATTRIBUTES,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn SetFileAttributesW(
    lpFileName: ?*u16,
    dwFileAttributes: FILE_FLAGS_AND_ATTRIBUTES,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn SetFileInformationByHandle(
    hFile: HANDLE,
    FileInformationClass: FILE_INFO_BY_HANDLE_CLASS,
    lpFileInformation: ?*opaque{},
    dwBufferSize: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn SetFilePointer(
    hFile: HANDLE,
    lDistanceToMove: i32,
    lpDistanceToMoveHigh: ?*i32,
    dwMoveMethod: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn SetFilePointerEx(
    hFile: HANDLE,
    liDistanceToMove: LARGE_INTEGER,
    lpNewFilePointer: ?*LARGE_INTEGER,
    dwMoveMethod: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn SetFileValidData(
    hFile: HANDLE,
    ValidDataLength: i64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn UnlockFile(
    hFile: HANDLE,
    dwFileOffsetLow: u32,
    dwFileOffsetHigh: u32,
    nNumberOfBytesToUnlockLow: u32,
    nNumberOfBytesToUnlockHigh: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn UnlockFileEx(
    hFile: HANDLE,
    dwReserved: u32,
    nNumberOfBytesToUnlockLow: u32,
    nNumberOfBytesToUnlockHigh: u32,
    lpOverlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn WriteFile(
    hFile: HANDLE,
    lpBuffer: ?*opaque{},
    nNumberOfBytesToWrite: u32,
    lpNumberOfBytesWritten: ?*u32,
    lpOverlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn WriteFileEx(
    hFile: HANDLE,
    lpBuffer: ?*opaque{},
    nNumberOfBytesToWrite: u32,
    lpOverlapped: ?*OVERLAPPED,
    lpCompletionRoutine: LPOVERLAPPED_COMPLETION_ROUTINE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn WriteFileGather(
    hFile: HANDLE,
    aSegmentArray: ?*FILE_SEGMENT_ELEMENT,
    nNumberOfBytesToWrite: u32,
    lpReserved: ?*u32,
    lpOverlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetTempPathW(
    nBufferLength: u32,
    lpBuffer: ?*u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetVolumeNameForVolumeMountPointW(
    lpszVolumeMountPoint: ?*u16,
    lpszVolumeName: ?*u16,
    cchBufferLength: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetVolumePathNamesForVolumeNameW(
    lpszVolumeName: ?*u16,
    lpszVolumePathNames: ?*u16,
    cchBufferLength: u32,
    lpcchReturnLength: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn CreateFile2(
    lpFileName: ?*u16,
    dwDesiredAccess: FILE_ACCESS_FLAGS,
    dwShareMode: FILE_SHARE_FLAGS,
    dwCreationDisposition: FILE_CREATE_FLAGS,
    pCreateExParams: ?*CREATEFILE2_EXTENDED_PARAMETERS,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn SetFileIoOverlappedRange(
    FileHandle: HANDLE,
    OverlappedRangeStart: ?*u8,
    Length: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetCompressedFileSizeA(
    lpFileName: ?*i8,
    lpFileSizeHigh: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetCompressedFileSizeW(
    lpFileName: ?*u16,
    lpFileSizeHigh: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn FindFirstStreamW(
    lpFileName: ?*u16,
    InfoLevel: STREAM_INFO_LEVELS,
    lpFindStreamData: ?*opaque{},
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) FindStreamHandle;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn FindNextStreamW(
    hFindStream: FindStreamHandle,
    lpFindStreamData: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn AreFileApisANSI(
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetTempPathA(
    nBufferLength: u32,
    lpBuffer: ?*i8,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn FindFirstFileNameW(
    lpFileName: ?*u16,
    dwFlags: u32,
    StringLength: ?*u32,
    LinkName: ?*u16,
) callconv(@import("std").os.windows.WINAPI) FindFileNameHandle;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn FindNextFileNameW(
    hFindStream: FindFileNameHandle,
    StringLength: ?*u32,
    LinkName: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetVolumeInformationA(
    lpRootPathName: ?*i8,
    lpVolumeNameBuffer: ?*i8,
    nVolumeNameSize: u32,
    lpVolumeSerialNumber: ?*u32,
    lpMaximumComponentLength: ?*u32,
    lpFileSystemFlags: ?*u32,
    lpFileSystemNameBuffer: ?*i8,
    nFileSystemNameSize: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetTempFileNameA(
    lpPathName: ?*i8,
    lpPrefixString: ?*i8,
    uUnique: u32,
    lpTempFileName: ?*i8,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn SetFileApisToOEM(
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn SetFileApisToANSI(
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-core-file-fromapp-l1-1-0" fn CopyFileFromAppW(
    lpExistingFileName: ?*u16,
    lpNewFileName: ?*u16,
    bFailIfExists: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-core-file-fromapp-l1-1-0" fn CreateDirectoryFromAppW(
    lpPathName: ?*u16,
    lpSecurityAttributes: ?*SECURITY_ATTRIBUTES,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-core-file-fromapp-l1-1-0" fn CreateFileFromAppW(
    lpFileName: ?*u16,
    dwDesiredAccess: u32,
    dwShareMode: u32,
    lpSecurityAttributes: ?*SECURITY_ATTRIBUTES,
    dwCreationDisposition: u32,
    dwFlagsAndAttributes: u32,
    hTemplateFile: HANDLE,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-core-file-fromapp-l1-1-0" fn CreateFile2FromAppW(
    lpFileName: ?*u16,
    dwDesiredAccess: u32,
    dwShareMode: u32,
    dwCreationDisposition: u32,
    pCreateExParams: ?*CREATEFILE2_EXTENDED_PARAMETERS,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-core-file-fromapp-l1-1-0" fn DeleteFileFromAppW(
    lpFileName: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-core-file-fromapp-l1-1-0" fn FindFirstFileExFromAppW(
    lpFileName: ?*u16,
    fInfoLevelId: FINDEX_INFO_LEVELS,
    lpFindFileData: ?*opaque{},
    fSearchOp: FINDEX_SEARCH_OPS,
    lpSearchFilter: ?*opaque{},
    dwAdditionalFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-core-file-fromapp-l1-1-0" fn GetFileAttributesExFromAppW(
    lpFileName: ?*u16,
    fInfoLevelId: GET_FILEEX_INFO_LEVELS,
    lpFileInformation: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-core-file-fromapp-l1-1-0" fn MoveFileFromAppW(
    lpExistingFileName: ?*u16,
    lpNewFileName: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-core-file-fromapp-l1-1-0" fn RemoveDirectoryFromAppW(
    lpPathName: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-core-file-fromapp-l1-1-0" fn ReplaceFileFromAppW(
    lpReplacedFileName: ?*u16,
    lpReplacementFileName: ?*u16,
    lpBackupFileName: ?*u16,
    dwReplaceFlags: u32,
    lpExclude: ?*opaque{},
    lpReserved: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-core-file-fromapp-l1-1-0" fn SetFileAttributesFromAppW(
    lpFileName: ?*u16,
    dwFileAttributes: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn CreateIoCompletionPort(
    FileHandle: HANDLE,
    ExistingCompletionPort: HANDLE,
    CompletionKey: ?*opaque{},
    NumberOfConcurrentThreads: u32,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetQueuedCompletionStatus(
    CompletionPort: HANDLE,
    lpNumberOfBytesTransferred: ?*u32,
    lpCompletionKey: ?*u32,
    lpOverlapped: ?*?*OVERLAPPED,
    dwMilliseconds: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetQueuedCompletionStatusEx(
    CompletionPort: HANDLE,
    lpCompletionPortEntries: ?*OVERLAPPED_ENTRY,
    ulCount: u32,
    ulNumEntriesRemoved: ?*u32,
    dwMilliseconds: u32,
    fAlertable: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn PostQueuedCompletionStatus(
    CompletionPort: HANDLE,
    dwNumberOfBytesTransferred: u32,
    dwCompletionKey: ?*opaque{},
    lpOverlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn CancelIoEx(
    hFile: HANDLE,
    lpOverlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn CancelIo(
    hFile: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn CancelSynchronousIo(
    hThread: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn Wow64DisableWow64FsRedirection(
    OldValue: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn Wow64RevertWow64FsRedirection(
    OlValue: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-core-wow64-l1-1-1" fn Wow64SetThreadDefaultGuestMachine(
    Machine: u16,
) callconv(@import("std").os.windows.WINAPI) u16;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn Wow64SuspendThread(
    hThread: HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn LZStart(
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn LZDone(
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn CopyLZFile(
    hfSource: i32,
    hfDest: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn LZCopy(
    hfSource: i32,
    hfDest: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn LZInit(
    hfSource: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetExpandedNameA(
    lpszSource: ?*i8,
    lpszBuffer: ?*i8,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetExpandedNameW(
    lpszSource: ?*u16,
    lpszBuffer: ?*u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn LZOpenFileA(
    lpFileName: ?*i8,
    lpReOpenBuf: ?*OFSTRUCT,
    wStyle: u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn LZOpenFileW(
    lpFileName: ?*u16,
    lpReOpenBuf: ?*OFSTRUCT,
    wStyle: u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn LZSeek(
    hFile: i32,
    lOffset: i32,
    iOrigin: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn LZRead(
    hFile: i32,
    lpBuffer: ?*i8,
    cbRead: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn LZClose(
    hFile: i32,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "ADVAPI32" fn QueryUsersOnEncryptedFile(
    lpFileName: ?*u16,
    pUsers: ?*?*ENCRYPTION_CERTIFICATE_HASH_LIST,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "ADVAPI32" fn QueryRecoveryAgentsOnEncryptedFile(
    lpFileName: ?*u16,
    pRecoveryAgents: ?*?*ENCRYPTION_CERTIFICATE_HASH_LIST,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "ADVAPI32" fn RemoveUsersFromEncryptedFile(
    lpFileName: ?*u16,
    pHashes: ?*ENCRYPTION_CERTIFICATE_HASH_LIST,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "ADVAPI32" fn AddUsersToEncryptedFile(
    lpFileName: ?*u16,
    pEncryptionCertificates: ?*ENCRYPTION_CERTIFICATE_LIST,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "ADVAPI32" fn SetUserFileEncryptionKey(
    pEncryptionCertificate: ?*ENCRYPTION_CERTIFICATE,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "ADVAPI32" fn SetUserFileEncryptionKeyEx(
    pEncryptionCertificate: ?*ENCRYPTION_CERTIFICATE,
    dwCapabilities: u32,
    dwFlags: u32,
    pvReserved: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "ADVAPI32" fn FreeEncryptionCertificateHashList(
    pUsers: ?*ENCRYPTION_CERTIFICATE_HASH_LIST,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=True (can and should we use this?)
pub extern "ADVAPI32" fn EncryptionDisable(
    DirPath: ?*u16,
    Disable: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "ADVAPI32" fn DuplicateEncryptionInfoFile(
    SrcFileName: ?*u16,
    DstFileName: ?*u16,
    dwCreationDistribution: u32,
    dwAttributes: u32,
    lpSecurityAttributes: ?*SECURITY_ATTRIBUTES,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "ADVAPI32" fn GetEncryptedFileMetadata(
    lpFileName: ?*u16,
    pcbMetadata: ?*u32,
    ppbMetadata: ?*?*u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "ADVAPI32" fn SetEncryptedFileMetadata(
    lpFileName: ?*u16,
    pbOldMetadata: ?*u8,
    pbNewMetadata: ?*u8,
    pOwnerHash: ?*ENCRYPTION_CERTIFICATE_HASH,
    dwOperation: u32,
    pCertificatesAdded: ?*ENCRYPTION_CERTIFICATE_HASH_LIST,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "ADVAPI32" fn FreeEncryptedFileMetadata(
    pbMetadata: ?*u8,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "clfsw32" fn LsnEqual(
    plsn1: ?*CLS_LSN,
    plsn2: ?*CLS_LSN,
) callconv(@import("std").os.windows.WINAPI) u8;

// set_last_errror=False (can and should we use this?)
pub extern "clfsw32" fn LsnLess(
    plsn1: ?*CLS_LSN,
    plsn2: ?*CLS_LSN,
) callconv(@import("std").os.windows.WINAPI) u8;

// set_last_errror=False (can and should we use this?)
pub extern "clfsw32" fn LsnGreater(
    plsn1: ?*CLS_LSN,
    plsn2: ?*CLS_LSN,
) callconv(@import("std").os.windows.WINAPI) u8;

// set_last_errror=False (can and should we use this?)
pub extern "clfsw32" fn LsnNull(
    plsn: ?*CLS_LSN,
) callconv(@import("std").os.windows.WINAPI) u8;

// set_last_errror=False (can and should we use this?)
pub extern "clfsw32" fn LsnContainer(
    plsn: ?*CLS_LSN,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "clfsw32" fn LsnCreate(
    cidContainer: u32,
    offBlock: u32,
    cRecord: u32,
) callconv(@import("std").os.windows.WINAPI) CLS_LSN;

// set_last_errror=False (can and should we use this?)
pub extern "clfsw32" fn LsnBlockOffset(
    plsn: ?*CLS_LSN,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "clfsw32" fn LsnRecordSequence(
    plsn: ?*CLS_LSN,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "clfsw32" fn LsnInvalid(
    plsn: ?*CLS_LSN,
) callconv(@import("std").os.windows.WINAPI) u8;

// set_last_errror=False (can and should we use this?)
pub extern "clfsw32" fn LsnIncrement(
    plsn: ?*CLS_LSN,
) callconv(@import("std").os.windows.WINAPI) CLS_LSN;

// set_last_errror=True (can and should we use this?)
pub extern "clfsw32" fn CreateLogFile(
    pszLogFileName: ?*u16,
    fDesiredAccess: u32,
    dwShareMode: u32,
    psaLogFile: ?*SECURITY_ATTRIBUTES,
    fCreateDisposition: u32,
    fFlagsAndAttributes: u32,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// set_last_errror=True (can and should we use this?)
pub extern "clfsw32" fn DeleteLogByHandle(
    hLog: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "clfsw32" fn DeleteLogFile(
    pszLogFileName: ?*u16,
    pvReserved: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "clfsw32" fn AddLogContainer(
    hLog: HANDLE,
    pcbContainer: ?*u64,
    pwszContainerPath: ?*u16,
    pReserved: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "clfsw32" fn AddLogContainerSet(
    hLog: HANDLE,
    cContainer: u16,
    pcbContainer: ?*u64,
    rgwszContainerPath: ?*?*u16,
    pReserved: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "clfsw32" fn RemoveLogContainer(
    hLog: HANDLE,
    pwszContainerPath: ?*u16,
    fForce: BOOL,
    pReserved: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "clfsw32" fn RemoveLogContainerSet(
    hLog: HANDLE,
    cContainer: u16,
    rgwszContainerPath: ?*?*u16,
    fForce: BOOL,
    pReserved: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "clfsw32" fn SetLogArchiveTail(
    hLog: HANDLE,
    plsnArchiveTail: ?*CLS_LSN,
    pReserved: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "clfsw32" fn SetEndOfLog(
    hLog: HANDLE,
    plsnEnd: ?*CLS_LSN,
    lpOverlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "clfsw32" fn TruncateLog(
    pvMarshal: ?*opaque{},
    plsnEnd: ?*CLS_LSN,
    lpOverlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "clfsw32" fn CreateLogContainerScanContext(
    hLog: HANDLE,
    cFromContainer: u32,
    cContainers: u32,
    eScanMode: u8,
    pcxScan: ?*CLS_SCAN_CONTEXT,
    pOverlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "clfsw32" fn ScanLogContainers(
    pcxScan: ?*CLS_SCAN_CONTEXT,
    eScanMode: u8,
    pReserved: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "clfsw32" fn AlignReservedLog(
    pvMarshal: ?*opaque{},
    cReservedRecords: u32,
    rgcbReservation: ?*i64,
    pcbAlignReservation: ?*i64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "clfsw32" fn AllocReservedLog(
    pvMarshal: ?*opaque{},
    cReservedRecords: u32,
    pcbAdjustment: ?*i64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "clfsw32" fn FreeReservedLog(
    pvMarshal: ?*opaque{},
    cReservedRecords: u32,
    pcbAdjustment: ?*i64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "clfsw32" fn GetLogFileInformation(
    hLog: HANDLE,
    pinfoBuffer: ?*CLS_INFORMATION,
    cbBuffer: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "clfsw32" fn SetLogArchiveMode(
    hLog: HANDLE,
    eMode: CLFS_LOG_ARCHIVE_MODE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "clfsw32" fn ReadLogRestartArea(
    pvMarshal: ?*opaque{},
    ppvRestartBuffer: ?*?*opaque{},
    pcbRestartBuffer: ?*u32,
    plsn: ?*CLS_LSN,
    ppvContext: ?*?*opaque{},
    pOverlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "clfsw32" fn ReadPreviousLogRestartArea(
    pvReadContext: ?*opaque{},
    ppvRestartBuffer: ?*?*opaque{},
    pcbRestartBuffer: ?*u32,
    plsnRestart: ?*CLS_LSN,
    pOverlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "clfsw32" fn WriteLogRestartArea(
    pvMarshal: ?*opaque{},
    pvRestartBuffer: ?*opaque{},
    cbRestartBuffer: u32,
    plsnBase: ?*CLS_LSN,
    fFlags: u32,
    pcbWritten: ?*u32,
    plsnNext: ?*CLS_LSN,
    pOverlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "clfsw32" fn GetLogReservationInfo(
    pvMarshal: ?*opaque{},
    pcbRecordNumber: ?*u32,
    pcbUserReservation: ?*i64,
    pcbCommitReservation: ?*i64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "clfsw32" fn AdvanceLogBase(
    pvMarshal: ?*opaque{},
    plsnBase: ?*CLS_LSN,
    fFlags: u32,
    pOverlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "clfsw32" fn CloseAndResetLogFile(
    hLog: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "clfsw32" fn CreateLogMarshallingArea(
    hLog: HANDLE,
    pfnAllocBuffer: CLFS_BLOCK_ALLOCATION,
    pfnFreeBuffer: CLFS_BLOCK_DEALLOCATION,
    pvBlockAllocContext: ?*opaque{},
    cbMarshallingBuffer: u32,
    cMaxWriteBuffers: u32,
    cMaxReadBuffers: u32,
    ppvMarshal: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "clfsw32" fn DeleteLogMarshallingArea(
    pvMarshal: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "clfsw32" fn ReserveAndAppendLog(
    pvMarshal: ?*opaque{},
    rgWriteEntries: ?*CLS_WRITE_ENTRY,
    cWriteEntries: u32,
    plsnUndoNext: ?*CLS_LSN,
    plsnPrevious: ?*CLS_LSN,
    cReserveRecords: u32,
    rgcbReservation: ?*i64,
    fFlags: u32,
    plsn: ?*CLS_LSN,
    pOverlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "clfsw32" fn ReserveAndAppendLogAligned(
    pvMarshal: ?*opaque{},
    rgWriteEntries: ?*CLS_WRITE_ENTRY,
    cWriteEntries: u32,
    cbEntryAlignment: u32,
    plsnUndoNext: ?*CLS_LSN,
    plsnPrevious: ?*CLS_LSN,
    cReserveRecords: u32,
    rgcbReservation: ?*i64,
    fFlags: u32,
    plsn: ?*CLS_LSN,
    pOverlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "clfsw32" fn FlushLogBuffers(
    pvMarshal: ?*opaque{},
    pOverlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "clfsw32" fn FlushLogToLsn(
    pvMarshalContext: ?*opaque{},
    plsnFlush: ?*CLS_LSN,
    plsnLastFlushed: ?*CLS_LSN,
    pOverlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "clfsw32" fn ReadLogRecord(
    pvMarshal: ?*opaque{},
    plsnFirst: ?*CLS_LSN,
    eContextMode: CLFS_CONTEXT_MODE,
    ppvReadBuffer: ?*?*opaque{},
    pcbReadBuffer: ?*u32,
    peRecordType: ?*u8,
    plsnUndoNext: ?*CLS_LSN,
    plsnPrevious: ?*CLS_LSN,
    ppvReadContext: ?*?*opaque{},
    pOverlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "clfsw32" fn ReadNextLogRecord(
    pvReadContext: ?*opaque{},
    ppvBuffer: ?*?*opaque{},
    pcbBuffer: ?*u32,
    peRecordType: ?*u8,
    plsnUser: ?*CLS_LSN,
    plsnUndoNext: ?*CLS_LSN,
    plsnPrevious: ?*CLS_LSN,
    plsnRecord: ?*CLS_LSN,
    pOverlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "clfsw32" fn TerminateReadLog(
    pvCursorContext: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "clfsw32" fn PrepareLogArchive(
    hLog: HANDLE,
    pszBaseLogFileName: ?*u16,
    cLen: u32,
    plsnLow: ?*CLS_LSN,
    plsnHigh: ?*CLS_LSN,
    pcActualLength: ?*u32,
    poffBaseLogFileData: ?*u64,
    pcbBaseLogFileLength: ?*u64,
    plsnBase: ?*CLS_LSN,
    plsnLast: ?*CLS_LSN,
    plsnCurrentArchiveTail: ?*CLS_LSN,
    ppvArchiveContext: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "clfsw32" fn ReadLogArchiveMetadata(
    pvArchiveContext: ?*opaque{},
    cbOffset: u32,
    cbBytesToRead: u32,
    pbReadBuffer: ?*u8,
    pcbBytesRead: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "clfsw32" fn GetNextLogArchiveExtent(
    pvArchiveContext: ?*opaque{},
    rgadExtent: ?*CLS_ARCHIVE_DESCRIPTOR,
    cDescriptors: u32,
    pcDescriptorsReturned: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "clfsw32" fn TerminateLogArchive(
    pvArchiveContext: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "clfsw32" fn ValidateLog(
    pszLogFileName: ?*u16,
    psaLogFile: ?*SECURITY_ATTRIBUTES,
    pinfoBuffer: ?*CLS_INFORMATION,
    pcbBuffer: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "clfsw32" fn GetLogContainerName(
    hLog: HANDLE,
    cidLogicalContainer: u32,
    pwstrContainerName: ?*u16,
    cLenContainerName: u32,
    pcActualLenContainerName: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "clfsw32" fn GetLogIoStatistics(
    hLog: HANDLE,
    pvStatsBuffer: ?*opaque{},
    cbStatsBuffer: u32,
    eStatsClass: CLFS_IOSTATS_CLASS,
    pcbStatsWritten: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "clfsw32" fn RegisterManageableLogClient(
    hLog: HANDLE,
    pCallbacks: ?*LOG_MANAGEMENT_CALLBACKS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "clfsw32" fn DeregisterManageableLogClient(
    hLog: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "clfsw32" fn ReadLogNotification(
    hLog: HANDLE,
    pNotification: ?*CLFS_MGMT_NOTIFICATION,
    lpOverlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "clfsw32" fn InstallLogPolicy(
    hLog: HANDLE,
    pPolicy: ?*CLFS_MGMT_POLICY,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "clfsw32" fn RemoveLogPolicy(
    hLog: HANDLE,
    ePolicyType: CLFS_MGMT_POLICY_TYPE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "clfsw32" fn QueryLogPolicy(
    hLog: HANDLE,
    ePolicyType: CLFS_MGMT_POLICY_TYPE,
    pPolicyBuffer: ?*CLFS_MGMT_POLICY,
    pcbPolicyBuffer: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "clfsw32" fn SetLogFileSizeWithPolicy(
    hLog: HANDLE,
    pDesiredSize: ?*u64,
    pResultingSize: ?*u64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "clfsw32" fn HandleLogFull(
    hLog: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "clfsw32" fn LogTailAdvanceFailure(
    hLog: HANDLE,
    dwReason: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "clfsw32" fn RegisterForLogWriteNotification(
    hLog: HANDLE,
    cbThreshold: u32,
    fEnable: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "WOFUTIL" fn WofShouldCompressBinaries(
    Volume: ?*u16,
    Algorithm: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "WOFUTIL" fn WofGetDriverVersion(
    FileOrVolumeHandle: HANDLE,
    Provider: u32,
    WofVersion: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "WOFUTIL" fn WofSetFileDataLocation(
    FileHandle: HANDLE,
    Provider: u32,
    ExternalFileInfo: ?*opaque{},
    Length: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "WOFUTIL" fn WofIsExternalFile(
    FilePath: ?*u16,
    IsExternalFile: ?*i32,
    Provider: ?*u32,
    ExternalFileInfo: ?*opaque{},
    BufferLength: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "WOFUTIL" fn WofEnumEntries(
    VolumeName: ?*u16,
    Provider: u32,
    EnumProc: WofEnumEntryProc,
    UserData: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "WOFUTIL" fn WofWimAddEntry(
    VolumeName: ?*u16,
    WimPath: ?*u16,
    WimType: u32,
    WimIndex: u32,
    DataSourceId: ?*LARGE_INTEGER,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "WOFUTIL" fn WofWimEnumFiles(
    VolumeName: ?*u16,
    DataSourceId: LARGE_INTEGER,
    EnumProc: WofEnumFilesProc,
    UserData: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "WOFUTIL" fn WofWimSuspendEntry(
    VolumeName: ?*u16,
    DataSourceId: LARGE_INTEGER,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "WOFUTIL" fn WofWimRemoveEntry(
    VolumeName: ?*u16,
    DataSourceId: LARGE_INTEGER,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "WOFUTIL" fn WofWimUpdateEntry(
    VolumeName: ?*u16,
    DataSourceId: LARGE_INTEGER,
    NewWimPath: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "WOFUTIL" fn WofFileEnumFiles(
    VolumeName: ?*u16,
    Algorithm: u32,
    EnumProc: WofEnumFilesProc,
    UserData: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=True (can and should we use this?)
pub extern "txfw32" fn TxfLogCreateFileReadContext(
    LogPath: ?*u16,
    BeginningLsn: CLS_LSN,
    EndingLsn: CLS_LSN,
    TxfFileId: ?*TXF_ID,
    TxfLogContext: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "txfw32" fn TxfLogCreateRangeReadContext(
    LogPath: ?*u16,
    BeginningLsn: CLS_LSN,
    EndingLsn: CLS_LSN,
    BeginningVirtualClock: ?*LARGE_INTEGER,
    EndingVirtualClock: ?*LARGE_INTEGER,
    RecordTypeMask: u32,
    TxfLogContext: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "txfw32" fn TxfLogDestroyReadContext(
    TxfLogContext: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "txfw32" fn TxfLogReadRecords(
    TxfLogContext: ?*opaque{},
    BufferLength: u32,
    Buffer: ?*opaque{},
    BytesUsed: ?*u32,
    RecordCount: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "txfw32" fn TxfReadMetadataInfo(
    FileHandle: HANDLE,
    TxfFileId: ?*TXF_ID,
    LastLsn: ?*CLS_LSN,
    TransactionState: ?*u32,
    LockingTransaction: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "txfw32" fn TxfLogRecordGetFileName(
    RecordBuffer: ?*opaque{},
    RecordBufferLengthInBytes: u32,
    NameBuffer: ?*u16,
    NameBufferLengthInBytes: ?*u32,
    TxfId: ?*TXF_ID,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "txfw32" fn TxfLogRecordGetGenericType(
    RecordBuffer: ?*opaque{},
    RecordBufferLengthInBytes: u32,
    GenericType: ?*u32,
    VirtualClock: ?*LARGE_INTEGER,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "txfw32" fn TxfSetThreadMiniVersionForCreate(
    MiniVersion: u16,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "txfw32" fn TxfGetThreadMiniVersionForCreate(
    MiniVersion: ?*u16,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=True (can and should we use this?)
pub extern "ktmw32" fn CreateTransaction(
    lpTransactionAttributes: ?*SECURITY_ATTRIBUTES,
    UOW: ?*Guid,
    CreateOptions: u32,
    IsolationLevel: u32,
    IsolationFlags: u32,
    Timeout: u32,
    Description: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// set_last_errror=True (can and should we use this?)
pub extern "ktmw32" fn OpenTransaction(
    dwDesiredAccess: u32,
    TransactionId: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// set_last_errror=True (can and should we use this?)
pub extern "ktmw32" fn CommitTransaction(
    TransactionHandle: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "ktmw32" fn CommitTransactionAsync(
    TransactionHandle: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "ktmw32" fn RollbackTransaction(
    TransactionHandle: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "ktmw32" fn RollbackTransactionAsync(
    TransactionHandle: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "ktmw32" fn GetTransactionId(
    TransactionHandle: HANDLE,
    TransactionId: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "ktmw32" fn GetTransactionInformation(
    TransactionHandle: HANDLE,
    Outcome: ?*u32,
    IsolationLevel: ?*u32,
    IsolationFlags: ?*u32,
    Timeout: ?*u32,
    BufferLength: u32,
    Description: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "ktmw32" fn SetTransactionInformation(
    TransactionHandle: HANDLE,
    IsolationLevel: u32,
    IsolationFlags: u32,
    Timeout: u32,
    Description: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "ktmw32" fn CreateTransactionManager(
    lpTransactionAttributes: ?*SECURITY_ATTRIBUTES,
    LogFileName: ?*u16,
    CreateOptions: u32,
    CommitStrength: u32,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// set_last_errror=True (can and should we use this?)
pub extern "ktmw32" fn OpenTransactionManager(
    LogFileName: ?*u16,
    DesiredAccess: u32,
    OpenOptions: u32,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// set_last_errror=True (can and should we use this?)
pub extern "ktmw32" fn OpenTransactionManagerById(
    TransactionManagerId: ?*Guid,
    DesiredAccess: u32,
    OpenOptions: u32,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// set_last_errror=True (can and should we use this?)
pub extern "ktmw32" fn RenameTransactionManager(
    LogFileName: ?*u16,
    ExistingTransactionManagerGuid: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "ktmw32" fn RollforwardTransactionManager(
    TransactionManagerHandle: HANDLE,
    TmVirtualClock: ?*LARGE_INTEGER,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "ktmw32" fn RecoverTransactionManager(
    TransactionManagerHandle: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "ktmw32" fn GetCurrentClockTransactionManager(
    TransactionManagerHandle: HANDLE,
    TmVirtualClock: ?*LARGE_INTEGER,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "ktmw32" fn GetTransactionManagerId(
    TransactionManagerHandle: HANDLE,
    TransactionManagerId: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "ktmw32" fn CreateResourceManager(
    lpResourceManagerAttributes: ?*SECURITY_ATTRIBUTES,
    ResourceManagerId: ?*Guid,
    CreateOptions: u32,
    TmHandle: HANDLE,
    Description: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// set_last_errror=True (can and should we use this?)
pub extern "ktmw32" fn OpenResourceManager(
    dwDesiredAccess: u32,
    TmHandle: HANDLE,
    ResourceManagerId: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// set_last_errror=True (can and should we use this?)
pub extern "ktmw32" fn RecoverResourceManager(
    ResourceManagerHandle: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "ktmw32" fn GetNotificationResourceManager(
    ResourceManagerHandle: HANDLE,
    TransactionNotification: ?*TRANSACTION_NOTIFICATION,
    NotificationLength: u32,
    dwMilliseconds: u32,
    ReturnLength: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "ktmw32" fn GetNotificationResourceManagerAsync(
    ResourceManagerHandle: HANDLE,
    TransactionNotification: ?*TRANSACTION_NOTIFICATION,
    TransactionNotificationLength: u32,
    ReturnLength: ?*u32,
    lpOverlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "ktmw32" fn SetResourceManagerCompletionPort(
    ResourceManagerHandle: HANDLE,
    IoCompletionPortHandle: HANDLE,
    CompletionKey: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "ktmw32" fn CreateEnlistment(
    lpEnlistmentAttributes: ?*SECURITY_ATTRIBUTES,
    ResourceManagerHandle: HANDLE,
    TransactionHandle: HANDLE,
    NotificationMask: u32,
    CreateOptions: u32,
    EnlistmentKey: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// set_last_errror=True (can and should we use this?)
pub extern "ktmw32" fn OpenEnlistment(
    dwDesiredAccess: u32,
    ResourceManagerHandle: HANDLE,
    EnlistmentId: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// set_last_errror=True (can and should we use this?)
pub extern "ktmw32" fn RecoverEnlistment(
    EnlistmentHandle: HANDLE,
    EnlistmentKey: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "ktmw32" fn GetEnlistmentRecoveryInformation(
    EnlistmentHandle: HANDLE,
    BufferSize: u32,
    Buffer: ?*opaque{},
    BufferUsed: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "ktmw32" fn GetEnlistmentId(
    EnlistmentHandle: HANDLE,
    EnlistmentId: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "ktmw32" fn SetEnlistmentRecoveryInformation(
    EnlistmentHandle: HANDLE,
    BufferSize: u32,
    Buffer: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "ktmw32" fn PrepareEnlistment(
    EnlistmentHandle: HANDLE,
    TmVirtualClock: ?*LARGE_INTEGER,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "ktmw32" fn PrePrepareEnlistment(
    EnlistmentHandle: HANDLE,
    TmVirtualClock: ?*LARGE_INTEGER,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "ktmw32" fn CommitEnlistment(
    EnlistmentHandle: HANDLE,
    TmVirtualClock: ?*LARGE_INTEGER,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "ktmw32" fn RollbackEnlistment(
    EnlistmentHandle: HANDLE,
    TmVirtualClock: ?*LARGE_INTEGER,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "ktmw32" fn PrePrepareComplete(
    EnlistmentHandle: HANDLE,
    TmVirtualClock: ?*LARGE_INTEGER,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "ktmw32" fn PrepareComplete(
    EnlistmentHandle: HANDLE,
    TmVirtualClock: ?*LARGE_INTEGER,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "ktmw32" fn ReadOnlyEnlistment(
    EnlistmentHandle: HANDLE,
    TmVirtualClock: ?*LARGE_INTEGER,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "ktmw32" fn CommitComplete(
    EnlistmentHandle: HANDLE,
    TmVirtualClock: ?*LARGE_INTEGER,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "ktmw32" fn RollbackComplete(
    EnlistmentHandle: HANDLE,
    TmVirtualClock: ?*LARGE_INTEGER,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "ktmw32" fn SinglePhaseReject(
    EnlistmentHandle: HANDLE,
    TmVirtualClock: ?*LARGE_INTEGER,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "srvcli" fn NetShareAdd(
    servername: ?*u16,
    level: u32,
    buf: ?*u8,
    parm_err: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "srvcli" fn NetShareEnum(
    servername: ?*u16,
    level: u32,
    bufptr: ?*?*u8,
    prefmaxlen: u32,
    entriesread: ?*u32,
    totalentries: ?*u32,
    resume_handle: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "srvcli" fn NetShareEnumSticky(
    servername: ?*u16,
    level: u32,
    bufptr: ?*?*u8,
    prefmaxlen: u32,
    entriesread: ?*u32,
    totalentries: ?*u32,
    resume_handle: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "srvcli" fn NetShareGetInfo(
    servername: ?*u16,
    netname: ?*u16,
    level: u32,
    bufptr: ?*?*u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "srvcli" fn NetShareSetInfo(
    servername: ?*u16,
    netname: ?*u16,
    level: u32,
    buf: ?*u8,
    parm_err: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "srvcli" fn NetShareDel(
    servername: ?*u16,
    netname: ?*u16,
    reserved: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "srvcli" fn NetShareDelSticky(
    servername: ?*u16,
    netname: ?*u16,
    reserved: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "srvcli" fn NetShareCheck(
    servername: ?*u16,
    device: ?*u16,
    type: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "srvcli" fn NetShareDelEx(
    servername: ?*u16,
    level: u32,
    buf: ?*u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "srvcli" fn NetServerAliasAdd(
    servername: ?*u16,
    level: u32,
    buf: ?*u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "srvcli" fn NetServerAliasDel(
    servername: ?*u16,
    level: u32,
    buf: ?*u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "srvcli" fn NetServerAliasEnum(
    servername: ?*u16,
    level: u32,
    bufptr: ?*?*u8,
    prefmaxlen: u32,
    entriesread: ?*u32,
    totalentries: ?*u32,
    resumehandle: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "srvcli" fn NetSessionEnum(
    servername: ?*u16,
    UncClientName: ?*u16,
    username: ?*u16,
    level: u32,
    bufptr: ?*?*u8,
    prefmaxlen: u32,
    entriesread: ?*u32,
    totalentries: ?*u32,
    resume_handle: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "srvcli" fn NetSessionDel(
    servername: ?*u16,
    UncClientName: ?*u16,
    username: ?*u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "srvcli" fn NetSessionGetInfo(
    servername: ?*u16,
    UncClientName: ?*u16,
    username: ?*u16,
    level: u32,
    bufptr: ?*?*u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "srvcli" fn NetConnectionEnum(
    servername: ?*u16,
    qualifier: ?*u16,
    level: u32,
    bufptr: ?*?*u8,
    prefmaxlen: u32,
    entriesread: ?*u32,
    totalentries: ?*u32,
    resume_handle: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "srvcli" fn NetFileClose(
    servername: ?*u16,
    fileid: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "srvcli" fn NetFileEnum(
    servername: ?*u16,
    basepath: ?*u16,
    username: ?*u16,
    level: u32,
    bufptr: ?*?*u8,
    prefmaxlen: u32,
    entriesread: ?*u32,
    totalentries: ?*u32,
    resume_handle: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "srvcli" fn NetFileGetInfo(
    servername: ?*u16,
    fileid: u32,
    level: u32,
    bufptr: ?*?*u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "NETAPI32" fn NetStatisticsGet(
    ServerName: ?*i8,
    Service: ?*i8,
    Level: u32,
    Options: u32,
    Buffer: ?*?*u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn SearchPathW(
    lpPath: ?*u16,
    lpFileName: ?*u16,
    lpExtension: ?*u16,
    nBufferLength: u32,
    lpBuffer: ?*u16,
    lpFilePart: ?*?*u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn SearchPathA(
    lpPath: ?*i8,
    lpFileName: ?*i8,
    lpExtension: ?*i8,
    nBufferLength: u32,
    lpBuffer: ?*i8,
    lpFilePart: ?*?*i8,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetBinaryTypeA(
    lpApplicationName: ?*i8,
    lpBinaryType: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetBinaryTypeW(
    lpApplicationName: ?*u16,
    lpBinaryType: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetShortPathNameA(
    lpszLongPath: ?*i8,
    lpszShortPath: ?*i8,
    cchBuffer: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetLongPathNameTransactedA(
    lpszShortPath: ?*i8,
    lpszLongPath: ?*i8,
    cchBuffer: u32,
    hTransaction: HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetLongPathNameTransactedW(
    lpszShortPath: ?*u16,
    lpszLongPath: ?*u16,
    cchBuffer: u32,
    hTransaction: HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn SetFileCompletionNotificationModes(
    FileHandle: HANDLE,
    Flags: u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn SetFileShortNameA(
    hFile: HANDLE,
    lpShortName: ?*i8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn SetFileShortNameW(
    hFile: HANDLE,
    lpShortName: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "ADVAPI32" fn EncryptFileA(
    lpFileName: ?*i8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "ADVAPI32" fn EncryptFileW(
    lpFileName: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "ADVAPI32" fn DecryptFileA(
    lpFileName: ?*i8,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "ADVAPI32" fn DecryptFileW(
    lpFileName: ?*u16,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "ADVAPI32" fn FileEncryptionStatusA(
    lpFileName: ?*i8,
    lpStatus: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "ADVAPI32" fn FileEncryptionStatusW(
    lpFileName: ?*u16,
    lpStatus: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "ADVAPI32" fn OpenEncryptedFileRawA(
    lpFileName: ?*i8,
    ulFlags: u32,
    pvContext: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "ADVAPI32" fn OpenEncryptedFileRawW(
    lpFileName: ?*u16,
    ulFlags: u32,
    pvContext: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "ADVAPI32" fn ReadEncryptedFileRaw(
    pfExportCallback: PFE_EXPORT_FUNC,
    pvCallbackContext: ?*opaque{},
    pvContext: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "ADVAPI32" fn WriteEncryptedFileRaw(
    pfImportCallback: PFE_IMPORT_FUNC,
    pvCallbackContext: ?*opaque{},
    pvContext: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "ADVAPI32" fn CloseEncryptedFileRaw(
    pvContext: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn OpenFile(
    lpFileName: ?*i8,
    lpReOpenBuff: ?*OFSTRUCT,
    uStyle: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetLogicalDriveStringsA(
    nBufferLength: u32,
    lpBuffer: ?*i8,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn Wow64EnableWow64FsRedirection(
    Wow64FsEnableRedirection: u8,
) callconv(@import("std").os.windows.WINAPI) u8;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn SetSearchPathMode(
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn CreateDirectoryExA(
    lpTemplateDirectory: ?*i8,
    lpNewDirectory: ?*i8,
    lpSecurityAttributes: ?*SECURITY_ATTRIBUTES,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn CreateDirectoryExW(
    lpTemplateDirectory: ?*u16,
    lpNewDirectory: ?*u16,
    lpSecurityAttributes: ?*SECURITY_ATTRIBUTES,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn CreateDirectoryTransactedA(
    lpTemplateDirectory: ?*i8,
    lpNewDirectory: ?*i8,
    lpSecurityAttributes: ?*SECURITY_ATTRIBUTES,
    hTransaction: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn CreateDirectoryTransactedW(
    lpTemplateDirectory: ?*u16,
    lpNewDirectory: ?*u16,
    lpSecurityAttributes: ?*SECURITY_ATTRIBUTES,
    hTransaction: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn RemoveDirectoryTransactedA(
    lpPathName: ?*i8,
    hTransaction: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn RemoveDirectoryTransactedW(
    lpPathName: ?*u16,
    hTransaction: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetFullPathNameTransactedA(
    lpFileName: ?*i8,
    nBufferLength: u32,
    lpBuffer: ?*i8,
    lpFilePart: ?*?*i8,
    hTransaction: HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetFullPathNameTransactedW(
    lpFileName: ?*u16,
    nBufferLength: u32,
    lpBuffer: ?*u16,
    lpFilePart: ?*?*u16,
    hTransaction: HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn DefineDosDeviceA(
    dwFlags: u32,
    lpDeviceName: ?*i8,
    lpTargetPath: ?*i8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn QueryDosDeviceA(
    lpDeviceName: ?*i8,
    lpTargetPath: ?*i8,
    ucchMax: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn CreateFileTransactedA(
    lpFileName: ?*i8,
    dwDesiredAccess: u32,
    dwShareMode: u32,
    lpSecurityAttributes: ?*SECURITY_ATTRIBUTES,
    dwCreationDisposition: u32,
    dwFlagsAndAttributes: u32,
    hTemplateFile: HANDLE,
    hTransaction: HANDLE,
    pusMiniVersion: ?*u16,
    lpExtendedParameter: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn CreateFileTransactedW(
    lpFileName: ?*u16,
    dwDesiredAccess: u32,
    dwShareMode: u32,
    lpSecurityAttributes: ?*SECURITY_ATTRIBUTES,
    dwCreationDisposition: u32,
    dwFlagsAndAttributes: u32,
    hTemplateFile: HANDLE,
    hTransaction: HANDLE,
    pusMiniVersion: ?*u16,
    lpExtendedParameter: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn ReOpenFile(
    hOriginalFile: HANDLE,
    dwDesiredAccess: u32,
    dwShareMode: u32,
    dwFlagsAndAttributes: u32,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn SetFileAttributesTransactedA(
    lpFileName: ?*i8,
    dwFileAttributes: u32,
    hTransaction: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn SetFileAttributesTransactedW(
    lpFileName: ?*u16,
    dwFileAttributes: u32,
    hTransaction: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetFileAttributesTransactedA(
    lpFileName: ?*i8,
    fInfoLevelId: GET_FILEEX_INFO_LEVELS,
    lpFileInformation: ?*opaque{},
    hTransaction: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetFileAttributesTransactedW(
    lpFileName: ?*u16,
    fInfoLevelId: GET_FILEEX_INFO_LEVELS,
    lpFileInformation: ?*opaque{},
    hTransaction: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetCompressedFileSizeTransactedA(
    lpFileName: ?*i8,
    lpFileSizeHigh: ?*u32,
    hTransaction: HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetCompressedFileSizeTransactedW(
    lpFileName: ?*u16,
    lpFileSizeHigh: ?*u32,
    hTransaction: HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn DeleteFileTransactedA(
    lpFileName: ?*i8,
    hTransaction: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn DeleteFileTransactedW(
    lpFileName: ?*u16,
    hTransaction: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn CheckNameLegalDOS8Dot3A(
    lpName: ?*i8,
    lpOemName: ?*i8,
    OemNameSize: u32,
    pbNameContainsSpaces: ?*i32,
    pbNameLegal: ?*i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn CheckNameLegalDOS8Dot3W(
    lpName: ?*u16,
    lpOemName: ?*i8,
    OemNameSize: u32,
    pbNameContainsSpaces: ?*i32,
    pbNameLegal: ?*i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn FindFirstFileTransactedA(
    lpFileName: ?*i8,
    fInfoLevelId: FINDEX_INFO_LEVELS,
    lpFindFileData: ?*opaque{},
    fSearchOp: FINDEX_SEARCH_OPS,
    lpSearchFilter: ?*opaque{},
    dwAdditionalFlags: u32,
    hTransaction: HANDLE,
) callconv(@import("std").os.windows.WINAPI) FindFileHandle;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn FindFirstFileTransactedW(
    lpFileName: ?*u16,
    fInfoLevelId: FINDEX_INFO_LEVELS,
    lpFindFileData: ?*opaque{},
    fSearchOp: FINDEX_SEARCH_OPS,
    lpSearchFilter: ?*opaque{},
    dwAdditionalFlags: u32,
    hTransaction: HANDLE,
) callconv(@import("std").os.windows.WINAPI) FindFileHandle;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn CopyFileA(
    lpExistingFileName: ?*i8,
    lpNewFileName: ?*i8,
    bFailIfExists: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn CopyFileW(
    lpExistingFileName: ?*u16,
    lpNewFileName: ?*u16,
    bFailIfExists: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn CopyFileExA(
    lpExistingFileName: ?*i8,
    lpNewFileName: ?*i8,
    lpProgressRoutine: LPPROGRESS_ROUTINE,
    lpData: ?*opaque{},
    pbCancel: ?*i32,
    dwCopyFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn CopyFileExW(
    lpExistingFileName: ?*u16,
    lpNewFileName: ?*u16,
    lpProgressRoutine: LPPROGRESS_ROUTINE,
    lpData: ?*opaque{},
    pbCancel: ?*i32,
    dwCopyFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn CopyFileTransactedA(
    lpExistingFileName: ?*i8,
    lpNewFileName: ?*i8,
    lpProgressRoutine: LPPROGRESS_ROUTINE,
    lpData: ?*opaque{},
    pbCancel: ?*i32,
    dwCopyFlags: u32,
    hTransaction: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn CopyFileTransactedW(
    lpExistingFileName: ?*u16,
    lpNewFileName: ?*u16,
    lpProgressRoutine: LPPROGRESS_ROUTINE,
    lpData: ?*opaque{},
    pbCancel: ?*i32,
    dwCopyFlags: u32,
    hTransaction: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn CopyFile2(
    pwszExistingFileName: ?*u16,
    pwszNewFileName: ?*u16,
    pExtendedParameters: ?*COPYFILE2_EXTENDED_PARAMETERS,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn MoveFileA(
    lpExistingFileName: ?*i8,
    lpNewFileName: ?*i8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn MoveFileW(
    lpExistingFileName: ?*u16,
    lpNewFileName: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn MoveFileExA(
    lpExistingFileName: ?*i8,
    lpNewFileName: ?*i8,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn MoveFileExW(
    lpExistingFileName: ?*u16,
    lpNewFileName: ?*u16,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn MoveFileWithProgressA(
    lpExistingFileName: ?*i8,
    lpNewFileName: ?*i8,
    lpProgressRoutine: LPPROGRESS_ROUTINE,
    lpData: ?*opaque{},
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn MoveFileWithProgressW(
    lpExistingFileName: ?*u16,
    lpNewFileName: ?*u16,
    lpProgressRoutine: LPPROGRESS_ROUTINE,
    lpData: ?*opaque{},
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn MoveFileTransactedA(
    lpExistingFileName: ?*i8,
    lpNewFileName: ?*i8,
    lpProgressRoutine: LPPROGRESS_ROUTINE,
    lpData: ?*opaque{},
    dwFlags: u32,
    hTransaction: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn MoveFileTransactedW(
    lpExistingFileName: ?*u16,
    lpNewFileName: ?*u16,
    lpProgressRoutine: LPPROGRESS_ROUTINE,
    lpData: ?*opaque{},
    dwFlags: u32,
    hTransaction: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn ReplaceFileA(
    lpReplacedFileName: ?*i8,
    lpReplacementFileName: ?*i8,
    lpBackupFileName: ?*i8,
    dwReplaceFlags: u32,
    lpExclude: ?*opaque{},
    lpReserved: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn ReplaceFileW(
    lpReplacedFileName: ?*u16,
    lpReplacementFileName: ?*u16,
    lpBackupFileName: ?*u16,
    dwReplaceFlags: u32,
    lpExclude: ?*opaque{},
    lpReserved: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn CreateHardLinkA(
    lpFileName: ?*i8,
    lpExistingFileName: ?*i8,
    lpSecurityAttributes: ?*SECURITY_ATTRIBUTES,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn CreateHardLinkW(
    lpFileName: ?*u16,
    lpExistingFileName: ?*u16,
    lpSecurityAttributes: ?*SECURITY_ATTRIBUTES,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn CreateHardLinkTransactedA(
    lpFileName: ?*i8,
    lpExistingFileName: ?*i8,
    lpSecurityAttributes: ?*SECURITY_ATTRIBUTES,
    hTransaction: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn CreateHardLinkTransactedW(
    lpFileName: ?*u16,
    lpExistingFileName: ?*u16,
    lpSecurityAttributes: ?*SECURITY_ATTRIBUTES,
    hTransaction: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn FindFirstStreamTransactedW(
    lpFileName: ?*u16,
    InfoLevel: STREAM_INFO_LEVELS,
    lpFindStreamData: ?*opaque{},
    dwFlags: u32,
    hTransaction: HANDLE,
) callconv(@import("std").os.windows.WINAPI) FindStreamHandle;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn FindFirstFileNameTransactedW(
    lpFileName: ?*u16,
    dwFlags: u32,
    StringLength: ?*u32,
    LinkName: ?*u16,
    hTransaction: HANDLE,
) callconv(@import("std").os.windows.WINAPI) FindFileNameHandle;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn SetVolumeLabelA(
    lpRootPathName: ?*i8,
    lpVolumeName: ?*i8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn SetVolumeLabelW(
    lpRootPathName: ?*u16,
    lpVolumeName: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn SetFileBandwidthReservation(
    hFile: HANDLE,
    nPeriodMilliseconds: u32,
    nBytesPerPeriod: u32,
    bDiscardable: BOOL,
    lpTransferSize: ?*u32,
    lpNumOutstandingRequests: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetFileBandwidthReservation(
    hFile: HANDLE,
    lpPeriodMilliseconds: ?*u32,
    lpBytesPerPeriod: ?*u32,
    pDiscardable: ?*i32,
    lpTransferSize: ?*u32,
    lpNumOutstandingRequests: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn ReadDirectoryChangesW(
    hDirectory: HANDLE,
    lpBuffer: ?*opaque{},
    nBufferLength: u32,
    bWatchSubtree: BOOL,
    dwNotifyFilter: u32,
    lpBytesReturned: ?*u32,
    lpOverlapped: ?*OVERLAPPED,
    lpCompletionRoutine: LPOVERLAPPED_COMPLETION_ROUTINE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn ReadDirectoryChangesExW(
    hDirectory: HANDLE,
    lpBuffer: ?*opaque{},
    nBufferLength: u32,
    bWatchSubtree: BOOL,
    dwNotifyFilter: u32,
    lpBytesReturned: ?*u32,
    lpOverlapped: ?*OVERLAPPED,
    lpCompletionRoutine: LPOVERLAPPED_COMPLETION_ROUTINE,
    ReadDirectoryNotifyInformationClass: READ_DIRECTORY_NOTIFY_INFORMATION_CLASS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn FindFirstVolumeA(
    lpszVolumeName: ?*i8,
    cchBufferLength: u32,
) callconv(@import("std").os.windows.WINAPI) FindVolumeHandle;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn FindNextVolumeA(
    hFindVolume: FindVolumeHandle,
    lpszVolumeName: ?*i8,
    cchBufferLength: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn FindFirstVolumeMountPointA(
    lpszRootPathName: ?*i8,
    lpszVolumeMountPoint: ?*i8,
    cchBufferLength: u32,
) callconv(@import("std").os.windows.WINAPI) FindVolumeMointPointHandle;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn FindFirstVolumeMountPointW(
    lpszRootPathName: ?*u16,
    lpszVolumeMountPoint: ?*u16,
    cchBufferLength: u32,
) callconv(@import("std").os.windows.WINAPI) FindVolumeMointPointHandle;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn FindNextVolumeMountPointA(
    hFindVolumeMountPoint: FindVolumeMointPointHandle,
    lpszVolumeMountPoint: ?*i8,
    cchBufferLength: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn FindNextVolumeMountPointW(
    hFindVolumeMountPoint: FindVolumeMointPointHandle,
    lpszVolumeMountPoint: ?*u16,
    cchBufferLength: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn FindVolumeMountPointClose(
    hFindVolumeMountPoint: FindVolumeMointPointHandle,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn SetVolumeMountPointA(
    lpszVolumeMountPoint: ?*i8,
    lpszVolumeName: ?*i8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn SetVolumeMountPointW(
    lpszVolumeMountPoint: ?*u16,
    lpszVolumeName: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn DeleteVolumeMountPointA(
    lpszVolumeMountPoint: ?*i8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetVolumeNameForVolumeMountPointA(
    lpszVolumeMountPoint: ?*i8,
    lpszVolumeName: ?*i8,
    cchBufferLength: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetVolumePathNameA(
    lpszFileName: ?*i8,
    lpszVolumePathName: ?*i8,
    cchBufferLength: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetVolumePathNamesForVolumeNameA(
    lpszVolumeName: ?*i8,
    lpszVolumePathNames: ?*i8,
    cchBufferLength: u32,
    lpcchReturnLength: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetFileInformationByHandleEx(
    hFile: HANDLE,
    FileInformationClass: FILE_INFO_BY_HANDLE_CLASS,
    lpFileInformation: ?*opaque{},
    dwBufferSize: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn OpenFileById(
    hVolumeHint: HANDLE,
    lpFileId: ?*FILE_ID_DESCRIPTOR,
    dwDesiredAccess: u32,
    dwShareMode: u32,
    lpSecurityAttributes: ?*SECURITY_ATTRIBUTES,
    dwFlagsAndAttributes: u32,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn CreateSymbolicLinkA(
    lpSymlinkFileName: ?*i8,
    lpTargetFileName: ?*i8,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) u8;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn CreateSymbolicLinkW(
    lpSymlinkFileName: ?*u16,
    lpTargetFileName: ?*u16,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) u8;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn CreateSymbolicLinkTransactedA(
    lpSymlinkFileName: ?*i8,
    lpTargetFileName: ?*i8,
    dwFlags: u32,
    hTransaction: HANDLE,
) callconv(@import("std").os.windows.WINAPI) u8;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn CreateSymbolicLinkTransactedW(
    lpSymlinkFileName: ?*u16,
    lpTargetFileName: ?*u16,
    dwFlags: u32,
    hTransaction: HANDLE,
) callconv(@import("std").os.windows.WINAPI) u8;

//
// Unicode Symbol Aliases
//
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {
        pub const WIN32_FIND_DATA = WIN32_FIND_DATAA;
        pub const NTMS_DRIVEINFORMATION = NTMS_DRIVEINFORMATIONA;
        pub const NTMS_CHANGERINFORMATION = NTMS_CHANGERINFORMATIONA;
        pub const NTMS_PMIDINFORMATION = NTMS_PMIDINFORMATIONA;
        pub const NTMS_PARTITIONINFORMATION = NTMS_PARTITIONINFORMATIONA;
        pub const NTMS_DRIVETYPEINFORMATION = NTMS_DRIVETYPEINFORMATIONA;
        pub const NTMS_CHANGERTYPEINFORMATION = NTMS_CHANGERTYPEINFORMATIONA;
        pub const NTMS_LIBREQUESTINFORMATION = NTMS_LIBREQUESTINFORMATIONA;
        pub const NTMS_OPREQUESTINFORMATION = NTMS_OPREQUESTINFORMATIONA;
        pub const NTMS_OBJECTINFORMATION = NTMS_OBJECTINFORMATIONA;
        pub const NTMS_I1_LIBREQUESTINFORMATION = NTMS_I1_LIBREQUESTINFORMATIONA;
        pub const NTMS_I1_PMIDINFORMATION = NTMS_I1_PMIDINFORMATIONA;
        pub const NTMS_I1_PARTITIONINFORMATION = NTMS_I1_PARTITIONINFORMATIONA;
        pub const NTMS_I1_OPREQUESTINFORMATION = NTMS_I1_OPREQUESTINFORMATIONA;
        pub const NTMS_I1_OBJECTINFORMATION = NTMS_I1_OBJECTINFORMATIONA;
        pub const CreateDirectory = CreateDirectoryA;
        pub const CreateFile = CreateFileA;
        pub const DefineDosDevice = DefineDosDeviceA;
        pub const DeleteFile = DeleteFileA;
        pub const DeleteVolumeMountPoint = DeleteVolumeMountPointA;
        pub const FindFirstChangeNotification = FindFirstChangeNotificationA;
        pub const FindFirstFile = FindFirstFileA;
        pub const FindFirstFileEx = FindFirstFileExA;
        pub const FindFirstVolume = FindFirstVolumeA;
        pub const FindNextFile = FindNextFileA;
        pub const FindNextVolume = FindNextVolumeA;
        pub const GetDiskFreeSpace = GetDiskFreeSpaceA;
        pub const GetDiskFreeSpaceEx = GetDiskFreeSpaceExA;
        pub const GetDiskSpaceInformation = GetDiskSpaceInformationA;
        pub const GetDriveType = GetDriveTypeA;
        pub const GetFileAttributes = GetFileAttributesA;
        pub const GetFileAttributesEx = GetFileAttributesExA;
        pub const GetFinalPathNameByHandle = GetFinalPathNameByHandleA;
        pub const GetFullPathName = GetFullPathNameA;
        pub const GetLogicalDriveStrings = GetLogicalDriveStringsA;
        pub const GetLongPathName = GetLongPathNameA;
        pub const GetShortPathName = GetShortPathNameA;
        pub const GetTempFileName = GetTempFileNameA;
        pub const GetVolumeInformation = GetVolumeInformationA;
        pub const GetVolumePathName = GetVolumePathNameA;
        pub const QueryDosDevice = QueryDosDeviceA;
        pub const RemoveDirectory = RemoveDirectoryA;
        pub const SetFileAttributes = SetFileAttributesA;
        pub const GetTempPath = GetTempPathA;
        pub const GetVolumeNameForVolumeMountPoint = GetVolumeNameForVolumeMountPointA;
        pub const GetVolumePathNamesForVolumeName = GetVolumePathNamesForVolumeNameA;
        pub const GetCompressedFileSize = GetCompressedFileSizeA;
        pub const GetExpandedName = GetExpandedNameA;
        pub const LZOpenFile = LZOpenFileA;
        pub const SearchPath = SearchPathA;
        pub const GetBinaryType = GetBinaryTypeA;
        pub const GetLongPathNameTransacted = GetLongPathNameTransactedA;
        pub const SetFileShortName = SetFileShortNameA;
        pub const EncryptFile = EncryptFileA;
        pub const DecryptFile = DecryptFileA;
        pub const FileEncryptionStatus = FileEncryptionStatusA;
        pub const OpenEncryptedFileRaw = OpenEncryptedFileRawA;
        pub const CreateDirectoryEx = CreateDirectoryExA;
        pub const CreateDirectoryTransacted = CreateDirectoryTransactedA;
        pub const RemoveDirectoryTransacted = RemoveDirectoryTransactedA;
        pub const GetFullPathNameTransacted = GetFullPathNameTransactedA;
        pub const CreateFileTransacted = CreateFileTransactedA;
        pub const SetFileAttributesTransacted = SetFileAttributesTransactedA;
        pub const GetFileAttributesTransacted = GetFileAttributesTransactedA;
        pub const GetCompressedFileSizeTransacted = GetCompressedFileSizeTransactedA;
        pub const DeleteFileTransacted = DeleteFileTransactedA;
        pub const CheckNameLegalDOS8Dot3 = CheckNameLegalDOS8Dot3A;
        pub const FindFirstFileTransacted = FindFirstFileTransactedA;
        pub const CopyFile = CopyFileA;
        pub const CopyFileEx = CopyFileExA;
        pub const CopyFileTransacted = CopyFileTransactedA;
        pub const MoveFile = MoveFileA;
        pub const MoveFileEx = MoveFileExA;
        pub const MoveFileWithProgress = MoveFileWithProgressA;
        pub const MoveFileTransacted = MoveFileTransactedA;
        pub const ReplaceFile = ReplaceFileA;
        pub const CreateHardLink = CreateHardLinkA;
        pub const CreateHardLinkTransacted = CreateHardLinkTransactedA;
        pub const SetVolumeLabel = SetVolumeLabelA;
        pub const FindFirstVolumeMountPoint = FindFirstVolumeMountPointA;
        pub const FindNextVolumeMountPoint = FindNextVolumeMountPointA;
        pub const SetVolumeMountPoint = SetVolumeMountPointA;
        pub const CreateSymbolicLink = CreateSymbolicLinkA;
        pub const CreateSymbolicLinkTransacted = CreateSymbolicLinkTransactedA;
    },
    .wide => struct {
        pub const WIN32_FIND_DATA = WIN32_FIND_DATAW;
        pub const NTMS_DRIVEINFORMATION = NTMS_DRIVEINFORMATIONW;
        pub const NTMS_CHANGERINFORMATION = NTMS_CHANGERINFORMATIONW;
        pub const NTMS_PMIDINFORMATION = NTMS_PMIDINFORMATIONW;
        pub const NTMS_PARTITIONINFORMATION = NTMS_PARTITIONINFORMATIONW;
        pub const NTMS_DRIVETYPEINFORMATION = NTMS_DRIVETYPEINFORMATIONW;
        pub const NTMS_CHANGERTYPEINFORMATION = NTMS_CHANGERTYPEINFORMATIONW;
        pub const NTMS_LIBREQUESTINFORMATION = NTMS_LIBREQUESTINFORMATIONW;
        pub const NTMS_OPREQUESTINFORMATION = NTMS_OPREQUESTINFORMATIONW;
        pub const NTMS_OBJECTINFORMATION = NTMS_OBJECTINFORMATIONW;
        pub const NTMS_I1_LIBREQUESTINFORMATION = NTMS_I1_LIBREQUESTINFORMATIONW;
        pub const NTMS_I1_PMIDINFORMATION = NTMS_I1_PMIDINFORMATIONW;
        pub const NTMS_I1_PARTITIONINFORMATION = NTMS_I1_PARTITIONINFORMATIONW;
        pub const NTMS_I1_OPREQUESTINFORMATION = NTMS_I1_OPREQUESTINFORMATIONW;
        pub const NTMS_I1_OBJECTINFORMATION = NTMS_I1_OBJECTINFORMATIONW;
        pub const CreateDirectory = CreateDirectoryW;
        pub const CreateFile = CreateFileW;
        pub const DefineDosDevice = DefineDosDeviceW;
        pub const DeleteFile = DeleteFileW;
        pub const DeleteVolumeMountPoint = DeleteVolumeMountPointW;
        pub const FindFirstChangeNotification = FindFirstChangeNotificationW;
        pub const FindFirstFile = FindFirstFileW;
        pub const FindFirstFileEx = FindFirstFileExW;
        pub const FindFirstVolume = FindFirstVolumeW;
        pub const FindNextFile = FindNextFileW;
        pub const FindNextVolume = FindNextVolumeW;
        pub const GetDiskFreeSpace = GetDiskFreeSpaceW;
        pub const GetDiskFreeSpaceEx = GetDiskFreeSpaceExW;
        pub const GetDiskSpaceInformation = GetDiskSpaceInformationW;
        pub const GetDriveType = GetDriveTypeW;
        pub const GetFileAttributes = GetFileAttributesW;
        pub const GetFileAttributesEx = GetFileAttributesExW;
        pub const GetFinalPathNameByHandle = GetFinalPathNameByHandleW;
        pub const GetFullPathName = GetFullPathNameW;
        pub const GetLogicalDriveStrings = GetLogicalDriveStringsW;
        pub const GetLongPathName = GetLongPathNameW;
        pub const GetShortPathName = GetShortPathNameW;
        pub const GetTempFileName = GetTempFileNameW;
        pub const GetVolumeInformation = GetVolumeInformationW;
        pub const GetVolumePathName = GetVolumePathNameW;
        pub const QueryDosDevice = QueryDosDeviceW;
        pub const RemoveDirectory = RemoveDirectoryW;
        pub const SetFileAttributes = SetFileAttributesW;
        pub const GetTempPath = GetTempPathW;
        pub const GetVolumeNameForVolumeMountPoint = GetVolumeNameForVolumeMountPointW;
        pub const GetVolumePathNamesForVolumeName = GetVolumePathNamesForVolumeNameW;
        pub const GetCompressedFileSize = GetCompressedFileSizeW;
        pub const GetExpandedName = GetExpandedNameW;
        pub const LZOpenFile = LZOpenFileW;
        pub const SearchPath = SearchPathW;
        pub const GetBinaryType = GetBinaryTypeW;
        pub const GetLongPathNameTransacted = GetLongPathNameTransactedW;
        pub const SetFileShortName = SetFileShortNameW;
        pub const EncryptFile = EncryptFileW;
        pub const DecryptFile = DecryptFileW;
        pub const FileEncryptionStatus = FileEncryptionStatusW;
        pub const OpenEncryptedFileRaw = OpenEncryptedFileRawW;
        pub const CreateDirectoryEx = CreateDirectoryExW;
        pub const CreateDirectoryTransacted = CreateDirectoryTransactedW;
        pub const RemoveDirectoryTransacted = RemoveDirectoryTransactedW;
        pub const GetFullPathNameTransacted = GetFullPathNameTransactedW;
        pub const CreateFileTransacted = CreateFileTransactedW;
        pub const SetFileAttributesTransacted = SetFileAttributesTransactedW;
        pub const GetFileAttributesTransacted = GetFileAttributesTransactedW;
        pub const GetCompressedFileSizeTransacted = GetCompressedFileSizeTransactedW;
        pub const DeleteFileTransacted = DeleteFileTransactedW;
        pub const CheckNameLegalDOS8Dot3 = CheckNameLegalDOS8Dot3W;
        pub const FindFirstFileTransacted = FindFirstFileTransactedW;
        pub const CopyFile = CopyFileW;
        pub const CopyFileEx = CopyFileExW;
        pub const CopyFileTransacted = CopyFileTransactedW;
        pub const MoveFile = MoveFileW;
        pub const MoveFileEx = MoveFileExW;
        pub const MoveFileWithProgress = MoveFileWithProgressW;
        pub const MoveFileTransacted = MoveFileTransactedW;
        pub const ReplaceFile = ReplaceFileW;
        pub const CreateHardLink = CreateHardLinkW;
        pub const CreateHardLinkTransacted = CreateHardLinkTransactedW;
        pub const SetVolumeLabel = SetVolumeLabelW;
        pub const FindFirstVolumeMountPoint = FindFirstVolumeMountPointW;
        pub const FindNextVolumeMountPoint = FindNextVolumeMountPointW;
        pub const SetVolumeMountPoint = SetVolumeMountPointW;
        pub const CreateSymbolicLink = CreateSymbolicLinkW;
        pub const CreateSymbolicLinkTransacted = CreateSymbolicLinkTransactedW;
    },
    else => if (@import("builtin").is_test) struct {
        pub const WIN32_FIND_DATA = *opaque{};
        pub const NTMS_DRIVEINFORMATION = *opaque{};
        pub const NTMS_CHANGERINFORMATION = *opaque{};
        pub const NTMS_PMIDINFORMATION = *opaque{};
        pub const NTMS_PARTITIONINFORMATION = *opaque{};
        pub const NTMS_DRIVETYPEINFORMATION = *opaque{};
        pub const NTMS_CHANGERTYPEINFORMATION = *opaque{};
        pub const NTMS_LIBREQUESTINFORMATION = *opaque{};
        pub const NTMS_OPREQUESTINFORMATION = *opaque{};
        pub const NTMS_OBJECTINFORMATION = *opaque{};
        pub const NTMS_I1_LIBREQUESTINFORMATION = *opaque{};
        pub const NTMS_I1_PMIDINFORMATION = *opaque{};
        pub const NTMS_I1_PARTITIONINFORMATION = *opaque{};
        pub const NTMS_I1_OPREQUESTINFORMATION = *opaque{};
        pub const NTMS_I1_OBJECTINFORMATION = *opaque{};
        pub const CreateDirectory = *opaque{};
        pub const CreateFile = *opaque{};
        pub const DefineDosDevice = *opaque{};
        pub const DeleteFile = *opaque{};
        pub const DeleteVolumeMountPoint = *opaque{};
        pub const FindFirstChangeNotification = *opaque{};
        pub const FindFirstFile = *opaque{};
        pub const FindFirstFileEx = *opaque{};
        pub const FindFirstVolume = *opaque{};
        pub const FindNextFile = *opaque{};
        pub const FindNextVolume = *opaque{};
        pub const GetDiskFreeSpace = *opaque{};
        pub const GetDiskFreeSpaceEx = *opaque{};
        pub const GetDiskSpaceInformation = *opaque{};
        pub const GetDriveType = *opaque{};
        pub const GetFileAttributes = *opaque{};
        pub const GetFileAttributesEx = *opaque{};
        pub const GetFinalPathNameByHandle = *opaque{};
        pub const GetFullPathName = *opaque{};
        pub const GetLogicalDriveStrings = *opaque{};
        pub const GetLongPathName = *opaque{};
        pub const GetShortPathName = *opaque{};
        pub const GetTempFileName = *opaque{};
        pub const GetVolumeInformation = *opaque{};
        pub const GetVolumePathName = *opaque{};
        pub const QueryDosDevice = *opaque{};
        pub const RemoveDirectory = *opaque{};
        pub const SetFileAttributes = *opaque{};
        pub const GetTempPath = *opaque{};
        pub const GetVolumeNameForVolumeMountPoint = *opaque{};
        pub const GetVolumePathNamesForVolumeName = *opaque{};
        pub const GetCompressedFileSize = *opaque{};
        pub const GetExpandedName = *opaque{};
        pub const LZOpenFile = *opaque{};
        pub const SearchPath = *opaque{};
        pub const GetBinaryType = *opaque{};
        pub const GetLongPathNameTransacted = *opaque{};
        pub const SetFileShortName = *opaque{};
        pub const EncryptFile = *opaque{};
        pub const DecryptFile = *opaque{};
        pub const FileEncryptionStatus = *opaque{};
        pub const OpenEncryptedFileRaw = *opaque{};
        pub const CreateDirectoryEx = *opaque{};
        pub const CreateDirectoryTransacted = *opaque{};
        pub const RemoveDirectoryTransacted = *opaque{};
        pub const GetFullPathNameTransacted = *opaque{};
        pub const CreateFileTransacted = *opaque{};
        pub const SetFileAttributesTransacted = *opaque{};
        pub const GetFileAttributesTransacted = *opaque{};
        pub const GetCompressedFileSizeTransacted = *opaque{};
        pub const DeleteFileTransacted = *opaque{};
        pub const CheckNameLegalDOS8Dot3 = *opaque{};
        pub const FindFirstFileTransacted = *opaque{};
        pub const CopyFile = *opaque{};
        pub const CopyFileEx = *opaque{};
        pub const CopyFileTransacted = *opaque{};
        pub const MoveFile = *opaque{};
        pub const MoveFileEx = *opaque{};
        pub const MoveFileWithProgress = *opaque{};
        pub const MoveFileTransacted = *opaque{};
        pub const ReplaceFile = *opaque{};
        pub const CreateHardLink = *opaque{};
        pub const CreateHardLinkTransacted = *opaque{};
        pub const SetVolumeLabel = *opaque{};
        pub const FindFirstVolumeMountPoint = *opaque{};
        pub const FindNextVolumeMountPoint = *opaque{};
        pub const SetVolumeMountPoint = *opaque{};
        pub const CreateSymbolicLink = *opaque{};
        pub const CreateSymbolicLinkTransacted = *opaque{};
    } else struct {
        pub const WIN32_FIND_DATA = @compileError("'WIN32_FIND_DATA' requires that UNICODE be set to true or false in the root module");
        pub const NTMS_DRIVEINFORMATION = @compileError("'NTMS_DRIVEINFORMATION' requires that UNICODE be set to true or false in the root module");
        pub const NTMS_CHANGERINFORMATION = @compileError("'NTMS_CHANGERINFORMATION' requires that UNICODE be set to true or false in the root module");
        pub const NTMS_PMIDINFORMATION = @compileError("'NTMS_PMIDINFORMATION' requires that UNICODE be set to true or false in the root module");
        pub const NTMS_PARTITIONINFORMATION = @compileError("'NTMS_PARTITIONINFORMATION' requires that UNICODE be set to true or false in the root module");
        pub const NTMS_DRIVETYPEINFORMATION = @compileError("'NTMS_DRIVETYPEINFORMATION' requires that UNICODE be set to true or false in the root module");
        pub const NTMS_CHANGERTYPEINFORMATION = @compileError("'NTMS_CHANGERTYPEINFORMATION' requires that UNICODE be set to true or false in the root module");
        pub const NTMS_LIBREQUESTINFORMATION = @compileError("'NTMS_LIBREQUESTINFORMATION' requires that UNICODE be set to true or false in the root module");
        pub const NTMS_OPREQUESTINFORMATION = @compileError("'NTMS_OPREQUESTINFORMATION' requires that UNICODE be set to true or false in the root module");
        pub const NTMS_OBJECTINFORMATION = @compileError("'NTMS_OBJECTINFORMATION' requires that UNICODE be set to true or false in the root module");
        pub const NTMS_I1_LIBREQUESTINFORMATION = @compileError("'NTMS_I1_LIBREQUESTINFORMATION' requires that UNICODE be set to true or false in the root module");
        pub const NTMS_I1_PMIDINFORMATION = @compileError("'NTMS_I1_PMIDINFORMATION' requires that UNICODE be set to true or false in the root module");
        pub const NTMS_I1_PARTITIONINFORMATION = @compileError("'NTMS_I1_PARTITIONINFORMATION' requires that UNICODE be set to true or false in the root module");
        pub const NTMS_I1_OPREQUESTINFORMATION = @compileError("'NTMS_I1_OPREQUESTINFORMATION' requires that UNICODE be set to true or false in the root module");
        pub const NTMS_I1_OBJECTINFORMATION = @compileError("'NTMS_I1_OBJECTINFORMATION' requires that UNICODE be set to true or false in the root module");
        pub const CreateDirectory = @compileError("'CreateDirectory' requires that UNICODE be set to true or false in the root module");
        pub const CreateFile = @compileError("'CreateFile' requires that UNICODE be set to true or false in the root module");
        pub const DefineDosDevice = @compileError("'DefineDosDevice' requires that UNICODE be set to true or false in the root module");
        pub const DeleteFile = @compileError("'DeleteFile' requires that UNICODE be set to true or false in the root module");
        pub const DeleteVolumeMountPoint = @compileError("'DeleteVolumeMountPoint' requires that UNICODE be set to true or false in the root module");
        pub const FindFirstChangeNotification = @compileError("'FindFirstChangeNotification' requires that UNICODE be set to true or false in the root module");
        pub const FindFirstFile = @compileError("'FindFirstFile' requires that UNICODE be set to true or false in the root module");
        pub const FindFirstFileEx = @compileError("'FindFirstFileEx' requires that UNICODE be set to true or false in the root module");
        pub const FindFirstVolume = @compileError("'FindFirstVolume' requires that UNICODE be set to true or false in the root module");
        pub const FindNextFile = @compileError("'FindNextFile' requires that UNICODE be set to true or false in the root module");
        pub const FindNextVolume = @compileError("'FindNextVolume' requires that UNICODE be set to true or false in the root module");
        pub const GetDiskFreeSpace = @compileError("'GetDiskFreeSpace' requires that UNICODE be set to true or false in the root module");
        pub const GetDiskFreeSpaceEx = @compileError("'GetDiskFreeSpaceEx' requires that UNICODE be set to true or false in the root module");
        pub const GetDiskSpaceInformation = @compileError("'GetDiskSpaceInformation' requires that UNICODE be set to true or false in the root module");
        pub const GetDriveType = @compileError("'GetDriveType' requires that UNICODE be set to true or false in the root module");
        pub const GetFileAttributes = @compileError("'GetFileAttributes' requires that UNICODE be set to true or false in the root module");
        pub const GetFileAttributesEx = @compileError("'GetFileAttributesEx' requires that UNICODE be set to true or false in the root module");
        pub const GetFinalPathNameByHandle = @compileError("'GetFinalPathNameByHandle' requires that UNICODE be set to true or false in the root module");
        pub const GetFullPathName = @compileError("'GetFullPathName' requires that UNICODE be set to true or false in the root module");
        pub const GetLogicalDriveStrings = @compileError("'GetLogicalDriveStrings' requires that UNICODE be set to true or false in the root module");
        pub const GetLongPathName = @compileError("'GetLongPathName' requires that UNICODE be set to true or false in the root module");
        pub const GetShortPathName = @compileError("'GetShortPathName' requires that UNICODE be set to true or false in the root module");
        pub const GetTempFileName = @compileError("'GetTempFileName' requires that UNICODE be set to true or false in the root module");
        pub const GetVolumeInformation = @compileError("'GetVolumeInformation' requires that UNICODE be set to true or false in the root module");
        pub const GetVolumePathName = @compileError("'GetVolumePathName' requires that UNICODE be set to true or false in the root module");
        pub const QueryDosDevice = @compileError("'QueryDosDevice' requires that UNICODE be set to true or false in the root module");
        pub const RemoveDirectory = @compileError("'RemoveDirectory' requires that UNICODE be set to true or false in the root module");
        pub const SetFileAttributes = @compileError("'SetFileAttributes' requires that UNICODE be set to true or false in the root module");
        pub const GetTempPath = @compileError("'GetTempPath' requires that UNICODE be set to true or false in the root module");
        pub const GetVolumeNameForVolumeMountPoint = @compileError("'GetVolumeNameForVolumeMountPoint' requires that UNICODE be set to true or false in the root module");
        pub const GetVolumePathNamesForVolumeName = @compileError("'GetVolumePathNamesForVolumeName' requires that UNICODE be set to true or false in the root module");
        pub const GetCompressedFileSize = @compileError("'GetCompressedFileSize' requires that UNICODE be set to true or false in the root module");
        pub const GetExpandedName = @compileError("'GetExpandedName' requires that UNICODE be set to true or false in the root module");
        pub const LZOpenFile = @compileError("'LZOpenFile' requires that UNICODE be set to true or false in the root module");
        pub const SearchPath = @compileError("'SearchPath' requires that UNICODE be set to true or false in the root module");
        pub const GetBinaryType = @compileError("'GetBinaryType' requires that UNICODE be set to true or false in the root module");
        pub const GetLongPathNameTransacted = @compileError("'GetLongPathNameTransacted' requires that UNICODE be set to true or false in the root module");
        pub const SetFileShortName = @compileError("'SetFileShortName' requires that UNICODE be set to true or false in the root module");
        pub const EncryptFile = @compileError("'EncryptFile' requires that UNICODE be set to true or false in the root module");
        pub const DecryptFile = @compileError("'DecryptFile' requires that UNICODE be set to true or false in the root module");
        pub const FileEncryptionStatus = @compileError("'FileEncryptionStatus' requires that UNICODE be set to true or false in the root module");
        pub const OpenEncryptedFileRaw = @compileError("'OpenEncryptedFileRaw' requires that UNICODE be set to true or false in the root module");
        pub const CreateDirectoryEx = @compileError("'CreateDirectoryEx' requires that UNICODE be set to true or false in the root module");
        pub const CreateDirectoryTransacted = @compileError("'CreateDirectoryTransacted' requires that UNICODE be set to true or false in the root module");
        pub const RemoveDirectoryTransacted = @compileError("'RemoveDirectoryTransacted' requires that UNICODE be set to true or false in the root module");
        pub const GetFullPathNameTransacted = @compileError("'GetFullPathNameTransacted' requires that UNICODE be set to true or false in the root module");
        pub const CreateFileTransacted = @compileError("'CreateFileTransacted' requires that UNICODE be set to true or false in the root module");
        pub const SetFileAttributesTransacted = @compileError("'SetFileAttributesTransacted' requires that UNICODE be set to true or false in the root module");
        pub const GetFileAttributesTransacted = @compileError("'GetFileAttributesTransacted' requires that UNICODE be set to true or false in the root module");
        pub const GetCompressedFileSizeTransacted = @compileError("'GetCompressedFileSizeTransacted' requires that UNICODE be set to true or false in the root module");
        pub const DeleteFileTransacted = @compileError("'DeleteFileTransacted' requires that UNICODE be set to true or false in the root module");
        pub const CheckNameLegalDOS8Dot3 = @compileError("'CheckNameLegalDOS8Dot3' requires that UNICODE be set to true or false in the root module");
        pub const FindFirstFileTransacted = @compileError("'FindFirstFileTransacted' requires that UNICODE be set to true or false in the root module");
        pub const CopyFile = @compileError("'CopyFile' requires that UNICODE be set to true or false in the root module");
        pub const CopyFileEx = @compileError("'CopyFileEx' requires that UNICODE be set to true or false in the root module");
        pub const CopyFileTransacted = @compileError("'CopyFileTransacted' requires that UNICODE be set to true or false in the root module");
        pub const MoveFile = @compileError("'MoveFile' requires that UNICODE be set to true or false in the root module");
        pub const MoveFileEx = @compileError("'MoveFileEx' requires that UNICODE be set to true or false in the root module");
        pub const MoveFileWithProgress = @compileError("'MoveFileWithProgress' requires that UNICODE be set to true or false in the root module");
        pub const MoveFileTransacted = @compileError("'MoveFileTransacted' requires that UNICODE be set to true or false in the root module");
        pub const ReplaceFile = @compileError("'ReplaceFile' requires that UNICODE be set to true or false in the root module");
        pub const CreateHardLink = @compileError("'CreateHardLink' requires that UNICODE be set to true or false in the root module");
        pub const CreateHardLinkTransacted = @compileError("'CreateHardLinkTransacted' requires that UNICODE be set to true or false in the root module");
        pub const SetVolumeLabel = @compileError("'SetVolumeLabel' requires that UNICODE be set to true or false in the root module");
        pub const FindFirstVolumeMountPoint = @compileError("'FindFirstVolumeMountPoint' requires that UNICODE be set to true or false in the root module");
        pub const FindNextVolumeMountPoint = @compileError("'FindNextVolumeMountPoint' requires that UNICODE be set to true or false in the root module");
        pub const SetVolumeMountPoint = @compileError("'SetVolumeMountPoint' requires that UNICODE be set to true or false in the root module");
        pub const CreateSymbolicLink = @compileError("'CreateSymbolicLink' requires that UNICODE be set to true or false in the root module");
        pub const CreateSymbolicLinkTransacted = @compileError("'CreateSymbolicLinkTransacted' requires that UNICODE be set to true or false in the root module");
    },
};

//
// type imports
//
const Guid = @import("../zig.zig").Guid;
const LARGE_INTEGER = @import("systemservices.zig").LARGE_INTEGER;
const OVERLAPPED = @import("systemservices.zig").OVERLAPPED;
const FILETIME = @import("windowsprogramming.zig").FILETIME;
const STORAGE_BUS_TYPE = @import("systemservices.zig").STORAGE_BUS_TYPE;
const DETECTION_TYPE = @import("systemservices.zig").DETECTION_TYPE;
const DISK_CACHE_RETENTION_PRIORITY = @import("systemservices.zig").DISK_CACHE_RETENTION_PRIORITY;
const HANDLE = @import("systemservices.zig").HANDLE;
const SID = @import("security.zig").SID;
const SHRINK_VOLUME_REQUEST_TYPES = @import("systemservices.zig").SHRINK_VOLUME_REQUEST_TYPES;
const FILE_STORAGE_TIER_CLASS = @import("systemservices.zig").FILE_STORAGE_TIER_CLASS;
const SECURITY_ATTRIBUTES = @import("systemservices.zig").SECURITY_ATTRIBUTES;
const BOOL = @import("systemservices.zig").BOOL;
const SYSTEMTIME = @import("windowsprogramming.zig").SYSTEMTIME;
const HRESULT = @import("com.zig").HRESULT;
const ULARGE_INTEGER = @import("systemservices.zig").ULARGE_INTEGER;
const FILE_SEGMENT_ELEMENT = @import("systemservices.zig").FILE_SEGMENT_ELEMENT;

test "" {
    const constant_export_count = 23;
    const type_export_count = 431;
    const func_count = 371;
    const unicode_alias_count = 84;
    const type_import_count = 17;
    @setEvalBranchQuota(0
        + constant_export_count
        + type_export_count
        + func_count
        + unicode_alias_count
        + type_import_count
        + 2 // TODO: why do I need these extra 2?
    );
    @import("std").testing.refAllDecls(@This());
}
