//! NOTE: this source file is autogenerated, DO NOT MODIFY

//
// constants
//
pub const GPFIDL_DEFAULT : i32 = 0;
pub const GPFIDL_ALTNAME : i32 = 1;
pub const GPFIDL_UNCPRINTER : i32 = 2;
pub const ISHCUTCMDID_DOWNLOADICON : i32 = 0;
pub const ISHCUTCMDID_INTSHORTCUTCREATE : i32 = 1;
pub const ISHCUTCMDID_COMMITHISTORY : i32 = 2;
pub const ISHCUTCMDID_SETUSERAWURL : i32 = 3;
pub const SFBID_PIDLCHANGED : i32 = 0;
pub const DBCID_EMPTY : i32 = 0;
pub const DBCID_ONDRAG : i32 = 1;
pub const DBCID_CLSIDOFBAR : i32 = 2;
pub const DBCID_RESIZE : i32 = 3;
pub const DBCID_GETBAR : i32 = 4;
pub const BMICON_LARGE : i32 = 0;
pub const BMICON_SMALL : i32 = 1;
pub const ASSOCF_NONE : i32 = 0;
pub const ASSOCF_INIT_NOREMAPCLSID : i32 = 1;
pub const ASSOCF_INIT_BYEXENAME : i32 = 2;
pub const ASSOCF_OPEN_BYEXENAME : i32 = 2;
pub const ASSOCF_INIT_DEFAULTTOSTAR : i32 = 4;
pub const ASSOCF_INIT_DEFAULTTOFOLDER : i32 = 8;
pub const ASSOCF_NOUSERSETTINGS : i32 = 16;
pub const ASSOCF_NOTRUNCATE : i32 = 32;
pub const ASSOCF_VERIFY : i32 = 64;
pub const ASSOCF_REMAPRUNDLL : i32 = 128;
pub const ASSOCF_NOFIXUPS : i32 = 256;
pub const ASSOCF_IGNOREBASECLASS : i32 = 512;
pub const ASSOCF_INIT_IGNOREUNKNOWN : i32 = 1024;
pub const ASSOCF_INIT_FIXED_PROGID : i32 = 2048;
pub const ASSOCF_IS_PROTOCOL : i32 = 4096;
pub const ASSOCF_INIT_FOR_FILE : i32 = 8192;
pub const ASSOCF_IS_FULL_URI : i32 = 16384;
pub const ASSOCF_PER_MACHINE_ONLY : i32 = 32768;
pub const ASSOCF_APP_TO_APP : i32 = 65536;
pub const CTF_INSIST : i32 = 1;
pub const CTF_THREAD_REF : i32 = 2;
pub const CTF_PROCESS_REF : i32 = 4;
pub const CTF_COINIT_STA : i32 = 8;
pub const CTF_COINIT : i32 = 8;
pub const CTF_FREELIBANDEXIT : i32 = 16;
pub const CTF_REF_COUNTED : i32 = 32;
pub const CTF_WAIT_ALLOWCOM : i32 = 64;
pub const CTF_UNUSED : i32 = 128;
pub const CTF_INHERITWOW64 : i32 = 256;
pub const CTF_WAIT_NO_REENTRANCY : i32 = 512;
pub const CTF_KEYBOARD_LOCALE : i32 = 1024;
pub const CTF_OLEINITIALIZE : i32 = 2048;
pub const CTF_COINIT_MTA : i32 = 4096;
pub const CTF_NOADDREFLIB : i32 = 8192;

//
// types
//
// --------------------------------------------------------
// Type: INotifyReplica
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const INotifyReplica = *opaque{
    // TODO: Method 'YouAreAReplica'
};
// --------------------------------------------------------
// Type: HELPINFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HELPINFO = extern struct {
    cbSize: u32,
    iContextType: i32,
    iCtrlId: i32,
    hItemHandle: HANDLE,
    dwContextId: ?*opaque{},
    MousePos: POINT,
};
// --------------------------------------------------------
// Type: MULTIKEYHELPA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const MULTIKEYHELPA = extern struct {
    mkSize: u32,
    mkKeylist: i8,
    szKeyphrase: ?[*]i8,
};
// --------------------------------------------------------
// Type: MULTIKEYHELPW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const MULTIKEYHELPW = extern struct {
    mkSize: u32,
    mkKeylist: u16,
    szKeyphrase: ?[*]u16,
};
// --------------------------------------------------------
// Type: HELPWININFOA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HELPWININFOA = extern struct {
    wStructSize: i32,
    x: i32,
    y: i32,
    dx: i32,
    dy: i32,
    wMax: i32,
    rgchMember: ?[*]i8,
};
// --------------------------------------------------------
// Type: HELPWININFOW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HELPWININFOW = extern struct {
    wStructSize: i32,
    x: i32,
    y: i32,
    dx: i32,
    dy: i32,
    wMax: i32,
    rgchMember: ?[*]u16,
};
// --------------------------------------------------------
// Type: SOFTDISTINFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SOFTDISTINFO = extern struct {
    cbSize: u32,
    dwFlags: u32,
    dwAdState: u32,
    szTitle: ?*u16,
    szAbstract: ?*u16,
    szHREF: ?*u16,
    dwInstalledVersionMS: u32,
    dwInstalledVersionLS: u32,
    dwUpdateVersionMS: u32,
    dwUpdateVersionLS: u32,
    dwAdvertisedVersionMS: u32,
    dwAdvertisedVersionLS: u32,
    dwReserved: u32,
};
// --------------------------------------------------------
// Type: HDROP__
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const HDROP__ = *opaque{
};
// --------------------------------------------------------
// Type: DRAGINFOA
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const DRAGINFOA = *opaque{
};
// --------------------------------------------------------
// Type: DRAGINFOW
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const DRAGINFOW = *opaque{
};
// --------------------------------------------------------
// Type: APPBARDATA
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const APPBARDATA = *opaque{
};
// --------------------------------------------------------
// Type: SHFILEOPSTRUCTA
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const SHFILEOPSTRUCTA = *opaque{
};
// --------------------------------------------------------
// Type: SHFILEOPSTRUCTW
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const SHFILEOPSTRUCTW = *opaque{
};
// --------------------------------------------------------
// Type: SHNAMEMAPPINGA
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const SHNAMEMAPPINGA = *opaque{
};
// --------------------------------------------------------
// Type: SHNAMEMAPPINGW
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const SHNAMEMAPPINGW = *opaque{
};
// --------------------------------------------------------
// Type: SHELLEXECUTEINFOA
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const SHELLEXECUTEINFOA = *opaque{
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: SHELLEXECUTEINFOW
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const SHELLEXECUTEINFOW = *opaque{
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: SHCREATEPROCESSINFOW
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const SHCREATEPROCESSINFOW = *opaque{
};
// --------------------------------------------------------
// Type: ASSOCCLASS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const ASSOCCLASS = *opaque{
};
// --------------------------------------------------------
// Type: ASSOCIATIONELEMENT
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const ASSOCIATIONELEMENT = *opaque{
};
// --------------------------------------------------------
// Type: SHQUERYRBINFO
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const SHQUERYRBINFO = *opaque{
};
// --------------------------------------------------------
// Type: QUERY_USER_NOTIFICATION_STATE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const QUERY_USER_NOTIFICATION_STATE = *opaque{
};
// --------------------------------------------------------
// Type: NOTIFYICONDATAA
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const NOTIFYICONDATAA = *opaque{
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: NOTIFYICONDATAW
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const NOTIFYICONDATAW = *opaque{
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: NOTIFYICONIDENTIFIER
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const NOTIFYICONIDENTIFIER = *opaque{
};
// --------------------------------------------------------
// Type: SHFILEINFOA
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const SHFILEINFOA = *opaque{
};
// --------------------------------------------------------
// Type: SHFILEINFOW
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const SHFILEINFOW = *opaque{
};
// --------------------------------------------------------
// Type: SHSTOCKICONINFO
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const SHSTOCKICONINFO = *opaque{
};
// --------------------------------------------------------
// Type: SHSTOCKICONID
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const SHSTOCKICONID = *opaque{
};
// --------------------------------------------------------
// Type: OPEN_PRINTER_PROPS_INFOA
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const OPEN_PRINTER_PROPS_INFOA = *opaque{
};
// --------------------------------------------------------
// Type: OPEN_PRINTER_PROPS_INFOW
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const OPEN_PRINTER_PROPS_INFOW = *opaque{
};
// --------------------------------------------------------
// Type: PFNCANSHAREFOLDERW
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFNCANSHAREFOLDERW = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PFNSHOWSHAREFOLDERUIW
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFNSHOWSHAREFOLDERUIW = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: IMarkupCallback
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const IMarkupCallback = opaque {
};
// --------------------------------------------------------
// Type: IControlMarkup
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const IControlMarkup = opaque {
};
// --------------------------------------------------------
// Type: QueryCancelAutoPlay
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const QueryCancelAutoPlay = opaque {
};
// --------------------------------------------------------
// Type: TimeCategorizer
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const TimeCategorizer = opaque {
};
// --------------------------------------------------------
// Type: AlphabeticalCategorizer
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const AlphabeticalCategorizer = opaque {
};
// --------------------------------------------------------
// Type: MergedCategorizer
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const MergedCategorizer = opaque {
};
// --------------------------------------------------------
// Type: ImageProperties
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const ImageProperties = opaque {
};
// --------------------------------------------------------
// Type: CDBurn
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const CDBurn = opaque {
};
// --------------------------------------------------------
// Type: StartMenuPin
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const StartMenuPin = opaque {
};
// --------------------------------------------------------
// Type: WebWizardHost
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const WebWizardHost = opaque {
};
// --------------------------------------------------------
// Type: PublishDropTarget
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const PublishDropTarget = opaque {
};
// --------------------------------------------------------
// Type: PublishingWizard
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const PublishingWizard = opaque {
};
// --------------------------------------------------------
// Type: InternetPrintOrdering
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const InternetPrintOrdering = opaque {
};
// --------------------------------------------------------
// Type: FolderViewHost
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const FolderViewHost = opaque {
};
// --------------------------------------------------------
// Type: ExplorerBrowser
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const ExplorerBrowser = opaque {
};
// --------------------------------------------------------
// Type: ImageRecompress
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const ImageRecompress = opaque {
};
// --------------------------------------------------------
// Type: TrayBandSiteService
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const TrayBandSiteService = opaque {
};
// --------------------------------------------------------
// Type: TrayDeskBand
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const TrayDeskBand = opaque {
};
// --------------------------------------------------------
// Type: AttachmentServices
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const AttachmentServices = opaque {
};
// --------------------------------------------------------
// Type: DocPropShellExtension
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const DocPropShellExtension = opaque {
};
// --------------------------------------------------------
// Type: FSCopyHandler
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const FSCopyHandler = opaque {
};
// --------------------------------------------------------
// Type: PreviousVersions
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const PreviousVersions = opaque {
};
// --------------------------------------------------------
// Type: NamespaceTreeControl
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const NamespaceTreeControl = opaque {
};
// --------------------------------------------------------
// Type: IENamespaceTreeControl
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const IENamespaceTreeControl = opaque {
};
// --------------------------------------------------------
// Type: ApplicationAssociationRegistrationUI
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const ApplicationAssociationRegistrationUI = opaque {
};
// --------------------------------------------------------
// Type: DesktopGadget
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const DesktopGadget = opaque {
};
// --------------------------------------------------------
// Type: AccessibilityDockingService
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const AccessibilityDockingService = opaque {
};
// --------------------------------------------------------
// Type: ExecuteFolder
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const ExecuteFolder = opaque {
};
// --------------------------------------------------------
// Type: VirtualDesktopManager
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const VirtualDesktopManager = opaque {
};
// --------------------------------------------------------
// Type: StorageProviderBanners
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const StorageProviderBanners = opaque {
};
// --------------------------------------------------------
// Type: SHITEMID
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const SHITEMID = *opaque{
};
// --------------------------------------------------------
// Type: ITEMIDLIST
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const ITEMIDLIST = extern struct {
    mkid: SHITEMID,
};
// --------------------------------------------------------
// Type: STRRET_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const STRRET_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: STRRET
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const STRRET = extern struct {
    uType: u32,
    Anonymous: _Anonymous_e__Union,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: SHELLDETAILS
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const SHELLDETAILS = *opaque{
};
// --------------------------------------------------------
// Type: PERCEIVED
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PERCEIVED = *opaque{
};
// --------------------------------------------------------
// Type: COMDLG_FILTERSPEC
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const COMDLG_FILTERSPEC = extern struct {
    pszName: ?*u16,
    pszSpec: ?*u16,
};
// --------------------------------------------------------
// Type: SHCOLSTATE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const SHCOLSTATE = *opaque{
};
// --------------------------------------------------------
// Type: DEVICE_SCALE_FACTOR
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const DEVICE_SCALE_FACTOR = *opaque{
};
// --------------------------------------------------------
// Type: IObjectArray
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IObjectArray = *opaque{
    // TODO: Method 'GetCount'
    // TODO: Method 'GetAt'
};
// --------------------------------------------------------
// Type: IObjectCollection
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IObjectCollection = *opaque{
    // TODO: Method 'AddObject'
    // TODO: Method 'AddFromArray'
    // TODO: Method 'RemoveObjectAt'
    // TODO: Method 'Clear'
};
// --------------------------------------------------------
// Type: DesktopWallpaper
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const DesktopWallpaper = opaque {
};
// --------------------------------------------------------
// Type: ShellDesktop
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const ShellDesktop = opaque {
};
// --------------------------------------------------------
// Type: ShellFSFolder
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const ShellFSFolder = opaque {
};
// --------------------------------------------------------
// Type: NetworkPlaces
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const NetworkPlaces = opaque {
};
// --------------------------------------------------------
// Type: ShellLink
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const ShellLink = opaque {
};
// --------------------------------------------------------
// Type: DriveSizeCategorizer
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const DriveSizeCategorizer = opaque {
};
// --------------------------------------------------------
// Type: DriveTypeCategorizer
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const DriveTypeCategorizer = opaque {
};
// --------------------------------------------------------
// Type: FreeSpaceCategorizer
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const FreeSpaceCategorizer = opaque {
};
// --------------------------------------------------------
// Type: SizeCategorizer
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const SizeCategorizer = opaque {
};
// --------------------------------------------------------
// Type: PropertiesUI
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const PropertiesUI = opaque {
};
// --------------------------------------------------------
// Type: UserNotification
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const UserNotification = opaque {
};
// --------------------------------------------------------
// Type: TaskbarList
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const TaskbarList = opaque {
};
// --------------------------------------------------------
// Type: ShellItem
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const ShellItem = opaque {
};
// --------------------------------------------------------
// Type: NamespaceWalker
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const NamespaceWalker = opaque {
};
// --------------------------------------------------------
// Type: FileOperation
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const FileOperation = opaque {
};
// --------------------------------------------------------
// Type: FileOpenDialog
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const FileOpenDialog = opaque {
};
// --------------------------------------------------------
// Type: FileSaveDialog
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const FileSaveDialog = opaque {
};
// --------------------------------------------------------
// Type: KnownFolderManager
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const KnownFolderManager = opaque {
};
// --------------------------------------------------------
// Type: SharingConfigurationManager
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const SharingConfigurationManager = opaque {
};
// --------------------------------------------------------
// Type: NetworkConnections
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const NetworkConnections = opaque {
};
// --------------------------------------------------------
// Type: ScheduledTasks
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const ScheduledTasks = opaque {
};
// --------------------------------------------------------
// Type: ApplicationAssociationRegistration
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const ApplicationAssociationRegistration = opaque {
};
// --------------------------------------------------------
// Type: SearchFolderItemFactory
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const SearchFolderItemFactory = opaque {
};
// --------------------------------------------------------
// Type: OpenControlPanel
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const OpenControlPanel = opaque {
};
// --------------------------------------------------------
// Type: MailRecipient
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const MailRecipient = opaque {
};
// --------------------------------------------------------
// Type: NetworkExplorerFolder
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const NetworkExplorerFolder = opaque {
};
// --------------------------------------------------------
// Type: DestinationList
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const DestinationList = opaque {
};
// --------------------------------------------------------
// Type: ApplicationDestinations
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const ApplicationDestinations = opaque {
};
// --------------------------------------------------------
// Type: ApplicationDocumentLists
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const ApplicationDocumentLists = opaque {
};
// --------------------------------------------------------
// Type: HomeGroup
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const HomeGroup = opaque {
};
// --------------------------------------------------------
// Type: ShellLibrary
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const ShellLibrary = opaque {
};
// --------------------------------------------------------
// Type: AppStartupLink
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const AppStartupLink = opaque {
};
// --------------------------------------------------------
// Type: EnumerableObjectCollection
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const EnumerableObjectCollection = opaque {
};
// --------------------------------------------------------
// Type: FrameworkInputPane
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const FrameworkInputPane = opaque {
};
// --------------------------------------------------------
// Type: DefFolderMenu
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const DefFolderMenu = opaque {
};
// --------------------------------------------------------
// Type: AppVisibility
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const AppVisibility = opaque {
};
// --------------------------------------------------------
// Type: AppShellVerbHandler
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const AppShellVerbHandler = opaque {
};
// --------------------------------------------------------
// Type: ExecuteUnknown
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const ExecuteUnknown = opaque {
};
// --------------------------------------------------------
// Type: PackageDebugSettings
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const PackageDebugSettings = opaque {
};
// --------------------------------------------------------
// Type: SuspensionDependencyManager
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const SuspensionDependencyManager = opaque {
};
// --------------------------------------------------------
// Type: ApplicationActivationManager
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const ApplicationActivationManager = opaque {
};
// --------------------------------------------------------
// Type: ApplicationDesignModeSettings
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const ApplicationDesignModeSettings = opaque {
};
// --------------------------------------------------------
// Type: CMINVOKECOMMANDINFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CMINVOKECOMMANDINFO = extern struct {
    cbSize: u32,
    fMask: u32,
    hwnd: HWND,
    lpVerb: ?*i8,
    lpParameters: ?*i8,
    lpDirectory: ?*i8,
    nShow: i32,
    dwHotKey: u32,
    hIcon: HANDLE,
};
// --------------------------------------------------------
// Type: CMINVOKECOMMANDINFOEX
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CMINVOKECOMMANDINFOEX = extern struct {
    cbSize: u32,
    fMask: u32,
    hwnd: HWND,
    lpVerb: ?*i8,
    lpParameters: ?*i8,
    lpDirectory: ?*i8,
    nShow: i32,
    dwHotKey: u32,
    hIcon: HANDLE,
    lpTitle: ?*i8,
    lpVerbW: ?*u16,
    lpParametersW: ?*u16,
    lpDirectoryW: ?*u16,
    lpTitleW: ?*u16,
    ptInvoke: POINT,
};
// --------------------------------------------------------
// Type: IContextMenu
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IContextMenu = *opaque{
    // TODO: Method 'QueryContextMenu'
    // TODO: Method 'InvokeCommand'
    // TODO: Method 'GetCommandString'
};
// --------------------------------------------------------
// Type: IContextMenu2
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IContextMenu2 = *opaque{
    // TODO: Method 'HandleMenuMsg'
};
// --------------------------------------------------------
// Type: IContextMenu3
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IContextMenu3 = *opaque{
    // TODO: Method 'HandleMenuMsg2'
};
// --------------------------------------------------------
// Type: IExecuteCommand
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IExecuteCommand = *opaque{
    // TODO: Method 'SetKeyState'
    // TODO: Method 'SetParameters'
    // TODO: Method 'SetPosition'
    // TODO: Method 'SetShowWindow'
    // TODO: Method 'SetNoShowUI'
    // TODO: Method 'SetDirectory'
    // TODO: Method 'Execute'
};
// --------------------------------------------------------
// Type: IPersistFolder
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IPersistFolder = *opaque{
    // TODO: Method 'Initialize'
};
// --------------------------------------------------------
// Type: IRunnableTask
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IRunnableTask = *opaque{
    // TODO: Method 'Run'
    // TODO: Method 'Kill'
    // TODO: Method 'Suspend'
    // TODO: Method 'Resume'
    // TODO: Method 'IsRunning'
};
// --------------------------------------------------------
// Type: IShellTaskScheduler
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IShellTaskScheduler = *opaque{
    // TODO: Method 'AddTask'
    // TODO: Method 'RemoveTasks'
    // TODO: Method 'CountTasks'
    // TODO: Method 'Status'
};
// --------------------------------------------------------
// Type: IPersistFolder2
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IPersistFolder2 = *opaque{
    // TODO: Method 'GetCurFolder'
};
// --------------------------------------------------------
// Type: PERSIST_FOLDER_TARGET_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PERSIST_FOLDER_TARGET_INFO = extern struct {
    pidlTargetFolder: ?*ITEMIDLIST,
    szTargetParsingName: ?[*]u16,
    szNetworkProvider: ?[*]u16,
    dwAttributes: u32,
    csidl: i32,
};
// --------------------------------------------------------
// Type: IPersistFolder3
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IPersistFolder3 = *opaque{
    // TODO: Method 'InitializeEx'
    // TODO: Method 'GetFolderTargetInfo'
};
// --------------------------------------------------------
// Type: IPersistIDList
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IPersistIDList = *opaque{
    // TODO: Method 'SetIDList'
    // TODO: Method 'GetIDList'
};
// --------------------------------------------------------
// Type: IEnumIDList
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IEnumIDList = *opaque{
    // TODO: Method 'Next'
    // TODO: Method 'Skip'
    // TODO: Method 'Reset'
    // TODO: Method 'Clone'
};
// --------------------------------------------------------
// Type: IEnumFullIDList
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IEnumFullIDList = *opaque{
    // TODO: Method 'Next'
    // TODO: Method 'Skip'
    // TODO: Method 'Reset'
    // TODO: Method 'Clone'
};
// --------------------------------------------------------
// Type: _SHGDNF
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const _SHGDNF = *opaque{
};
// --------------------------------------------------------
// Type: _SHCONTF
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const _SHCONTF = *opaque{
};
// --------------------------------------------------------
// Type: STORAGE_PROVIDER_FILE_FLAGS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const STORAGE_PROVIDER_FILE_FLAGS = *opaque{
};
// --------------------------------------------------------
// Type: MERGE_UPDATE_STATUS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const MERGE_UPDATE_STATUS = *opaque{
};
// --------------------------------------------------------
// Type: IFileSyncMergeHandler
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IFileSyncMergeHandler = *opaque{
    // TODO: Method 'Merge'
    // TODO: Method 'ShowResolveConflictUIAsync'
};
// --------------------------------------------------------
// Type: FOLDER_ENUM_MODE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const FOLDER_ENUM_MODE = *opaque{
};
// --------------------------------------------------------
// Type: IObjectWithFolderEnumMode
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IObjectWithFolderEnumMode = *opaque{
    // TODO: Method 'SetMode'
    // TODO: Method 'GetMode'
};
// --------------------------------------------------------
// Type: IParseAndCreateItem
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IParseAndCreateItem = *opaque{
    // TODO: Method 'SetItem'
    // TODO: Method 'GetItem'
};
// --------------------------------------------------------
// Type: IShellFolder
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IShellFolder = *opaque{
    // TODO: Method 'ParseDisplayName'
    // TODO: Method 'EnumObjects'
    // TODO: Method 'BindToObject'
    // TODO: Method 'BindToStorage'
    // TODO: Method 'CompareIDs'
    // TODO: Method 'CreateViewObject'
    // TODO: Method 'GetAttributesOf'
    // TODO: Method 'GetUIObjectOf'
    // TODO: Method 'GetDisplayNameOf'
    // TODO: Method 'SetNameOf'
};
// --------------------------------------------------------
// Type: EXTRASEARCH
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const EXTRASEARCH = extern struct {
    guidSearch: Guid,
    wszFriendlyName: ?[*]u16,
    wszUrl: ?[*]u16,
};
// --------------------------------------------------------
// Type: IEnumExtraSearch
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IEnumExtraSearch = *opaque{
    // TODO: Method 'Next'
    // TODO: Method 'Skip'
    // TODO: Method 'Reset'
    // TODO: Method 'Clone'
};
// --------------------------------------------------------
// Type: IShellFolder2
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IShellFolder2 = *opaque{
    // TODO: Method 'GetDefaultSearchGUID'
    // TODO: Method 'EnumSearches'
    // TODO: Method 'GetDefaultColumn'
    // TODO: Method 'GetDefaultColumnState'
    // TODO: Method 'GetDetailsEx'
    // TODO: Method 'GetDetailsOf'
    // TODO: Method 'MapColumnToSCID'
};
// --------------------------------------------------------
// Type: FOLDERFLAGS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const FOLDERFLAGS = *opaque{
};
// --------------------------------------------------------
// Type: FOLDERVIEWMODE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const FOLDERVIEWMODE = *opaque{
};
// --------------------------------------------------------
// Type: FOLDERLOGICALVIEWMODE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const FOLDERLOGICALVIEWMODE = *opaque{
};
// --------------------------------------------------------
// Type: FOLDERSETTINGS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const FOLDERSETTINGS = extern struct {
    ViewMode: u32,
    fFlags: u32,
};
// --------------------------------------------------------
// Type: _SVSIF
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const _SVSIF = *opaque{
};
// --------------------------------------------------------
// Type: _SVGIO
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const _SVGIO = *opaque{
};
// --------------------------------------------------------
// Type: SVUIA_STATUS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const SVUIA_STATUS = *opaque{
};
// --------------------------------------------------------
// Type: LPFNSVADDPROPSHEETPAGE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const LPFNSVADDPROPSHEETPAGE = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: IShellView
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IShellView = *opaque{
    // TODO: Method 'TranslateAcceleratorA'
    // TODO: Method 'EnableModeless'
    // TODO: Method 'UIActivate'
    // TODO: Method 'Refresh'
    // TODO: Method 'CreateViewWindow'
    // TODO: Method 'DestroyViewWindow'
    // TODO: Method 'GetCurrentInfo'
    // TODO: Method 'AddPropertySheetPages'
    // TODO: Method 'SaveViewState'
    // TODO: Method 'SelectItem'
    // TODO: Method 'GetItemObject'
};
// --------------------------------------------------------
// Type: SV2CVW2_PARAMS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SV2CVW2_PARAMS = extern struct {
    cbSize: u32,
    psvPrev: IShellView,
    pfs: ?*FOLDERSETTINGS,
    psbOwner: IShellBrowser,
    prcView: ?*RECT,
    pvid: ?*Guid,
    hwndView: HWND,
};
// --------------------------------------------------------
// Type: IShellView2
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IShellView2 = *opaque{
    // TODO: Method 'GetView'
    // TODO: Method 'CreateViewWindow2'
    // TODO: Method 'HandleRename'
    // TODO: Method 'SelectAndPositionItem'
};
// --------------------------------------------------------
// Type: IFolderView
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IFolderView = *opaque{
    // TODO: Method 'GetCurrentViewMode'
    // TODO: Method 'SetCurrentViewMode'
    // TODO: Method 'GetFolder'
    // TODO: Method 'Item'
    // TODO: Method 'ItemCount'
    // TODO: Method 'Items'
    // TODO: Method 'GetSelectionMarkedItem'
    // TODO: Method 'GetFocusedItem'
    // TODO: Method 'GetItemPosition'
    // TODO: Method 'GetSpacing'
    // TODO: Method 'GetDefaultSpacing'
    // TODO: Method 'GetAutoArrange'
    // TODO: Method 'SelectItem'
    // TODO: Method 'SelectAndPositionItems'
};
// --------------------------------------------------------
// Type: tagSORTDIRECTION
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const tagSORTDIRECTION = *opaque{
};
// --------------------------------------------------------
// Type: SORTCOLUMN
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SORTCOLUMN = extern struct {
    propkey: PROPERTYKEY,
    direction: i32,
};
// --------------------------------------------------------
// Type: FVTEXTTYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const FVTEXTTYPE = *opaque{
};
// --------------------------------------------------------
// Type: IFolderView2
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IFolderView2 = *opaque{
    // TODO: Method 'SetGroupBy'
    // TODO: Method 'GetGroupBy'
    // TODO: Method 'SetViewProperty'
    // TODO: Method 'GetViewProperty'
    // TODO: Method 'SetTileViewProperties'
    // TODO: Method 'SetExtendedTileViewProperties'
    // TODO: Method 'SetText'
    // TODO: Method 'SetCurrentFolderFlags'
    // TODO: Method 'GetCurrentFolderFlags'
    // TODO: Method 'GetSortColumnCount'
    // TODO: Method 'SetSortColumns'
    // TODO: Method 'GetSortColumns'
    // TODO: Method 'GetItem'
    // TODO: Method 'GetVisibleItem'
    // TODO: Method 'GetSelectedItem'
    // TODO: Method 'GetSelection'
    // TODO: Method 'GetSelectionState'
    // TODO: Method 'InvokeVerbOnSelection'
    // TODO: Method 'SetViewModeAndIconSize'
    // TODO: Method 'GetViewModeAndIconSize'
    // TODO: Method 'SetGroupSubsetCount'
    // TODO: Method 'GetGroupSubsetCount'
    // TODO: Method 'SetRedraw'
    // TODO: Method 'IsMoveInSameFolder'
    // TODO: Method 'DoRename'
};
// --------------------------------------------------------
// Type: IFolderViewSettings
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IFolderViewSettings = *opaque{
    // TODO: Method 'GetColumnPropertyList'
    // TODO: Method 'GetGroupByProperty'
    // TODO: Method 'GetViewMode'
    // TODO: Method 'GetIconSize'
    // TODO: Method 'GetFolderFlags'
    // TODO: Method 'GetSortColumns'
    // TODO: Method 'GetGroupSubsetCount'
};
// --------------------------------------------------------
// Type: IInitializeNetworkFolder
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IInitializeNetworkFolder = *opaque{
    // TODO: Method 'Initialize'
};
// --------------------------------------------------------
// Type: INetworkFolderInternal
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const INetworkFolderInternal = *opaque{
    // TODO: Method 'GetResourceDisplayType'
    // TODO: Method 'GetIDList'
    // TODO: Method 'GetProvider'
};
// --------------------------------------------------------
// Type: IPreviewHandlerVisuals
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IPreviewHandlerVisuals = *opaque{
    // TODO: Method 'SetBackgroundColor'
    // TODO: Method 'SetFont'
    // TODO: Method 'SetTextColor'
};
// --------------------------------------------------------
// Type: ICommDlgBrowser
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ICommDlgBrowser = *opaque{
    // TODO: Method 'OnDefaultCommand'
    // TODO: Method 'OnStateChange'
    // TODO: Method 'IncludeObject'
};
// --------------------------------------------------------
// Type: ICommDlgBrowser2
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ICommDlgBrowser2 = *opaque{
    // TODO: Method 'Notify'
    // TODO: Method 'GetDefaultMenuText'
    // TODO: Method 'GetViewFlags'
};
// --------------------------------------------------------
// Type: CM_MASK
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const CM_MASK = *opaque{
};
// --------------------------------------------------------
// Type: CM_STATE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const CM_STATE = *opaque{
};
// --------------------------------------------------------
// Type: CM_ENUM_FLAGS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const CM_ENUM_FLAGS = *opaque{
};
// --------------------------------------------------------
// Type: CM_SET_WIDTH_VALUE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const CM_SET_WIDTH_VALUE = *opaque{
};
// --------------------------------------------------------
// Type: CM_COLUMNINFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CM_COLUMNINFO = extern struct {
    cbSize: u32,
    dwMask: u32,
    dwState: u32,
    uWidth: u32,
    uDefaultWidth: u32,
    uIdealWidth: u32,
    wszName: ?[*]u16,
};
// --------------------------------------------------------
// Type: IColumnManager
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IColumnManager = *opaque{
    // TODO: Method 'SetColumnInfo'
    // TODO: Method 'GetColumnInfo'
    // TODO: Method 'GetColumnCount'
    // TODO: Method 'GetColumns'
    // TODO: Method 'SetColumns'
};
// --------------------------------------------------------
// Type: IFolderFilterSite
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IFolderFilterSite = *opaque{
    // TODO: Method 'SetFilter'
};
// --------------------------------------------------------
// Type: IFolderFilter
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IFolderFilter = *opaque{
    // TODO: Method 'ShouldShow'
    // TODO: Method 'GetEnumFlags'
};
// --------------------------------------------------------
// Type: IInputObjectSite
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IInputObjectSite = *opaque{
    // TODO: Method 'OnFocusChangeIS'
};
// --------------------------------------------------------
// Type: IInputObject
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IInputObject = *opaque{
    // TODO: Method 'UIActivateIO'
    // TODO: Method 'HasFocusIO'
    // TODO: Method 'TranslateAcceleratorIO'
};
// --------------------------------------------------------
// Type: IInputObject2
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IInputObject2 = *opaque{
    // TODO: Method 'TranslateAcceleratorGlobal'
};
// --------------------------------------------------------
// Type: IShellIcon
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IShellIcon = *opaque{
    // TODO: Method 'GetIconOf'
};
// --------------------------------------------------------
// Type: IShellBrowser
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IShellBrowser = *opaque{
    // TODO: Method 'InsertMenusSB'
    // TODO: Method 'SetMenuSB'
    // TODO: Method 'RemoveMenusSB'
    // TODO: Method 'SetStatusTextSB'
    // TODO: Method 'EnableModelessSB'
    // TODO: Method 'TranslateAcceleratorSB'
    // TODO: Method 'BrowseObject'
    // TODO: Method 'GetViewStateStream'
    // TODO: Method 'GetControlWindow'
    // TODO: Method 'SendControlMsg'
    // TODO: Method 'QueryActiveShellView'
    // TODO: Method 'OnViewWindowActive'
    // TODO: Method 'SetToolbarItems'
};
// --------------------------------------------------------
// Type: IProfferService
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IProfferService = *opaque{
    // TODO: Method 'ProfferService'
    // TODO: Method 'RevokeService'
};
// --------------------------------------------------------
// Type: SIGDN
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const SIGDN = *opaque{
};
// --------------------------------------------------------
// Type: _SICHINTF
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const _SICHINTF = *opaque{
};
// --------------------------------------------------------
// Type: IShellItem
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IShellItem = *opaque{
    // TODO: Method 'BindToHandler'
    // TODO: Method 'GetParent'
    // TODO: Method 'GetDisplayName'
    // TODO: Method 'GetAttributes'
    // TODO: Method 'Compare'
};
// --------------------------------------------------------
// Type: DATAOBJ_GET_ITEM_FLAGS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const DATAOBJ_GET_ITEM_FLAGS = *opaque{
};
// --------------------------------------------------------
// Type: IShellItem2
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IShellItem2 = *opaque{
    // TODO: Method 'GetPropertyStore'
    // TODO: Method 'GetPropertyStoreWithCreateObject'
    // TODO: Method 'GetPropertyStoreForKeys'
    // TODO: Method 'GetPropertyDescriptionList'
    // TODO: Method 'Update'
    // TODO: Method 'GetProperty'
    // TODO: Method 'GetCLSID'
    // TODO: Method 'GetFileTime'
    // TODO: Method 'GetInt32'
    // TODO: Method 'GetString'
    // TODO: Method 'GetUInt32'
    // TODO: Method 'GetUInt64'
    // TODO: Method 'GetBool'
};
// --------------------------------------------------------
// Type: _SIIGBF
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const _SIIGBF = *opaque{
};
// --------------------------------------------------------
// Type: IShellItemImageFactory
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IShellItemImageFactory = *opaque{
    // TODO: Method 'GetImage'
};
// --------------------------------------------------------
// Type: IEnumShellItems
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IEnumShellItems = *opaque{
    // TODO: Method 'Next'
    // TODO: Method 'Skip'
    // TODO: Method 'Reset'
    // TODO: Method 'Clone'
};
// --------------------------------------------------------
// Type: STGOP
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const STGOP = *opaque{
};
// --------------------------------------------------------
// Type: _TRANSFER_SOURCE_FLAGS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const _TRANSFER_SOURCE_FLAGS = *opaque{
};
// --------------------------------------------------------
// Type: _TRANSFER_ADVISE_STATE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const _TRANSFER_ADVISE_STATE = *opaque{
};
// --------------------------------------------------------
// Type: ITransferAdviseSink
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ITransferAdviseSink = *opaque{
    // TODO: Method 'UpdateProgress'
    // TODO: Method 'UpdateTransferState'
    // TODO: Method 'ConfirmOverwrite'
    // TODO: Method 'ConfirmEncryptionLoss'
    // TODO: Method 'FileFailure'
    // TODO: Method 'SubStreamFailure'
    // TODO: Method 'PropertyFailure'
};
// --------------------------------------------------------
// Type: ITransferSource
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ITransferSource = *opaque{
    // TODO: Method 'Advise'
    // TODO: Method 'Unadvise'
    // TODO: Method 'SetProperties'
    // TODO: Method 'OpenItem'
    // TODO: Method 'MoveItem'
    // TODO: Method 'RecycleItem'
    // TODO: Method 'RemoveItem'
    // TODO: Method 'RenameItem'
    // TODO: Method 'LinkItem'
    // TODO: Method 'ApplyPropertiesToItem'
    // TODO: Method 'GetDefaultDestinationName'
    // TODO: Method 'EnterFolder'
    // TODO: Method 'LeaveFolder'
};
// --------------------------------------------------------
// Type: SHELL_ITEM_RESOURCE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SHELL_ITEM_RESOURCE = extern struct {
    guidType: Guid,
    szName: ?[*]u16,
};
// --------------------------------------------------------
// Type: IEnumResources
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IEnumResources = *opaque{
    // TODO: Method 'Next'
    // TODO: Method 'Skip'
    // TODO: Method 'Reset'
    // TODO: Method 'Clone'
};
// --------------------------------------------------------
// Type: IShellItemResources
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IShellItemResources = *opaque{
    // TODO: Method 'GetAttributes'
    // TODO: Method 'GetSize'
    // TODO: Method 'GetTimes'
    // TODO: Method 'SetTimes'
    // TODO: Method 'GetResourceDescription'
    // TODO: Method 'EnumResources'
    // TODO: Method 'SupportsResource'
    // TODO: Method 'OpenResource'
    // TODO: Method 'CreateResource'
    // TODO: Method 'MarkForDelete'
};
// --------------------------------------------------------
// Type: ITransferDestination
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ITransferDestination = *opaque{
    // TODO: Method 'Advise'
    // TODO: Method 'Unadvise'
    // TODO: Method 'CreateItem'
};
// --------------------------------------------------------
// Type: IFileOperationProgressSink
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IFileOperationProgressSink = *opaque{
    // TODO: Method 'StartOperations'
    // TODO: Method 'FinishOperations'
    // TODO: Method 'PreRenameItem'
    // TODO: Method 'PostRenameItem'
    // TODO: Method 'PreMoveItem'
    // TODO: Method 'PostMoveItem'
    // TODO: Method 'PreCopyItem'
    // TODO: Method 'PostCopyItem'
    // TODO: Method 'PreDeleteItem'
    // TODO: Method 'PostDeleteItem'
    // TODO: Method 'PreNewItem'
    // TODO: Method 'PostNewItem'
    // TODO: Method 'UpdateProgress'
    // TODO: Method 'ResetTimer'
    // TODO: Method 'PauseTimer'
    // TODO: Method 'ResumeTimer'
};
// --------------------------------------------------------
// Type: SIATTRIBFLAGS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const SIATTRIBFLAGS = *opaque{
};
// --------------------------------------------------------
// Type: IShellItemArray
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IShellItemArray = *opaque{
    // TODO: Method 'BindToHandler'
    // TODO: Method 'GetPropertyStore'
    // TODO: Method 'GetPropertyDescriptionList'
    // TODO: Method 'GetAttributes'
    // TODO: Method 'GetCount'
    // TODO: Method 'GetItemAt'
    // TODO: Method 'EnumItems'
};
// --------------------------------------------------------
// Type: IInitializeWithItem
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IInitializeWithItem = *opaque{
    // TODO: Method 'Initialize'
};
// --------------------------------------------------------
// Type: IObjectWithSelection
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IObjectWithSelection = *opaque{
    // TODO: Method 'SetSelection'
    // TODO: Method 'GetSelection'
};
// --------------------------------------------------------
// Type: IObjectWithBackReferences
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IObjectWithBackReferences = *opaque{
    // TODO: Method 'RemoveBackReferences'
};
// --------------------------------------------------------
// Type: _PROPERTYUI_NAME_FLAGS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const _PROPERTYUI_NAME_FLAGS = *opaque{
};
// --------------------------------------------------------
// Type: _PROPERTYUI_FORMAT_FLAGS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const _PROPERTYUI_FORMAT_FLAGS = *opaque{
};
// --------------------------------------------------------
// Type: ICategoryProvider
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ICategoryProvider = *opaque{
    // TODO: Method 'CanCategorizeOnSCID'
    // TODO: Method 'GetDefaultCategory'
    // TODO: Method 'GetCategoryForSCID'
    // TODO: Method 'EnumCategories'
    // TODO: Method 'GetCategoryName'
    // TODO: Method 'CreateCategory'
};
// --------------------------------------------------------
// Type: CATEGORYINFO_FLAGS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const CATEGORYINFO_FLAGS = *opaque{
};
// --------------------------------------------------------
// Type: CATSORT_FLAGS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const CATSORT_FLAGS = *opaque{
};
// --------------------------------------------------------
// Type: CATEGORY_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CATEGORY_INFO = extern struct {
    cif: CATEGORYINFO_FLAGS,
    wszName: ?[*]u16,
};
// --------------------------------------------------------
// Type: ICategorizer
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ICategorizer = *opaque{
    // TODO: Method 'GetDescription'
    // TODO: Method 'GetCategory'
    // TODO: Method 'GetCategoryInfo'
    // TODO: Method 'CompareCategory'
};
// --------------------------------------------------------
// Type: SHDRAGIMAGE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SHDRAGIMAGE = extern struct {
    sizeDragImage: SIZE,
    ptOffset: POINT,
    hbmpDragImage: HBITMAP,
    crColorKey: u32,
};
// --------------------------------------------------------
// Type: IDropTargetHelper
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IDropTargetHelper = *opaque{
    // TODO: Method 'DragEnter'
    // TODO: Method 'DragLeave'
    // TODO: Method 'DragOver'
    // TODO: Method 'Drop'
    // TODO: Method 'Show'
};
// --------------------------------------------------------
// Type: IDragSourceHelper
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IDragSourceHelper = *opaque{
    // TODO: Method 'InitializeFromBitmap'
    // TODO: Method 'InitializeFromWindow'
};
// --------------------------------------------------------
// Type: SLR_FLAGS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const SLR_FLAGS = *opaque{
};
// --------------------------------------------------------
// Type: SLGP_FLAGS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const SLGP_FLAGS = *opaque{
};
// --------------------------------------------------------
// Type: IShellLinkA
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IShellLinkA = *opaque{
    // TODO: Method 'GetPath'
    // TODO: Method 'GetIDList'
    // TODO: Method 'SetIDList'
    // TODO: Method 'GetDescription'
    // TODO: Method 'SetDescription'
    // TODO: Method 'GetWorkingDirectory'
    // TODO: Method 'SetWorkingDirectory'
    // TODO: Method 'GetArguments'
    // TODO: Method 'SetArguments'
    // TODO: Method 'GetHotkey'
    // TODO: Method 'SetHotkey'
    // TODO: Method 'GetShowCmd'
    // TODO: Method 'SetShowCmd'
    // TODO: Method 'GetIconLocation'
    // TODO: Method 'SetIconLocation'
    // TODO: Method 'SetRelativePath'
    // TODO: Method 'Resolve'
    // TODO: Method 'SetPath'
};
// --------------------------------------------------------
// Type: IShellLinkW
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IShellLinkW = *opaque{
    // TODO: Method 'GetPath'
    // TODO: Method 'GetIDList'
    // TODO: Method 'SetIDList'
    // TODO: Method 'GetDescription'
    // TODO: Method 'SetDescription'
    // TODO: Method 'GetWorkingDirectory'
    // TODO: Method 'SetWorkingDirectory'
    // TODO: Method 'GetArguments'
    // TODO: Method 'SetArguments'
    // TODO: Method 'GetHotkey'
    // TODO: Method 'SetHotkey'
    // TODO: Method 'GetShowCmd'
    // TODO: Method 'SetShowCmd'
    // TODO: Method 'GetIconLocation'
    // TODO: Method 'SetIconLocation'
    // TODO: Method 'SetRelativePath'
    // TODO: Method 'Resolve'
    // TODO: Method 'SetPath'
};
// --------------------------------------------------------
// Type: IShellLinkDataList
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IShellLinkDataList = *opaque{
    // TODO: Method 'AddDataBlock'
    // TODO: Method 'CopyDataBlock'
    // TODO: Method 'RemoveDataBlock'
    // TODO: Method 'GetFlags'
    // TODO: Method 'SetFlags'
};
// --------------------------------------------------------
// Type: IResolveShellLink
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IResolveShellLink = *opaque{
    // TODO: Method 'ResolveShellLink'
};
// --------------------------------------------------------
// Type: _SPINITF
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const _SPINITF = *opaque{
};
// --------------------------------------------------------
// Type: IActionProgressDialog
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IActionProgressDialog = *opaque{
    // TODO: Method 'Initialize'
    // TODO: Method 'Stop'
};
// --------------------------------------------------------
// Type: _SPBEGINF
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const _SPBEGINF = *opaque{
};
// --------------------------------------------------------
// Type: SPACTION
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const SPACTION = *opaque{
};
// --------------------------------------------------------
// Type: SPTEXT
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const SPTEXT = *opaque{
};
// --------------------------------------------------------
// Type: IActionProgress
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IActionProgress = *opaque{
    // TODO: Method 'Begin'
    // TODO: Method 'UpdateProgress'
    // TODO: Method 'UpdateText'
    // TODO: Method 'QueryCancel'
    // TODO: Method 'ResetCancel'
    // TODO: Method 'End'
};
// --------------------------------------------------------
// Type: IShellExtInit
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IShellExtInit = *opaque{
    // TODO: Method 'Initialize'
};
// --------------------------------------------------------
// Type: _EXPPS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const _EXPPS = *opaque{
};
// --------------------------------------------------------
// Type: IShellPropSheetExt
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IShellPropSheetExt = *opaque{
    // TODO: Method 'AddPages'
    // TODO: Method 'ReplacePage'
};
// --------------------------------------------------------
// Type: IRemoteComputer
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IRemoteComputer = *opaque{
    // TODO: Method 'Initialize'
};
// --------------------------------------------------------
// Type: IQueryContinue
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IQueryContinue = *opaque{
    // TODO: Method 'QueryContinue'
};
// --------------------------------------------------------
// Type: IObjectWithCancelEvent
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IObjectWithCancelEvent = *opaque{
    // TODO: Method 'GetCancelEvent'
};
// --------------------------------------------------------
// Type: IUserNotification
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IUserNotification = *opaque{
    // TODO: Method 'SetBalloonInfo'
    // TODO: Method 'SetBalloonRetry'
    // TODO: Method 'SetIconInfo'
    // TODO: Method 'Show'
    // TODO: Method 'PlaySoundA'
};
// --------------------------------------------------------
// Type: IItemNameLimits
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IItemNameLimits = *opaque{
    // TODO: Method 'GetValidCharacters'
    // TODO: Method 'GetMaxLength'
};
// --------------------------------------------------------
// Type: ISearchFolderItemFactory
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ISearchFolderItemFactory = *opaque{
    // TODO: Method 'SetDisplayName'
    // TODO: Method 'SetFolderTypeID'
    // TODO: Method 'SetFolderLogicalViewMode'
    // TODO: Method 'SetIconSize'
    // TODO: Method 'SetVisibleColumns'
    // TODO: Method 'SetSortColumns'
    // TODO: Method 'SetGroupColumn'
    // TODO: Method 'SetStacks'
    // TODO: Method 'SetScope'
    // TODO: Method 'SetCondition'
    // TODO: Method 'GetShellItem'
    // TODO: Method 'GetIDList'
};
// --------------------------------------------------------
// Type: IExtractImage
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IExtractImage = *opaque{
    // TODO: Method 'GetLocation'
    // TODO: Method 'Extract'
};
// --------------------------------------------------------
// Type: IExtractImage2
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IExtractImage2 = *opaque{
    // TODO: Method 'GetDateStamp'
};
// --------------------------------------------------------
// Type: IThumbnailHandlerFactory
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IThumbnailHandlerFactory = *opaque{
    // TODO: Method 'GetThumbnailHandler'
};
// --------------------------------------------------------
// Type: IParentAndItem
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IParentAndItem = *opaque{
    // TODO: Method 'SetParentAndItem'
    // TODO: Method 'GetParentAndItem'
};
// --------------------------------------------------------
// Type: IDockingWindow
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IDockingWindow = *opaque{
    // TODO: Method 'ShowDW'
    // TODO: Method 'CloseDW'
    // TODO: Method 'ResizeBorderDW'
};
// --------------------------------------------------------
// Type: DESKBANDINFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DESKBANDINFO = extern struct {
    dwMask: u32,
    ptMinSize: POINTL,
    ptMaxSize: POINTL,
    ptIntegral: POINTL,
    ptActual: POINTL,
    wszTitle: ?[*]u16,
    dwModeFlags: u32,
    crBkgnd: u32,
};
// --------------------------------------------------------
// Type: tagDESKBANDCID
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const tagDESKBANDCID = *opaque{
};
// --------------------------------------------------------
// Type: IDeskBand
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IDeskBand = *opaque{
    // TODO: Method 'GetBandInfo'
};
// --------------------------------------------------------
// Type: IDeskBandInfo
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IDeskBandInfo = *opaque{
    // TODO: Method 'GetDefaultBandWidth'
};
// --------------------------------------------------------
// Type: ITaskbarList
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ITaskbarList = *opaque{
    // TODO: Method 'HrInit'
    // TODO: Method 'AddTab'
    // TODO: Method 'DeleteTab'
    // TODO: Method 'ActivateTab'
    // TODO: Method 'SetActiveAlt'
};
// --------------------------------------------------------
// Type: ITaskbarList2
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ITaskbarList2 = *opaque{
    // TODO: Method 'MarkFullscreenWindow'
};
// --------------------------------------------------------
// Type: THUMBBUTTONFLAGS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const THUMBBUTTONFLAGS = *opaque{
};
// --------------------------------------------------------
// Type: THUMBBUTTONMASK
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const THUMBBUTTONMASK = *opaque{
};
// --------------------------------------------------------
// Type: THUMBBUTTON
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const THUMBBUTTON = extern struct {
    dwMask: THUMBBUTTONMASK,
    iId: u32,
    iBitmap: u32,
    hIcon: HICON,
    szTip: ?[*]u16,
    dwFlags: THUMBBUTTONFLAGS,
};
// --------------------------------------------------------
// Type: TBPFLAG
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const TBPFLAG = *opaque{
};
// --------------------------------------------------------
// Type: ITaskbarList3
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ITaskbarList3 = *opaque{
    // TODO: Method 'SetProgressValue'
    // TODO: Method 'SetProgressState'
    // TODO: Method 'RegisterTab'
    // TODO: Method 'UnregisterTab'
    // TODO: Method 'SetTabOrder'
    // TODO: Method 'SetTabActive'
    // TODO: Method 'ThumbBarAddButtons'
    // TODO: Method 'ThumbBarUpdateButtons'
    // TODO: Method 'ThumbBarSetImageList'
    // TODO: Method 'SetOverlayIcon'
    // TODO: Method 'SetThumbnailTooltip'
    // TODO: Method 'SetThumbnailClip'
};
// --------------------------------------------------------
// Type: STPFLAG
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const STPFLAG = *opaque{
};
// --------------------------------------------------------
// Type: ITaskbarList4
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ITaskbarList4 = *opaque{
    // TODO: Method 'SetTabProperties'
};
// --------------------------------------------------------
// Type: IExplorerBrowserEvents
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IExplorerBrowserEvents = *opaque{
    // TODO: Method 'OnNavigationPending'
    // TODO: Method 'OnViewCreated'
    // TODO: Method 'OnNavigationComplete'
    // TODO: Method 'OnNavigationFailed'
};
// --------------------------------------------------------
// Type: EXPLORER_BROWSER_OPTIONS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const EXPLORER_BROWSER_OPTIONS = *opaque{
};
// --------------------------------------------------------
// Type: EXPLORER_BROWSER_FILL_FLAGS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const EXPLORER_BROWSER_FILL_FLAGS = *opaque{
};
// --------------------------------------------------------
// Type: IExplorerBrowser
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IExplorerBrowser = *opaque{
    // TODO: Method 'Initialize'
    // TODO: Method 'Destroy'
    // TODO: Method 'SetRect'
    // TODO: Method 'SetPropertyBag'
    // TODO: Method 'SetEmptyText'
    // TODO: Method 'SetFolderSettings'
    // TODO: Method 'Advise'
    // TODO: Method 'Unadvise'
    // TODO: Method 'SetOptions'
    // TODO: Method 'GetOptions'
    // TODO: Method 'BrowseToIDList'
    // TODO: Method 'BrowseToObject'
    // TODO: Method 'FillFromObject'
    // TODO: Method 'RemoveAll'
    // TODO: Method 'GetCurrentView'
};
// --------------------------------------------------------
// Type: IEnumObjects
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IEnumObjects = *opaque{
    // TODO: Method 'Next'
    // TODO: Method 'Skip'
    // TODO: Method 'Reset'
    // TODO: Method 'Clone'
};
// --------------------------------------------------------
// Type: _OPPROGDLGF
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const _OPPROGDLGF = *opaque{
};
// --------------------------------------------------------
// Type: _PDMODE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const _PDMODE = *opaque{
};
// --------------------------------------------------------
// Type: IOperationsProgressDialog
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IOperationsProgressDialog = *opaque{
    // TODO: Method 'StartProgressDialog'
    // TODO: Method 'StopProgressDialog'
    // TODO: Method 'SetOperation'
    // TODO: Method 'SetMode'
    // TODO: Method 'UpdateProgress'
    // TODO: Method 'UpdateLocations'
    // TODO: Method 'ResetTimer'
    // TODO: Method 'PauseTimer'
    // TODO: Method 'ResumeTimer'
    // TODO: Method 'GetMilliseconds'
    // TODO: Method 'GetOperationStatus'
};
// --------------------------------------------------------
// Type: IIOCancelInformation
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IIOCancelInformation = *opaque{
    // TODO: Method 'SetCancelInformation'
    // TODO: Method 'GetCancelInformation'
};
// --------------------------------------------------------
// Type: IFileOperation
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IFileOperation = *opaque{
    // TODO: Method 'Advise'
    // TODO: Method 'Unadvise'
    // TODO: Method 'SetOperationFlags'
    // TODO: Method 'SetProgressMessage'
    // TODO: Method 'SetProgressDialog'
    // TODO: Method 'SetProperties'
    // TODO: Method 'SetOwnerWindow'
    // TODO: Method 'ApplyPropertiesToItem'
    // TODO: Method 'ApplyPropertiesToItems'
    // TODO: Method 'RenameItem'
    // TODO: Method 'RenameItems'
    // TODO: Method 'MoveItem'
    // TODO: Method 'MoveItems'
    // TODO: Method 'CopyItem'
    // TODO: Method 'CopyItems'
    // TODO: Method 'DeleteItem'
    // TODO: Method 'DeleteItems'
    // TODO: Method 'NewItem'
    // TODO: Method 'PerformOperations'
    // TODO: Method 'GetAnyOperationsAborted'
};
// --------------------------------------------------------
// Type: FILE_OPERATION_FLAGS2
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const FILE_OPERATION_FLAGS2 = *opaque{
};
// --------------------------------------------------------
// Type: IFileOperation2
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IFileOperation2 = *opaque{
    // TODO: Method 'SetOperationFlags2'
};
// --------------------------------------------------------
// Type: IObjectProvider
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IObjectProvider = *opaque{
    // TODO: Method 'QueryObject'
};
// --------------------------------------------------------
// Type: INamespaceWalkCB
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const INamespaceWalkCB = *opaque{
    // TODO: Method 'FoundItem'
    // TODO: Method 'EnterFolder'
    // TODO: Method 'LeaveFolder'
    // TODO: Method 'InitializeProgressDialog'
};
// --------------------------------------------------------
// Type: INamespaceWalkCB2
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const INamespaceWalkCB2 = *opaque{
    // TODO: Method 'WalkComplete'
};
// --------------------------------------------------------
// Type: NAMESPACEWALKFLAG
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const NAMESPACEWALKFLAG = *opaque{
};
// --------------------------------------------------------
// Type: INamespaceWalk
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const INamespaceWalk = *opaque{
    // TODO: Method 'Walk'
    // TODO: Method 'GetIDArrayResult'
};
// --------------------------------------------------------
// Type: BANDSITEINFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const BANDSITEINFO = extern struct {
    dwMask: u32,
    dwState: u32,
    dwStyle: u32,
};
// --------------------------------------------------------
// Type: tagBANDSITECID
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const tagBANDSITECID = *opaque{
};
// --------------------------------------------------------
// Type: IBandSite
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IBandSite = *opaque{
    // TODO: Method 'AddBand'
    // TODO: Method 'EnumBands'
    // TODO: Method 'QueryBand'
    // TODO: Method 'SetBandState'
    // TODO: Method 'RemoveBand'
    // TODO: Method 'GetBandObject'
    // TODO: Method 'SetBandSiteInfo'
    // TODO: Method 'GetBandSiteInfo'
};
// --------------------------------------------------------
// Type: IModalWindow
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IModalWindow = *opaque{
    // TODO: Method 'Show'
};
// --------------------------------------------------------
// Type: IContextMenuSite
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IContextMenuSite = *opaque{
    // TODO: Method 'DoContextMenuPopup'
};
// --------------------------------------------------------
// Type: tagMENUBANDHANDLERCID
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const tagMENUBANDHANDLERCID = *opaque{
};
// --------------------------------------------------------
// Type: IMenuBand
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IMenuBand = *opaque{
    // TODO: Method 'IsMenuMessage'
    // TODO: Method 'TranslateMenuMessage'
};
// --------------------------------------------------------
// Type: IRegTreeItem
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IRegTreeItem = *opaque{
    // TODO: Method 'GetCheckState'
    // TODO: Method 'SetCheckState'
};
// --------------------------------------------------------
// Type: IDeskBar
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IDeskBar = *opaque{
    // TODO: Method 'SetClient'
    // TODO: Method 'GetClient'
    // TODO: Method 'OnPosRectChangeDB'
};
// --------------------------------------------------------
// Type: tagMENUPOPUPSELECT
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const tagMENUPOPUPSELECT = *opaque{
};
// --------------------------------------------------------
// Type: tagMENUPOPUPPOPUPFLAGS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const tagMENUPOPUPPOPUPFLAGS = *opaque{
};
// --------------------------------------------------------
// Type: IMenuPopup
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IMenuPopup = *opaque{
    // TODO: Method 'Popup'
    // TODO: Method 'OnSelect'
    // TODO: Method 'SetSubMenu'
};
// --------------------------------------------------------
// Type: FILE_USAGE_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const FILE_USAGE_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: IFileIsInUse
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IFileIsInUse = *opaque{
    // TODO: Method 'GetAppName'
    // TODO: Method 'GetUsage'
    // TODO: Method 'GetCapabilities'
    // TODO: Method 'GetSwitchToHWND'
    // TODO: Method 'CloseFile'
};
// --------------------------------------------------------
// Type: FDE_OVERWRITE_RESPONSE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const FDE_OVERWRITE_RESPONSE = *opaque{
};
// --------------------------------------------------------
// Type: FDE_SHAREVIOLATION_RESPONSE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const FDE_SHAREVIOLATION_RESPONSE = *opaque{
};
// --------------------------------------------------------
// Type: FDAP
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const FDAP = *opaque{
};
// --------------------------------------------------------
// Type: IFileDialogEvents
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IFileDialogEvents = *opaque{
    // TODO: Method 'OnFileOk'
    // TODO: Method 'OnFolderChanging'
    // TODO: Method 'OnFolderChange'
    // TODO: Method 'OnSelectionChange'
    // TODO: Method 'OnShareViolation'
    // TODO: Method 'OnTypeChange'
    // TODO: Method 'OnOverwrite'
};
// --------------------------------------------------------
// Type: _FILEOPENDIALOGOPTIONS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const _FILEOPENDIALOGOPTIONS = *opaque{
};
// --------------------------------------------------------
// Type: IFileDialog
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IFileDialog = *opaque{
    // TODO: Method 'SetFileTypes'
    // TODO: Method 'SetFileTypeIndex'
    // TODO: Method 'GetFileTypeIndex'
    // TODO: Method 'Advise'
    // TODO: Method 'Unadvise'
    // TODO: Method 'SetOptions'
    // TODO: Method 'GetOptions'
    // TODO: Method 'SetDefaultFolder'
    // TODO: Method 'SetFolder'
    // TODO: Method 'GetFolder'
    // TODO: Method 'GetCurrentSelection'
    // TODO: Method 'SetFileName'
    // TODO: Method 'GetFileName'
    // TODO: Method 'SetTitle'
    // TODO: Method 'SetOkButtonLabel'
    // TODO: Method 'SetFileNameLabel'
    // TODO: Method 'GetResult'
    // TODO: Method 'AddPlace'
    // TODO: Method 'SetDefaultExtension'
    // TODO: Method 'Close'
    // TODO: Method 'SetClientGuid'
    // TODO: Method 'ClearClientData'
    // TODO: Method 'SetFilter'
};
// --------------------------------------------------------
// Type: IFileSaveDialog
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IFileSaveDialog = *opaque{
    // TODO: Method 'SetSaveAsItem'
    // TODO: Method 'SetProperties'
    // TODO: Method 'SetCollectedProperties'
    // TODO: Method 'GetProperties'
    // TODO: Method 'ApplyProperties'
};
// --------------------------------------------------------
// Type: IFileOpenDialog
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IFileOpenDialog = *opaque{
    // TODO: Method 'GetResults'
    // TODO: Method 'GetSelectedItems'
};
// --------------------------------------------------------
// Type: CDCONTROLSTATEF
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const CDCONTROLSTATEF = *opaque{
};
// --------------------------------------------------------
// Type: IFileDialogCustomize
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IFileDialogCustomize = *opaque{
    // TODO: Method 'EnableOpenDropDown'
    // TODO: Method 'AddMenu'
    // TODO: Method 'AddPushButton'
    // TODO: Method 'AddComboBox'
    // TODO: Method 'AddRadioButtonList'
    // TODO: Method 'AddCheckButton'
    // TODO: Method 'AddEditBox'
    // TODO: Method 'AddSeparator'
    // TODO: Method 'AddText'
    // TODO: Method 'SetControlLabel'
    // TODO: Method 'GetControlState'
    // TODO: Method 'SetControlState'
    // TODO: Method 'GetEditBoxText'
    // TODO: Method 'SetEditBoxText'
    // TODO: Method 'GetCheckButtonState'
    // TODO: Method 'SetCheckButtonState'
    // TODO: Method 'AddControlItem'
    // TODO: Method 'RemoveControlItem'
    // TODO: Method 'RemoveAllControlItems'
    // TODO: Method 'GetControlItemState'
    // TODO: Method 'SetControlItemState'
    // TODO: Method 'GetSelectedControlItem'
    // TODO: Method 'SetSelectedControlItem'
    // TODO: Method 'StartVisualGroup'
    // TODO: Method 'EndVisualGroup'
    // TODO: Method 'MakeProminent'
    // TODO: Method 'SetControlItemText'
};
// --------------------------------------------------------
// Type: ASSOCIATIONLEVEL
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const ASSOCIATIONLEVEL = *opaque{
};
// --------------------------------------------------------
// Type: ASSOCIATIONTYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const ASSOCIATIONTYPE = *opaque{
};
// --------------------------------------------------------
// Type: IApplicationAssociationRegistration
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IApplicationAssociationRegistration = *opaque{
    // TODO: Method 'QueryCurrentDefault'
    // TODO: Method 'QueryAppIsDefault'
    // TODO: Method 'QueryAppIsDefaultAll'
    // TODO: Method 'SetAppAsDefault'
    // TODO: Method 'SetAppAsDefaultAll'
    // TODO: Method 'ClearUserAssociations'
};
// --------------------------------------------------------
// Type: DELEGATEITEMID
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const DELEGATEITEMID = *opaque{
};
// --------------------------------------------------------
// Type: IDelegateFolder
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IDelegateFolder = *opaque{
    // TODO: Method 'SetItemAlloc'
};
// --------------------------------------------------------
// Type: _BROWSERFRAMEOPTIONS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const _BROWSERFRAMEOPTIONS = *opaque{
};
// --------------------------------------------------------
// Type: IBrowserFrameOptions
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IBrowserFrameOptions = *opaque{
    // TODO: Method 'GetFrameOptions'
};
// --------------------------------------------------------
// Type: NWMF
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const NWMF = *opaque{
};
// --------------------------------------------------------
// Type: INewWindowManager
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const INewWindowManager = *opaque{
    // TODO: Method 'EvaluateNewWindow'
};
// --------------------------------------------------------
// Type: ATTACHMENT_PROMPT
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const ATTACHMENT_PROMPT = *opaque{
};
// --------------------------------------------------------
// Type: ATTACHMENT_ACTION
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const ATTACHMENT_ACTION = *opaque{
};
// --------------------------------------------------------
// Type: IAttachmentExecute
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IAttachmentExecute = *opaque{
    // TODO: Method 'SetClientTitle'
    // TODO: Method 'SetClientGuid'
    // TODO: Method 'SetLocalPath'
    // TODO: Method 'SetFileName'
    // TODO: Method 'SetSource'
    // TODO: Method 'SetReferrer'
    // TODO: Method 'CheckPolicy'
    // TODO: Method 'Prompt'
    // TODO: Method 'Save'
    // TODO: Method 'Execute'
    // TODO: Method 'SaveWithUI'
    // TODO: Method 'ClearClientState'
};
// --------------------------------------------------------
// Type: SMDATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SMDATA = extern struct {
    dwMask: u32,
    dwFlags: u32,
    hmenu: HMENU,
    hwnd: HWND,
    uId: u32,
    uIdParent: u32,
    uIdAncestor: u32,
    punk: IUnknown,
    pidlFolder: ?*ITEMIDLIST,
    pidlItem: ?*ITEMIDLIST,
    psf: IShellFolder,
    pvUserData: ?*opaque{},
};
// --------------------------------------------------------
// Type: SMINFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SMINFO = extern struct {
    dwMask: u32,
    dwType: u32,
    dwFlags: u32,
    iIcon: i32,
};
// --------------------------------------------------------
// Type: SMCSHCHANGENOTIFYSTRUCT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SMCSHCHANGENOTIFYSTRUCT = extern struct {
    lEvent: i32,
    pidl1: ?*ITEMIDLIST,
    pidl2: ?*ITEMIDLIST,
};
// --------------------------------------------------------
// Type: tagSMINFOMASK
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const tagSMINFOMASK = *opaque{
};
// --------------------------------------------------------
// Type: tagSMINFOTYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const tagSMINFOTYPE = *opaque{
};
// --------------------------------------------------------
// Type: tagSMINFOFLAGS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const tagSMINFOFLAGS = *opaque{
};
// --------------------------------------------------------
// Type: IShellMenuCallback
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IShellMenuCallback = *opaque{
    // TODO: Method 'CallbackSM'
};
// --------------------------------------------------------
// Type: IShellMenu
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IShellMenu = *opaque{
    // TODO: Method 'Initialize'
    // TODO: Method 'GetMenuInfo'
    // TODO: Method 'SetShellFolder'
    // TODO: Method 'GetShellFolder'
    // TODO: Method 'SetMenu'
    // TODO: Method 'GetMenu'
    // TODO: Method 'InvalidateItem'
    // TODO: Method 'GetState'
    // TODO: Method 'SetMenuToolbar'
};
// --------------------------------------------------------
// Type: KF_CATEGORY
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const KF_CATEGORY = *opaque{
};
// --------------------------------------------------------
// Type: _KF_DEFINITION_FLAGS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const _KF_DEFINITION_FLAGS = *opaque{
};
// --------------------------------------------------------
// Type: _KF_REDIRECT_FLAGS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const _KF_REDIRECT_FLAGS = *opaque{
};
// --------------------------------------------------------
// Type: _KF_REDIRECTION_CAPABILITIES
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const _KF_REDIRECTION_CAPABILITIES = *opaque{
};
// --------------------------------------------------------
// Type: KNOWNFOLDER_DEFINITION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const KNOWNFOLDER_DEFINITION = extern struct {
    category: KF_CATEGORY,
    pszName: ?*u16,
    pszDescription: ?*u16,
    fidParent: Guid,
    pszRelativePath: ?*u16,
    pszParsingName: ?*u16,
    pszTooltip: ?*u16,
    pszLocalizedName: ?*u16,
    pszIcon: ?*u16,
    pszSecurity: ?*u16,
    dwAttributes: u32,
    kfdFlags: u32,
    ftidType: Guid,
};
// --------------------------------------------------------
// Type: IKnownFolder
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IKnownFolder = *opaque{
    // TODO: Method 'GetId'
    // TODO: Method 'GetCategory'
    // TODO: Method 'GetShellItem'
    // TODO: Method 'GetPath'
    // TODO: Method 'SetPath'
    // TODO: Method 'GetIDList'
    // TODO: Method 'GetFolderType'
    // TODO: Method 'GetRedirectionCapabilities'
    // TODO: Method 'GetFolderDefinition'
};
// --------------------------------------------------------
// Type: FFFP_MODE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const FFFP_MODE = *opaque{
};
// --------------------------------------------------------
// Type: IKnownFolderManager
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IKnownFolderManager = *opaque{
    // TODO: Method 'FolderIdFromCsidl'
    // TODO: Method 'FolderIdToCsidl'
    // TODO: Method 'GetFolderIds'
    // TODO: Method 'GetFolder'
    // TODO: Method 'GetFolderByName'
    // TODO: Method 'RegisterFolder'
    // TODO: Method 'UnregisterFolder'
    // TODO: Method 'FindFolderFromPath'
    // TODO: Method 'FindFolderFromIDList'
    // TODO: Method 'Redirect'
};
// --------------------------------------------------------
// Type: SHARE_ROLE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const SHARE_ROLE = *opaque{
};
// --------------------------------------------------------
// Type: DEF_SHARE_ID
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const DEF_SHARE_ID = *opaque{
};
// --------------------------------------------------------
// Type: ISharingConfigurationManager
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ISharingConfigurationManager = *opaque{
    // TODO: Method 'CreateShare'
    // TODO: Method 'DeleteShare'
    // TODO: Method 'ShareExists'
    // TODO: Method 'GetSharePermissions'
    // TODO: Method 'SharePrinters'
    // TODO: Method 'StopSharingPrinters'
    // TODO: Method 'ArePrintersShared'
};
// --------------------------------------------------------
// Type: IRelatedItem
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IRelatedItem = *opaque{
    // TODO: Method 'GetItemIDList'
    // TODO: Method 'GetItem'
};
// --------------------------------------------------------
// Type: IIdentityName
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IIdentityName = *opaque{
};
// --------------------------------------------------------
// Type: IDelegateItem
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IDelegateItem = *opaque{
};
// --------------------------------------------------------
// Type: ICurrentItem
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ICurrentItem = *opaque{
};
// --------------------------------------------------------
// Type: ITransferMediumItem
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ITransferMediumItem = *opaque{
};
// --------------------------------------------------------
// Type: IDisplayItem
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IDisplayItem = *opaque{
};
// --------------------------------------------------------
// Type: IViewStateIdentityItem
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IViewStateIdentityItem = *opaque{
};
// --------------------------------------------------------
// Type: IPreviewItem
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IPreviewItem = *opaque{
};
// --------------------------------------------------------
// Type: IDestinationStreamFactory
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IDestinationStreamFactory = *opaque{
    // TODO: Method 'GetDestinationStream'
};
// --------------------------------------------------------
// Type: ICreateProcessInputs
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ICreateProcessInputs = *opaque{
    // TODO: Method 'GetCreateFlags'
    // TODO: Method 'SetCreateFlags'
    // TODO: Method 'AddCreateFlags'
    // TODO: Method 'SetHotKey'
    // TODO: Method 'AddStartupFlags'
    // TODO: Method 'SetTitle'
    // TODO: Method 'SetEnvironmentVariableA'
};
// --------------------------------------------------------
// Type: ICreatingProcess
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ICreatingProcess = *opaque{
    // TODO: Method 'OnCreating'
};
// --------------------------------------------------------
// Type: ILaunchUIContext
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ILaunchUIContext = *opaque{
    // TODO: Method 'SetAssociatedWindow'
    // TODO: Method 'SetTabGroupingPreference'
};
// --------------------------------------------------------
// Type: ILaunchUIContextProvider
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ILaunchUIContextProvider = *opaque{
    // TODO: Method 'UpdateContext'
};
// --------------------------------------------------------
// Type: _NMCII_FLAGS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const _NMCII_FLAGS = *opaque{
};
// --------------------------------------------------------
// Type: _NMCSAEI_FLAGS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const _NMCSAEI_FLAGS = *opaque{
};
// --------------------------------------------------------
// Type: INewMenuClient
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const INewMenuClient = *opaque{
    // TODO: Method 'IncludeItems'
    // TODO: Method 'SelectAndEditItem'
};
// --------------------------------------------------------
// Type: IInitializeWithBindCtx
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IInitializeWithBindCtx = *opaque{
    // TODO: Method 'Initialize'
};
// --------------------------------------------------------
// Type: IShellItemFilter
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IShellItemFilter = *opaque{
    // TODO: Method 'IncludeItem'
    // TODO: Method 'GetEnumFlagsForItem'
};
// --------------------------------------------------------
// Type: _NSTCSTYLE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const _NSTCSTYLE = *opaque{
};
// --------------------------------------------------------
// Type: _NSTCROOTSTYLE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const _NSTCROOTSTYLE = *opaque{
};
// --------------------------------------------------------
// Type: _NSTCITEMSTATE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const _NSTCITEMSTATE = *opaque{
};
// --------------------------------------------------------
// Type: NSTCGNI
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const NSTCGNI = *opaque{
};
// --------------------------------------------------------
// Type: INameSpaceTreeControl
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const INameSpaceTreeControl = *opaque{
    // TODO: Method 'Initialize'
    // TODO: Method 'TreeAdvise'
    // TODO: Method 'TreeUnadvise'
    // TODO: Method 'AppendRoot'
    // TODO: Method 'InsertRoot'
    // TODO: Method 'RemoveRoot'
    // TODO: Method 'RemoveAllRoots'
    // TODO: Method 'GetRootItems'
    // TODO: Method 'SetItemState'
    // TODO: Method 'GetItemState'
    // TODO: Method 'GetSelectedItems'
    // TODO: Method 'GetItemCustomState'
    // TODO: Method 'SetItemCustomState'
    // TODO: Method 'EnsureItemVisible'
    // TODO: Method 'SetTheme'
    // TODO: Method 'GetNextItem'
    // TODO: Method 'HitTest'
    // TODO: Method 'GetItemRect'
    // TODO: Method 'CollapseAll'
};
// --------------------------------------------------------
// Type: NSTCFOLDERCAPABILITIES
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const NSTCFOLDERCAPABILITIES = *opaque{
};
// --------------------------------------------------------
// Type: INameSpaceTreeControlFolderCapabilities
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const INameSpaceTreeControlFolderCapabilities = *opaque{
    // TODO: Method 'GetFolderCapabilities'
};
// --------------------------------------------------------
// Type: IPreviewHandler
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IPreviewHandler = *opaque{
    // TODO: Method 'SetWindow'
    // TODO: Method 'SetRect'
    // TODO: Method 'DoPreview'
    // TODO: Method 'Unload'
    // TODO: Method 'SetFocus'
    // TODO: Method 'QueryFocus'
    // TODO: Method 'TranslateAcceleratorA'
};
// --------------------------------------------------------
// Type: PREVIEWHANDLERFRAMEINFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PREVIEWHANDLERFRAMEINFO = extern struct {
    haccel: HACCEL,
    cAccelEntries: u32,
};
// --------------------------------------------------------
// Type: IPreviewHandlerFrame
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IPreviewHandlerFrame = *opaque{
    // TODO: Method 'GetWindowContext'
    // TODO: Method 'TranslateAcceleratorA'
};
// --------------------------------------------------------
// Type: _EXPLORERPANESTATE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const _EXPLORERPANESTATE = *opaque{
};
// --------------------------------------------------------
// Type: IExplorerPaneVisibility
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IExplorerPaneVisibility = *opaque{
    // TODO: Method 'GetPaneState'
};
// --------------------------------------------------------
// Type: IContextMenuCB
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IContextMenuCB = *opaque{
    // TODO: Method 'CallBack'
};
// --------------------------------------------------------
// Type: IDefaultExtractIconInit
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IDefaultExtractIconInit = *opaque{
    // TODO: Method 'SetFlags'
    // TODO: Method 'SetKey'
    // TODO: Method 'SetNormalIcon'
    // TODO: Method 'SetOpenIcon'
    // TODO: Method 'SetShortcutIcon'
    // TODO: Method 'SetDefaultIcon'
};
// --------------------------------------------------------
// Type: _EXPCMDSTATE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const _EXPCMDSTATE = *opaque{
};
// --------------------------------------------------------
// Type: _EXPCMDFLAGS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const _EXPCMDFLAGS = *opaque{
};
// --------------------------------------------------------
// Type: IExplorerCommand
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IExplorerCommand = *opaque{
    // TODO: Method 'GetTitle'
    // TODO: Method 'GetIcon'
    // TODO: Method 'GetToolTip'
    // TODO: Method 'GetCanonicalName'
    // TODO: Method 'GetState'
    // TODO: Method 'Invoke'
    // TODO: Method 'GetFlags'
    // TODO: Method 'EnumSubCommands'
};
// --------------------------------------------------------
// Type: IExplorerCommandState
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IExplorerCommandState = *opaque{
    // TODO: Method 'GetState'
};
// --------------------------------------------------------
// Type: IInitializeCommand
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IInitializeCommand = *opaque{
    // TODO: Method 'Initialize'
};
// --------------------------------------------------------
// Type: IEnumExplorerCommand
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IEnumExplorerCommand = *opaque{
    // TODO: Method 'Next'
    // TODO: Method 'Skip'
    // TODO: Method 'Reset'
    // TODO: Method 'Clone'
};
// --------------------------------------------------------
// Type: IExplorerCommandProvider
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IExplorerCommandProvider = *opaque{
    // TODO: Method 'GetCommands'
    // TODO: Method 'GetCommand'
};
// --------------------------------------------------------
// Type: CPVIEW
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const CPVIEW = *opaque{
};
// --------------------------------------------------------
// Type: IOpenControlPanel
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IOpenControlPanel = *opaque{
    // TODO: Method 'Open'
    // TODO: Method 'GetPath'
    // TODO: Method 'GetCurrentView'
};
// --------------------------------------------------------
// Type: IFileSystemBindData
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IFileSystemBindData = *opaque{
    // TODO: Method 'SetFindData'
    // TODO: Method 'GetFindData'
};
// --------------------------------------------------------
// Type: IFileSystemBindData2
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IFileSystemBindData2 = *opaque{
    // TODO: Method 'SetFileID'
    // TODO: Method 'GetFileID'
    // TODO: Method 'SetJunctionCLSID'
    // TODO: Method 'GetJunctionCLSID'
};
// --------------------------------------------------------
// Type: KNOWNDESTCATEGORY
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const KNOWNDESTCATEGORY = *opaque{
};
// --------------------------------------------------------
// Type: ICustomDestinationList
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ICustomDestinationList = *opaque{
    // TODO: Method 'SetAppID'
    // TODO: Method 'BeginList'
    // TODO: Method 'AppendCategory'
    // TODO: Method 'AppendKnownCategory'
    // TODO: Method 'AddUserTasks'
    // TODO: Method 'CommitList'
    // TODO: Method 'GetRemovedDestinations'
    // TODO: Method 'DeleteList'
    // TODO: Method 'AbortList'
};
// --------------------------------------------------------
// Type: IApplicationDestinations
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IApplicationDestinations = *opaque{
    // TODO: Method 'SetAppID'
    // TODO: Method 'RemoveDestination'
    // TODO: Method 'RemoveAllDestinations'
};
// --------------------------------------------------------
// Type: APPDOCLISTTYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const APPDOCLISTTYPE = *opaque{
};
// --------------------------------------------------------
// Type: IApplicationDocumentLists
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IApplicationDocumentLists = *opaque{
    // TODO: Method 'SetAppID'
    // TODO: Method 'GetList'
};
// --------------------------------------------------------
// Type: IObjectWithAppUserModelID
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IObjectWithAppUserModelID = *opaque{
    // TODO: Method 'SetAppID'
    // TODO: Method 'GetAppID'
};
// --------------------------------------------------------
// Type: IObjectWithProgID
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IObjectWithProgID = *opaque{
    // TODO: Method 'SetProgID'
    // TODO: Method 'GetProgID'
};
// --------------------------------------------------------
// Type: IUpdateIDList
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IUpdateIDList = *opaque{
    // TODO: Method 'Update'
};
// --------------------------------------------------------
// Type: DESKTOP_SLIDESHOW_OPTIONS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const DESKTOP_SLIDESHOW_OPTIONS = *opaque{
};
// --------------------------------------------------------
// Type: DESKTOP_SLIDESHOW_STATE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const DESKTOP_SLIDESHOW_STATE = *opaque{
};
// --------------------------------------------------------
// Type: DESKTOP_SLIDESHOW_DIRECTION
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const DESKTOP_SLIDESHOW_DIRECTION = *opaque{
};
// --------------------------------------------------------
// Type: DESKTOP_WALLPAPER_POSITION
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const DESKTOP_WALLPAPER_POSITION = *opaque{
};
// --------------------------------------------------------
// Type: IDesktopWallpaper
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IDesktopWallpaper = *opaque{
    // TODO: Method 'SetWallpaper'
    // TODO: Method 'GetWallpaper'
    // TODO: Method 'GetMonitorDevicePathAt'
    // TODO: Method 'GetMonitorDevicePathCount'
    // TODO: Method 'GetMonitorRECT'
    // TODO: Method 'SetBackgroundColor'
    // TODO: Method 'GetBackgroundColor'
    // TODO: Method 'SetPosition'
    // TODO: Method 'GetPosition'
    // TODO: Method 'SetSlideshow'
    // TODO: Method 'GetSlideshow'
    // TODO: Method 'SetSlideshowOptions'
    // TODO: Method 'GetSlideshowOptions'
    // TODO: Method 'AdvanceSlideshow'
    // TODO: Method 'GetStatus'
    // TODO: Method 'Enable'
};
// --------------------------------------------------------
// Type: HOMEGROUPSHARINGCHOICES
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const HOMEGROUPSHARINGCHOICES = *opaque{
};
// --------------------------------------------------------
// Type: IHomeGroup
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IHomeGroup = *opaque{
    // TODO: Method 'IsMember'
    // TODO: Method 'ShowSharingWizard'
};
// --------------------------------------------------------
// Type: IInitializeWithPropertyStore
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IInitializeWithPropertyStore = *opaque{
    // TODO: Method 'Initialize'
};
// --------------------------------------------------------
// Type: IOpenSearchSource
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IOpenSearchSource = *opaque{
    // TODO: Method 'GetResults'
};
// --------------------------------------------------------
// Type: LIBRARYFOLDERFILTER
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const LIBRARYFOLDERFILTER = *opaque{
};
// --------------------------------------------------------
// Type: LIBRARYOPTIONFLAGS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const LIBRARYOPTIONFLAGS = *opaque{
};
// --------------------------------------------------------
// Type: DEFAULTSAVEFOLDERTYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const DEFAULTSAVEFOLDERTYPE = *opaque{
};
// --------------------------------------------------------
// Type: LIBRARYSAVEFLAGS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const LIBRARYSAVEFLAGS = *opaque{
};
// --------------------------------------------------------
// Type: IShellLibrary
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IShellLibrary = *opaque{
    // TODO: Method 'LoadLibraryFromItem'
    // TODO: Method 'LoadLibraryFromKnownFolder'
    // TODO: Method 'AddFolder'
    // TODO: Method 'RemoveFolder'
    // TODO: Method 'GetFolders'
    // TODO: Method 'ResolveFolder'
    // TODO: Method 'GetDefaultSaveFolder'
    // TODO: Method 'SetDefaultSaveFolder'
    // TODO: Method 'GetOptions'
    // TODO: Method 'SetOptions'
    // TODO: Method 'GetFolderType'
    // TODO: Method 'SetFolderType'
    // TODO: Method 'GetIcon'
    // TODO: Method 'SetIcon'
    // TODO: Method 'Commit'
    // TODO: Method 'Save'
    // TODO: Method 'SaveInKnownFolder'
};
// --------------------------------------------------------
// Type: DEFAULT_FOLDER_MENU_RESTRICTIONS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const DEFAULT_FOLDER_MENU_RESTRICTIONS = *opaque{
};
// --------------------------------------------------------
// Type: IDefaultFolderMenuInitialize
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IDefaultFolderMenuInitialize = *opaque{
    // TODO: Method 'Initialize'
    // TODO: Method 'SetMenuRestrictions'
    // TODO: Method 'GetMenuRestrictions'
    // TODO: Method 'SetHandlerClsid'
};
// --------------------------------------------------------
// Type: ACTIVATEOPTIONS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const ACTIVATEOPTIONS = *opaque{
};
// --------------------------------------------------------
// Type: IApplicationActivationManager
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IApplicationActivationManager = *opaque{
    // TODO: Method 'ActivateApplication'
    // TODO: Method 'ActivateForFile'
    // TODO: Method 'ActivateForProtocol'
};
// --------------------------------------------------------
// Type: IVirtualDesktopManager
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IVirtualDesktopManager = *opaque{
    // TODO: Method 'IsWindowOnCurrentVirtualDesktop'
    // TODO: Method 'GetWindowDesktopId'
    // TODO: Method 'MoveWindowToDesktop'
};
// --------------------------------------------------------
// Type: LIBRARYMANAGEDIALOGOPTIONS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const LIBRARYMANAGEDIALOGOPTIONS = *opaque{
};
// --------------------------------------------------------
// Type: IAssocHandlerInvoker
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IAssocHandlerInvoker = *opaque{
    // TODO: Method 'SupportsSelection'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: AHTYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const AHTYPE = *opaque{
};
// --------------------------------------------------------
// Type: IAssocHandler
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IAssocHandler = *opaque{
    // TODO: Method 'GetName'
    // TODO: Method 'GetUIName'
    // TODO: Method 'GetIconLocation'
    // TODO: Method 'IsRecommended'
    // TODO: Method 'MakeDefault'
    // TODO: Method 'Invoke'
    // TODO: Method 'CreateInvoker'
};
// --------------------------------------------------------
// Type: IEnumAssocHandlers
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IEnumAssocHandlers = *opaque{
    // TODO: Method 'Next'
};
// --------------------------------------------------------
// Type: ASSOC_FILTER
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const ASSOC_FILTER = *opaque{
};
// --------------------------------------------------------
// Type: IDataObjectProvider
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IDataObjectProvider = *opaque{
    // TODO: Method 'GetDataObject'
    // TODO: Method 'SetDataObject'
};
// --------------------------------------------------------
// Type: IDataTransferManagerInterop
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IDataTransferManagerInterop = *opaque{
    // TODO: Method 'GetForWindow'
    // TODO: Method 'ShowShareUIForWindow'
};
// --------------------------------------------------------
// Type: IFrameworkInputPaneHandler
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IFrameworkInputPaneHandler = *opaque{
    // TODO: Method 'Showing'
    // TODO: Method 'Hiding'
};
// --------------------------------------------------------
// Type: IFrameworkInputPane
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IFrameworkInputPane = *opaque{
    // TODO: Method 'Advise'
    // TODO: Method 'AdviseWithHWND'
    // TODO: Method 'Unadvise'
    // TODO: Method 'Location'
};
// --------------------------------------------------------
// Type: MONITOR_APP_VISIBILITY
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const MONITOR_APP_VISIBILITY = *opaque{
};
// --------------------------------------------------------
// Type: IAppVisibilityEvents
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IAppVisibilityEvents = *opaque{
    // TODO: Method 'AppVisibilityOnMonitorChanged'
    // TODO: Method 'LauncherVisibilityChange'
};
// --------------------------------------------------------
// Type: IAppVisibility
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IAppVisibility = *opaque{
    // TODO: Method 'GetAppVisibilityOnMonitor'
    // TODO: Method 'IsLauncherVisible'
    // TODO: Method 'Advise'
    // TODO: Method 'Unadvise'
};
// --------------------------------------------------------
// Type: PACKAGE_EXECUTION_STATE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PACKAGE_EXECUTION_STATE = *opaque{
};
// --------------------------------------------------------
// Type: IPackageExecutionStateChangeNotification
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IPackageExecutionStateChangeNotification = *opaque{
    // TODO: Method 'OnStateChanged'
};
// --------------------------------------------------------
// Type: IPackageDebugSettings
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IPackageDebugSettings = *opaque{
    // TODO: Method 'EnableDebugging'
    // TODO: Method 'DisableDebugging'
    // TODO: Method 'Suspend'
    // TODO: Method 'Resume'
    // TODO: Method 'TerminateAllProcesses'
    // TODO: Method 'SetTargetSessionId'
    // TODO: Method 'EnumerateBackgroundTasks'
    // TODO: Method 'ActivateBackgroundTask'
    // TODO: Method 'StartServicing'
    // TODO: Method 'StopServicing'
    // TODO: Method 'StartSessionRedirection'
    // TODO: Method 'StopSessionRedirection'
    // TODO: Method 'GetPackageExecutionState'
    // TODO: Method 'RegisterForPackageStateChanges'
    // TODO: Method 'UnregisterForPackageStateChanges'
};
// --------------------------------------------------------
// Type: IPackageDebugSettings2
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IPackageDebugSettings2 = *opaque{
    // TODO: Method 'EnumerateApps'
};
// --------------------------------------------------------
// Type: ISuspensionDependencyManager
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ISuspensionDependencyManager = *opaque{
    // TODO: Method 'RegisterAsChild'
    // TODO: Method 'GroupChildWithParent'
    // TODO: Method 'UngroupChildFromParent'
};
// --------------------------------------------------------
// Type: AHE_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const AHE_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: IExecuteCommandApplicationHostEnvironment
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IExecuteCommandApplicationHostEnvironment = *opaque{
    // TODO: Method 'GetValue'
};
// --------------------------------------------------------
// Type: EC_HOST_UI_MODE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const EC_HOST_UI_MODE = *opaque{
};
// --------------------------------------------------------
// Type: IExecuteCommandHost
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IExecuteCommandHost = *opaque{
    // TODO: Method 'GetUIMode'
};
// --------------------------------------------------------
// Type: APPLICATION_VIEW_STATE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const APPLICATION_VIEW_STATE = *opaque{
};
// --------------------------------------------------------
// Type: EDGE_GESTURE_KIND
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const EDGE_GESTURE_KIND = *opaque{
};
// --------------------------------------------------------
// Type: IApplicationDesignModeSettings
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IApplicationDesignModeSettings = *opaque{
    // TODO: Method 'SetNativeDisplaySize'
    // TODO: Method 'SetScaleFactor'
    // TODO: Method 'SetApplicationViewState'
    // TODO: Method 'ComputeApplicationSize'
    // TODO: Method 'IsApplicationViewStateSupported'
    // TODO: Method 'TriggerEdgeGesture'
};
// --------------------------------------------------------
// Type: NATIVE_DISPLAY_ORIENTATION
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const NATIVE_DISPLAY_ORIENTATION = *opaque{
};
// --------------------------------------------------------
// Type: APPLICATION_VIEW_ORIENTATION
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const APPLICATION_VIEW_ORIENTATION = *opaque{
};
// --------------------------------------------------------
// Type: ADJACENT_DISPLAY_EDGES
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const ADJACENT_DISPLAY_EDGES = *opaque{
};
// --------------------------------------------------------
// Type: APPLICATION_VIEW_MIN_WIDTH
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const APPLICATION_VIEW_MIN_WIDTH = *opaque{
};
// --------------------------------------------------------
// Type: IApplicationDesignModeSettings2
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IApplicationDesignModeSettings2 = *opaque{
    // TODO: Method 'SetNativeDisplayOrientation'
    // TODO: Method 'SetApplicationViewOrientation'
    // TODO: Method 'SetAdjacentDisplayEdges'
    // TODO: Method 'SetIsOnLockScreen'
    // TODO: Method 'SetApplicationViewMinWidth'
    // TODO: Method 'GetApplicationSizeBounds'
    // TODO: Method 'GetApplicationViewOrientation'
};
// --------------------------------------------------------
// Type: ILaunchTargetMonitor
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ILaunchTargetMonitor = *opaque{
    // TODO: Method 'GetMonitor'
};
// --------------------------------------------------------
// Type: APPLICATION_VIEW_SIZE_PREFERENCE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const APPLICATION_VIEW_SIZE_PREFERENCE = *opaque{
};
// --------------------------------------------------------
// Type: ILaunchSourceViewSizePreference
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ILaunchSourceViewSizePreference = *opaque{
    // TODO: Method 'GetSourceViewToPosition'
    // TODO: Method 'GetSourceViewSizePreference'
};
// --------------------------------------------------------
// Type: ILaunchTargetViewSizePreference
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ILaunchTargetViewSizePreference = *opaque{
    // TODO: Method 'GetTargetViewSizePreference'
};
// --------------------------------------------------------
// Type: ILaunchSourceAppUserModelId
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ILaunchSourceAppUserModelId = *opaque{
    // TODO: Method 'GetAppUserModelId'
};
// --------------------------------------------------------
// Type: IInitializeWithWindow
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IInitializeWithWindow = *opaque{
    // TODO: Method 'Initialize'
};
// --------------------------------------------------------
// Type: IHandlerInfo
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IHandlerInfo = *opaque{
    // TODO: Method 'GetApplicationDisplayName'
    // TODO: Method 'GetApplicationPublisher'
    // TODO: Method 'GetApplicationIconReference'
};
// --------------------------------------------------------
// Type: IHandlerInfo2
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IHandlerInfo2 = *opaque{
    // TODO: Method 'GetApplicationId'
};
// --------------------------------------------------------
// Type: IHandlerActivationHost
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IHandlerActivationHost = *opaque{
    // TODO: Method 'BeforeCoCreateInstance'
    // TODO: Method 'BeforeCreateProcess'
};
// --------------------------------------------------------
// Type: IAppActivationUIInfo
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IAppActivationUIInfo = *opaque{
    // TODO: Method 'GetMonitor'
    // TODO: Method 'GetInvokePoint'
    // TODO: Method 'GetShowCommand'
    // TODO: Method 'GetShowUI'
    // TODO: Method 'GetKeyState'
};
// --------------------------------------------------------
// Type: FLYOUT_PLACEMENT
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const FLYOUT_PLACEMENT = *opaque{
};
// --------------------------------------------------------
// Type: IContactManagerInterop
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IContactManagerInterop = *opaque{
    // TODO: Method 'ShowContactCardForWindow'
};
// --------------------------------------------------------
// Type: IShellIconOverlayIdentifier
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IShellIconOverlayIdentifier = *opaque{
    // TODO: Method 'IsMemberOf'
    // TODO: Method 'GetOverlayInfo'
    // TODO: Method 'GetPriority'
};
// --------------------------------------------------------
// Type: BANNER_NOTIFICATION_EVENT
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const BANNER_NOTIFICATION_EVENT = *opaque{
};
// --------------------------------------------------------
// Type: BANNER_NOTIFICATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const BANNER_NOTIFICATION = extern struct {
    event: BANNER_NOTIFICATION_EVENT,
    providerIdentity: ?*u16,
    contentId: ?*u16,
};
// --------------------------------------------------------
// Type: IBannerNotificationHandler
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IBannerNotificationHandler = *opaque{
    // TODO: Method 'OnBannerEvent'
};
// --------------------------------------------------------
// Type: SORT_ORDER_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const SORT_ORDER_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: ISortColumnArray
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ISortColumnArray = *opaque{
    // TODO: Method 'GetCount'
    // TODO: Method 'GetAt'
    // TODO: Method 'GetSortType'
};
// --------------------------------------------------------
// Type: IPropertyKeyStore
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IPropertyKeyStore = *opaque{
    // TODO: Method 'GetKeyCount'
    // TODO: Method 'GetKeyAt'
    // TODO: Method 'AppendKey'
    // TODO: Method 'DeleteKey'
    // TODO: Method 'IsKeyInStore'
    // TODO: Method 'RemoveKey'
};
// --------------------------------------------------------
// Type: IQueryCodePage
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IQueryCodePage = *opaque{
    // TODO: Method 'GetCodePage'
    // TODO: Method 'SetCodePage'
};
// --------------------------------------------------------
// Type: FOLDERVIEWOPTIONS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const FOLDERVIEWOPTIONS = *opaque{
};
// --------------------------------------------------------
// Type: IFolderViewOptions
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IFolderViewOptions = *opaque{
    // TODO: Method 'SetFolderViewOptions'
    // TODO: Method 'GetFolderViewOptions'
};
// --------------------------------------------------------
// Type: _SV3CVW3_FLAGS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const _SV3CVW3_FLAGS = *opaque{
};
// --------------------------------------------------------
// Type: IShellView3
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IShellView3 = *opaque{
    // TODO: Method 'CreateViewWindow3'
};
// --------------------------------------------------------
// Type: ISearchBoxInfo
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ISearchBoxInfo = *opaque{
    // TODO: Method 'GetCondition'
    // TODO: Method 'GetText'
};
// --------------------------------------------------------
// Type: VPWATERMARKFLAGS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const VPWATERMARKFLAGS = *opaque{
};
// --------------------------------------------------------
// Type: VPCOLORFLAGS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const VPCOLORFLAGS = *opaque{
};
// --------------------------------------------------------
// Type: IVisualProperties
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IVisualProperties = *opaque{
    // TODO: Method 'SetWatermark'
    // TODO: Method 'SetColor'
    // TODO: Method 'GetColor'
    // TODO: Method 'SetItemHeight'
    // TODO: Method 'GetItemHeight'
    // TODO: Method 'SetFont'
    // TODO: Method 'GetFont'
    // TODO: Method 'SetTheme'
};
// --------------------------------------------------------
// Type: ICommDlgBrowser3
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ICommDlgBrowser3 = *opaque{
    // TODO: Method 'OnColumnClicked'
    // TODO: Method 'GetCurrentFilter'
    // TODO: Method 'OnPreViewCreated'
};
// --------------------------------------------------------
// Type: IUserAccountChangeCallback
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IUserAccountChangeCallback = *opaque{
    // TODO: Method 'OnPictureChange'
};
// --------------------------------------------------------
// Type: IStreamAsync
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IStreamAsync = *opaque{
    // TODO: Method 'ReadAsync'
    // TODO: Method 'WriteAsync'
    // TODO: Method 'OverlappedResult'
    // TODO: Method 'CancelIo'
};
// --------------------------------------------------------
// Type: IStreamUnbufferedInfo
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IStreamUnbufferedInfo = *opaque{
    // TODO: Method 'GetSectorSize'
};
// --------------------------------------------------------
// Type: DSH_FLAGS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const DSH_FLAGS = *opaque{
};
// --------------------------------------------------------
// Type: IDragSourceHelper2
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IDragSourceHelper2 = *opaque{
    // TODO: Method 'SetFlags'
};
// --------------------------------------------------------
// Type: IHWEventHandler
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IHWEventHandler = *opaque{
    // TODO: Method 'Initialize'
    // TODO: Method 'HandleEvent'
    // TODO: Method 'HandleEventWithContent'
};
// --------------------------------------------------------
// Type: IHWEventHandler2
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IHWEventHandler2 = *opaque{
    // TODO: Method 'HandleEventWithHWND'
};
// --------------------------------------------------------
// Type: IQueryCancelAutoPlay
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IQueryCancelAutoPlay = *opaque{
    // TODO: Method 'AllowAutoPlay'
};
// --------------------------------------------------------
// Type: IDynamicHWHandler
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IDynamicHWHandler = *opaque{
    // TODO: Method 'GetDynamicInfo'
};
// --------------------------------------------------------
// Type: IUserNotificationCallback
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IUserNotificationCallback = *opaque{
    // TODO: Method 'OnBalloonUserClick'
    // TODO: Method 'OnLeftClick'
    // TODO: Method 'OnContextMenu'
};
// --------------------------------------------------------
// Type: IUserNotification2
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IUserNotification2 = *opaque{
    // TODO: Method 'SetBalloonInfo'
    // TODO: Method 'SetBalloonRetry'
    // TODO: Method 'SetIconInfo'
    // TODO: Method 'Show'
    // TODO: Method 'PlaySoundA'
};
// --------------------------------------------------------
// Type: IDeskBand2
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IDeskBand2 = *opaque{
    // TODO: Method 'CanRenderComposited'
    // TODO: Method 'SetCompositionState'
    // TODO: Method 'GetCompositionState'
};
// --------------------------------------------------------
// Type: IStartMenuPinnedList
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IStartMenuPinnedList = *opaque{
    // TODO: Method 'RemoveFromList'
};
// --------------------------------------------------------
// Type: ICDBurn
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ICDBurn = *opaque{
    // TODO: Method 'GetRecorderDriveLetter'
    // TODO: Method 'Burn'
    // TODO: Method 'HasRecordableDrive'
};
// --------------------------------------------------------
// Type: IWizardSite
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IWizardSite = *opaque{
    // TODO: Method 'GetPreviousPage'
    // TODO: Method 'GetNextPage'
    // TODO: Method 'GetCancelledPage'
};
// --------------------------------------------------------
// Type: IWizardExtension
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IWizardExtension = *opaque{
    // TODO: Method 'AddPages'
    // TODO: Method 'GetFirstPage'
    // TODO: Method 'GetLastPage'
};
// --------------------------------------------------------
// Type: IWebWizardExtension
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IWebWizardExtension = *opaque{
    // TODO: Method 'SetInitialURL'
    // TODO: Method 'SetErrorURL'
};
// --------------------------------------------------------
// Type: IPublishingWizard
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IPublishingWizard = *opaque{
    // TODO: Method 'Initialize'
    // TODO: Method 'GetTransferManifest'
};
// --------------------------------------------------------
// Type: IFolderViewHost
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IFolderViewHost = *opaque{
    // TODO: Method 'Initialize'
};
// --------------------------------------------------------
// Type: IAccessibleObject
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IAccessibleObject = *opaque{
    // TODO: Method 'SetAccessibleName'
};
// --------------------------------------------------------
// Type: IResultsFolder
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IResultsFolder = *opaque{
    // TODO: Method 'AddItem'
    // TODO: Method 'AddIDList'
    // TODO: Method 'RemoveItem'
    // TODO: Method 'RemoveIDList'
    // TODO: Method 'RemoveAll'
};
// --------------------------------------------------------
// Type: IAutoCompleteDropDown
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IAutoCompleteDropDown = *opaque{
    // TODO: Method 'GetDropDownStatus'
    // TODO: Method 'ResetEnumerator'
};
// --------------------------------------------------------
// Type: tagCDBURNINGEXTENSIONRET
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const tagCDBURNINGEXTENSIONRET = *opaque{
};
// --------------------------------------------------------
// Type: _CDBE_ACTIONS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const _CDBE_ACTIONS = *opaque{
};
// --------------------------------------------------------
// Type: ICDBurnExt
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ICDBurnExt = *opaque{
    // TODO: Method 'GetSupportedActionTypes'
};
// --------------------------------------------------------
// Type: IEnumReadyCallback
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IEnumReadyCallback = *opaque{
    // TODO: Method 'EnumReady'
};
// --------------------------------------------------------
// Type: IEnumerableView
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IEnumerableView = *opaque{
    // TODO: Method 'SetEnumReadyCallback'
    // TODO: Method 'CreateEnumIDListFromContents'
};
// --------------------------------------------------------
// Type: IInsertItem
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IInsertItem = *opaque{
    // TODO: Method 'InsertItem'
};
// --------------------------------------------------------
// Type: IFolderBandPriv
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IFolderBandPriv = *opaque{
    // TODO: Method 'SetCascade'
    // TODO: Method 'SetAccelerators'
    // TODO: Method 'SetNoIcons'
    // TODO: Method 'SetNoText'
};
// --------------------------------------------------------
// Type: IImageRecompress
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IImageRecompress = *opaque{
    // TODO: Method 'RecompressImage'
};
// --------------------------------------------------------
// Type: IFileDialogControlEvents
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IFileDialogControlEvents = *opaque{
    // TODO: Method 'OnItemSelected'
    // TODO: Method 'OnButtonClicked'
    // TODO: Method 'OnCheckButtonToggled'
    // TODO: Method 'OnControlActivating'
};
// --------------------------------------------------------
// Type: IFileDialog2
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IFileDialog2 = *opaque{
    // TODO: Method 'SetCancelButtonLabel'
    // TODO: Method 'SetNavigationRoot'
};
// --------------------------------------------------------
// Type: IApplicationAssociationRegistrationUI
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IApplicationAssociationRegistrationUI = *opaque{
    // TODO: Method 'LaunchAdvancedAssociationUI'
};
// --------------------------------------------------------
// Type: IShellRunDll
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IShellRunDll = *opaque{
    // TODO: Method 'Run'
};
// --------------------------------------------------------
// Type: IPreviousVersionsInfo
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IPreviousVersionsInfo = *opaque{
    // TODO: Method 'AreSnapshotsAvailable'
};
// --------------------------------------------------------
// Type: IUseToBrowseItem
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IUseToBrowseItem = *opaque{
};
// --------------------------------------------------------
// Type: NSTCSTYLE2
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const NSTCSTYLE2 = *opaque{
};
// --------------------------------------------------------
// Type: INameSpaceTreeControl2
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const INameSpaceTreeControl2 = *opaque{
    // TODO: Method 'SetControlStyle'
    // TODO: Method 'GetControlStyle'
    // TODO: Method 'SetControlStyle2'
    // TODO: Method 'GetControlStyle2'
};
// --------------------------------------------------------
// Type: _NSTCEHITTEST
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const _NSTCEHITTEST = *opaque{
};
// --------------------------------------------------------
// Type: _NSTCECLICKTYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const _NSTCECLICKTYPE = *opaque{
};
// --------------------------------------------------------
// Type: INameSpaceTreeControlEvents
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const INameSpaceTreeControlEvents = *opaque{
    // TODO: Method 'OnItemClick'
    // TODO: Method 'OnPropertyItemCommit'
    // TODO: Method 'OnItemStateChanging'
    // TODO: Method 'OnItemStateChanged'
    // TODO: Method 'OnSelectionChanged'
    // TODO: Method 'OnKeyboardInput'
    // TODO: Method 'OnBeforeExpand'
    // TODO: Method 'OnAfterExpand'
    // TODO: Method 'OnBeginLabelEdit'
    // TODO: Method 'OnEndLabelEdit'
    // TODO: Method 'OnGetToolTip'
    // TODO: Method 'OnBeforeItemDelete'
    // TODO: Method 'OnItemAdded'
    // TODO: Method 'OnItemDeleted'
    // TODO: Method 'OnBeforeContextMenu'
    // TODO: Method 'OnAfterContextMenu'
    // TODO: Method 'OnBeforeStateImageChange'
    // TODO: Method 'OnGetDefaultIconIndex'
};
// --------------------------------------------------------
// Type: INameSpaceTreeControlDropHandler
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const INameSpaceTreeControlDropHandler = *opaque{
    // TODO: Method 'OnDragEnter'
    // TODO: Method 'OnDragOver'
    // TODO: Method 'OnDragPosition'
    // TODO: Method 'OnDrop'
    // TODO: Method 'OnDropPosition'
    // TODO: Method 'OnDragLeave'
};
// --------------------------------------------------------
// Type: INameSpaceTreeAccessible
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const INameSpaceTreeAccessible = *opaque{
    // TODO: Method 'OnGetDefaultAccessibilityAction'
    // TODO: Method 'OnDoDefaultAccessibilityAction'
    // TODO: Method 'OnGetAccessibilityRole'
};
// --------------------------------------------------------
// Type: NSTCCUSTOMDRAW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NSTCCUSTOMDRAW = extern struct {
    psi: IShellItem,
    uItemState: u32,
    nstcis: u32,
    pszText: ?*u16,
    iImage: i32,
    himl: HIMAGELIST,
    iLevel: i32,
    iIndent: i32,
};
// --------------------------------------------------------
// Type: INameSpaceTreeControlCustomDraw
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const INameSpaceTreeControlCustomDraw = *opaque{
    // TODO: Method 'PrePaint'
    // TODO: Method 'PostPaint'
    // TODO: Method 'ItemPrePaint'
    // TODO: Method 'ItemPostPaint'
};
// --------------------------------------------------------
// Type: ITrayDeskBand
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ITrayDeskBand = *opaque{
    // TODO: Method 'ShowDeskBand'
    // TODO: Method 'HideDeskBand'
    // TODO: Method 'IsDeskBandShown'
    // TODO: Method 'DeskBandRegistrationChanged'
};
// --------------------------------------------------------
// Type: IBandHost
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IBandHost = *opaque{
    // TODO: Method 'CreateBand'
    // TODO: Method 'SetBandAvailability'
    // TODO: Method 'DestroyBand'
};
// --------------------------------------------------------
// Type: IComputerInfoChangeNotify
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IComputerInfoChangeNotify = *opaque{
    // TODO: Method 'ComputerInfoChanged'
};
// --------------------------------------------------------
// Type: IDesktopGadget
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IDesktopGadget = *opaque{
    // TODO: Method 'RunGadget'
};
// --------------------------------------------------------
// Type: UNDOCK_REASON
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UNDOCK_REASON = *opaque{
};
// --------------------------------------------------------
// Type: IStorageProviderBanners
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IStorageProviderBanners = *opaque{
    // TODO: Method 'SetBanner'
    // TODO: Method 'ClearBanner'
    // TODO: Method 'ClearAllBanners'
    // TODO: Method 'GetBanner'
};
// --------------------------------------------------------
// Type: ShellFolderViewOC
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const ShellFolderViewOC = opaque {
};
// --------------------------------------------------------
// Type: ShellFolderItem
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const ShellFolderItem = opaque {
};
// --------------------------------------------------------
// Type: ShellLinkObject
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const ShellLinkObject = opaque {
};
// --------------------------------------------------------
// Type: ShellFolderView
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const ShellFolderView = opaque {
};
// --------------------------------------------------------
// Type: Shell
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const Shell = opaque {
};
// --------------------------------------------------------
// Type: ShellDispatchInproc
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const ShellDispatchInproc = opaque {
};
// --------------------------------------------------------
// Type: FileSearchBand
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const FileSearchBand = opaque {
};
// --------------------------------------------------------
// Type: OfflineFolderStatus
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const OfflineFolderStatus = *opaque{
};
// --------------------------------------------------------
// Type: ShellFolderViewOptions
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const ShellFolderViewOptions = *opaque{
};
// --------------------------------------------------------
// Type: ShellSpecialFolderConstants
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const ShellSpecialFolderConstants = *opaque{
};
// --------------------------------------------------------
// Type: IFolderViewOC
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IFolderViewOC = *opaque{
    // TODO: Method 'SetFolderView'
};
// --------------------------------------------------------
// Type: DShellFolderViewEvents
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const DShellFolderViewEvents = *opaque{
};
// --------------------------------------------------------
// Type: DFConstraint
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const DFConstraint = *opaque{
    // TODO: Method 'get_Name'
    // TODO: Method 'get_Value'
};
// --------------------------------------------------------
// Type: FolderItem
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const FolderItem = *opaque{
    // TODO: Method 'get_Application'
    // TODO: Method 'get_Parent'
    // TODO: Method 'get_Name'
    // TODO: Method 'put_Name'
    // TODO: Method 'get_Path'
    // TODO: Method 'get_GetLink'
    // TODO: Method 'get_GetFolder'
    // TODO: Method 'get_IsLink'
    // TODO: Method 'get_IsFolder'
    // TODO: Method 'get_IsFileSystem'
    // TODO: Method 'get_IsBrowsable'
    // TODO: Method 'get_ModifyDate'
    // TODO: Method 'put_ModifyDate'
    // TODO: Method 'get_Size'
    // TODO: Method 'get_Type'
    // TODO: Method 'Verbs'
    // TODO: Method 'InvokeVerb'
};
// --------------------------------------------------------
// Type: FolderItems
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const FolderItems = *opaque{
    // TODO: Method 'get_Count'
    // TODO: Method 'get_Application'
    // TODO: Method 'get_Parent'
    // TODO: Method 'Item'
    // TODO: Method '_NewEnum'
};
// --------------------------------------------------------
// Type: FolderItemVerb
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const FolderItemVerb = *opaque{
    // TODO: Method 'get_Application'
    // TODO: Method 'get_Parent'
    // TODO: Method 'get_Name'
    // TODO: Method 'DoIt'
};
// --------------------------------------------------------
// Type: FolderItemVerbs
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const FolderItemVerbs = *opaque{
    // TODO: Method 'get_Count'
    // TODO: Method 'get_Application'
    // TODO: Method 'get_Parent'
    // TODO: Method 'Item'
    // TODO: Method '_NewEnum'
};
// --------------------------------------------------------
// Type: Folder
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const Folder = *opaque{
    // TODO: Method 'get_Title'
    // TODO: Method 'get_Application'
    // TODO: Method 'get_Parent'
    // TODO: Method 'get_ParentFolder'
    // TODO: Method 'Items'
    // TODO: Method 'ParseName'
    // TODO: Method 'NewFolder'
    // TODO: Method 'MoveHere'
    // TODO: Method 'CopyHere'
    // TODO: Method 'GetDetailsOf'
};
// --------------------------------------------------------
// Type: Folder2
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const Folder2 = *opaque{
    // TODO: Method 'get_Self'
    // TODO: Method 'get_OfflineStatus'
    // TODO: Method 'Synchronize'
    // TODO: Method 'get_HaveToShowWebViewBarricade'
    // TODO: Method 'DismissedWebViewBarricade'
};
// --------------------------------------------------------
// Type: Folder3
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const Folder3 = *opaque{
    // TODO: Method 'get_ShowWebViewBarricade'
    // TODO: Method 'put_ShowWebViewBarricade'
};
// --------------------------------------------------------
// Type: FolderItem2
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const FolderItem2 = *opaque{
    // TODO: Method 'InvokeVerbEx'
    // TODO: Method 'ExtendedProperty'
};
// --------------------------------------------------------
// Type: FolderItems2
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const FolderItems2 = *opaque{
    // TODO: Method 'InvokeVerbEx'
};
// --------------------------------------------------------
// Type: FolderItems3
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const FolderItems3 = *opaque{
    // TODO: Method 'Filter'
    // TODO: Method 'get_Verbs'
};
// --------------------------------------------------------
// Type: IShellLinkDual
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IShellLinkDual = *opaque{
    // TODO: Method 'get_Path'
    // TODO: Method 'put_Path'
    // TODO: Method 'get_Description'
    // TODO: Method 'put_Description'
    // TODO: Method 'get_WorkingDirectory'
    // TODO: Method 'put_WorkingDirectory'
    // TODO: Method 'get_Arguments'
    // TODO: Method 'put_Arguments'
    // TODO: Method 'get_Hotkey'
    // TODO: Method 'put_Hotkey'
    // TODO: Method 'get_ShowCommand'
    // TODO: Method 'put_ShowCommand'
    // TODO: Method 'Resolve'
    // TODO: Method 'GetIconLocation'
    // TODO: Method 'SetIconLocation'
    // TODO: Method 'Save'
};
// --------------------------------------------------------
// Type: IShellLinkDual2
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IShellLinkDual2 = *opaque{
    // TODO: Method 'get_Target'
};
// --------------------------------------------------------
// Type: IShellFolderViewDual
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IShellFolderViewDual = *opaque{
    // TODO: Method 'get_Application'
    // TODO: Method 'get_Parent'
    // TODO: Method 'get_Folder'
    // TODO: Method 'SelectedItems'
    // TODO: Method 'get_FocusedItem'
    // TODO: Method 'SelectItem'
    // TODO: Method 'PopupItemMenu'
    // TODO: Method 'get_Script'
    // TODO: Method 'get_ViewOptions'
};
// --------------------------------------------------------
// Type: IShellFolderViewDual2
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IShellFolderViewDual2 = *opaque{
    // TODO: Method 'get_CurrentViewMode'
    // TODO: Method 'put_CurrentViewMode'
    // TODO: Method 'SelectItemRelative'
};
// --------------------------------------------------------
// Type: IShellFolderViewDual3
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IShellFolderViewDual3 = *opaque{
    // TODO: Method 'get_GroupBy'
    // TODO: Method 'put_GroupBy'
    // TODO: Method 'get_FolderFlags'
    // TODO: Method 'put_FolderFlags'
    // TODO: Method 'get_SortColumns'
    // TODO: Method 'put_SortColumns'
    // TODO: Method 'put_IconSize'
    // TODO: Method 'get_IconSize'
    // TODO: Method 'FilterView'
};
// --------------------------------------------------------
// Type: IShellDispatch
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IShellDispatch = *opaque{
    // TODO: Method 'get_Application'
    // TODO: Method 'get_Parent'
    // TODO: Method 'NameSpace'
    // TODO: Method 'BrowseForFolder'
    // TODO: Method 'Windows'
    // TODO: Method 'Open'
    // TODO: Method 'Explore'
    // TODO: Method 'MinimizeAll'
    // TODO: Method 'UndoMinimizeALL'
    // TODO: Method 'FileRun'
    // TODO: Method 'CascadeWindows'
    // TODO: Method 'TileVertically'
    // TODO: Method 'TileHorizontally'
    // TODO: Method 'ShutdownWindows'
    // TODO: Method 'Suspend'
    // TODO: Method 'EjectPC'
    // TODO: Method 'SetTime'
    // TODO: Method 'TrayProperties'
    // TODO: Method 'Help'
    // TODO: Method 'FindFiles'
    // TODO: Method 'FindComputer'
    // TODO: Method 'RefreshMenu'
    // TODO: Method 'ControlPanelItem'
};
// --------------------------------------------------------
// Type: IShellDispatch2
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IShellDispatch2 = *opaque{
    // TODO: Method 'IsRestricted'
    // TODO: Method 'ShellExecuteA'
    // TODO: Method 'FindPrinter'
    // TODO: Method 'GetSystemInformation'
    // TODO: Method 'ServiceStart'
    // TODO: Method 'ServiceStop'
    // TODO: Method 'IsServiceRunning'
    // TODO: Method 'CanStartStopService'
    // TODO: Method 'ShowBrowserBar'
};
// --------------------------------------------------------
// Type: IShellDispatch3
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IShellDispatch3 = *opaque{
    // TODO: Method 'AddToRecent'
};
// --------------------------------------------------------
// Type: IShellDispatch4
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IShellDispatch4 = *opaque{
    // TODO: Method 'WindowsSecurity'
    // TODO: Method 'ToggleDesktop'
    // TODO: Method 'ExplorerPolicy'
    // TODO: Method 'GetSetting'
};
// --------------------------------------------------------
// Type: IShellDispatch5
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IShellDispatch5 = *opaque{
    // TODO: Method 'WindowSwitcher'
};
// --------------------------------------------------------
// Type: IShellDispatch6
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IShellDispatch6 = *opaque{
    // TODO: Method 'SearchCommand'
};
// --------------------------------------------------------
// Type: IFileSearchBand
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IFileSearchBand = *opaque{
    // TODO: Method 'SetFocus'
    // TODO: Method 'SetSearchParameters'
    // TODO: Method 'get_SearchID'
    // TODO: Method 'get_Scope'
    // TODO: Method 'get_QueryFile'
};
// --------------------------------------------------------
// Type: IWebWizardHost
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IWebWizardHost = *opaque{
    // TODO: Method 'FinalBack'
    // TODO: Method 'FinalNext'
    // TODO: Method 'Cancel'
    // TODO: Method 'put_Caption'
    // TODO: Method 'get_Caption'
    // TODO: Method 'put_Property'
    // TODO: Method 'get_Property'
    // TODO: Method 'SetWizardButtons'
    // TODO: Method 'SetHeaderText'
};
// --------------------------------------------------------
// Type: IWebWizardHost2
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IWebWizardHost2 = *opaque{
    // TODO: Method 'SignString'
};
// --------------------------------------------------------
// Type: INewWDEvents
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const INewWDEvents = *opaque{
    // TODO: Method 'PassportAuthenticate'
};
// --------------------------------------------------------
// Type: IAutoComplete
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IAutoComplete = *opaque{
    // TODO: Method 'Init'
    // TODO: Method 'Enable'
};
// --------------------------------------------------------
// Type: AUTOCOMPLETEOPTIONS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const AUTOCOMPLETEOPTIONS = *opaque{
};
// --------------------------------------------------------
// Type: IAutoComplete2
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IAutoComplete2 = *opaque{
    // TODO: Method 'SetOptions'
    // TODO: Method 'GetOptions'
};
// --------------------------------------------------------
// Type: ACENUMOPTION
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const ACENUMOPTION = *opaque{
};
// --------------------------------------------------------
// Type: IEnumACString
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IEnumACString = *opaque{
    // TODO: Method 'NextItem'
    // TODO: Method 'SetEnumOptions'
    // TODO: Method 'GetEnumOptions'
};
// --------------------------------------------------------
// Type: IDataObjectAsyncCapability
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IDataObjectAsyncCapability = *opaque{
    // TODO: Method 'SetAsyncMode'
    // TODO: Method 'GetAsyncMode'
    // TODO: Method 'StartOperation'
    // TODO: Method 'InOperation'
    // TODO: Method 'EndOperation'
};
// --------------------------------------------------------
// Type: IExtractIconA
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IExtractIconA = *opaque{
    // TODO: Method 'GetIconLocation'
    // TODO: Method 'Extract'
};
// --------------------------------------------------------
// Type: IExtractIconW
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IExtractIconW = *opaque{
    // TODO: Method 'GetIconLocation'
    // TODO: Method 'Extract'
};
// --------------------------------------------------------
// Type: IShellIconOverlayManager
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IShellIconOverlayManager = *opaque{
    // TODO: Method 'GetFileOverlayInfo'
    // TODO: Method 'GetReservedOverlayInfo'
    // TODO: Method 'RefreshOverlayImages'
    // TODO: Method 'LoadNonloadedOverlayIdentifiers'
    // TODO: Method 'OverlayIndexFromImageIndex'
};
// --------------------------------------------------------
// Type: IShellIconOverlay
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IShellIconOverlay = *opaque{
    // TODO: Method 'GetOverlayIndex'
    // TODO: Method 'GetOverlayIconIndex'
};
// --------------------------------------------------------
// Type: SHELL_LINK_DATA_FLAGS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const SHELL_LINK_DATA_FLAGS = *opaque{
};
// --------------------------------------------------------
// Type: DATABLOCK_HEADER
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const DATABLOCK_HEADER = *opaque{
};
// --------------------------------------------------------
// Type: NT_CONSOLE_PROPS
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const NT_CONSOLE_PROPS = *opaque{
};
// --------------------------------------------------------
// Type: NT_FE_CONSOLE_PROPS
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const NT_FE_CONSOLE_PROPS = *opaque{
};
// --------------------------------------------------------
// Type: EXP_DARWIN_LINK
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const EXP_DARWIN_LINK = *opaque{
};
// --------------------------------------------------------
// Type: EXP_SPECIAL_FOLDER
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const EXP_SPECIAL_FOLDER = *opaque{
};
// --------------------------------------------------------
// Type: EXP_SZ_LINK
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const EXP_SZ_LINK = *opaque{
};
// --------------------------------------------------------
// Type: EXP_PROPERTYSTORAGE
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const EXP_PROPERTYSTORAGE = *opaque{
};
// --------------------------------------------------------
// Type: IShellExecuteHookA
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IShellExecuteHookA = *opaque{
    // TODO: Method 'Execute'
};
// --------------------------------------------------------
// Type: IShellExecuteHookW
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IShellExecuteHookW = *opaque{
    // TODO: Method 'Execute'
};
// --------------------------------------------------------
// Type: IURLSearchHook
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IURLSearchHook = *opaque{
    // TODO: Method 'Translate'
};
// --------------------------------------------------------
// Type: ISearchContext
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ISearchContext = *opaque{
    // TODO: Method 'GetSearchUrl'
    // TODO: Method 'GetSearchText'
    // TODO: Method 'GetSearchStyle'
};
// --------------------------------------------------------
// Type: IURLSearchHook2
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IURLSearchHook2 = *opaque{
    // TODO: Method 'TranslateWithSearchContext'
};
// --------------------------------------------------------
// Type: SHGFP_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const SHGFP_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: KNOWN_FOLDER_FLAG
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const KNOWN_FOLDER_FLAG = *opaque{
};
// --------------------------------------------------------
// Type: SHFOLDERCUSTOMSETTINGS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SHFOLDERCUSTOMSETTINGS = extern struct {
    dwSize: u32,
    dwMask: u32,
    pvid: ?*Guid,
    pszWebViewTemplate: ?*u16,
    cchWebViewTemplate: u32,
    pszWebViewTemplateVersion: ?*u16,
    pszInfoTip: ?*u16,
    cchInfoTip: u32,
    pclsid: ?*Guid,
    dwFlags: u32,
    pszIconFile: ?*u16,
    cchIconFile: u32,
    iIconIndex: i32,
    pszLogo: ?*u16,
    cchLogo: u32,
};
// --------------------------------------------------------
// Type: BROWSEINFOA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const BROWSEINFOA = extern struct {
    hwndOwner: HWND,
    pidlRoot: ?*ITEMIDLIST,
    pszDisplayName: ?*i8,
    lpszTitle: ?*i8,
    ulFlags: u32,
    lpfn: BFFCALLBACK,
    lParam: LPARAM,
    iImage: i32,
};
// --------------------------------------------------------
// Type: BROWSEINFOW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const BROWSEINFOW = extern struct {
    hwndOwner: HWND,
    pidlRoot: ?*ITEMIDLIST,
    pszDisplayName: ?*u16,
    lpszTitle: ?*u16,
    ulFlags: u32,
    lpfn: BFFCALLBACK,
    lParam: LPARAM,
    iImage: i32,
};
// --------------------------------------------------------
// Type: IShellDetails
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IShellDetails = *opaque{
    // TODO: Method 'GetDetailsOf'
    // TODO: Method 'ColumnClick'
};
// --------------------------------------------------------
// Type: IObjMgr
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IObjMgr = *opaque{
    // TODO: Method 'Append'
    // TODO: Method 'Remove'
};
// --------------------------------------------------------
// Type: IACList
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IACList = *opaque{
    // TODO: Method 'Expand'
};
// --------------------------------------------------------
// Type: AUTOCOMPLETELISTOPTIONS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const AUTOCOMPLETELISTOPTIONS = *opaque{
};
// --------------------------------------------------------
// Type: IACList2
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IACList2 = *opaque{
    // TODO: Method 'SetOptions'
    // TODO: Method 'GetOptions'
};
// --------------------------------------------------------
// Type: IProgressDialog
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IProgressDialog = *opaque{
    // TODO: Method 'StartProgressDialog'
    // TODO: Method 'StopProgressDialog'
    // TODO: Method 'SetTitle'
    // TODO: Method 'SetAnimation'
    // TODO: Method 'HasUserCancelled'
    // TODO: Method 'SetProgress'
    // TODO: Method 'SetProgress64'
    // TODO: Method 'SetLine'
    // TODO: Method 'SetCancelMsg'
    // TODO: Method 'Timer'
};
// --------------------------------------------------------
// Type: IDockingWindowSite
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IDockingWindowSite = *opaque{
    // TODO: Method 'GetBorderDW'
    // TODO: Method 'RequestBorderSpaceDW'
    // TODO: Method 'SetBorderSpaceDW'
};
// --------------------------------------------------------
// Type: NRESARRAY
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NRESARRAY = extern struct {
    cItems: u32,
    nr: ?[*]NETRESOURCEA,
};
// --------------------------------------------------------
// Type: CIDA
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const CIDA = *opaque{
};
// --------------------------------------------------------
// Type: FD_FLAGS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const FD_FLAGS = *opaque{
};
// --------------------------------------------------------
// Type: FILEDESCRIPTORA
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const FILEDESCRIPTORA = *opaque{
};
// --------------------------------------------------------
// Type: FILEDESCRIPTORW
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const FILEDESCRIPTORW = *opaque{
};
// --------------------------------------------------------
// Type: FILEGROUPDESCRIPTORA
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const FILEGROUPDESCRIPTORA = *opaque{
};
// --------------------------------------------------------
// Type: FILEGROUPDESCRIPTORW
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const FILEGROUPDESCRIPTORW = *opaque{
};
// --------------------------------------------------------
// Type: DROPFILES
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const DROPFILES = *opaque{
};
// --------------------------------------------------------
// Type: FILE_ATTRIBUTES_ARRAY
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const FILE_ATTRIBUTES_ARRAY = *opaque{
};
// --------------------------------------------------------
// Type: DROPIMAGETYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const DROPIMAGETYPE = *opaque{
};
// --------------------------------------------------------
// Type: DROPDESCRIPTION
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const DROPDESCRIPTION = *opaque{
};
// --------------------------------------------------------
// Type: SHChangeNotifyEntry
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const SHChangeNotifyEntry = *opaque{
};
// --------------------------------------------------------
// Type: IShellChangeNotify
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IShellChangeNotify = *opaque{
    // TODO: Method 'OnChange'
};
// --------------------------------------------------------
// Type: IQueryInfo
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IQueryInfo = *opaque{
    // TODO: Method 'GetInfoTip'
    // TODO: Method 'GetInfoFlags'
};
// --------------------------------------------------------
// Type: SHARD
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const SHARD = *opaque{
};
// --------------------------------------------------------
// Type: SHARDAPPIDINFO
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const SHARDAPPIDINFO = *opaque{
};
// --------------------------------------------------------
// Type: SHARDAPPIDINFOIDLIST
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const SHARDAPPIDINFOIDLIST = *opaque{
};
// --------------------------------------------------------
// Type: SHARDAPPIDINFOLINK
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const SHARDAPPIDINFOLINK = *opaque{
};
// --------------------------------------------------------
// Type: SHChangeDWORDAsIDList
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const SHChangeDWORDAsIDList = *opaque{
};
// --------------------------------------------------------
// Type: SHChangeUpdateImageIDList
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const SHChangeUpdateImageIDList = *opaque{
};
// --------------------------------------------------------
// Type: SCNRT_STATUS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const SCNRT_STATUS = *opaque{
};
// --------------------------------------------------------
// Type: SHDESCRIPTIONID
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SHDESCRIPTIONID = extern struct {
    dwDescriptionId: u32,
    clsid: Guid,
};
// --------------------------------------------------------
// Type: AUTO_SCROLL_DATA
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const AUTO_SCROLL_DATA = *opaque{
};
// --------------------------------------------------------
// Type: CABINETSTATE
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const CABINETSTATE = *opaque{
};
// --------------------------------------------------------
// Type: HPSXA__
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const HPSXA__ = *opaque{
};
// --------------------------------------------------------
// Type: RESTRICTIONS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const RESTRICTIONS = *opaque{
};
// --------------------------------------------------------
// Type: tagOPEN_AS_INFO_FLAGS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const tagOPEN_AS_INFO_FLAGS = *opaque{
};
// --------------------------------------------------------
// Type: OPENASINFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const OPENASINFO = extern struct {
    pcszFile: ?*u16,
    pcszClass: ?*u16,
    oaifInFlags: i32,
};
// --------------------------------------------------------
// Type: IShellFolderViewCB
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IShellFolderViewCB = *opaque{
    // TODO: Method 'MessageSFVCB'
};
// --------------------------------------------------------
// Type: QCMINFO_IDMAP_PLACEMENT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const QCMINFO_IDMAP_PLACEMENT = extern struct {
    id: u32,
    fFlags: u32,
};
// --------------------------------------------------------
// Type: QCMINFO_IDMAP
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const QCMINFO_IDMAP = extern struct {
    nMaxIds: u32,
    pIdList: ?[*]QCMINFO_IDMAP_PLACEMENT,
};
// --------------------------------------------------------
// Type: QCMINFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const QCMINFO = extern struct {
    hmenu: HMENU,
    indexMenu: u32,
    idCmdFirst: u32,
    idCmdLast: u32,
    pIdMap: ?*QCMINFO_IDMAP,
};
// --------------------------------------------------------
// Type: DETAILSINFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DETAILSINFO = extern struct {
    pidl: ?*ITEMIDLIST,
    fmt: i32,
    cxChar: i32,
    str: STRRET,
    iImage: i32,
};
// --------------------------------------------------------
// Type: SFVM_PROPPAGE_DATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SFVM_PROPPAGE_DATA = extern struct {
    dwReserved: u32,
    pfn: LPFNADDPROPSHEETPAGE,
    lParam: LPARAM,
};
// --------------------------------------------------------
// Type: SFVM_HELPTOPIC_DATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SFVM_HELPTOPIC_DATA = extern struct {
    wszHelpFile: ?[*]u16,
    wszHelpTopic: ?[*]u16,
};
// --------------------------------------------------------
// Type: ITEMSPACING
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const ITEMSPACING = extern struct {
    cxSmall: i32,
    cySmall: i32,
    cxLarge: i32,
    cyLarge: i32,
};
// --------------------------------------------------------
// Type: IShellFolderView
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IShellFolderView = *opaque{
    // TODO: Method 'Rearrange'
    // TODO: Method 'GetArrangeParam'
    // TODO: Method 'ArrangeGrid'
    // TODO: Method 'AutoArrange'
    // TODO: Method 'GetAutoArrange'
    // TODO: Method 'AddObject'
    // TODO: Method 'GetObjectA'
    // TODO: Method 'RemoveObject'
    // TODO: Method 'GetObjectCount'
    // TODO: Method 'SetObjectCount'
    // TODO: Method 'UpdateObject'
    // TODO: Method 'RefreshObject'
    // TODO: Method 'SetRedraw'
    // TODO: Method 'GetSelectedCount'
    // TODO: Method 'GetSelectedObjects'
    // TODO: Method 'IsDropOnSource'
    // TODO: Method 'GetDragPoint'
    // TODO: Method 'GetDropPoint'
    // TODO: Method 'MoveIcons'
    // TODO: Method 'SetItemPos'
    // TODO: Method 'IsBkDropTarget'
    // TODO: Method 'SetClipboard'
    // TODO: Method 'SetPoints'
    // TODO: Method 'GetItemSpacing'
    // TODO: Method 'SetCallback'
    // TODO: Method 'Select'
    // TODO: Method 'QuerySupport'
    // TODO: Method 'SetAutomationObject'
};
// --------------------------------------------------------
// Type: SFV_CREATE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SFV_CREATE = extern struct {
    cbSize: u32,
    pshf: IShellFolder,
    psvOuter: IShellView,
    psfvcb: IShellFolderViewCB,
};
// --------------------------------------------------------
// Type: LPFNDFMCALLBACK
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const LPFNDFMCALLBACK = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: DEFCONTEXTMENU
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DEFCONTEXTMENU = extern struct {
    hwnd: HWND,
    pcmcb: IContextMenuCB,
    pidlFolder: ?*ITEMIDLIST,
    psf: IShellFolder,
    cidl: u32,
    apidl: ?*?*ITEMIDLIST,
    punkAssociationInfo: IUnknown,
    cKeys: u32,
    aKeys: ?*?*opaque{},
};
// --------------------------------------------------------
// Type: DFMICS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DFMICS = extern struct {
    cbSize: u32,
    fMask: u32,
    lParam: LPARAM,
    idCmdFirst: u32,
    idDefMax: u32,
    pici: ?*CMINVOKECOMMANDINFO,
    punkSite: IUnknown,
};
// --------------------------------------------------------
// Type: LPFNVIEWCALLBACK
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const LPFNVIEWCALLBACK = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: CSFV
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CSFV = extern struct {
    cbSize: u32,
    pshf: IShellFolder,
    psvOuter: IShellView,
    pidl: ?*ITEMIDLIST,
    lEvents: i32,
    pfnCallback: LPFNVIEWCALLBACK,
    fvm: FOLDERVIEWMODE,
};
// --------------------------------------------------------
// Type: SHELLSTATEA
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const SHELLSTATEA = *opaque{
};
// --------------------------------------------------------
// Type: SHELLSTATEW
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const SHELLSTATEW = *opaque{
};
// --------------------------------------------------------
// Type: SHELLFLAGSTATE
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const SHELLFLAGSTATE = *opaque{
};
// --------------------------------------------------------
// Type: INamedPropertyBag
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const INamedPropertyBag = *opaque{
    // TODO: Method 'ReadPropertyNPB'
    // TODO: Method 'WritePropertyNPB'
    // TODO: Method 'RemovePropertyNPB'
};
// --------------------------------------------------------
// Type: IESHORTCUTFLAGS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const IESHORTCUTFLAGS = *opaque{
};
// --------------------------------------------------------
// Type: INewShortcutHookA
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const INewShortcutHookA = *opaque{
    // TODO: Method 'SetReferent'
    // TODO: Method 'GetReferent'
    // TODO: Method 'SetFolder'
    // TODO: Method 'GetFolder'
    // TODO: Method 'GetName'
    // TODO: Method 'GetExtension'
};
// --------------------------------------------------------
// Type: INewShortcutHookW
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const INewShortcutHookW = *opaque{
    // TODO: Method 'SetReferent'
    // TODO: Method 'GetReferent'
    // TODO: Method 'SetFolder'
    // TODO: Method 'GetFolder'
    // TODO: Method 'GetName'
    // TODO: Method 'GetExtension'
};
// --------------------------------------------------------
// Type: ICopyHookA
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ICopyHookA = *opaque{
    // TODO: Method 'CopyCallback'
};
// --------------------------------------------------------
// Type: ICopyHookW
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ICopyHookW = *opaque{
    // TODO: Method 'CopyCallback'
};
// --------------------------------------------------------
// Type: ICurrentWorkingDirectory
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ICurrentWorkingDirectory = *opaque{
    // TODO: Method 'GetDirectory'
    // TODO: Method 'SetDirectory'
};
// --------------------------------------------------------
// Type: IDockingWindowFrame
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IDockingWindowFrame = *opaque{
    // TODO: Method 'AddToolbar'
    // TODO: Method 'RemoveToolbar'
    // TODO: Method 'FindToolbar'
};
// --------------------------------------------------------
// Type: IThumbnailCapture
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IThumbnailCapture = *opaque{
    // TODO: Method 'CaptureThumbnail'
};
// --------------------------------------------------------
// Type: BANDINFOSFB
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const BANDINFOSFB = extern struct {
    dwMask: u32,
    dwStateMask: u32,
    dwState: u32,
    crBkgnd: u32,
    crBtnLt: u32,
    crBtnDk: u32,
    wViewMode: u16,
    wAlign: u16,
    psf: IShellFolder,
    pidl: ?*ITEMIDLIST,
};
// --------------------------------------------------------
// Type: IShellFolderBand
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IShellFolderBand = *opaque{
    // TODO: Method 'InitializeSFB'
    // TODO: Method 'SetBandInfoSFB'
    // TODO: Method 'GetBandInfoSFB'
};
// --------------------------------------------------------
// Type: IDeskBarClient
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IDeskBarClient = *opaque{
    // TODO: Method 'SetDeskBarSite'
    // TODO: Method 'SetModeDBC'
    // TODO: Method 'UIActivateDBC'
    // TODO: Method 'GetSize'
};
// --------------------------------------------------------
// Type: SHCOLUMNINFO
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const SHCOLUMNINFO = *opaque{
};
// --------------------------------------------------------
// Type: SHCOLUMNINIT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SHCOLUMNINIT = extern struct {
    dwFlags: u32,
    dwReserved: u32,
    wszFolder: ?[*]u16,
};
// --------------------------------------------------------
// Type: SHCOLUMNDATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SHCOLUMNDATA = extern struct {
    dwFlags: u32,
    dwFileAttributes: u32,
    dwReserved: u32,
    pwszExt: ?*u16,
    wszFile: ?[*]u16,
};
// --------------------------------------------------------
// Type: IColumnProvider
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IColumnProvider = *opaque{
    // TODO: Method 'Initialize'
    // TODO: Method 'GetColumnInfo'
    // TODO: Method 'GetItemData'
};
// --------------------------------------------------------
// Type: SHChangeProductKeyAsIDList
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const SHChangeProductKeyAsIDList = *opaque{
};
// --------------------------------------------------------
// Type: IDocViewSite
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IDocViewSite = *opaque{
    // TODO: Method 'OnSetTitle'
};
// --------------------------------------------------------
// Type: IInitializeObject
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IInitializeObject = *opaque{
    // TODO: Method 'Initialize'
};
// --------------------------------------------------------
// Type: IBanneredBar
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IBanneredBar = *opaque{
    // TODO: Method 'SetIconSize'
    // TODO: Method 'GetIconSize'
    // TODO: Method 'SetBitmap'
    // TODO: Method 'GetBitmap'
};
// --------------------------------------------------------
// Type: TBINFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TBINFO = extern struct {
    cbuttons: u32,
    uFlags: u32,
};
// --------------------------------------------------------
// Type: SFV_SETITEMPOS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SFV_SETITEMPOS = extern struct {
    pidl: ?*ITEMIDLIST,
    pt: POINT,
};
// --------------------------------------------------------
// Type: AASHELLMENUFILENAME
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const AASHELLMENUFILENAME = extern struct {
    cbTotal: i16,
    rgbReserved: ?[*]u8,
    szFileName: ?[*]u16,
};
// --------------------------------------------------------
// Type: AASHELLMENUITEM
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const AASHELLMENUITEM = extern struct {
    lpReserved1: ?*opaque{},
    iReserved: i32,
    uiReserved: u32,
    lpName: ?*AASHELLMENUFILENAME,
    psz: ?*u16,
};
// --------------------------------------------------------
// Type: DISPLAY_DEVICE_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const DISPLAY_DEVICE_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: SCALE_CHANGE_FLAGS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const SCALE_CHANGE_FLAGS = *opaque{
};
// --------------------------------------------------------
// Type: SHELL_UI_COMPONENT
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const SHELL_UI_COMPONENT = *opaque{
};
// --------------------------------------------------------
// Type: tagSFBS_FLAGS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const tagSFBS_FLAGS = *opaque{
};
// --------------------------------------------------------
// Type: URL_SCHEME
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const URL_SCHEME = *opaque{
};
// --------------------------------------------------------
// Type: URL_PART
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const URL_PART = *opaque{
};
// --------------------------------------------------------
// Type: URLIS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const URLIS = *opaque{
};
// --------------------------------------------------------
// Type: PARSEDURLA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PARSEDURLA = extern struct {
    cbSize: u32,
    pszProtocol: ?*i8,
    cchProtocol: u32,
    pszSuffix: ?*i8,
    cchSuffix: u32,
    nScheme: u32,
};
// --------------------------------------------------------
// Type: PARSEDURLW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PARSEDURLW = extern struct {
    cbSize: u32,
    pszProtocol: ?*u16,
    cchProtocol: u32,
    pszSuffix: ?*u16,
    cchSuffix: u32,
    nScheme: u32,
};
// --------------------------------------------------------
// Type: SHREGDEL_FLAGS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const SHREGDEL_FLAGS = *opaque{
};
// --------------------------------------------------------
// Type: SHREGENUM_FLAGS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const SHREGENUM_FLAGS = *opaque{
};
// --------------------------------------------------------
// Type: ASSOCSTR
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const ASSOCSTR = *opaque{
};
// --------------------------------------------------------
// Type: ASSOCKEY
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const ASSOCKEY = *opaque{
};
// --------------------------------------------------------
// Type: ASSOCDATA
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const ASSOCDATA = *opaque{
};
// --------------------------------------------------------
// Type: ASSOCENUM
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const ASSOCENUM = *opaque{
};
// --------------------------------------------------------
// Type: FILETYPEATTRIBUTEFLAGS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const FILETYPEATTRIBUTEFLAGS = *opaque{
};
// --------------------------------------------------------
// Type: IQueryAssociations
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IQueryAssociations = *opaque{
    // TODO: Method 'Init'
    // TODO: Method 'GetString'
    // TODO: Method 'GetKey'
    // TODO: Method 'GetData'
    // TODO: Method 'GetEnum'
};
// --------------------------------------------------------
// Type: SHGLOBALCOUNTER
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const SHGLOBALCOUNTER = *opaque{
};
// --------------------------------------------------------
// Type: QITAB
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const QITAB = extern struct {
    piid: ?*Guid,
    dwOffset: u32,
};
// --------------------------------------------------------
// Type: DLLVERSIONINFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DLLVERSIONINFO = extern struct {
    cbSize: u32,
    dwMajorVersion: u32,
    dwMinorVersion: u32,
    dwBuildNumber: u32,
    dwPlatformID: u32,
};
// --------------------------------------------------------
// Type: DLLVERSIONINFO2
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DLLVERSIONINFO2 = extern struct {
    info1: DLLVERSIONINFO,
    dwFlags: u32,
    ullVersion: u64,
};
// --------------------------------------------------------
// Type: DLLGETVERSIONPROC
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const DLLGETVERSIONPROC = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: APPINFODATAFLAGS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const APPINFODATAFLAGS = *opaque{
};
// --------------------------------------------------------
// Type: APPINFODATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const APPINFODATA = extern struct {
    cbSize: u32,
    dwMask: u32,
    pszDisplayName: ?*u16,
    pszVersion: ?*u16,
    pszPublisher: ?*u16,
    pszProductID: ?*u16,
    pszRegisteredOwner: ?*u16,
    pszRegisteredCompany: ?*u16,
    pszLanguage: ?*u16,
    pszSupportUrl: ?*u16,
    pszSupportTelephone: ?*u16,
    pszHelpLink: ?*u16,
    pszInstallLocation: ?*u16,
    pszInstallSource: ?*u16,
    pszInstallDate: ?*u16,
    pszContact: ?*u16,
    pszComments: ?*u16,
    pszImage: ?*u16,
    pszReadmeUrl: ?*u16,
    pszUpdateInfoUrl: ?*u16,
};
// --------------------------------------------------------
// Type: APPACTIONFLAGS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const APPACTIONFLAGS = *opaque{
};
// --------------------------------------------------------
// Type: SLOWAPPINFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SLOWAPPINFO = extern struct {
    ullSize: u64,
    ftLastUsed: FILETIME,
    iTimesUsed: i32,
    pszImage: ?*u16,
};
// --------------------------------------------------------
// Type: IShellApp
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IShellApp = *opaque{
    // TODO: Method 'GetAppInfo'
    // TODO: Method 'GetPossibleActions'
    // TODO: Method 'GetSlowAppInfo'
    // TODO: Method 'GetCachedSlowAppInfo'
    // TODO: Method 'IsInstalled'
};
// --------------------------------------------------------
// Type: PUBAPPINFOFLAGS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PUBAPPINFOFLAGS = *opaque{
};
// --------------------------------------------------------
// Type: PUBAPPINFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PUBAPPINFO = extern struct {
    cbSize: u32,
    dwMask: u32,
    pszSource: ?*u16,
    stAssigned: SYSTEMTIME,
    stPublished: SYSTEMTIME,
    stScheduled: SYSTEMTIME,
    stExpire: SYSTEMTIME,
};
// --------------------------------------------------------
// Type: IPublishedApp
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IPublishedApp = *opaque{
    // TODO: Method 'Install'
    // TODO: Method 'GetPublishedAppInfo'
    // TODO: Method 'Unschedule'
};
// --------------------------------------------------------
// Type: IPublishedApp2
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IPublishedApp2 = *opaque{
    // TODO: Method 'Install2'
};
// --------------------------------------------------------
// Type: IEnumPublishedApps
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IEnumPublishedApps = *opaque{
    // TODO: Method 'Next'
    // TODO: Method 'Reset'
};
// --------------------------------------------------------
// Type: IAppPublisher
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IAppPublisher = *opaque{
    // TODO: Method 'GetNumberOfCategories'
    // TODO: Method 'GetCategories'
    // TODO: Method 'GetNumberOfApps'
    // TODO: Method 'EnumApps'
};
// --------------------------------------------------------
// Type: PasswordCredentialProvider
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const PasswordCredentialProvider = opaque {
};
// --------------------------------------------------------
// Type: V1PasswordCredentialProvider
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const V1PasswordCredentialProvider = opaque {
};
// --------------------------------------------------------
// Type: PINLogonCredentialProvider
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const PINLogonCredentialProvider = opaque {
};
// --------------------------------------------------------
// Type: NPCredentialProvider
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const NPCredentialProvider = opaque {
};
// --------------------------------------------------------
// Type: SmartcardCredentialProvider
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const SmartcardCredentialProvider = opaque {
};
// --------------------------------------------------------
// Type: V1SmartcardCredentialProvider
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const V1SmartcardCredentialProvider = opaque {
};
// --------------------------------------------------------
// Type: SmartcardPinProvider
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const SmartcardPinProvider = opaque {
};
// --------------------------------------------------------
// Type: SmartcardReaderSelectionProvider
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const SmartcardReaderSelectionProvider = opaque {
};
// --------------------------------------------------------
// Type: SmartcardWinRTProvider
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const SmartcardWinRTProvider = opaque {
};
// --------------------------------------------------------
// Type: GenericCredentialProvider
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const GenericCredentialProvider = opaque {
};
// --------------------------------------------------------
// Type: RASProvider
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const RASProvider = opaque {
};
// --------------------------------------------------------
// Type: OnexCredentialProvider
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const OnexCredentialProvider = opaque {
};
// --------------------------------------------------------
// Type: OnexPlapSmartcardCredentialProvider
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const OnexPlapSmartcardCredentialProvider = opaque {
};
// --------------------------------------------------------
// Type: VaultProvider
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const VaultProvider = opaque {
};
// --------------------------------------------------------
// Type: WinBioCredentialProvider
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const WinBioCredentialProvider = opaque {
};
// --------------------------------------------------------
// Type: V1WinBioCredentialProvider
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const V1WinBioCredentialProvider = opaque {
};
// --------------------------------------------------------
// Type: CREDENTIAL_PROVIDER_USAGE_SCENARIO
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const CREDENTIAL_PROVIDER_USAGE_SCENARIO = *opaque{
};
// --------------------------------------------------------
// Type: CREDENTIAL_PROVIDER_FIELD_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const CREDENTIAL_PROVIDER_FIELD_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: CREDENTIAL_PROVIDER_FIELD_STATE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const CREDENTIAL_PROVIDER_FIELD_STATE = *opaque{
};
// --------------------------------------------------------
// Type: CREDENTIAL_PROVIDER_FIELD_INTERACTIVE_STATE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const CREDENTIAL_PROVIDER_FIELD_INTERACTIVE_STATE = *opaque{
};
// --------------------------------------------------------
// Type: CREDENTIAL_PROVIDER_FIELD_DESCRIPTOR
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CREDENTIAL_PROVIDER_FIELD_DESCRIPTOR = extern struct {
    dwFieldID: u32,
    cpft: CREDENTIAL_PROVIDER_FIELD_TYPE,
    pszLabel: ?*u16,
    guidFieldType: Guid,
};
// --------------------------------------------------------
// Type: CREDENTIAL_PROVIDER_GET_SERIALIZATION_RESPONSE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const CREDENTIAL_PROVIDER_GET_SERIALIZATION_RESPONSE = *opaque{
};
// --------------------------------------------------------
// Type: CREDENTIAL_PROVIDER_STATUS_ICON
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const CREDENTIAL_PROVIDER_STATUS_ICON = *opaque{
};
// --------------------------------------------------------
// Type: CREDENTIAL_PROVIDER_CREDENTIAL_SERIALIZATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CREDENTIAL_PROVIDER_CREDENTIAL_SERIALIZATION = extern struct {
    ulAuthenticationPackage: u32,
    clsidCredentialProvider: Guid,
    cbSerialization: u32,
    rgbSerialization: ?*u8,
};
// --------------------------------------------------------
// Type: CREDENTIAL_PROVIDER_ACCOUNT_OPTIONS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const CREDENTIAL_PROVIDER_ACCOUNT_OPTIONS = *opaque{
};
// --------------------------------------------------------
// Type: CREDENTIAL_PROVIDER_CREDENTIAL_FIELD_OPTIONS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const CREDENTIAL_PROVIDER_CREDENTIAL_FIELD_OPTIONS = *opaque{
};
// --------------------------------------------------------
// Type: ICredentialProviderCredential
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ICredentialProviderCredential = *opaque{
    // TODO: Method 'Advise'
    // TODO: Method 'UnAdvise'
    // TODO: Method 'SetSelected'
    // TODO: Method 'SetDeselected'
    // TODO: Method 'GetFieldState'
    // TODO: Method 'GetStringValue'
    // TODO: Method 'GetBitmapValue'
    // TODO: Method 'GetCheckboxValue'
    // TODO: Method 'GetSubmitButtonValue'
    // TODO: Method 'GetComboBoxValueCount'
    // TODO: Method 'GetComboBoxValueAt'
    // TODO: Method 'SetStringValue'
    // TODO: Method 'SetCheckboxValue'
    // TODO: Method 'SetComboBoxSelectedValue'
    // TODO: Method 'CommandLinkClicked'
    // TODO: Method 'GetSerialization'
    // TODO: Method 'ReportResult'
};
// --------------------------------------------------------
// Type: IQueryContinueWithStatus
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IQueryContinueWithStatus = *opaque{
    // TODO: Method 'SetStatusMessage'
};
// --------------------------------------------------------
// Type: IConnectableCredentialProviderCredential
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IConnectableCredentialProviderCredential = *opaque{
    // TODO: Method 'Connect'
    // TODO: Method 'Disconnect'
};
// --------------------------------------------------------
// Type: ICredentialProviderCredentialEvents
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ICredentialProviderCredentialEvents = *opaque{
    // TODO: Method 'SetFieldState'
    // TODO: Method 'SetFieldInteractiveState'
    // TODO: Method 'SetFieldString'
    // TODO: Method 'SetFieldCheckbox'
    // TODO: Method 'SetFieldBitmap'
    // TODO: Method 'SetFieldComboBoxSelectedItem'
    // TODO: Method 'DeleteFieldComboBoxItem'
    // TODO: Method 'AppendFieldComboBoxItem'
    // TODO: Method 'SetFieldSubmitButton'
    // TODO: Method 'OnCreatingWindow'
};
// --------------------------------------------------------
// Type: ICredentialProvider
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ICredentialProvider = *opaque{
    // TODO: Method 'SetUsageScenario'
    // TODO: Method 'SetSerialization'
    // TODO: Method 'Advise'
    // TODO: Method 'UnAdvise'
    // TODO: Method 'GetFieldDescriptorCount'
    // TODO: Method 'GetFieldDescriptorAt'
    // TODO: Method 'GetCredentialCount'
    // TODO: Method 'GetCredentialAt'
};
// --------------------------------------------------------
// Type: ICredentialProviderEvents
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ICredentialProviderEvents = *opaque{
    // TODO: Method 'CredentialsChanged'
};
// --------------------------------------------------------
// Type: ICredentialProviderFilter
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ICredentialProviderFilter = *opaque{
    // TODO: Method 'Filter'
    // TODO: Method 'UpdateRemoteCredential'
};
// --------------------------------------------------------
// Type: ICredentialProviderCredential2
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ICredentialProviderCredential2 = *opaque{
    // TODO: Method 'GetUserSid'
};
// --------------------------------------------------------
// Type: ICredentialProviderCredentialWithFieldOptions
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ICredentialProviderCredentialWithFieldOptions = *opaque{
    // TODO: Method 'GetFieldOptions'
};
// --------------------------------------------------------
// Type: ICredentialProviderCredentialEvents2
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ICredentialProviderCredentialEvents2 = *opaque{
    // TODO: Method 'BeginFieldUpdates'
    // TODO: Method 'EndFieldUpdates'
    // TODO: Method 'SetFieldOptions'
};
// --------------------------------------------------------
// Type: ICredentialProviderUser
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ICredentialProviderUser = *opaque{
    // TODO: Method 'GetSid'
    // TODO: Method 'GetProviderID'
    // TODO: Method 'GetStringValue'
    // TODO: Method 'GetValue'
};
// --------------------------------------------------------
// Type: ICredentialProviderUserArray
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ICredentialProviderUserArray = *opaque{
    // TODO: Method 'SetProviderFilter'
    // TODO: Method 'GetAccountOptions'
    // TODO: Method 'GetCount'
    // TODO: Method 'GetAt'
};
// --------------------------------------------------------
// Type: ICredentialProviderSetUserArray
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ICredentialProviderSetUserArray = *opaque{
    // TODO: Method 'SetUserArray'
};
// --------------------------------------------------------
// Type: SyncMgrClient
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const SyncMgrClient = opaque {
};
// --------------------------------------------------------
// Type: SyncMgrControl
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const SyncMgrControl = opaque {
};
// --------------------------------------------------------
// Type: SyncMgrScheduleWizard
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const SyncMgrScheduleWizard = opaque {
};
// --------------------------------------------------------
// Type: SyncMgrFolder
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const SyncMgrFolder = opaque {
};
// --------------------------------------------------------
// Type: SyncSetupFolder
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const SyncSetupFolder = opaque {
};
// --------------------------------------------------------
// Type: ConflictFolder
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const ConflictFolder = opaque {
};
// --------------------------------------------------------
// Type: SyncResultsFolder
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const SyncResultsFolder = opaque {
};
// --------------------------------------------------------
// Type: SimpleConflictPresenter
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const SimpleConflictPresenter = opaque {
};
// --------------------------------------------------------
// Type: ISyncMgrHandlerCollection
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ISyncMgrHandlerCollection = *opaque{
    // TODO: Method 'GetHandlerEnumerator'
    // TODO: Method 'BindToHandler'
};
// --------------------------------------------------------
// Type: SYNCMGR_HANDLER_CAPABILITIES
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const SYNCMGR_HANDLER_CAPABILITIES = *opaque{
};
// --------------------------------------------------------
// Type: SYNCMGR_HANDLER_POLICIES
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const SYNCMGR_HANDLER_POLICIES = *opaque{
};
// --------------------------------------------------------
// Type: ISyncMgrHandler
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ISyncMgrHandler = *opaque{
    // TODO: Method 'GetName'
    // TODO: Method 'GetHandlerInfo'
    // TODO: Method 'GetObjectA'
    // TODO: Method 'GetCapabilities'
    // TODO: Method 'GetPolicies'
    // TODO: Method 'Activate'
    // TODO: Method 'Enable'
    // TODO: Method 'Synchronize'
};
// --------------------------------------------------------
// Type: SYNCMGR_HANDLER_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const SYNCMGR_HANDLER_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: ISyncMgrHandlerInfo
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ISyncMgrHandlerInfo = *opaque{
    // TODO: Method 'GetType'
    // TODO: Method 'GetTypeLabel'
    // TODO: Method 'GetComment'
    // TODO: Method 'GetLastSyncTime'
    // TODO: Method 'IsActive'
    // TODO: Method 'IsEnabled'
    // TODO: Method 'IsConnected'
};
// --------------------------------------------------------
// Type: ISyncMgrSyncItemContainer
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ISyncMgrSyncItemContainer = *opaque{
    // TODO: Method 'GetSyncItem'
    // TODO: Method 'GetSyncItemEnumerator'
    // TODO: Method 'GetSyncItemCount'
};
// --------------------------------------------------------
// Type: SYNCMGR_ITEM_CAPABILITIES
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const SYNCMGR_ITEM_CAPABILITIES = *opaque{
};
// --------------------------------------------------------
// Type: SYNCMGR_ITEM_POLICIES
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const SYNCMGR_ITEM_POLICIES = *opaque{
};
// --------------------------------------------------------
// Type: ISyncMgrSyncItem
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ISyncMgrSyncItem = *opaque{
    // TODO: Method 'GetItemID'
    // TODO: Method 'GetName'
    // TODO: Method 'GetItemInfo'
    // TODO: Method 'GetObjectA'
    // TODO: Method 'GetCapabilities'
    // TODO: Method 'GetPolicies'
    // TODO: Method 'Enable'
    // TODO: Method 'Delete'
};
// --------------------------------------------------------
// Type: ISyncMgrSyncItemInfo
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ISyncMgrSyncItemInfo = *opaque{
    // TODO: Method 'GetTypeLabel'
    // TODO: Method 'GetComment'
    // TODO: Method 'GetLastSyncTime'
    // TODO: Method 'IsEnabled'
    // TODO: Method 'IsConnected'
};
// --------------------------------------------------------
// Type: IEnumSyncMgrSyncItems
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IEnumSyncMgrSyncItems = *opaque{
    // TODO: Method 'Next'
    // TODO: Method 'Skip'
    // TODO: Method 'Reset'
    // TODO: Method 'Clone'
};
// --------------------------------------------------------
// Type: SYNCMGR_PROGRESS_STATUS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const SYNCMGR_PROGRESS_STATUS = *opaque{
};
// --------------------------------------------------------
// Type: SYNCMGR_CANCEL_REQUEST
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const SYNCMGR_CANCEL_REQUEST = *opaque{
};
// --------------------------------------------------------
// Type: SYNCMGR_EVENT_LEVEL
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const SYNCMGR_EVENT_LEVEL = *opaque{
};
// --------------------------------------------------------
// Type: SYNCMGR_EVENT_FLAGS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const SYNCMGR_EVENT_FLAGS = *opaque{
};
// --------------------------------------------------------
// Type: ISyncMgrSessionCreator
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ISyncMgrSessionCreator = *opaque{
    // TODO: Method 'CreateSession'
};
// --------------------------------------------------------
// Type: ISyncMgrSyncCallback
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ISyncMgrSyncCallback = *opaque{
    // TODO: Method 'ReportProgress'
    // TODO: Method 'SetHandlerProgressText'
    // TODO: Method 'ReportEventA'
    // TODO: Method 'CanContinue'
    // TODO: Method 'QueryForAdditionalItems'
    // TODO: Method 'AddItemToSession'
    // TODO: Method 'AddIUnknownToSession'
    // TODO: Method 'ProposeItem'
    // TODO: Method 'CommitItem'
    // TODO: Method 'ReportManualSync'
};
// --------------------------------------------------------
// Type: ISyncMgrUIOperation
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ISyncMgrUIOperation = *opaque{
    // TODO: Method 'Run'
};
// --------------------------------------------------------
// Type: ISyncMgrEventLinkUIOperation
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ISyncMgrEventLinkUIOperation = *opaque{
    // TODO: Method 'Init'
};
// --------------------------------------------------------
// Type: ISyncMgrScheduleWizardUIOperation
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ISyncMgrScheduleWizardUIOperation = *opaque{
    // TODO: Method 'InitWizard'
};
// --------------------------------------------------------
// Type: ISyncMgrSyncResult
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ISyncMgrSyncResult = *opaque{
    // TODO: Method 'Result'
};
// --------------------------------------------------------
// Type: SYNCMGR_CONTROL_FLAGS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const SYNCMGR_CONTROL_FLAGS = *opaque{
};
// --------------------------------------------------------
// Type: SYNCMGR_SYNC_CONTROL_FLAGS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const SYNCMGR_SYNC_CONTROL_FLAGS = *opaque{
};
// --------------------------------------------------------
// Type: SYNCMGR_UPDATE_REASON
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const SYNCMGR_UPDATE_REASON = *opaque{
};
// --------------------------------------------------------
// Type: ISyncMgrControl
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ISyncMgrControl = *opaque{
    // TODO: Method 'StartHandlerSync'
    // TODO: Method 'StartItemSync'
    // TODO: Method 'StartSyncAll'
    // TODO: Method 'StopHandlerSync'
    // TODO: Method 'StopItemSync'
    // TODO: Method 'StopSyncAll'
    // TODO: Method 'UpdateHandlerCollection'
    // TODO: Method 'UpdateHandler'
    // TODO: Method 'UpdateItem'
    // TODO: Method 'UpdateEvents'
    // TODO: Method 'UpdateConflict'
    // TODO: Method 'UpdateConflicts'
    // TODO: Method 'ActivateHandler'
    // TODO: Method 'EnableHandler'
    // TODO: Method 'EnableItem'
};
// --------------------------------------------------------
// Type: ISyncMgrEventStore
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ISyncMgrEventStore = *opaque{
    // TODO: Method 'GetEventEnumerator'
    // TODO: Method 'GetEventCount'
    // TODO: Method 'GetEvent'
    // TODO: Method 'RemoveEvent'
};
// --------------------------------------------------------
// Type: ISyncMgrEvent
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ISyncMgrEvent = *opaque{
    // TODO: Method 'GetEventID'
    // TODO: Method 'GetHandlerID'
    // TODO: Method 'GetItemID'
    // TODO: Method 'GetLevel'
    // TODO: Method 'GetFlags'
    // TODO: Method 'GetTime'
    // TODO: Method 'GetName'
    // TODO: Method 'GetDescription'
    // TODO: Method 'GetLinkText'
    // TODO: Method 'GetLinkReference'
    // TODO: Method 'GetContext'
};
// --------------------------------------------------------
// Type: IEnumSyncMgrEvents
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IEnumSyncMgrEvents = *opaque{
    // TODO: Method 'Next'
    // TODO: Method 'Skip'
    // TODO: Method 'Reset'
    // TODO: Method 'Clone'
};
// --------------------------------------------------------
// Type: SYNCMGR_CONFLICT_ID_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SYNCMGR_CONFLICT_ID_INFO = extern struct {
    pblobID: ?*BYTE_BLOB,
    pblobExtra: ?*BYTE_BLOB,
};
// --------------------------------------------------------
// Type: ISyncMgrConflictStore
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ISyncMgrConflictStore = *opaque{
    // TODO: Method 'EnumConflicts'
    // TODO: Method 'BindToConflict'
    // TODO: Method 'RemoveConflicts'
    // TODO: Method 'GetCount'
};
// --------------------------------------------------------
// Type: IEnumSyncMgrConflict
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IEnumSyncMgrConflict = *opaque{
    // TODO: Method 'Next'
    // TODO: Method 'Skip'
    // TODO: Method 'Reset'
    // TODO: Method 'Clone'
};
// --------------------------------------------------------
// Type: SYNCMGR_CONFLICT_ITEM_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const SYNCMGR_CONFLICT_ITEM_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: ISyncMgrConflict
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ISyncMgrConflict = *opaque{
    // TODO: Method 'GetProperty'
    // TODO: Method 'GetConflictIdInfo'
    // TODO: Method 'GetItemsArray'
    // TODO: Method 'Resolve'
    // TODO: Method 'GetResolutionHandler'
};
// --------------------------------------------------------
// Type: SYNCMGR_RESOLUTION_ABILITIES
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const SYNCMGR_RESOLUTION_ABILITIES = *opaque{
};
// --------------------------------------------------------
// Type: SYNCMGR_RESOLUTION_FEEDBACK
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const SYNCMGR_RESOLUTION_FEEDBACK = *opaque{
};
// --------------------------------------------------------
// Type: ISyncMgrResolutionHandler
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ISyncMgrResolutionHandler = *opaque{
    // TODO: Method 'QueryAbilities'
    // TODO: Method 'KeepOther'
    // TODO: Method 'KeepRecent'
    // TODO: Method 'RemoveFromSyncSet'
    // TODO: Method 'KeepItems'
};
// --------------------------------------------------------
// Type: ISyncMgrConflictPresenter
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ISyncMgrConflictPresenter = *opaque{
    // TODO: Method 'PresentConflict'
};
// --------------------------------------------------------
// Type: SYNCMGR_PRESENTER_NEXT_STEP
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const SYNCMGR_PRESENTER_NEXT_STEP = *opaque{
};
// --------------------------------------------------------
// Type: SYNCMGR_PRESENTER_CHOICE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const SYNCMGR_PRESENTER_CHOICE = *opaque{
};
// --------------------------------------------------------
// Type: ISyncMgrConflictResolveInfo
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ISyncMgrConflictResolveInfo = *opaque{
    // TODO: Method 'GetIterationInfo'
    // TODO: Method 'GetPresenterNextStep'
    // TODO: Method 'GetPresenterChoice'
    // TODO: Method 'GetItemChoiceCount'
    // TODO: Method 'GetItemChoice'
    // TODO: Method 'SetPresenterNextStep'
    // TODO: Method 'SetPresenterChoice'
    // TODO: Method 'SetItemChoices'
};
// --------------------------------------------------------
// Type: ISyncMgrConflictFolder
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ISyncMgrConflictFolder = *opaque{
    // TODO: Method 'GetConflictIDList'
};
// --------------------------------------------------------
// Type: CONFIRM_CONFLICT_ITEM
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CONFIRM_CONFLICT_ITEM = extern struct {
    pShellItem: IShellItem2,
    pszOriginalName: ?*u16,
    pszAlternateName: ?*u16,
    pszLocationShort: ?*u16,
    pszLocationFull: ?*u16,
    nType: SYNCMGR_CONFLICT_ITEM_TYPE,
};
// --------------------------------------------------------
// Type: CONFIRM_CONFLICT_RESULT_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CONFIRM_CONFLICT_RESULT_INFO = extern struct {
    pszNewName: ?*u16,
    iItemIndex: u32,
};
// --------------------------------------------------------
// Type: ISyncMgrConflictItems
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ISyncMgrConflictItems = *opaque{
    // TODO: Method 'GetCount'
    // TODO: Method 'GetItem'
};
// --------------------------------------------------------
// Type: ISyncMgrConflictResolutionItems
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ISyncMgrConflictResolutionItems = *opaque{
    // TODO: Method 'GetCount'
    // TODO: Method 'GetItem'
};
// --------------------------------------------------------
// Type: InputPanelConfiguration
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const InputPanelConfiguration = opaque {
};
// --------------------------------------------------------
// Type: IInputPanelConfiguration
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IInputPanelConfiguration = *opaque{
    // TODO: Method 'EnableFocusTracking'
};
// --------------------------------------------------------
// Type: IInputPanelInvocationConfiguration
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IInputPanelInvocationConfiguration = *opaque{
    // TODO: Method 'RequireTouchInEditControl'
};
// --------------------------------------------------------
// Type: LocalThumbnailCache
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const LocalThumbnailCache = opaque {
};
// --------------------------------------------------------
// Type: SharedBitmap
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const SharedBitmap = opaque {
};
// --------------------------------------------------------
// Type: WTS_FLAGS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const WTS_FLAGS = *opaque{
};
// --------------------------------------------------------
// Type: WTS_CACHEFLAGS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const WTS_CACHEFLAGS = *opaque{
};
// --------------------------------------------------------
// Type: WTS_CONTEXTFLAGS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const WTS_CONTEXTFLAGS = *opaque{
};
// --------------------------------------------------------
// Type: WTS_ALPHATYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const WTS_ALPHATYPE = *opaque{
};
// --------------------------------------------------------
// Type: WTS_THUMBNAILID
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const WTS_THUMBNAILID = extern struct {
    rgbKey: ?[*]u8,
};
// --------------------------------------------------------
// Type: ISharedBitmap
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ISharedBitmap = *opaque{
    // TODO: Method 'GetSharedBitmap'
    // TODO: Method 'GetSize'
    // TODO: Method 'GetFormat'
    // TODO: Method 'InitializeBitmap'
    // TODO: Method 'Detach'
};
// --------------------------------------------------------
// Type: IThumbnailCache
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IThumbnailCache = *opaque{
    // TODO: Method 'GetThumbnail'
    // TODO: Method 'GetThumbnailByID'
};
// --------------------------------------------------------
// Type: IThumbnailProvider
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IThumbnailProvider = *opaque{
    // TODO: Method 'GetThumbnail'
};
// --------------------------------------------------------
// Type: IThumbnailSettings
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IThumbnailSettings = *opaque{
    // TODO: Method 'SetContext'
};
// --------------------------------------------------------
// Type: IThumbnailCachePrimer
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IThumbnailCachePrimer = *opaque{
    // TODO: Method 'PageInThumbnail'
};
// --------------------------------------------------------
// Type: ShellImageDataFactory
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const ShellImageDataFactory = opaque {
};
// --------------------------------------------------------
// Type: IShellImageDataFactory
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IShellImageDataFactory = *opaque{
    // TODO: Method 'CreateIShellImageData'
    // TODO: Method 'CreateImageFromFile'
    // TODO: Method 'CreateImageFromStream'
    // TODO: Method 'GetDataFormatFromPath'
};
// --------------------------------------------------------
// Type: IShellImageData
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IShellImageData = *opaque{
    // TODO: Method 'Decode'
    // TODO: Method 'Draw'
    // TODO: Method 'NextFrame'
    // TODO: Method 'NextPage'
    // TODO: Method 'PrevPage'
    // TODO: Method 'IsTransparent'
    // TODO: Method 'IsAnimated'
    // TODO: Method 'IsVector'
    // TODO: Method 'IsMultipage'
    // TODO: Method 'IsEditable'
    // TODO: Method 'IsPrintable'
    // TODO: Method 'IsDecoded'
    // TODO: Method 'GetCurrentPage'
    // TODO: Method 'GetPageCount'
    // TODO: Method 'SelectPage'
    // TODO: Method 'GetSize'
    // TODO: Method 'GetRawDataFormat'
    // TODO: Method 'GetPixelFormat'
    // TODO: Method 'GetDelay'
    // TODO: Method 'GetProperties'
    // TODO: Method 'Rotate'
    // TODO: Method 'Scale'
    // TODO: Method 'DiscardEdit'
    // TODO: Method 'SetEncoderParams'
    // TODO: Method 'DisplayName'
    // TODO: Method 'GetResolution'
    // TODO: Method 'GetEncoderParams'
    // TODO: Method 'RegisterAbort'
    // TODO: Method 'CloneFrame'
    // TODO: Method 'ReplaceFrame'
};
// --------------------------------------------------------
// Type: IShellImageDataAbort
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IShellImageDataAbort = *opaque{
    // TODO: Method 'QueryAbort'
};
// --------------------------------------------------------
// Type: IStorageProviderPropertyHandler
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IStorageProviderPropertyHandler = *opaque{
    // TODO: Method 'RetrieveProperties'
    // TODO: Method 'SaveProperties'
};
// --------------------------------------------------------
// Type: IStorageProviderHandler
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IStorageProviderHandler = *opaque{
    // TODO: Method 'GetPropertyHandlerFromPath'
    // TODO: Method 'GetPropertyHandlerFromUri'
    // TODO: Method 'GetPropertyHandlerFromFileId'
};
// --------------------------------------------------------
// Type: SyncMgr
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const SyncMgr = opaque {
};
// --------------------------------------------------------
// Type: SYNCMGRSTATUS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const SYNCMGRSTATUS = *opaque{
};
// --------------------------------------------------------
// Type: SYNCMGRPROGRESSITEM
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SYNCMGRPROGRESSITEM = extern struct {
    cbSize: u32,
    mask: u32,
    lpcStatusText: ?*u16,
    dwStatusType: u32,
    iProgValue: i32,
    iMaxValue: i32,
};
// --------------------------------------------------------
// Type: SYNCMGRLOGLEVEL
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const SYNCMGRLOGLEVEL = *opaque{
};
// --------------------------------------------------------
// Type: SYNCMGRERRORFLAGS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const SYNCMGRERRORFLAGS = *opaque{
};
// --------------------------------------------------------
// Type: SYNCMGRLOGERRORINFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SYNCMGRLOGERRORINFO = extern struct {
    cbSize: u32,
    mask: u32,
    dwSyncMgrErrorFlags: u32,
    ErrorID: Guid,
    ItemID: Guid,
};
// --------------------------------------------------------
// Type: ISyncMgrSynchronizeCallback
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ISyncMgrSynchronizeCallback = *opaque{
    // TODO: Method 'ShowPropertiesCompleted'
    // TODO: Method 'PrepareForSyncCompleted'
    // TODO: Method 'SynchronizeCompleted'
    // TODO: Method 'ShowErrorCompleted'
    // TODO: Method 'EnableModeless'
    // TODO: Method 'Progress'
    // TODO: Method 'LogError'
    // TODO: Method 'DeleteLogError'
    // TODO: Method 'EstablishConnection'
};
// --------------------------------------------------------
// Type: SYNCMGRITEMFLAGS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const SYNCMGRITEMFLAGS = *opaque{
};
// --------------------------------------------------------
// Type: SYNCMGRITEM
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SYNCMGRITEM = extern struct {
    cbSize: u32,
    dwFlags: u32,
    ItemID: Guid,
    dwItemState: u32,
    hIcon: HICON,
    wszItemName: ?[*]u16,
    ftLastUpdate: FILETIME,
};
// --------------------------------------------------------
// Type: ISyncMgrEnumItems
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ISyncMgrEnumItems = *opaque{
    // TODO: Method 'Next'
    // TODO: Method 'Skip'
    // TODO: Method 'Reset'
    // TODO: Method 'Clone'
};
// --------------------------------------------------------
// Type: SYNCMGRFLAG
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const SYNCMGRFLAG = *opaque{
};
// --------------------------------------------------------
// Type: SYNCMGRHANDLERFLAGS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const SYNCMGRHANDLERFLAGS = *opaque{
};
// --------------------------------------------------------
// Type: SYNCMGRHANDLERINFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SYNCMGRHANDLERINFO = extern struct {
    cbSize: u32,
    hIcon: HICON,
    SyncMgrHandlerFlags: u32,
    wszHandlerName: ?[*]u16,
};
// --------------------------------------------------------
// Type: SYNCMGRITEMSTATE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const SYNCMGRITEMSTATE = *opaque{
};
// --------------------------------------------------------
// Type: ISyncMgrSynchronize
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ISyncMgrSynchronize = *opaque{
    // TODO: Method 'Initialize'
    // TODO: Method 'GetHandlerInfo'
    // TODO: Method 'EnumSyncMgrItems'
    // TODO: Method 'GetItemObject'
    // TODO: Method 'ShowProperties'
    // TODO: Method 'SetProgressCallback'
    // TODO: Method 'PrepareForSync'
    // TODO: Method 'Synchronize'
    // TODO: Method 'SetItemStatus'
    // TODO: Method 'ShowError'
};
// --------------------------------------------------------
// Type: SYNCMGRINVOKEFLAGS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const SYNCMGRINVOKEFLAGS = *opaque{
};
// --------------------------------------------------------
// Type: ISyncMgrSynchronizeInvoke
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ISyncMgrSynchronizeInvoke = *opaque{
    // TODO: Method 'UpdateItems'
    // TODO: Method 'UpdateAll'
};
// --------------------------------------------------------
// Type: SYNCMGRREGISTERFLAGS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const SYNCMGRREGISTERFLAGS = *opaque{
};
// --------------------------------------------------------
// Type: ISyncMgrRegister
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ISyncMgrRegister = *opaque{
    // TODO: Method 'RegisterSyncMgrHandler'
    // TODO: Method 'UnregisterSyncMgrHandler'
    // TODO: Method 'GetHandlerRegistrationInfo'
};
// --------------------------------------------------------
// Type: ThumbnailStreamCache
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const ThumbnailStreamCache = opaque {
};
// --------------------------------------------------------
// Type: ThumbnailStreamCacheOptions
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const ThumbnailStreamCacheOptions = *opaque{
};
// --------------------------------------------------------
// Type: IThumbnailStreamCache
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IThumbnailStreamCache = *opaque{
    // TODO: Method 'GetThumbnailStream'
    // TODO: Method 'SetThumbnailStream'
};
// --------------------------------------------------------
// Type: TrackShellMenu
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const TrackShellMenu = opaque {
};
// --------------------------------------------------------
// Type: WINDOWDATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const WINDOWDATA = extern struct {
    dwWindowID: u32,
    uiCP: u32,
    pidl: ?*ITEMIDLIST,
    lpszUrl: ?*u16,
    lpszUrlLocation: ?*u16,
    lpszTitle: ?*u16,
};
// --------------------------------------------------------
// Type: ITravelLogEntry
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ITravelLogEntry = *opaque{
    // TODO: Method 'GetTitle'
    // TODO: Method 'GetURL'
};
// --------------------------------------------------------
// Type: ITravelLogClient
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ITravelLogClient = *opaque{
    // TODO: Method 'FindWindowByIndex'
    // TODO: Method 'GetWindowData'
    // TODO: Method 'LoadHistoryPosition'
};
// --------------------------------------------------------
// Type: IEnumTravelLogEntry
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IEnumTravelLogEntry = *opaque{
    // TODO: Method 'Next'
    // TODO: Method 'Skip'
    // TODO: Method 'Reset'
    // TODO: Method 'Clone'
};
// --------------------------------------------------------
// Type: tagTLENUMF
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const tagTLENUMF = *opaque{
};
// --------------------------------------------------------
// Type: ITravelLogStg
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ITravelLogStg = *opaque{
    // TODO: Method 'CreateEntry'
    // TODO: Method 'TravelTo'
    // TODO: Method 'EnumEntries'
    // TODO: Method 'FindEntries'
    // TODO: Method 'GetCount'
    // TODO: Method 'RemoveEntry'
    // TODO: Method 'GetRelativeEntry'
};
// --------------------------------------------------------
// Type: _HLSR_NOREDEF10
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const _HLSR_NOREDEF10 = *opaque{
};
// --------------------------------------------------------
// Type: _HLSHORTCUTF__NOREDEF10
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const _HLSHORTCUTF__NOREDEF10 = *opaque{
};
// --------------------------------------------------------
// Type: _HLTRANSLATEF_NOREDEF10
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const _HLTRANSLATEF_NOREDEF10 = *opaque{
};
// --------------------------------------------------------
// Type: __MIDL_IHlink_0001
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const __MIDL_IHlink_0001 = *opaque{
};
// --------------------------------------------------------
// Type: __MIDL_IHlink_0002
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const __MIDL_IHlink_0002 = *opaque{
};
// --------------------------------------------------------
// Type: __MIDL_IHlink_0003
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const __MIDL_IHlink_0003 = *opaque{
};
// --------------------------------------------------------
// Type: __MIDL_IHlink_0004
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const __MIDL_IHlink_0004 = *opaque{
};
// --------------------------------------------------------
// Type: __MIDL_IHlink_0005
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const __MIDL_IHlink_0005 = *opaque{
};
// --------------------------------------------------------
// Type: IHlink
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IHlink = *opaque{
    // TODO: Method 'SetHlinkSite'
    // TODO: Method 'GetHlinkSite'
    // TODO: Method 'SetMonikerReference'
    // TODO: Method 'GetMonikerReference'
    // TODO: Method 'SetStringReference'
    // TODO: Method 'GetStringReference'
    // TODO: Method 'SetFriendlyName'
    // TODO: Method 'GetFriendlyName'
    // TODO: Method 'SetTargetFrameName'
    // TODO: Method 'GetTargetFrameName'
    // TODO: Method 'GetMiscStatus'
    // TODO: Method 'Navigate'
    // TODO: Method 'SetAdditionalParams'
    // TODO: Method 'GetAdditionalParams'
};
// --------------------------------------------------------
// Type: __MIDL_IHlinkSite_0001
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const __MIDL_IHlinkSite_0001 = *opaque{
};
// --------------------------------------------------------
// Type: IHlinkSite
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IHlinkSite = *opaque{
    // TODO: Method 'QueryService'
    // TODO: Method 'GetMoniker'
    // TODO: Method 'ReadyToNavigate'
    // TODO: Method 'OnNavigationComplete'
};
// --------------------------------------------------------
// Type: IHlinkTarget
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IHlinkTarget = *opaque{
    // TODO: Method 'SetBrowseContext'
    // TODO: Method 'GetBrowseContext'
    // TODO: Method 'Navigate'
    // TODO: Method 'GetMoniker'
    // TODO: Method 'GetFriendlyName'
};
// --------------------------------------------------------
// Type: IHlinkFrame
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IHlinkFrame = *opaque{
    // TODO: Method 'SetBrowseContext'
    // TODO: Method 'GetBrowseContext'
    // TODO: Method 'Navigate'
    // TODO: Method 'OnNavigate'
    // TODO: Method 'UpdateHlink'
};
// --------------------------------------------------------
// Type: HLITEM
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HLITEM = extern struct {
    uHLID: u32,
    pwzFriendlyName: ?*u16,
};
// --------------------------------------------------------
// Type: IEnumHLITEM
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IEnumHLITEM = *opaque{
    // TODO: Method 'Next'
    // TODO: Method 'Skip'
    // TODO: Method 'Reset'
    // TODO: Method 'Clone'
};
// --------------------------------------------------------
// Type: __MIDL_IHlinkBrowseContext_0001
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const __MIDL_IHlinkBrowseContext_0001 = *opaque{
};
// --------------------------------------------------------
// Type: HLTBINFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HLTBINFO = extern struct {
    uDockType: u32,
    rcTbPos: RECT,
};
// --------------------------------------------------------
// Type: __MIDL_IHlinkBrowseContext_0002
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const __MIDL_IHlinkBrowseContext_0002 = *opaque{
};
// --------------------------------------------------------
// Type: HLBWINFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HLBWINFO = extern struct {
    cbSize: u32,
    grfHLBWIF: u32,
    rcFramePos: RECT,
    rcDocPos: RECT,
    hltbinfo: HLTBINFO,
};
// --------------------------------------------------------
// Type: __MIDL_IHlinkBrowseContext_0003
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const __MIDL_IHlinkBrowseContext_0003 = *opaque{
};
// --------------------------------------------------------
// Type: __MIDL_IHlinkBrowseContext_0004
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const __MIDL_IHlinkBrowseContext_0004 = *opaque{
};
// --------------------------------------------------------
// Type: IHlinkBrowseContext
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IHlinkBrowseContext = *opaque{
    // TODO: Method 'Register'
    // TODO: Method 'GetObjectA'
    // TODO: Method 'Revoke'
    // TODO: Method 'SetBrowseWindowInfo'
    // TODO: Method 'GetBrowseWindowInfo'
    // TODO: Method 'SetInitialHlink'
    // TODO: Method 'OnNavigateHlink'
    // TODO: Method 'UpdateHlink'
    // TODO: Method 'EnumNavigationStack'
    // TODO: Method 'QueryHlink'
    // TODO: Method 'GetHlink'
    // TODO: Method 'SetCurrentHlink'
    // TODO: Method 'Clone'
    // TODO: Method 'Close'
};
// --------------------------------------------------------
// Type: IExtensionServices
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IExtensionServices = *opaque{
    // TODO: Method 'SetAdditionalHeaders'
    // TODO: Method 'SetAuthenticateData'
};
// --------------------------------------------------------
// Type: ITravelEntry
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ITravelEntry = *opaque{
    // TODO: Method 'Invoke'
    // TODO: Method 'Update'
    // TODO: Method 'GetPidl'
};
// --------------------------------------------------------
// Type: ITravelLog
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ITravelLog = *opaque{
    // TODO: Method 'AddEntry'
    // TODO: Method 'UpdateEntry'
    // TODO: Method 'UpdateExternal'
    // TODO: Method 'Travel'
    // TODO: Method 'GetTravelEntry'
    // TODO: Method 'FindTravelEntry'
    // TODO: Method 'GetToolTipText'
    // TODO: Method 'InsertMenuEntries'
    // TODO: Method 'Clone'
    // TODO: Method 'CountEntries'
    // TODO: Method 'Revert'
};
// --------------------------------------------------------
// Type: CIE4ConnectionPoint
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const CIE4ConnectionPoint = *opaque{
    // TODO: Method 'DoInvokeIE4'
    // TODO: Method 'DoInvokePIDLIE4'
};
// --------------------------------------------------------
// Type: IExpDispSupportXP
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IExpDispSupportXP = *opaque{
    // TODO: Method 'FindCIE4ConnectionPoint'
    // TODO: Method 'OnTranslateAccelerator'
    // TODO: Method 'OnInvoke'
};
// --------------------------------------------------------
// Type: IExpDispSupport
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IExpDispSupport = *opaque{
    // TODO: Method 'FindConnectionPoint'
    // TODO: Method 'OnTranslateAccelerator'
    // TODO: Method 'OnInvoke'
};
// --------------------------------------------------------
// Type: BNSTATE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const BNSTATE = *opaque{
};
// --------------------------------------------------------
// Type: SHELLBROWSERSHOWCONTROL
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const SHELLBROWSERSHOWCONTROL = *opaque{
};
// --------------------------------------------------------
// Type: IBrowserService
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IBrowserService = *opaque{
    // TODO: Method 'GetParentSite'
    // TODO: Method 'SetTitle'
    // TODO: Method 'GetTitle'
    // TODO: Method 'GetOleObject'
    // TODO: Method 'GetTravelLog'
    // TODO: Method 'ShowControlWindow'
    // TODO: Method 'IsControlWindowShown'
    // TODO: Method 'IEGetDisplayName'
    // TODO: Method 'IEParseDisplayName'
    // TODO: Method 'DisplayParseError'
    // TODO: Method 'NavigateToPidl'
    // TODO: Method 'SetNavigateState'
    // TODO: Method 'GetNavigateState'
    // TODO: Method 'NotifyRedirect'
    // TODO: Method 'UpdateWindowList'
    // TODO: Method 'UpdateBackForwardState'
    // TODO: Method 'SetFlags'
    // TODO: Method 'GetFlags'
    // TODO: Method 'CanNavigateNow'
    // TODO: Method 'GetPidl'
    // TODO: Method 'SetReferrer'
    // TODO: Method 'GetBrowserIndex'
    // TODO: Method 'GetBrowserByIndex'
    // TODO: Method 'GetHistoryObject'
    // TODO: Method 'SetHistoryObject'
    // TODO: Method 'CacheOLEServer'
    // TODO: Method 'GetSetCodePage'
    // TODO: Method 'OnHttpEquiv'
    // TODO: Method 'GetPalette'
    // TODO: Method 'RegisterWindow'
};
// --------------------------------------------------------
// Type: IShellService
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IShellService = *opaque{
    // TODO: Method 'SetOwner'
};
// --------------------------------------------------------
// Type: SECURELOCKCODE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const SECURELOCKCODE = *opaque{
};
// --------------------------------------------------------
// Type: BASEBROWSERDATAXP
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const BASEBROWSERDATAXP = extern struct {
    _hwnd: HWND,
    _ptl: ITravelLog,
    _phlf: IHlinkFrame,
    _pautoWB2: IWebBrowser2,
    _pautoEDS: IExpDispSupportXP,
    _pautoSS: IShellService,
    _eSecureLockIcon: i32,
    _bitfield: u32,
    _uActivateState: u32,
    _pidlViewState: ?*ITEMIDLIST,
    _pctView: IOleCommandTarget,
    _pidlCur: ?*ITEMIDLIST,
    _psv: IShellView,
    _psf: IShellFolder,
    _hwndView: HWND,
    _pszTitleCur: ?*u16,
    _pidlPending: ?*ITEMIDLIST,
    _psvPending: IShellView,
    _psfPending: IShellFolder,
    _hwndViewPending: HWND,
    _pszTitlePending: ?*u16,
    _fIsViewMSHTML: BOOL,
    _fPrivacyImpacted: BOOL,
    _clsidView: Guid,
    _clsidViewPending: Guid,
    _hwndFrame: HWND,
};
// --------------------------------------------------------
// Type: BASEBROWSERDATALH
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const BASEBROWSERDATALH = extern struct {
    _hwnd: HWND,
    _ptl: ITravelLog,
    _phlf: IHlinkFrame,
    _pautoWB2: IWebBrowser2,
    _pautoEDS: IExpDispSupport,
    _pautoSS: IShellService,
    _eSecureLockIcon: i32,
    _bitfield: u32,
    _uActivateState: u32,
    _pidlViewState: ?*ITEMIDLIST,
    _pctView: IOleCommandTarget,
    _pidlCur: ?*ITEMIDLIST,
    _psv: IShellView,
    _psf: IShellFolder,
    _hwndView: HWND,
    _pszTitleCur: ?*u16,
    _pidlPending: ?*ITEMIDLIST,
    _psvPending: IShellView,
    _psfPending: IShellFolder,
    _hwndViewPending: HWND,
    _pszTitlePending: ?*u16,
    _fIsViewMSHTML: BOOL,
    _fPrivacyImpacted: BOOL,
    _clsidView: Guid,
    _clsidViewPending: Guid,
    _hwndFrame: HWND,
    _lPhishingFilterStatus: i32,
};
// --------------------------------------------------------
// Type: FOLDERSETDATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const FOLDERSETDATA = extern struct {
    _fs: FOLDERSETTINGS,
    _vidRestore: Guid,
    _dwViewPriority: u32,
};
// --------------------------------------------------------
// Type: TOOLBARITEM
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TOOLBARITEM = extern struct {
    ptbar: IDockingWindow,
    rcBorderTool: RECT,
    pwszItem: ?*u16,
    fShow: BOOL,
    hMon: ?*opaque{},
};
// --------------------------------------------------------
// Type: IBrowserService2
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IBrowserService2 = *opaque{
    // TODO: Method 'WndProcBS'
    // TODO: Method 'SetAsDefFolderSettings'
    // TODO: Method 'GetViewRect'
    // TODO: Method 'OnSize'
    // TODO: Method 'OnCreate'
    // TODO: Method 'OnCommand'
    // TODO: Method 'OnDestroy'
    // TODO: Method 'OnNotify'
    // TODO: Method 'OnSetFocus'
    // TODO: Method 'OnFrameWindowActivateBS'
    // TODO: Method 'ReleaseShellView'
    // TODO: Method 'ActivatePendingView'
    // TODO: Method 'CreateViewWindow'
    // TODO: Method 'CreateBrowserPropSheetExt'
    // TODO: Method 'GetViewWindow'
    // TODO: Method 'GetBaseBrowserData'
    // TODO: Method 'PutBaseBrowserData'
    // TODO: Method 'InitializeTravelLog'
    // TODO: Method 'SetTopBrowser'
    // TODO: Method 'Offline'
    // TODO: Method 'AllowViewResize'
    // TODO: Method 'SetActivateState'
    // TODO: Method 'UpdateSecureLockIcon'
    // TODO: Method 'InitializeDownloadManager'
    // TODO: Method 'InitializeTransitionSite'
    // TODO: Method '_Initialize'
    // TODO: Method '_CancelPendingNavigationAsync'
    // TODO: Method '_CancelPendingView'
    // TODO: Method '_MaySaveChanges'
    // TODO: Method '_PauseOrResumeView'
    // TODO: Method '_DisableModeless'
    // TODO: Method '_NavigateToPidl2'
    // TODO: Method '_TryShell2Rename'
    // TODO: Method '_SwitchActivationNow'
    // TODO: Method '_ExecChildren'
    // TODO: Method '_SendChildren'
    // TODO: Method 'GetFolderSetData'
    // TODO: Method '_OnFocusChange'
    // TODO: Method 'v_ShowHideChildWindows'
    // TODO: Method '_get_itbLastFocus'
    // TODO: Method '_put_itbLastFocus'
    // TODO: Method '_UIActivateView'
    // TODO: Method '_GetViewBorderRect'
    // TODO: Method '_UpdateViewRectSize'
    // TODO: Method '_ResizeNextBorder'
    // TODO: Method '_ResizeView'
    // TODO: Method '_GetEffectiveClientArea'
    // TODO: Method 'v_GetViewStream'
    // TODO: Method 'ForwardViewMsg'
    // TODO: Method 'SetAcceleratorMenu'
    // TODO: Method '_GetToolbarCount'
    // TODO: Method '_GetToolbarItem'
    // TODO: Method '_SaveToolbars'
    // TODO: Method '_LoadToolbars'
    // TODO: Method '_CloseAndReleaseToolbars'
    // TODO: Method 'v_MayGetNextToolbarFocus'
    // TODO: Method '_ResizeNextBorderHelper'
    // TODO: Method '_FindTBar'
    // TODO: Method '_SetFocus'
    // TODO: Method 'v_MayTranslateAccelerator'
    // TODO: Method '_GetBorderDWHelper'
    // TODO: Method 'v_CheckZoneCrossing'
};
// --------------------------------------------------------
// Type: IEPDNFLAGS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const IEPDNFLAGS = *opaque{
};
// --------------------------------------------------------
// Type: IBrowserService3
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IBrowserService3 = *opaque{
    // TODO: Method '_PositionViewWindow'
    // TODO: Method 'IEParseDisplayNameEx'
};
// --------------------------------------------------------
// Type: IBrowserService4
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IBrowserService4 = *opaque{
    // TODO: Method 'ActivateView'
    // TODO: Method 'SaveViewState'
    // TODO: Method '_ResizeAllBorders'
};
// --------------------------------------------------------
// Type: ITrackShellMenu
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ITrackShellMenu = *opaque{
    // TODO: Method 'SetObscured'
    // TODO: Method 'Popup'
};
// --------------------------------------------------------
// Type: ImageTranscode
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const ImageTranscode = opaque {
};
// --------------------------------------------------------
// Type: TI_FLAGS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const TI_FLAGS = *opaque{
};
// --------------------------------------------------------
// Type: ITranscodeImage
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ITranscodeImage = *opaque{
    // TODO: Method 'TranscodeImage'
};
// --------------------------------------------------------
// Type: PATHCCH_OPTIONS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PATHCCH_OPTIONS = *opaque{
};
// --------------------------------------------------------
// Type: APPLET_PROC
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const APPLET_PROC = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: CPLINFO
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const CPLINFO = *opaque{
};
// --------------------------------------------------------
// Type: NEWCPLINFOA
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const NEWCPLINFOA = *opaque{
};
// --------------------------------------------------------
// Type: NEWCPLINFOW
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const NEWCPLINFOW = *opaque{
};
// --------------------------------------------------------
// Type: PROFILEINFOA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PROFILEINFOA = extern struct {
    dwSize: u32,
    dwFlags: u32,
    lpUserName: ?*i8,
    lpProfilePath: ?*i8,
    lpDefaultPath: ?*i8,
    lpServerName: ?*i8,
    lpPolicyPath: ?*i8,
    hProfile: HANDLE,
};
// --------------------------------------------------------
// Type: PROFILEINFOW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PROFILEINFOW = extern struct {
    dwSize: u32,
    dwFlags: u32,
    lpUserName: ?*u16,
    lpProfilePath: ?*u16,
    lpDefaultPath: ?*u16,
    lpServerName: ?*u16,
    lpPolicyPath: ?*u16,
    hProfile: HANDLE,
};
// --------------------------------------------------------
// Type: iurl_seturl_flags
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const iurl_seturl_flags = *opaque{
};
// --------------------------------------------------------
// Type: iurl_invokecommand_flags
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const iurl_invokecommand_flags = *opaque{
};
// --------------------------------------------------------
// Type: urlinvokecommandinfoA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const urlinvokecommandinfoA = extern struct {
    dwcbSize: u32,
    dwFlags: u32,
    hwndParent: HWND,
    pcszVerb: ?*i8,
};
// --------------------------------------------------------
// Type: urlinvokecommandinfoW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const urlinvokecommandinfoW = extern struct {
    dwcbSize: u32,
    dwFlags: u32,
    hwndParent: HWND,
    pcszVerb: ?*u16,
};
// --------------------------------------------------------
// Type: IUniformResourceLocatorA
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IUniformResourceLocatorA = *opaque{
    // TODO: Method 'SetURL'
    // TODO: Method 'GetURL'
    // TODO: Method 'InvokeCommand'
};
// --------------------------------------------------------
// Type: IUniformResourceLocatorW
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IUniformResourceLocatorW = *opaque{
    // TODO: Method 'SetURL'
    // TODO: Method 'GetURL'
    // TODO: Method 'InvokeCommand'
};
// --------------------------------------------------------
// Type: translateurl_in_flags
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const translateurl_in_flags = *opaque{
};
// --------------------------------------------------------
// Type: urlassociationdialog_in_flags
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const urlassociationdialog_in_flags = *opaque{
};
// --------------------------------------------------------
// Type: mimeassociationdialog_in_flags
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const mimeassociationdialog_in_flags = *opaque{
};
// --------------------------------------------------------
// Type: PAPPSTATE_CHANGE_ROUTINE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PAPPSTATE_CHANGE_ROUTINE = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: _APPSTATE_REGISTRATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const _APPSTATE_REGISTRATION = opaque {
};
// --------------------------------------------------------
// Type: PAPPCONSTRAIN_CHANGE_ROUTINE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PAPPCONSTRAIN_CHANGE_ROUTINE = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: _APPCONSTRAIN_REGISTRATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const _APPCONSTRAIN_REGISTRATION = opaque {
};
// --------------------------------------------------------
// Type: CActiveIMM
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const CActiveIMM = opaque {
};
// --------------------------------------------------------
// Type: __MIDL___MIDL_itf_dimm_0000_0000_0012
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const __MIDL___MIDL_itf_dimm_0000_0000_0012 = extern struct {
    hWnd: HWND,
    fOpen: BOOL,
    ptStatusWndPos: POINT,
    ptSoftKbdPos: POINT,
    fdwConversion: u32,
    fdwSentence: u32,
    lfFont: _lfFont_e__Union,
    cfCompForm: COMPOSITIONFORM,
    cfCandForm: ?[*]CANDIDATEFORM,
    hCompStr: ?*HIMCC__,
    hCandInfo: ?*HIMCC__,
    hGuideLine: ?*HIMCC__,
    hPrivate: ?*HIMCC__,
    dwNumMsgBuf: u32,
    hMsgBuf: ?*HIMCC__,
    fdwInit: u32,
    dwReserve: ?[*]u32,
    // --------------------------------------------------------
    // Type: _lfFont_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _lfFont_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: __MIDL___MIDL_itf_dimm_0000_0000_0014
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const __MIDL___MIDL_itf_dimm_0000_0000_0014 = extern struct {
    dwPrivateDataSize: u32,
    fdwProperty: u32,
    fdwConversionCaps: u32,
    fdwSentenceCaps: u32,
    fdwUICaps: u32,
    fdwSCSCaps: u32,
    fdwSelectCaps: u32,
};
// --------------------------------------------------------
// Type: IEnumRegisterWordA
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IEnumRegisterWordA = *opaque{
    // TODO: Method 'Clone'
    // TODO: Method 'Next'
    // TODO: Method 'Reset'
    // TODO: Method 'Skip'
};
// --------------------------------------------------------
// Type: IEnumRegisterWordW
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IEnumRegisterWordW = *opaque{
    // TODO: Method 'Clone'
    // TODO: Method 'Next'
    // TODO: Method 'Reset'
    // TODO: Method 'Skip'
};
// --------------------------------------------------------
// Type: IEnumInputContext
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IEnumInputContext = *opaque{
    // TODO: Method 'Clone'
    // TODO: Method 'Next'
    // TODO: Method 'Reset'
    // TODO: Method 'Skip'
};
// --------------------------------------------------------
// Type: IActiveIMMRegistrar
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IActiveIMMRegistrar = *opaque{
    // TODO: Method 'RegisterIME'
    // TODO: Method 'UnregisterIME'
};
// --------------------------------------------------------
// Type: IActiveIMMMessagePumpOwner
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IActiveIMMMessagePumpOwner = *opaque{
    // TODO: Method 'Start'
    // TODO: Method 'End'
    // TODO: Method 'OnTranslateMessage'
    // TODO: Method 'Pause'
    // TODO: Method 'Resume'
};
// --------------------------------------------------------
// Type: IActiveIMMApp
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IActiveIMMApp = *opaque{
    // TODO: Method 'AssociateContext'
    // TODO: Method 'ConfigureIMEA'
    // TODO: Method 'ConfigureIMEW'
    // TODO: Method 'CreateContext'
    // TODO: Method 'DestroyContext'
    // TODO: Method 'EnumRegisterWordA'
    // TODO: Method 'EnumRegisterWordW'
    // TODO: Method 'EscapeA'
    // TODO: Method 'EscapeW'
    // TODO: Method 'GetCandidateListA'
    // TODO: Method 'GetCandidateListW'
    // TODO: Method 'GetCandidateListCountA'
    // TODO: Method 'GetCandidateListCountW'
    // TODO: Method 'GetCandidateWindow'
    // TODO: Method 'GetCompositionFontA'
    // TODO: Method 'GetCompositionFontW'
    // TODO: Method 'GetCompositionStringA'
    // TODO: Method 'GetCompositionStringW'
    // TODO: Method 'GetCompositionWindow'
    // TODO: Method 'GetContext'
    // TODO: Method 'GetConversionListA'
    // TODO: Method 'GetConversionListW'
    // TODO: Method 'GetConversionStatus'
    // TODO: Method 'GetDefaultIMEWnd'
    // TODO: Method 'GetDescriptionA'
    // TODO: Method 'GetDescriptionW'
    // TODO: Method 'GetGuideLineA'
    // TODO: Method 'GetGuideLineW'
    // TODO: Method 'GetIMEFileNameA'
    // TODO: Method 'GetIMEFileNameW'
    // TODO: Method 'GetOpenStatus'
    // TODO: Method 'GetProperty'
    // TODO: Method 'GetRegisterWordStyleA'
    // TODO: Method 'GetRegisterWordStyleW'
    // TODO: Method 'GetStatusWindowPos'
    // TODO: Method 'GetVirtualKey'
    // TODO: Method 'InstallIMEA'
    // TODO: Method 'InstallIMEW'
    // TODO: Method 'IsIME'
    // TODO: Method 'IsUIMessageA'
    // TODO: Method 'IsUIMessageW'
    // TODO: Method 'NotifyIME'
    // TODO: Method 'RegisterWordA'
    // TODO: Method 'RegisterWordW'
    // TODO: Method 'ReleaseContext'
    // TODO: Method 'SetCandidateWindow'
    // TODO: Method 'SetCompositionFontA'
    // TODO: Method 'SetCompositionFontW'
    // TODO: Method 'SetCompositionStringA'
    // TODO: Method 'SetCompositionStringW'
    // TODO: Method 'SetCompositionWindow'
    // TODO: Method 'SetConversionStatus'
    // TODO: Method 'SetOpenStatus'
    // TODO: Method 'SetStatusWindowPos'
    // TODO: Method 'SimulateHotKey'
    // TODO: Method 'UnregisterWordA'
    // TODO: Method 'UnregisterWordW'
    // TODO: Method 'Activate'
    // TODO: Method 'Deactivate'
    // TODO: Method 'OnDefWindowProc'
    // TODO: Method 'FilterClientWindows'
    // TODO: Method 'GetCodePageA'
    // TODO: Method 'GetLangId'
    // TODO: Method 'AssociateContextEx'
    // TODO: Method 'DisableIME'
    // TODO: Method 'GetImeMenuItemsA'
    // TODO: Method 'GetImeMenuItemsW'
    // TODO: Method 'EnumInputContext'
};
// --------------------------------------------------------
// Type: IActiveIMMIME
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IActiveIMMIME = *opaque{
    // TODO: Method 'AssociateContext'
    // TODO: Method 'ConfigureIMEA'
    // TODO: Method 'ConfigureIMEW'
    // TODO: Method 'CreateContext'
    // TODO: Method 'DestroyContext'
    // TODO: Method 'EnumRegisterWordA'
    // TODO: Method 'EnumRegisterWordW'
    // TODO: Method 'EscapeA'
    // TODO: Method 'EscapeW'
    // TODO: Method 'GetCandidateListA'
    // TODO: Method 'GetCandidateListW'
    // TODO: Method 'GetCandidateListCountA'
    // TODO: Method 'GetCandidateListCountW'
    // TODO: Method 'GetCandidateWindow'
    // TODO: Method 'GetCompositionFontA'
    // TODO: Method 'GetCompositionFontW'
    // TODO: Method 'GetCompositionStringA'
    // TODO: Method 'GetCompositionStringW'
    // TODO: Method 'GetCompositionWindow'
    // TODO: Method 'GetContext'
    // TODO: Method 'GetConversionListA'
    // TODO: Method 'GetConversionListW'
    // TODO: Method 'GetConversionStatus'
    // TODO: Method 'GetDefaultIMEWnd'
    // TODO: Method 'GetDescriptionA'
    // TODO: Method 'GetDescriptionW'
    // TODO: Method 'GetGuideLineA'
    // TODO: Method 'GetGuideLineW'
    // TODO: Method 'GetIMEFileNameA'
    // TODO: Method 'GetIMEFileNameW'
    // TODO: Method 'GetOpenStatus'
    // TODO: Method 'GetProperty'
    // TODO: Method 'GetRegisterWordStyleA'
    // TODO: Method 'GetRegisterWordStyleW'
    // TODO: Method 'GetStatusWindowPos'
    // TODO: Method 'GetVirtualKey'
    // TODO: Method 'InstallIMEA'
    // TODO: Method 'InstallIMEW'
    // TODO: Method 'IsIME'
    // TODO: Method 'IsUIMessageA'
    // TODO: Method 'IsUIMessageW'
    // TODO: Method 'NotifyIME'
    // TODO: Method 'RegisterWordA'
    // TODO: Method 'RegisterWordW'
    // TODO: Method 'ReleaseContext'
    // TODO: Method 'SetCandidateWindow'
    // TODO: Method 'SetCompositionFontA'
    // TODO: Method 'SetCompositionFontW'
    // TODO: Method 'SetCompositionStringA'
    // TODO: Method 'SetCompositionStringW'
    // TODO: Method 'SetCompositionWindow'
    // TODO: Method 'SetConversionStatus'
    // TODO: Method 'SetOpenStatus'
    // TODO: Method 'SetStatusWindowPos'
    // TODO: Method 'SimulateHotKey'
    // TODO: Method 'UnregisterWordA'
    // TODO: Method 'UnregisterWordW'
    // TODO: Method 'GenerateMessage'
    // TODO: Method 'LockIMC'
    // TODO: Method 'UnlockIMC'
    // TODO: Method 'GetIMCLockCount'
    // TODO: Method 'CreateIMCC'
    // TODO: Method 'DestroyIMCC'
    // TODO: Method 'LockIMCC'
    // TODO: Method 'UnlockIMCC'
    // TODO: Method 'ReSizeIMCC'
    // TODO: Method 'GetIMCCSize'
    // TODO: Method 'GetIMCCLockCount'
    // TODO: Method 'GetHotKey'
    // TODO: Method 'SetHotKey'
    // TODO: Method 'CreateSoftKeyboard'
    // TODO: Method 'DestroySoftKeyboard'
    // TODO: Method 'ShowSoftKeyboard'
    // TODO: Method 'GetCodePageA'
    // TODO: Method 'GetLangId'
    // TODO: Method 'KeybdEvent'
    // TODO: Method 'LockModal'
    // TODO: Method 'UnlockModal'
    // TODO: Method 'AssociateContextEx'
    // TODO: Method 'DisableIME'
    // TODO: Method 'GetImeMenuItemsA'
    // TODO: Method 'GetImeMenuItemsW'
    // TODO: Method 'EnumInputContext'
    // TODO: Method 'RequestMessageA'
    // TODO: Method 'RequestMessageW'
    // TODO: Method 'SendIMCA'
    // TODO: Method 'SendIMCW'
    // TODO: Method 'IsSleeping'
};
// --------------------------------------------------------
// Type: IActiveIME
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IActiveIME = *opaque{
    // TODO: Method 'Inquire'
    // TODO: Method 'ConversionList'
    // TODO: Method 'Configure'
    // TODO: Method 'Destroy'
    // TODO: Method 'Escape'
    // TODO: Method 'SetActiveContext'
    // TODO: Method 'ProcessKey'
    // TODO: Method 'Notify'
    // TODO: Method 'Select'
    // TODO: Method 'SetCompositionString'
    // TODO: Method 'ToAsciiEx'
    // TODO: Method 'RegisterWord'
    // TODO: Method 'UnregisterWord'
    // TODO: Method 'GetRegisterWordStyle'
    // TODO: Method 'EnumRegisterWord'
    // TODO: Method 'GetCodePageA'
    // TODO: Method 'GetLangId'
};
// --------------------------------------------------------
// Type: IActiveIME2
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IActiveIME2 = *opaque{
    // TODO: Method 'Sleep'
    // TODO: Method 'Unsleep'
};
// --------------------------------------------------------
// Type: NC_ADDRESS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NC_ADDRESS = extern struct {
    pAddrInfo: ?*NET_ADDRESS_INFO,
    PortNumber: u16,
    PrefixLength: u8,
};
// --------------------------------------------------------
// Type: ShFindChangeNotifcationHandle
// TypeLayoutAttr: sequential
// RAIIFree 'SHChangeNotification_Unlock' (TODO: can we use this information?)
pub const ShFindChangeNotifcationHandle = ?*opaque{};
// --------------------------------------------------------
// Type: LOGFONTA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const LOGFONTA = extern struct {
    lfHeight: i32,
    lfWidth: i32,
    lfEscapement: i32,
    lfOrientation: i32,
    lfWeight: i32,
    lfItalic: u8,
    lfUnderline: u8,
    lfStrikeOut: u8,
    lfCharSet: u8,
    lfOutPrecision: u8,
    lfClipPrecision: u8,
    lfQuality: u8,
    lfPitchAndFamily: u8,
    lfFaceName: ?[*]i8,
};
// --------------------------------------------------------
// Type: LOGFONTW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const LOGFONTW = extern struct {
    lfHeight: i32,
    lfWidth: i32,
    lfEscapement: i32,
    lfOrientation: i32,
    lfWeight: i32,
    lfItalic: u8,
    lfUnderline: u8,
    lfStrikeOut: u8,
    lfCharSet: u8,
    lfOutPrecision: u8,
    lfClipPrecision: u8,
    lfQuality: u8,
    lfPitchAndFamily: u8,
    lfFaceName: ?[*]u16,
};
// --------------------------------------------------------
// Type: SERIALIZEDPROPERTYVALUE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SERIALIZEDPROPERTYVALUE = extern struct {
    dwType: u32,
    rgb: ?[*]u8,
};
// --------------------------------------------------------
// Type: APPCATEGORYINFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const APPCATEGORYINFO = extern struct {
    Locale: u32,
    pszDescription: ?*u16,
    AppCategoryId: Guid,
};
// --------------------------------------------------------
// Type: APPCATEGORYINFOLIST
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const APPCATEGORYINFOLIST = extern struct {
    cCategory: u32,
    pCategoryInfo: ?*APPCATEGORYINFO,
};
// --------------------------------------------------------
// Type: IInitializeWithFile
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IInitializeWithFile = *opaque{
    // TODO: Method 'Initialize'
};
// --------------------------------------------------------
// Type: IInitializeWithStream
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IInitializeWithStream = *opaque{
    // TODO: Method 'Initialize'
};
// --------------------------------------------------------
// Type: INamedPropertyStore
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const INamedPropertyStore = *opaque{
    // TODO: Method 'GetNamedValue'
    // TODO: Method 'SetNamedValue'
    // TODO: Method 'GetNameCount'
    // TODO: Method 'GetNameAt'
};
// --------------------------------------------------------
// Type: IObjectWithPropertyKey
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IObjectWithPropertyKey = *opaque{
    // TODO: Method 'SetPropertyKey'
    // TODO: Method 'GetPropertyKey'
};
// --------------------------------------------------------
// Type: IDelayedPropertyStoreFactory
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IDelayedPropertyStoreFactory = *opaque{
    // TODO: Method 'GetDelayedPropertyStore'
};
// --------------------------------------------------------
// Type: IPersistSerializedPropStorage
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IPersistSerializedPropStorage = *opaque{
    // TODO: Method 'SetFlags'
    // TODO: Method 'SetPropertyStorage'
    // TODO: Method 'GetPropertyStorage'
};
// --------------------------------------------------------
// Type: IPersistSerializedPropStorage2
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IPersistSerializedPropStorage2 = *opaque{
    // TODO: Method 'GetPropertyStorageSize'
    // TODO: Method 'GetPropertyStorageBuffer'
};
// --------------------------------------------------------
// Type: ICreateObject
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ICreateObject = *opaque{
    // TODO: Method 'CreateObject'
};
// --------------------------------------------------------
// Type: SUBCLASSPROC
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const SUBCLASSPROC = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: ShellWindowTypeConstants
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const ShellWindowTypeConstants = *opaque{
};
// --------------------------------------------------------
// Type: ShellWindowFindWindowOptions
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const ShellWindowFindWindowOptions = *opaque{
};
// --------------------------------------------------------
// Type: IShellWindows
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IShellWindows = *opaque{
    // TODO: Method 'get_Count'
    // TODO: Method 'Item'
    // TODO: Method '_NewEnum'
    // TODO: Method 'Register'
    // TODO: Method 'RegisterPending'
    // TODO: Method 'Revoke'
    // TODO: Method 'OnNavigate'
    // TODO: Method 'OnActivated'
    // TODO: Method 'FindWindowSW'
    // TODO: Method 'OnCreated'
    // TODO: Method 'ProcessAttachDetach'
};

//
// functions
//

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn SetWindowContextHelpId(
    param0: HWND,
    param1: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn GetWindowContextHelpId(
    param0: HWND,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn SetMenuContextHelpId(
    param0: HMENU,
    param1: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn GetMenuContextHelpId(
    param0: HMENU,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn WinHelpA(
    hWndMain: HWND,
    lpszHelp: ?*i8,
    uCommand: u32,
    dwData: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn WinHelpW(
    hWndMain: HWND,
    lpszHelp: ?*u16,
    uCommand: u32,
    dwData: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "SHELL32" fn CommandLineToArgvW(
    lpCmdLine: ?*u16,
    pNumArgs: ?*i32,
) callconv(@import("std").os.windows.WINAPI) ?*?*u16;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn DragQueryFileA(
    hDrop: ?*HDROP__,
    iFile: u32,
    lpszFile: ?*i8,
    cch: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn DragQueryFileW(
    hDrop: ?*HDROP__,
    iFile: u32,
    lpszFile: ?*u16,
    cch: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn DragQueryPoint(
    hDrop: ?*HDROP__,
    ppt: ?*POINT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn DragFinish(
    hDrop: ?*HDROP__,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn DragAcceptFiles(
    hWnd: HWND,
    fAccept: BOOL,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn ShellExecuteA(
    hwnd: HWND,
    lpOperation: ?*i8,
    lpFile: ?*i8,
    lpParameters: ?*i8,
    lpDirectory: ?*i8,
    nShowCmd: i32,
) callconv(@import("std").os.windows.WINAPI) HINSTANCE;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn ShellExecuteW(
    hwnd: HWND,
    lpOperation: ?*u16,
    lpFile: ?*u16,
    lpParameters: ?*u16,
    lpDirectory: ?*u16,
    nShowCmd: i32,
) callconv(@import("std").os.windows.WINAPI) HINSTANCE;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn FindExecutableA(
    lpFile: ?*i8,
    lpDirectory: ?*i8,
    lpResult: ?*i8,
) callconv(@import("std").os.windows.WINAPI) HINSTANCE;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn FindExecutableW(
    lpFile: ?*u16,
    lpDirectory: ?*u16,
    lpResult: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HINSTANCE;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn ShellAboutA(
    hWnd: HWND,
    szApp: ?*i8,
    szOtherStuff: ?*i8,
    hIcon: HICON,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn ShellAboutW(
    hWnd: HWND,
    szApp: ?*u16,
    szOtherStuff: ?*u16,
    hIcon: HICON,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn DuplicateIcon(
    hInst: HINSTANCE,
    hIcon: HICON,
) callconv(@import("std").os.windows.WINAPI) HICON;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn ExtractAssociatedIconA(
    hInst: HINSTANCE,
    pszIconPath: ?*i8,
    piIcon: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HICON;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn ExtractAssociatedIconW(
    hInst: HINSTANCE,
    pszIconPath: ?*u16,
    piIcon: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HICON;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn ExtractAssociatedIconExA(
    hInst: HINSTANCE,
    pszIconPath: ?*i8,
    piIconIndex: ?*u16,
    piIconId: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HICON;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn ExtractAssociatedIconExW(
    hInst: HINSTANCE,
    pszIconPath: ?*u16,
    piIconIndex: ?*u16,
    piIconId: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HICON;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn ExtractIconA(
    hInst: HINSTANCE,
    pszExeFileName: ?*i8,
    nIconIndex: u32,
) callconv(@import("std").os.windows.WINAPI) HICON;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn ExtractIconW(
    hInst: HINSTANCE,
    pszExeFileName: ?*u16,
    nIconIndex: u32,
) callconv(@import("std").os.windows.WINAPI) HICON;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHAppBarMessage(
    dwMessage: u32,
    pData: ?*APPBARDATA,
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn DoEnvironmentSubstA(
    pszSrc: ?*i8,
    cchSrc: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn DoEnvironmentSubstW(
    pszSrc: ?*u16,
    cchSrc: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "SHELL32" fn ExtractIconExA(
    lpszFile: ?*i8,
    nIconIndex: i32,
    phiconLarge: ?*HICON,
    phiconSmall: ?*HICON,
    nIcons: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "SHELL32" fn ExtractIconExW(
    lpszFile: ?*u16,
    nIconIndex: i32,
    phiconLarge: ?*HICON,
    phiconSmall: ?*HICON,
    nIcons: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "SHELL32" fn SHFileOperationA(
    lpFileOp: ?*SHFILEOPSTRUCTA,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=True (can and should we use this?)
pub extern "SHELL32" fn SHFileOperationW(
    lpFileOp: ?*SHFILEOPSTRUCTW,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHFreeNameMappings(
    hNameMappings: HANDLE,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=True (can and should we use this?)
pub extern "SHELL32" fn ShellExecuteExA(
    pExecInfo: ?*SHELLEXECUTEINFOA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "SHELL32" fn ShellExecuteExW(
    pExecInfo: ?*SHELLEXECUTEINFOW,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "SHELL32" fn SHCreateProcessAsUserW(
    pscpi: ?*SHCREATEPROCESSINFOW,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHEvaluateSystemCommandTemplate(
    pszCmdTemplate: ?*u16,
    ppszApplication: ?*?*u16,
    ppszCommandLine: ?*?*u16,
    ppszParameters: ?*?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn AssocCreateForClasses(
    rgClasses: ?*ASSOCIATIONELEMENT,
    cClasses: u32,
    riid: ?*Guid,
    ppv: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHQueryRecycleBinA(
    pszRootPath: ?*i8,
    pSHQueryRBInfo: ?*SHQUERYRBINFO,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHQueryRecycleBinW(
    pszRootPath: ?*u16,
    pSHQueryRBInfo: ?*SHQUERYRBINFO,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHEmptyRecycleBinA(
    hwnd: HWND,
    pszRootPath: ?*i8,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHEmptyRecycleBinW(
    hwnd: HWND,
    pszRootPath: ?*u16,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHQueryUserNotificationState(
    pquns: ?*QUERY_USER_NOTIFICATION_STATE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn Shell_NotifyIconA(
    dwMessage: u32,
    lpData: ?*NOTIFYICONDATAA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn Shell_NotifyIconW(
    dwMessage: u32,
    lpData: ?*NOTIFYICONDATAW,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn Shell_NotifyIconGetRect(
    identifier: ?*NOTIFYICONIDENTIFIER,
    iconLocation: ?*RECT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHGetFileInfoA(
    pszPath: ?*i8,
    dwFileAttributes: u32,
    psfi: ?*SHFILEINFOA,
    cbFileInfo: u32,
    uFlags: u32,
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHGetFileInfoW(
    pszPath: ?*u16,
    dwFileAttributes: u32,
    psfi: ?*SHFILEINFOW,
    cbFileInfo: u32,
    uFlags: u32,
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHGetStockIconInfo(
    siid: SHSTOCKICONID,
    uFlags: u32,
    psii: ?*SHSTOCKICONINFO,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHGetDiskFreeSpaceExA(
    pszDirectoryName: ?*i8,
    pulFreeBytesAvailableToCaller: ?*ULARGE_INTEGER,
    pulTotalNumberOfBytes: ?*ULARGE_INTEGER,
    pulTotalNumberOfFreeBytes: ?*ULARGE_INTEGER,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHGetDiskFreeSpaceExW(
    pszDirectoryName: ?*u16,
    pulFreeBytesAvailableToCaller: ?*ULARGE_INTEGER,
    pulTotalNumberOfBytes: ?*ULARGE_INTEGER,
    pulTotalNumberOfFreeBytes: ?*ULARGE_INTEGER,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHGetNewLinkInfoA(
    pszLinkTo: ?*i8,
    pszDir: ?*i8,
    pszName: ?*i8,
    pfMustCopy: ?*i32,
    uFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHGetNewLinkInfoW(
    pszLinkTo: ?*u16,
    pszDir: ?*u16,
    pszName: ?*u16,
    pfMustCopy: ?*i32,
    uFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHInvokePrinterCommandA(
    hwnd: HWND,
    uAction: u32,
    lpBuf1: ?*i8,
    lpBuf2: ?*i8,
    fModal: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHInvokePrinterCommandW(
    hwnd: HWND,
    uAction: u32,
    lpBuf1: ?*u16,
    lpBuf2: ?*u16,
    fModal: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHLoadNonloadedIconOverlayIdentifiers(
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHIsFileAvailableOffline(
    pwszPath: ?*u16,
    pdwStatus: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHSetLocalizedName(
    pszPath: ?*u16,
    pszResModule: ?*u16,
    idsRes: i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHRemoveLocalizedName(
    pszPath: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHGetLocalizedName(
    pszPath: ?*u16,
    pszResModule: ?*u16,
    cch: u32,
    pidsRes: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=True (can and should we use this?)
pub extern "SHLWAPI" fn ShellMessageBoxA(
    hAppInst: HINSTANCE,
    hWnd: HWND,
    lpcText: ?*i8,
    lpcTitle: ?*i8,
    fuStyle: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=True (can and should we use this?)
pub extern "SHLWAPI" fn ShellMessageBoxW(
    hAppInst: HINSTANCE,
    hWnd: HWND,
    lpcText: ?*u16,
    lpcTitle: ?*u16,
    fuStyle: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn IsLFNDriveA(
    pszPath: ?*i8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn IsLFNDriveW(
    pszPath: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHEnumerateUnreadMailAccountsW(
    hKeyUser: HKEY,
    dwIndex: u32,
    pszMailAddress: ?*u16,
    cchMailAddress: i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHGetUnreadMailCountW(
    hKeyUser: HKEY,
    pszMailAddress: ?*u16,
    pdwCount: ?*u32,
    pFileTime: ?*FILETIME,
    pszShellExecuteCommand: ?*u16,
    cchShellExecuteCommand: i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHSetUnreadMailCountW(
    pszMailAddress: ?*u16,
    dwCount: u32,
    pszShellExecuteCommand: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHTestTokenMembership(
    hToken: HANDLE,
    ulRID: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHGetImageList(
    iImageList: i32,
    riid: ?*Guid,
    ppvObj: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn InitNetworkAddressControl(
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHGetDriveMedia(
    pszDrive: ?*u16,
    pdwMediaContent: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHSimpleIDListFromPath(
    pszPath: ?*u16,
) callconv(@import("std").os.windows.WINAPI) ?*ITEMIDLIST;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHCreateItemFromIDList(
    pidl: ?*ITEMIDLIST,
    riid: ?*Guid,
    ppv: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHCreateItemFromParsingName(
    pszPath: ?*u16,
    pbc: IBindCtx,
    riid: ?*Guid,
    ppv: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHCreateItemWithParent(
    pidlParent: ?*ITEMIDLIST,
    psfParent: IShellFolder,
    pidl: ?*ITEMIDLIST,
    riid: ?*Guid,
    ppvItem: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHCreateItemFromRelativeName(
    psiParent: IShellItem,
    pszName: ?*u16,
    pbc: IBindCtx,
    riid: ?*Guid,
    ppv: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHCreateItemInKnownFolder(
    kfid: ?*Guid,
    dwKFFlags: u32,
    pszItem: ?*u16,
    riid: ?*Guid,
    ppv: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHGetIDListFromObject(
    punk: IUnknown,
    ppidl: ?*?*ITEMIDLIST,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHGetItemFromObject(
    punk: IUnknown,
    riid: ?*Guid,
    ppv: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHGetNameFromIDList(
    pidl: ?*ITEMIDLIST,
    sigdnName: SIGDN,
    ppszName: ?*?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHGetItemFromDataObject(
    pdtobj: IDataObject,
    dwFlags: DATAOBJ_GET_ITEM_FLAGS,
    riid: ?*Guid,
    ppv: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHCreateShellItemArray(
    pidlParent: ?*ITEMIDLIST,
    psf: IShellFolder,
    cidl: u32,
    ppidl: ?*?*ITEMIDLIST,
    ppsiItemArray: ?*IShellItemArray,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHCreateShellItemArrayFromDataObject(
    pdo: IDataObject,
    riid: ?*Guid,
    ppv: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHCreateShellItemArrayFromIDLists(
    cidl: u32,
    rgpidl: ?*?*ITEMIDLIST,
    ppsiItemArray: ?*IShellItemArray,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHCreateShellItemArrayFromShellItem(
    psi: IShellItem,
    riid: ?*Guid,
    ppv: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHCreateAssociationRegistration(
    riid: ?*Guid,
    ppv: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHCreateDefaultExtractIcon(
    riid: ?*Guid,
    ppv: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SetCurrentProcessExplicitAppUserModelID(
    AppID: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn GetCurrentProcessExplicitAppUserModelID(
    AppID: ?*?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHGetTemporaryPropertyForItem(
    psi: IShellItem,
    propkey: ?*PROPERTYKEY,
    ppropvar: ?*PROPVARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHSetTemporaryPropertyForItem(
    psi: IShellItem,
    propkey: ?*PROPERTYKEY,
    propvar: ?*PROPVARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHShowManageLibraryUI(
    psiLibrary: IShellItem,
    hwndOwner: HWND,
    pszTitle: ?*u16,
    pszInstruction: ?*u16,
    lmdOptions: LIBRARYMANAGEDIALOGOPTIONS,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHResolveLibrary(
    psiLibrary: IShellItem,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHAssocEnumHandlers(
    pszExtra: ?*u16,
    afFilter: ASSOC_FILTER,
    ppEnumHandler: ?*IEnumAssocHandlers,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHAssocEnumHandlersForProtocolByApplication(
    protocol: ?*u16,
    riid: ?*Guid,
    enumHandlers: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn HMONITOR_UserSize(
    param0: ?*u32,
    param1: u32,
    param2: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn HMONITOR_UserMarshal(
    param0: ?*u32,
    param1: ?*u8,
    param2: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) ?*u8;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn HMONITOR_UserUnmarshal(
    param0: ?*u32,
    param1: ?*u8,
    param2: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) ?*u8;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn HMONITOR_UserFree(
    param0: ?*u32,
    param1: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn HMONITOR_UserSize64(
    param0: ?*u32,
    param1: u32,
    param2: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn HMONITOR_UserMarshal64(
    param0: ?*u32,
    param1: ?*u8,
    param2: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) ?*u8;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn HMONITOR_UserUnmarshal64(
    param0: ?*u32,
    param1: ?*u8,
    param2: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) ?*u8;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn HMONITOR_UserFree64(
    param0: ?*u32,
    param1: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHCreateDefaultPropertiesOp(
    psi: IShellItem,
    ppFileOp: ?*IFileOperation,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHSetDefaultProperties(
    hwnd: HWND,
    psi: IShellItem,
    dwFileOpFlags: u32,
    pfops: IFileOperationProgressSink,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHGetMalloc(
    ppMalloc: ?*IMalloc,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHAlloc(
    cb: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHFree(
    pv: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHGetIconOverlayIndexA(
    pszIconPath: ?*i8,
    iIconIndex: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHGetIconOverlayIndexW(
    pszIconPath: ?*u16,
    iIconIndex: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn ILClone(
    pidl: ?*ITEMIDLIST,
) callconv(@import("std").os.windows.WINAPI) ?*ITEMIDLIST;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn ILCloneFirst(
    pidl: ?*ITEMIDLIST,
) callconv(@import("std").os.windows.WINAPI) ?*ITEMIDLIST;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn ILCombine(
    pidl1: ?*ITEMIDLIST,
    pidl2: ?*ITEMIDLIST,
) callconv(@import("std").os.windows.WINAPI) ?*ITEMIDLIST;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn ILFree(
    pidl: ?*ITEMIDLIST,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn ILGetNext(
    pidl: ?*ITEMIDLIST,
) callconv(@import("std").os.windows.WINAPI) ?*ITEMIDLIST;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn ILGetSize(
    pidl: ?*ITEMIDLIST,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn ILFindChild(
    pidlParent: ?*ITEMIDLIST,
    pidlChild: ?*ITEMIDLIST,
) callconv(@import("std").os.windows.WINAPI) ?*ITEMIDLIST;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn ILFindLastID(
    pidl: ?*ITEMIDLIST,
) callconv(@import("std").os.windows.WINAPI) ?*ITEMIDLIST;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn ILRemoveLastID(
    pidl: ?*ITEMIDLIST,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn ILIsEqual(
    pidl1: ?*ITEMIDLIST,
    pidl2: ?*ITEMIDLIST,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn ILIsParent(
    pidl1: ?*ITEMIDLIST,
    pidl2: ?*ITEMIDLIST,
    fImmediate: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn ILSaveToStream(
    pstm: IStream,
    pidl: ?*ITEMIDLIST,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn ILLoadFromStreamEx(
    pstm: IStream,
    pidl: ?*?*ITEMIDLIST,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn ILCreateFromPathA(
    pszPath: ?*i8,
) callconv(@import("std").os.windows.WINAPI) ?*ITEMIDLIST;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn ILCreateFromPathW(
    pszPath: ?*u16,
) callconv(@import("std").os.windows.WINAPI) ?*ITEMIDLIST;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHILCreateFromPath(
    pszPath: ?*u16,
    ppidl: ?*?*ITEMIDLIST,
    rgfInOut: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn ILAppendID(
    pidl: ?*ITEMIDLIST,
    pmkid: ?*SHITEMID,
    fAppend: BOOL,
) callconv(@import("std").os.windows.WINAPI) ?*ITEMIDLIST;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHGetPathFromIDListEx(
    pidl: ?*ITEMIDLIST,
    pszPath: ?*u16,
    cchPath: u32,
    uOpts: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHGetPathFromIDListA(
    pidl: ?*ITEMIDLIST,
    pszPath: ?*i8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHGetPathFromIDListW(
    pidl: ?*ITEMIDLIST,
    pszPath: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHCreateDirectory(
    hwnd: HWND,
    pszPath: ?*u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHCreateDirectoryExA(
    hwnd: HWND,
    pszPath: ?*i8,
    psa: ?*SECURITY_ATTRIBUTES,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHCreateDirectoryExW(
    hwnd: HWND,
    pszPath: ?*u16,
    psa: ?*SECURITY_ATTRIBUTES,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHOpenFolderAndSelectItems(
    pidlFolder: ?*ITEMIDLIST,
    cidl: u32,
    apidl: ?*?*ITEMIDLIST,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHCreateShellItem(
    pidlParent: ?*ITEMIDLIST,
    psfParent: IShellFolder,
    pidl: ?*ITEMIDLIST,
    ppsi: ?*IShellItem,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHGetSpecialFolderLocation(
    hwnd: HWND,
    csidl: i32,
    ppidl: ?*?*ITEMIDLIST,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHCloneSpecialIDList(
    hwnd: HWND,
    csidl: i32,
    fCreate: BOOL,
) callconv(@import("std").os.windows.WINAPI) ?*ITEMIDLIST;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHGetSpecialFolderPathA(
    hwnd: HWND,
    pszPath: ?*i8,
    csidl: i32,
    fCreate: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHGetSpecialFolderPathW(
    hwnd: HWND,
    pszPath: ?*u16,
    csidl: i32,
    fCreate: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHFlushSFCache(
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHGetFolderPathA(
    hwnd: HWND,
    csidl: i32,
    hToken: HANDLE,
    dwFlags: u32,
    pszPath: ?*i8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHGetFolderPathW(
    hwnd: HWND,
    csidl: i32,
    hToken: HANDLE,
    dwFlags: u32,
    pszPath: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHGetFolderLocation(
    hwnd: HWND,
    csidl: i32,
    hToken: HANDLE,
    dwFlags: u32,
    ppidl: ?*?*ITEMIDLIST,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHSetFolderPathA(
    csidl: i32,
    hToken: HANDLE,
    dwFlags: u32,
    pszPath: ?*i8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHSetFolderPathW(
    csidl: i32,
    hToken: HANDLE,
    dwFlags: u32,
    pszPath: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHGetFolderPathAndSubDirA(
    hwnd: HWND,
    csidl: i32,
    hToken: HANDLE,
    dwFlags: u32,
    pszSubDir: ?*i8,
    pszPath: ?*i8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHGetFolderPathAndSubDirW(
    hwnd: HWND,
    csidl: i32,
    hToken: HANDLE,
    dwFlags: u32,
    pszSubDir: ?*u16,
    pszPath: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHGetKnownFolderIDList(
    rfid: ?*Guid,
    dwFlags: u32,
    hToken: HANDLE,
    ppidl: ?*?*ITEMIDLIST,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHSetKnownFolderPath(
    rfid: ?*Guid,
    dwFlags: u32,
    hToken: HANDLE,
    pszPath: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHGetKnownFolderPath(
    rfid: ?*Guid,
    dwFlags: u32,
    hToken: HANDLE,
    ppszPath: ?*?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHGetKnownFolderItem(
    rfid: ?*Guid,
    flags: KNOWN_FOLDER_FLAG,
    hToken: HANDLE,
    riid: ?*Guid,
    ppv: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHGetSetFolderCustomSettings(
    pfcs: ?*SHFOLDERCUSTOMSETTINGS,
    pszPath: ?*u16,
    dwReadWrite: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHBrowseForFolderA(
    lpbi: ?*BROWSEINFOA,
) callconv(@import("std").os.windows.WINAPI) ?*ITEMIDLIST;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHBrowseForFolderW(
    lpbi: ?*BROWSEINFOW,
) callconv(@import("std").os.windows.WINAPI) ?*ITEMIDLIST;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHLoadInProc(
    rclsid: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHGetDesktopFolder(
    ppshf: ?*IShellFolder,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHChangeNotify(
    wEventId: i32,
    uFlags: u32,
    dwItem1: ?*opaque{},
    dwItem2: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHAddToRecentDocs(
    uFlags: u32,
    pv: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHHandleUpdateImage(
    pidlExtra: ?*ITEMIDLIST,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHUpdateImageA(
    pszHashItem: ?*i8,
    iIndex: i32,
    uFlags: u32,
    iImageIndex: i32,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHUpdateImageW(
    pszHashItem: ?*u16,
    iIndex: i32,
    uFlags: u32,
    iImageIndex: i32,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHChangeNotifyRegister(
    hwnd: HWND,
    fSources: i32,
    fEvents: i32,
    wMsg: u32,
    cEntries: i32,
    pshcne: ?*SHChangeNotifyEntry,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHChangeNotifyDeregister(
    ulID: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHChangeNotification_Lock(
    hChange: HANDLE,
    dwProcId: u32,
    pppidl: ?*?*?*ITEMIDLIST,
    plEvent: ?*i32,
) callconv(@import("std").os.windows.WINAPI) ShFindChangeNotifcationHandle;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHChangeNotification_Unlock(
    hLock: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHGetRealIDL(
    psf: IShellFolder,
    pidlSimple: ?*ITEMIDLIST,
    ppidlReal: ?*?*ITEMIDLIST,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHGetInstanceExplorer(
    ppunk: ?*IUnknown,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHGetDataFromIDListA(
    psf: IShellFolder,
    pidl: ?*ITEMIDLIST,
    nFormat: i32,
    pv: ?*opaque{},
    cb: i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHGetDataFromIDListW(
    psf: IShellFolder,
    pidl: ?*ITEMIDLIST,
    nFormat: i32,
    pv: ?*opaque{},
    cb: i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn RestartDialog(
    hwnd: HWND,
    pszPrompt: ?*u16,
    dwReturn: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn RestartDialogEx(
    hwnd: HWND,
    pszPrompt: ?*u16,
    dwReturn: u32,
    dwReasonCode: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHCoCreateInstance(
    pszCLSID: ?*u16,
    pclsid: ?*Guid,
    pUnkOuter: IUnknown,
    riid: ?*Guid,
    ppv: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHCreateDataObject(
    pidlFolder: ?*ITEMIDLIST,
    cidl: u32,
    apidl: ?*?*ITEMIDLIST,
    pdtInner: IDataObject,
    riid: ?*Guid,
    ppv: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn CIDLData_CreateFromIDArray(
    pidlFolder: ?*ITEMIDLIST,
    cidl: u32,
    apidl: ?*?*ITEMIDLIST,
    ppdtobj: ?*IDataObject,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHCreateStdEnumFmtEtc(
    cfmt: u32,
    afmt: ?*FORMATETC,
    ppenumFormatEtc: ?*IEnumFORMATETC,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHDoDragDrop(
    hwnd: HWND,
    pdata: IDataObject,
    pdsrc: IDropSource,
    dwEffect: u32,
    pdwEffect: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn DAD_SetDragImage(
    him: HIMAGELIST,
    pptOffset: ?*POINT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn DAD_DragEnterEx(
    hwndTarget: HWND,
    ptStart: POINT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn DAD_DragEnterEx2(
    hwndTarget: HWND,
    ptStart: POINT,
    pdtObject: IDataObject,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn DAD_ShowDragImage(
    fShow: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn DAD_DragMove(
    pt: POINT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn DAD_DragLeave(
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn DAD_AutoScroll(
    hwnd: HWND,
    pad: ?*AUTO_SCROLL_DATA,
    pptNow: ?*POINT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn ReadCabinetState(
    pcs: ?*CABINETSTATE,
    cLength: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn WriteCabinetState(
    pcs: ?*CABINETSTATE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn PathMakeUniqueName(
    pszUniqueName: ?*u16,
    cchMax: u32,
    pszTemplate: ?*u16,
    pszLongPlate: ?*u16,
    pszDir: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn PathIsExe(
    pszPath: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn PathCleanupSpec(
    pszDir: ?*u16,
    pszSpec: ?*u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=True (can and should we use this?)
pub extern "SHELL32" fn PathResolve(
    pszPath: ?*u16,
    dirs: ?*?*u16,
    fFlags: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn GetFileNameFromBrowse(
    hwnd: HWND,
    pszFilePath: ?*u16,
    cchFilePath: u32,
    pszWorkingDir: ?*u16,
    pszDefExt: ?*u16,
    pszFilters: ?*u16,
    pszTitle: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn DriveType(
    iDrive: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn RealDriveType(
    iDrive: i32,
    fOKToHitNet: BOOL,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn IsNetDrive(
    iDrive: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn Shell_MergeMenus(
    hmDst: HMENU,
    hmSrc: HMENU,
    uInsert: u32,
    uIDAdjust: u32,
    uIDAdjustMax: u32,
    uFlags: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHObjectProperties(
    hwnd: HWND,
    shopObjectType: u32,
    pszObjectName: ?*u16,
    pszPropertyPage: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHFormatDrive(
    hwnd: HWND,
    drive: u32,
    fmtID: u32,
    options: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHDestroyPropSheetExtArray(
    hpsxa: ?*HPSXA__,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHAddFromPropSheetExtArray(
    hpsxa: ?*HPSXA__,
    lpfnAddPage: LPFNADDPROPSHEETPAGE,
    lParam: LPARAM,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHReplaceFromPropSheetExtArray(
    hpsxa: ?*HPSXA__,
    uPageID: u32,
    lpfnReplaceWith: LPFNADDPROPSHEETPAGE,
    lParam: LPARAM,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn OpenRegStream(
    hkey: HKEY,
    pszSubkey: ?*u16,
    pszValue: ?*u16,
    grfMode: u32,
) callconv(@import("std").os.windows.WINAPI) IStream;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHFindFiles(
    pidlFolder: ?*ITEMIDLIST,
    pidlSaveFile: ?*ITEMIDLIST,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn PathGetShortPath(
    pszLongPath: ?*u16,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn PathYetAnotherMakeUniqueName(
    pszUniqueName: ?*u16,
    pszPath: ?*u16,
    pszShort: ?*u16,
    pszFileSpec: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn Win32DeleteFile(
    pszPath: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHRestricted(
    rest: RESTRICTIONS,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SignalFileOpen(
    pidl: ?*ITEMIDLIST,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn AssocGetDetailsOfPropKey(
    psf: IShellFolder,
    pidl: ?*ITEMIDLIST,
    pkey: ?*PROPERTYKEY,
    pv: ?*VARIANT,
    pfFoundPropKey: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHStartNetConnectionDialogW(
    hwnd: HWND,
    pszRemoteName: ?*u16,
    dwType: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHDefExtractIconA(
    pszIconFile: ?*i8,
    iIndex: i32,
    uFlags: u32,
    phiconLarge: ?*HICON,
    phiconSmall: ?*HICON,
    nIconSize: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHDefExtractIconW(
    pszIconFile: ?*u16,
    iIndex: i32,
    uFlags: u32,
    phiconLarge: ?*HICON,
    phiconSmall: ?*HICON,
    nIconSize: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHOpenWithDialog(
    hwndParent: HWND,
    poainfo: ?*OPENASINFO,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn Shell_GetImageLists(
    phiml: ?*HIMAGELIST,
    phimlSmall: ?*HIMAGELIST,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn Shell_GetCachedImageIndex(
    pwszIconPath: ?*u16,
    iIconIndex: i32,
    uIconFlags: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn Shell_GetCachedImageIndexA(
    pszIconPath: ?*i8,
    iIconIndex: i32,
    uIconFlags: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn Shell_GetCachedImageIndexW(
    pszIconPath: ?*u16,
    iIconIndex: i32,
    uIconFlags: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHValidateUNC(
    hwndOwner: HWND,
    pszFile: ?*u16,
    fConnect: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHSetInstanceExplorer(
    punk: IUnknown,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn IsUserAnAdmin(
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHShellFolderView_Message(
    hwndMain: HWND,
    uMsg: u32,
    lParam: LPARAM,
) callconv(@import("std").os.windows.WINAPI) LRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHCreateShellFolderView(
    pcsfv: ?*SFV_CREATE,
    ppsv: ?*IShellView,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn CDefFolderMenu_Create2(
    pidlFolder: ?*ITEMIDLIST,
    hwnd: HWND,
    cidl: u32,
    apidl: ?*?*ITEMIDLIST,
    psf: IShellFolder,
    pfn: LPFNDFMCALLBACK,
    nKeys: u32,
    ahkeys: ?*?*opaque{},
    ppcm: ?*IContextMenu,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHCreateDefaultContextMenu(
    pdcm: ?*DEFCONTEXTMENU,
    riid: ?*Guid,
    ppv: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHFind_InitMenuPopup(
    hmenu: HMENU,
    hwndOwner: HWND,
    idCmdFirst: u32,
    idCmdLast: u32,
) callconv(@import("std").os.windows.WINAPI) IContextMenu;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHCreateShellFolderViewEx(
    pcsfv: ?*CSFV,
    ppsv: ?*IShellView,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHGetSetSettings(
    lpss: ?*SHELLSTATEA,
    dwMask: u32,
    bSet: BOOL,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHGetSettings(
    psfs: ?*SHELLFLAGSTATE,
    dwMask: u32,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHBindToParent(
    pidl: ?*ITEMIDLIST,
    riid: ?*Guid,
    ppv: ?*?*opaque{},
    ppidlLast: ?*?*ITEMIDLIST,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHBindToFolderIDListParent(
    psfRoot: IShellFolder,
    pidl: ?*ITEMIDLIST,
    riid: ?*Guid,
    ppv: ?*?*opaque{},
    ppidlLast: ?*?*ITEMIDLIST,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHBindToFolderIDListParentEx(
    psfRoot: IShellFolder,
    pidl: ?*ITEMIDLIST,
    ppbc: IBindCtx,
    riid: ?*Guid,
    ppv: ?*?*opaque{},
    ppidlLast: ?*?*ITEMIDLIST,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHBindToObject(
    psf: IShellFolder,
    pidl: ?*ITEMIDLIST,
    pbc: IBindCtx,
    riid: ?*Guid,
    ppv: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHParseDisplayName(
    pszName: ?*u16,
    pbc: IBindCtx,
    ppidl: ?*?*ITEMIDLIST,
    sfgaoIn: u32,
    psfgaoOut: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHPathPrepareForWriteA(
    hwnd: HWND,
    punkEnableModless: IUnknown,
    pszPath: ?*i8,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHPathPrepareForWriteW(
    hwnd: HWND,
    punkEnableModless: IUnknown,
    pszPath: ?*u16,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHCreateFileExtractIconW(
    pszFile: ?*u16,
    dwFileAttributes: u32,
    riid: ?*Guid,
    ppv: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHLimitInputEdit(
    hwndEdit: HWND,
    psf: IShellFolder,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHGetAttributesFromDataObject(
    pdo: IDataObject,
    dwAttributeMask: u32,
    pdwAttributes: ?*u32,
    pcItems: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHMapPIDLToSystemImageListIndex(
    pshf: IShellFolder,
    pidl: ?*ITEMIDLIST,
    piIndexSel: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHCLSIDFromString(
    psz: ?*u16,
    pclsid: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn PickIconDlg(
    hwnd: HWND,
    pszIconPath: ?*u16,
    cchIconPath: u32,
    piIconIndex: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn StgMakeUniqueName(
    pstgParent: IStorage,
    pszFileSpec: ?*u16,
    grfMode: u32,
    riid: ?*Guid,
    ppv: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHChangeNotifyRegisterThread(
    status: SCNRT_STATUS,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn PathQualify(
    psz: ?*u16,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn PathIsSlowA(
    pszFile: ?*i8,
    dwAttr: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn PathIsSlowW(
    pszFile: ?*u16,
    dwAttr: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHCreatePropSheetExtArray(
    hKey: HKEY,
    pszSubKey: ?*u16,
    max_iface: u32,
) callconv(@import("std").os.windows.WINAPI) ?*HPSXA__;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHOpenPropSheetW(
    pszCaption: ?*u16,
    ahkeys: ?*?*HKEY,
    ckeys: u32,
    pclsidDefault: ?*Guid,
    pdtobj: IDataObject,
    psb: IShellBrowser,
    pStartPage: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHDOCVW" fn SoftwareUpdateMessageBox(
    hWnd: HWND,
    pszDistUnit: ?*u16,
    dwFlags: u32,
    psdi: ?*SOFTDISTINFO,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHMultiFileProperties(
    pdtobj: IDataObject,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHELL32" fn SHCreateQueryCancelAutoPlayMoniker(
    ppmoniker: ?*IMoniker,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHDOCVW" fn ImportPrivacySettings(
    pszFilename: ?*u16,
    pfParsePrivacyPreferences: ?*i32,
    pfParsePerSiteRules: ?*i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHDOCVW" fn DoPrivacyDlg(
    hwndOwner: HWND,
    pszUrl: ?*u16,
    pPrivacyEnum: IEnumPrivacyRecords,
    fReportAllSites: BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-shcore-scaling-l1-1-0" fn GetScaleFactorForDevice(
    deviceType: DISPLAY_DEVICE_TYPE,
) callconv(@import("std").os.windows.WINAPI) DEVICE_SCALE_FACTOR;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-shcore-scaling-l1-1-0" fn RegisterScaleChangeNotifications(
    displayDevice: DISPLAY_DEVICE_TYPE,
    hwndNotify: HWND,
    uMsgNotify: u32,
    pdwCookie: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-shcore-scaling-l1-1-0" fn RevokeScaleChangeNotifications(
    displayDevice: DISPLAY_DEVICE_TYPE,
    dwCookie: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-shcore-scaling-l1-1-1" fn GetScaleFactorForMonitor(
    hMon: ?*opaque{},
    pScale: ?*DEVICE_SCALE_FACTOR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-shcore-scaling-l1-1-1" fn RegisterScaleChangeEvent(
    hEvent: HANDLE,
    pdwCookie: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-shcore-scaling-l1-1-1" fn UnregisterScaleChangeEvent(
    dwCookie: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-shcore-scaling-l1-1-2" fn GetDpiForShellUIComponent(
    param0: SHELL_UI_COMPONENT,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn StrChrA(
    pszStart: ?*i8,
    wMatch: u16,
) callconv(@import("std").os.windows.WINAPI) ?*i8;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn StrChrW(
    pszStart: ?*u16,
    wMatch: u16,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn StrChrIA(
    pszStart: ?*i8,
    wMatch: u16,
) callconv(@import("std").os.windows.WINAPI) ?*i8;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn StrChrIW(
    pszStart: ?*u16,
    wMatch: u16,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn StrChrNW(
    pszStart: ?*u16,
    wMatch: u16,
    cchMax: u32,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn StrChrNIW(
    pszStart: ?*u16,
    wMatch: u16,
    cchMax: u32,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn StrCmpNA(
    psz1: ?*i8,
    psz2: ?*i8,
    nChar: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn StrCmpNW(
    psz1: ?*u16,
    psz2: ?*u16,
    nChar: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn StrCmpNIA(
    psz1: ?*i8,
    psz2: ?*i8,
    nChar: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn StrCmpNIW(
    psz1: ?*u16,
    psz2: ?*u16,
    nChar: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn StrCSpnA(
    pszStr: ?*i8,
    pszSet: ?*i8,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn StrCSpnW(
    pszStr: ?*u16,
    pszSet: ?*u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn StrCSpnIA(
    pszStr: ?*i8,
    pszSet: ?*i8,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn StrCSpnIW(
    pszStr: ?*u16,
    pszSet: ?*u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn StrDupA(
    pszSrch: ?*i8,
) callconv(@import("std").os.windows.WINAPI) ?*i8;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn StrDupW(
    pszSrch: ?*u16,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn StrFormatByteSizeEx(
    ull: u64,
    flags: i32,
    pszBuf: ?*u16,
    cchBuf: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn StrFormatByteSizeA(
    dw: u32,
    pszBuf: ?*i8,
    cchBuf: u32,
) callconv(@import("std").os.windows.WINAPI) ?*i8;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn StrFormatByteSize64A(
    qdw: i64,
    pszBuf: ?*i8,
    cchBuf: u32,
) callconv(@import("std").os.windows.WINAPI) ?*i8;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn StrFormatByteSizeW(
    qdw: i64,
    pszBuf: ?*u16,
    cchBuf: u32,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn StrFormatKBSizeW(
    qdw: i64,
    pszBuf: ?*u16,
    cchBuf: u32,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn StrFormatKBSizeA(
    qdw: i64,
    pszBuf: ?*i8,
    cchBuf: u32,
) callconv(@import("std").os.windows.WINAPI) ?*i8;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn StrFromTimeIntervalA(
    pszOut: ?*i8,
    cchMax: u32,
    dwTimeMS: u32,
    digits: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn StrFromTimeIntervalW(
    pszOut: ?*u16,
    cchMax: u32,
    dwTimeMS: u32,
    digits: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn StrIsIntlEqualA(
    fCaseSens: BOOL,
    pszString1: ?*i8,
    pszString2: ?*i8,
    nChar: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn StrIsIntlEqualW(
    fCaseSens: BOOL,
    pszString1: ?*u16,
    pszString2: ?*u16,
    nChar: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn StrNCatA(
    psz1: ?*i8,
    psz2: ?*i8,
    cchMax: i32,
) callconv(@import("std").os.windows.WINAPI) ?*i8;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn StrNCatW(
    psz1: ?*u16,
    psz2: ?*u16,
    cchMax: i32,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn StrPBrkA(
    psz: ?*i8,
    pszSet: ?*i8,
) callconv(@import("std").os.windows.WINAPI) ?*i8;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn StrPBrkW(
    psz: ?*u16,
    pszSet: ?*u16,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn StrRChrA(
    pszStart: ?*i8,
    pszEnd: ?*i8,
    wMatch: u16,
) callconv(@import("std").os.windows.WINAPI) ?*i8;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn StrRChrW(
    pszStart: ?*u16,
    pszEnd: ?*u16,
    wMatch: u16,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn StrRChrIA(
    pszStart: ?*i8,
    pszEnd: ?*i8,
    wMatch: u16,
) callconv(@import("std").os.windows.WINAPI) ?*i8;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn StrRChrIW(
    pszStart: ?*u16,
    pszEnd: ?*u16,
    wMatch: u16,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn StrRStrIA(
    pszSource: ?*i8,
    pszLast: ?*i8,
    pszSrch: ?*i8,
) callconv(@import("std").os.windows.WINAPI) ?*i8;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn StrRStrIW(
    pszSource: ?*u16,
    pszLast: ?*u16,
    pszSrch: ?*u16,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn StrSpnA(
    psz: ?*i8,
    pszSet: ?*i8,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn StrSpnW(
    psz: ?*u16,
    pszSet: ?*u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn StrStrA(
    pszFirst: ?*i8,
    pszSrch: ?*i8,
) callconv(@import("std").os.windows.WINAPI) ?*i8;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn StrStrW(
    pszFirst: ?*u16,
    pszSrch: ?*u16,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn StrStrIA(
    pszFirst: ?*i8,
    pszSrch: ?*i8,
) callconv(@import("std").os.windows.WINAPI) ?*i8;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn StrStrIW(
    pszFirst: ?*u16,
    pszSrch: ?*u16,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn StrStrNW(
    pszFirst: ?*u16,
    pszSrch: ?*u16,
    cchMax: u32,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn StrStrNIW(
    pszFirst: ?*u16,
    pszSrch: ?*u16,
    cchMax: u32,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn StrToIntA(
    pszSrc: ?*i8,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn StrToIntW(
    pszSrc: ?*u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn StrToIntExA(
    pszString: ?*i8,
    dwFlags: i32,
    piRet: ?*i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn StrToIntExW(
    pszString: ?*u16,
    dwFlags: i32,
    piRet: ?*i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn StrToInt64ExA(
    pszString: ?*i8,
    dwFlags: i32,
    pllRet: ?*i64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn StrToInt64ExW(
    pszString: ?*u16,
    dwFlags: i32,
    pllRet: ?*i64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn StrTrimA(
    psz: ?*i8,
    pszTrimChars: ?*i8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn StrTrimW(
    psz: ?*u16,
    pszTrimChars: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn StrCatW(
    psz1: ?*u16,
    psz2: ?*u16,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn StrCmpW(
    psz1: ?*u16,
    psz2: ?*u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn StrCmpIW(
    psz1: ?*u16,
    psz2: ?*u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn StrCpyW(
    psz1: ?*u16,
    psz2: ?*u16,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn StrCpyNW(
    pszDst: ?*u16,
    pszSrc: ?*u16,
    cchMax: i32,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn StrCatBuffW(
    pszDest: ?*u16,
    pszSrc: ?*u16,
    cchDestBuffSize: i32,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn StrCatBuffA(
    pszDest: ?*i8,
    pszSrc: ?*i8,
    cchDestBuffSize: i32,
) callconv(@import("std").os.windows.WINAPI) ?*i8;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn ChrCmpIA(
    w1: u16,
    w2: u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn ChrCmpIW(
    w1: u16,
    w2: u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn wvnsprintfA(
    pszDest: ?*i8,
    cchDest: i32,
    pszFmt: ?*i8,
    arglist: ?*i8,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn wvnsprintfW(
    pszDest: ?*u16,
    cchDest: i32,
    pszFmt: ?*u16,
    arglist: ?*i8,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn wnsprintfA(
    pszDest: ?*i8,
    cchDest: i32,
    pszFmt: ?*i8,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn wnsprintfW(
    pszDest: ?*u16,
    cchDest: i32,
    pszFmt: ?*u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn StrRetToStrA(
    pstr: ?*STRRET,
    pidl: ?*ITEMIDLIST,
    ppsz: ?*?*i8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn StrRetToStrW(
    pstr: ?*STRRET,
    pidl: ?*ITEMIDLIST,
    ppsz: ?*?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn StrRetToBufA(
    pstr: ?*STRRET,
    pidl: ?*ITEMIDLIST,
    pszBuf: ?*i8,
    cchBuf: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn StrRetToBufW(
    pstr: ?*STRRET,
    pidl: ?*ITEMIDLIST,
    pszBuf: ?*u16,
    cchBuf: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn SHStrDupA(
    psz: ?*i8,
    ppwsz: ?*?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn SHStrDupW(
    psz: ?*u16,
    ppwsz: ?*?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn StrCmpLogicalW(
    psz1: ?*u16,
    psz2: ?*u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn StrCatChainW(
    pszDst: ?*u16,
    cchDst: u32,
    ichAt: u32,
    pszSrc: ?*u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn StrRetToBSTR(
    pstr: ?*STRRET,
    pidl: ?*ITEMIDLIST,
    pbstr: ?*BSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn SHLoadIndirectString(
    pszSource: ?*u16,
    pszOutBuf: ?*u16,
    cchOutBuf: u32,
    ppvReserved: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn IsCharSpaceA(
    wch: i8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn IsCharSpaceW(
    wch: u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn StrCmpCA(
    pszStr1: ?*i8,
    pszStr2: ?*i8,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn StrCmpCW(
    pszStr1: ?*u16,
    pszStr2: ?*u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn StrCmpICA(
    pszStr1: ?*i8,
    pszStr2: ?*i8,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn StrCmpICW(
    pszStr1: ?*u16,
    pszStr2: ?*u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn StrCmpNCA(
    pszStr1: ?*i8,
    pszStr2: ?*i8,
    nChar: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn StrCmpNCW(
    pszStr1: ?*u16,
    pszStr2: ?*u16,
    nChar: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn StrCmpNICA(
    pszStr1: ?*i8,
    pszStr2: ?*i8,
    nChar: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn StrCmpNICW(
    pszStr1: ?*u16,
    pszStr2: ?*u16,
    nChar: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn IntlStrEqWorkerA(
    fCaseSens: BOOL,
    lpString1: ?*i8,
    lpString2: ?*i8,
    nChar: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn IntlStrEqWorkerW(
    fCaseSens: BOOL,
    lpString1: ?*u16,
    lpString2: ?*u16,
    nChar: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn PathAddBackslashA(
    pszPath: ?*i8,
) callconv(@import("std").os.windows.WINAPI) ?*i8;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn PathAddBackslashW(
    pszPath: ?*u16,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn PathAddExtensionA(
    pszPath: ?*i8,
    pszExt: ?*i8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn PathAddExtensionW(
    pszPath: ?*u16,
    pszExt: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn PathAppendA(
    pszPath: ?*i8,
    pszMore: ?*i8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn PathAppendW(
    pszPath: ?*u16,
    pszMore: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn PathBuildRootA(
    pszRoot: ?*i8,
    iDrive: i32,
) callconv(@import("std").os.windows.WINAPI) ?*i8;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn PathBuildRootW(
    pszRoot: ?*u16,
    iDrive: i32,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

// set_last_errror=True (can and should we use this?)
pub extern "SHLWAPI" fn PathCanonicalizeA(
    pszBuf: ?*i8,
    pszPath: ?*i8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "SHLWAPI" fn PathCanonicalizeW(
    pszBuf: ?*u16,
    pszPath: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn PathCombineA(
    pszDest: ?*i8,
    pszDir: ?*i8,
    pszFile: ?*i8,
) callconv(@import("std").os.windows.WINAPI) ?*i8;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn PathCombineW(
    pszDest: ?*u16,
    pszDir: ?*u16,
    pszFile: ?*u16,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn PathCompactPathA(
    hDC: HDC,
    pszPath: ?*i8,
    dx: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn PathCompactPathW(
    hDC: HDC,
    pszPath: ?*u16,
    dx: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn PathCompactPathExA(
    pszOut: ?*i8,
    pszSrc: ?*i8,
    cchMax: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn PathCompactPathExW(
    pszOut: ?*u16,
    pszSrc: ?*u16,
    cchMax: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn PathCommonPrefixA(
    pszFile1: ?*i8,
    pszFile2: ?*i8,
    achPath: ?*i8,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn PathCommonPrefixW(
    pszFile1: ?*u16,
    pszFile2: ?*u16,
    achPath: ?*u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=True (can and should we use this?)
pub extern "SHLWAPI" fn PathFileExistsA(
    pszPath: ?*i8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "SHLWAPI" fn PathFileExistsW(
    pszPath: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn PathFindExtensionA(
    pszPath: ?*i8,
) callconv(@import("std").os.windows.WINAPI) ?*i8;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn PathFindExtensionW(
    pszPath: ?*u16,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn PathFindFileNameA(
    pszPath: ?*i8,
) callconv(@import("std").os.windows.WINAPI) ?*i8;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn PathFindFileNameW(
    pszPath: ?*u16,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn PathFindNextComponentA(
    pszPath: ?*i8,
) callconv(@import("std").os.windows.WINAPI) ?*i8;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn PathFindNextComponentW(
    pszPath: ?*u16,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn PathFindOnPathA(
    pszPath: ?*i8,
    ppszOtherDirs: ?*?*i8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn PathFindOnPathW(
    pszPath: ?*u16,
    ppszOtherDirs: ?*?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn PathFindSuffixArrayA(
    pszPath: ?*i8,
    apszSuffix: ?*?*i8,
    iArraySize: i32,
) callconv(@import("std").os.windows.WINAPI) ?*i8;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn PathFindSuffixArrayW(
    pszPath: ?*u16,
    apszSuffix: ?*?*u16,
    iArraySize: i32,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn PathGetArgsA(
    pszPath: ?*i8,
) callconv(@import("std").os.windows.WINAPI) ?*i8;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn PathGetArgsW(
    pszPath: ?*u16,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn PathIsLFNFileSpecA(
    pszName: ?*i8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn PathIsLFNFileSpecW(
    pszName: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn PathGetCharTypeA(
    ch: u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn PathGetCharTypeW(
    ch: u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn PathGetDriveNumberA(
    pszPath: ?*i8,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn PathGetDriveNumberW(
    pszPath: ?*u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn PathIsDirectoryA(
    pszPath: ?*i8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn PathIsDirectoryW(
    pszPath: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn PathIsDirectoryEmptyA(
    pszPath: ?*i8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn PathIsDirectoryEmptyW(
    pszPath: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn PathIsFileSpecA(
    pszPath: ?*i8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn PathIsFileSpecW(
    pszPath: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn PathIsPrefixA(
    pszPrefix: ?*i8,
    pszPath: ?*i8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn PathIsPrefixW(
    pszPrefix: ?*u16,
    pszPath: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn PathIsRelativeA(
    pszPath: ?*i8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn PathIsRelativeW(
    pszPath: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn PathIsRootA(
    pszPath: ?*i8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn PathIsRootW(
    pszPath: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn PathIsSameRootA(
    pszPath1: ?*i8,
    pszPath2: ?*i8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn PathIsSameRootW(
    pszPath1: ?*u16,
    pszPath2: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn PathIsUNCA(
    pszPath: ?*i8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn PathIsUNCW(
    pszPath: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn PathIsNetworkPathA(
    pszPath: ?*i8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn PathIsNetworkPathW(
    pszPath: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn PathIsUNCServerA(
    pszPath: ?*i8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn PathIsUNCServerW(
    pszPath: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn PathIsUNCServerShareA(
    pszPath: ?*i8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn PathIsUNCServerShareW(
    pszPath: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn PathIsContentTypeA(
    pszPath: ?*i8,
    pszContentType: ?*i8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn PathIsContentTypeW(
    pszPath: ?*u16,
    pszContentType: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn PathIsURLA(
    pszPath: ?*i8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn PathIsURLW(
    pszPath: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn PathMakePrettyA(
    pszPath: ?*i8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn PathMakePrettyW(
    pszPath: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn PathMatchSpecA(
    pszFile: ?*i8,
    pszSpec: ?*i8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn PathMatchSpecW(
    pszFile: ?*u16,
    pszSpec: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn PathMatchSpecExA(
    pszFile: ?*i8,
    pszSpec: ?*i8,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn PathMatchSpecExW(
    pszFile: ?*u16,
    pszSpec: ?*u16,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn PathParseIconLocationA(
    pszIconFile: ?*i8,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn PathParseIconLocationW(
    pszIconFile: ?*u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn PathQuoteSpacesA(
    lpsz: ?*i8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn PathQuoteSpacesW(
    lpsz: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn PathRelativePathToA(
    pszPath: ?*i8,
    pszFrom: ?*i8,
    dwAttrFrom: u32,
    pszTo: ?*i8,
    dwAttrTo: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn PathRelativePathToW(
    pszPath: ?*u16,
    pszFrom: ?*u16,
    dwAttrFrom: u32,
    pszTo: ?*u16,
    dwAttrTo: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn PathRemoveArgsA(
    pszPath: ?*i8,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn PathRemoveArgsW(
    pszPath: ?*u16,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn PathRemoveBackslashA(
    pszPath: ?*i8,
) callconv(@import("std").os.windows.WINAPI) ?*i8;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn PathRemoveBackslashW(
    pszPath: ?*u16,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn PathRemoveBlanksA(
    pszPath: ?*i8,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn PathRemoveBlanksW(
    pszPath: ?*u16,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn PathRemoveExtensionA(
    pszPath: ?*i8,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn PathRemoveExtensionW(
    pszPath: ?*u16,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn PathRemoveFileSpecA(
    pszPath: ?*i8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn PathRemoveFileSpecW(
    pszPath: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn PathRenameExtensionA(
    pszPath: ?*i8,
    pszExt: ?*i8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn PathRenameExtensionW(
    pszPath: ?*u16,
    pszExt: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn PathSearchAndQualifyA(
    pszPath: ?*i8,
    pszBuf: ?*i8,
    cchBuf: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn PathSearchAndQualifyW(
    pszPath: ?*u16,
    pszBuf: ?*u16,
    cchBuf: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn PathSetDlgItemPathA(
    hDlg: HWND,
    id: i32,
    pszPath: ?*i8,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn PathSetDlgItemPathW(
    hDlg: HWND,
    id: i32,
    pszPath: ?*u16,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn PathSkipRootA(
    pszPath: ?*i8,
) callconv(@import("std").os.windows.WINAPI) ?*i8;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn PathSkipRootW(
    pszPath: ?*u16,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn PathStripPathA(
    pszPath: ?*i8,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn PathStripPathW(
    pszPath: ?*u16,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn PathStripToRootA(
    pszPath: ?*i8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn PathStripToRootW(
    pszPath: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn PathUnquoteSpacesA(
    lpsz: ?*i8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn PathUnquoteSpacesW(
    lpsz: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn PathMakeSystemFolderA(
    pszPath: ?*i8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn PathMakeSystemFolderW(
    pszPath: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn PathUnmakeSystemFolderA(
    pszPath: ?*i8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn PathUnmakeSystemFolderW(
    pszPath: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn PathIsSystemFolderA(
    pszPath: ?*i8,
    dwAttrb: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn PathIsSystemFolderW(
    pszPath: ?*u16,
    dwAttrb: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn PathUndecorateA(
    pszPath: ?*i8,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn PathUndecorateW(
    pszPath: ?*u16,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn PathUnExpandEnvStringsA(
    pszPath: ?*i8,
    pszBuf: ?*i8,
    cchBuf: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn PathUnExpandEnvStringsW(
    pszPath: ?*u16,
    pszBuf: ?*u16,
    cchBuf: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn UrlCompareA(
    psz1: ?*i8,
    psz2: ?*i8,
    fIgnoreSlash: BOOL,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn UrlCompareW(
    psz1: ?*u16,
    psz2: ?*u16,
    fIgnoreSlash: BOOL,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn UrlCombineA(
    pszBase: ?*i8,
    pszRelative: ?*i8,
    pszCombined: ?*i8,
    pcchCombined: ?*u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn UrlCombineW(
    pszBase: ?*u16,
    pszRelative: ?*u16,
    pszCombined: ?*u16,
    pcchCombined: ?*u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn UrlCanonicalizeA(
    pszUrl: ?*i8,
    pszCanonicalized: ?*i8,
    pcchCanonicalized: ?*u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn UrlCanonicalizeW(
    pszUrl: ?*u16,
    pszCanonicalized: ?*u16,
    pcchCanonicalized: ?*u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn UrlIsOpaqueA(
    pszURL: ?*i8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn UrlIsOpaqueW(
    pszURL: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn UrlIsNoHistoryA(
    pszURL: ?*i8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn UrlIsNoHistoryW(
    pszURL: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn UrlIsA(
    pszUrl: ?*i8,
    UrlIs: URLIS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn UrlIsW(
    pszUrl: ?*u16,
    UrlIs: URLIS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn UrlGetLocationA(
    pszURL: ?*i8,
) callconv(@import("std").os.windows.WINAPI) ?*i8;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn UrlGetLocationW(
    pszURL: ?*u16,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn UrlUnescapeA(
    pszUrl: ?*i8,
    pszUnescaped: ?*i8,
    pcchUnescaped: ?*u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn UrlUnescapeW(
    pszUrl: ?*u16,
    pszUnescaped: ?*u16,
    pcchUnescaped: ?*u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn UrlEscapeA(
    pszUrl: ?*i8,
    pszEscaped: ?*i8,
    pcchEscaped: ?*u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn UrlEscapeW(
    pszUrl: ?*u16,
    pszEscaped: ?*u16,
    pcchEscaped: ?*u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn UrlCreateFromPathA(
    pszPath: ?*i8,
    pszUrl: ?*i8,
    pcchUrl: ?*u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn UrlCreateFromPathW(
    pszPath: ?*u16,
    pszUrl: ?*u16,
    pcchUrl: ?*u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn PathCreateFromUrlA(
    pszUrl: ?*i8,
    pszPath: ?*i8,
    pcchPath: ?*u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn PathCreateFromUrlW(
    pszUrl: ?*u16,
    pszPath: ?*u16,
    pcchPath: ?*u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn PathCreateFromUrlAlloc(
    pszIn: ?*u16,
    ppszOut: ?*?*u16,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn UrlHashA(
    pszUrl: ?*i8,
    pbHash: ?*u8,
    cbHash: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn UrlHashW(
    pszUrl: ?*u16,
    pbHash: ?*u8,
    cbHash: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn UrlGetPartW(
    pszIn: ?*u16,
    pszOut: ?*u16,
    pcchOut: ?*u32,
    dwPart: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn UrlGetPartA(
    pszIn: ?*i8,
    pszOut: ?*i8,
    pcchOut: ?*u32,
    dwPart: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn UrlApplySchemeA(
    pszIn: ?*i8,
    pszOut: ?*i8,
    pcchOut: ?*u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn UrlApplySchemeW(
    pszIn: ?*u16,
    pszOut: ?*u16,
    pcchOut: ?*u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn HashData(
    pbData: ?*u8,
    cbData: u32,
    pbHash: ?*u8,
    cbHash: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn UrlFixupW(
    pcszUrl: ?*u16,
    pszTranslatedUrl: ?*u16,
    cchMax: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn ParseURLA(
    pcszURL: ?*i8,
    ppu: ?*PARSEDURLA,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn ParseURLW(
    pcszURL: ?*u16,
    ppu: ?*PARSEDURLW,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn SHDeleteEmptyKeyA(
    hkey: HKEY,
    pszSubKey: ?*i8,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn SHDeleteEmptyKeyW(
    hkey: HKEY,
    pszSubKey: ?*u16,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn SHDeleteKeyA(
    hkey: HKEY,
    pszSubKey: ?*i8,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn SHDeleteKeyW(
    hkey: HKEY,
    pszSubKey: ?*u16,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn SHRegDuplicateHKey(
    hkey: HKEY,
) callconv(@import("std").os.windows.WINAPI) HKEY;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn SHDeleteValueA(
    hkey: HKEY,
    pszSubKey: ?*i8,
    pszValue: ?*i8,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn SHDeleteValueW(
    hkey: HKEY,
    pszSubKey: ?*u16,
    pszValue: ?*u16,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn SHGetValueA(
    hkey: HKEY,
    pszSubKey: ?*i8,
    pszValue: ?*i8,
    pdwType: ?*u32,
    pvData: ?*opaque{},
    pcbData: ?*u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn SHGetValueW(
    hkey: HKEY,
    pszSubKey: ?*u16,
    pszValue: ?*u16,
    pdwType: ?*u32,
    pvData: ?*opaque{},
    pcbData: ?*u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn SHSetValueA(
    hkey: HKEY,
    pszSubKey: ?*i8,
    pszValue: ?*i8,
    dwType: u32,
    pvData: ?*opaque{},
    cbData: u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn SHSetValueW(
    hkey: HKEY,
    pszSubKey: ?*u16,
    pszValue: ?*u16,
    dwType: u32,
    pvData: ?*opaque{},
    cbData: u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn SHRegGetValueA(
    hkey: HKEY,
    pszSubKey: ?*i8,
    pszValue: ?*i8,
    srrfFlags: i32,
    pdwType: ?*u32,
    pvData: ?*opaque{},
    pcbData: ?*u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn SHRegGetValueW(
    hkey: HKEY,
    pszSubKey: ?*u16,
    pszValue: ?*u16,
    srrfFlags: i32,
    pdwType: ?*u32,
    pvData: ?*opaque{},
    pcbData: ?*u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn SHRegGetValueFromHKCUHKLM(
    pwszKey: ?*u16,
    pwszValue: ?*u16,
    srrfFlags: i32,
    pdwType: ?*u32,
    pvData: ?*opaque{},
    pcbData: ?*u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn SHQueryValueExA(
    hkey: HKEY,
    pszValue: ?*i8,
    pdwReserved: ?*u32,
    pdwType: ?*u32,
    pvData: ?*opaque{},
    pcbData: ?*u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn SHQueryValueExW(
    hkey: HKEY,
    pszValue: ?*u16,
    pdwReserved: ?*u32,
    pdwType: ?*u32,
    pvData: ?*opaque{},
    pcbData: ?*u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn SHEnumKeyExA(
    hkey: HKEY,
    dwIndex: u32,
    pszName: ?*i8,
    pcchName: ?*u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn SHEnumKeyExW(
    hkey: HKEY,
    dwIndex: u32,
    pszName: ?*u16,
    pcchName: ?*u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn SHEnumValueA(
    hkey: HKEY,
    dwIndex: u32,
    pszValueName: ?*i8,
    pcchValueName: ?*u32,
    pdwType: ?*u32,
    pvData: ?*opaque{},
    pcbData: ?*u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn SHEnumValueW(
    hkey: HKEY,
    dwIndex: u32,
    pszValueName: ?*u16,
    pcchValueName: ?*u32,
    pdwType: ?*u32,
    pvData: ?*opaque{},
    pcbData: ?*u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn SHQueryInfoKeyA(
    hkey: HKEY,
    pcSubKeys: ?*u32,
    pcchMaxSubKeyLen: ?*u32,
    pcValues: ?*u32,
    pcchMaxValueNameLen: ?*u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn SHQueryInfoKeyW(
    hkey: HKEY,
    pcSubKeys: ?*u32,
    pcchMaxSubKeyLen: ?*u32,
    pcValues: ?*u32,
    pcchMaxValueNameLen: ?*u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn SHCopyKeyA(
    hkeySrc: HKEY,
    pszSrcSubKey: ?*i8,
    hkeyDest: HKEY,
    fReserved: u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn SHCopyKeyW(
    hkeySrc: HKEY,
    pszSrcSubKey: ?*u16,
    hkeyDest: HKEY,
    fReserved: u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn SHRegGetPathA(
    hKey: HKEY,
    pcszSubKey: ?*i8,
    pcszValue: ?*i8,
    pszPath: ?*i8,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn SHRegGetPathW(
    hKey: HKEY,
    pcszSubKey: ?*u16,
    pcszValue: ?*u16,
    pszPath: ?*u16,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn SHRegSetPathA(
    hKey: HKEY,
    pcszSubKey: ?*i8,
    pcszValue: ?*i8,
    pcszPath: ?*i8,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn SHRegSetPathW(
    hKey: HKEY,
    pcszSubKey: ?*u16,
    pcszValue: ?*u16,
    pcszPath: ?*u16,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn SHRegCreateUSKeyA(
    pszPath: ?*i8,
    samDesired: u32,
    hRelativeUSKey: ?*opaque{},
    phNewUSKey: ?*?*opaque{},
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn SHRegCreateUSKeyW(
    pwzPath: ?*u16,
    samDesired: u32,
    hRelativeUSKey: ?*opaque{},
    phNewUSKey: ?*?*opaque{},
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn SHRegOpenUSKeyA(
    pszPath: ?*i8,
    samDesired: u32,
    hRelativeUSKey: ?*opaque{},
    phNewUSKey: ?*?*opaque{},
    fIgnoreHKCU: BOOL,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn SHRegOpenUSKeyW(
    pwzPath: ?*u16,
    samDesired: u32,
    hRelativeUSKey: ?*opaque{},
    phNewUSKey: ?*?*opaque{},
    fIgnoreHKCU: BOOL,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn SHRegQueryUSValueA(
    hUSKey: ?*opaque{},
    pszValue: ?*i8,
    pdwType: ?*u32,
    pvData: ?*opaque{},
    pcbData: ?*u32,
    fIgnoreHKCU: BOOL,
    pvDefaultData: ?*opaque{},
    dwDefaultDataSize: u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn SHRegQueryUSValueW(
    hUSKey: ?*opaque{},
    pszValue: ?*u16,
    pdwType: ?*u32,
    pvData: ?*opaque{},
    pcbData: ?*u32,
    fIgnoreHKCU: BOOL,
    pvDefaultData: ?*opaque{},
    dwDefaultDataSize: u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn SHRegWriteUSValueA(
    hUSKey: ?*opaque{},
    pszValue: ?*i8,
    dwType: u32,
    pvData: ?*opaque{},
    cbData: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn SHRegWriteUSValueW(
    hUSKey: ?*opaque{},
    pwzValue: ?*u16,
    dwType: u32,
    pvData: ?*opaque{},
    cbData: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn SHRegDeleteUSValueA(
    hUSKey: ?*opaque{},
    pszValue: ?*i8,
    delRegFlags: SHREGDEL_FLAGS,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn SHRegDeleteUSValueW(
    hUSKey: ?*opaque{},
    pwzValue: ?*u16,
    delRegFlags: SHREGDEL_FLAGS,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn SHRegDeleteEmptyUSKeyW(
    hUSKey: ?*opaque{},
    pwzSubKey: ?*u16,
    delRegFlags: SHREGDEL_FLAGS,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn SHRegDeleteEmptyUSKeyA(
    hUSKey: ?*opaque{},
    pszSubKey: ?*i8,
    delRegFlags: SHREGDEL_FLAGS,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn SHRegEnumUSKeyA(
    hUSKey: ?*opaque{},
    dwIndex: u32,
    pszName: ?*i8,
    pcchName: ?*u32,
    enumRegFlags: SHREGENUM_FLAGS,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn SHRegEnumUSKeyW(
    hUSKey: ?*opaque{},
    dwIndex: u32,
    pwzName: ?*u16,
    pcchName: ?*u32,
    enumRegFlags: SHREGENUM_FLAGS,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn SHRegEnumUSValueA(
    hUSkey: ?*opaque{},
    dwIndex: u32,
    pszValueName: ?*i8,
    pcchValueName: ?*u32,
    pdwType: ?*u32,
    pvData: ?*opaque{},
    pcbData: ?*u32,
    enumRegFlags: SHREGENUM_FLAGS,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn SHRegEnumUSValueW(
    hUSkey: ?*opaque{},
    dwIndex: u32,
    pszValueName: ?*u16,
    pcchValueName: ?*u32,
    pdwType: ?*u32,
    pvData: ?*opaque{},
    pcbData: ?*u32,
    enumRegFlags: SHREGENUM_FLAGS,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn SHRegQueryInfoUSKeyA(
    hUSKey: ?*opaque{},
    pcSubKeys: ?*u32,
    pcchMaxSubKeyLen: ?*u32,
    pcValues: ?*u32,
    pcchMaxValueNameLen: ?*u32,
    enumRegFlags: SHREGENUM_FLAGS,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn SHRegQueryInfoUSKeyW(
    hUSKey: ?*opaque{},
    pcSubKeys: ?*u32,
    pcchMaxSubKeyLen: ?*u32,
    pcValues: ?*u32,
    pcchMaxValueNameLen: ?*u32,
    enumRegFlags: SHREGENUM_FLAGS,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn SHRegCloseUSKey(
    hUSKey: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn SHRegGetUSValueA(
    pszSubKey: ?*i8,
    pszValue: ?*i8,
    pdwType: ?*u32,
    pvData: ?*opaque{},
    pcbData: ?*u32,
    fIgnoreHKCU: BOOL,
    pvDefaultData: ?*opaque{},
    dwDefaultDataSize: u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn SHRegGetUSValueW(
    pszSubKey: ?*u16,
    pszValue: ?*u16,
    pdwType: ?*u32,
    pvData: ?*opaque{},
    pcbData: ?*u32,
    fIgnoreHKCU: BOOL,
    pvDefaultData: ?*opaque{},
    dwDefaultDataSize: u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn SHRegSetUSValueA(
    pszSubKey: ?*i8,
    pszValue: ?*i8,
    dwType: u32,
    pvData: ?*opaque{},
    cbData: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn SHRegSetUSValueW(
    pwzSubKey: ?*u16,
    pwzValue: ?*u16,
    dwType: u32,
    pvData: ?*opaque{},
    cbData: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn SHRegGetIntW(
    hk: HKEY,
    pwzKey: ?*u16,
    iDefault: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn SHRegGetBoolUSValueA(
    pszSubKey: ?*i8,
    pszValue: ?*i8,
    fIgnoreHKCU: BOOL,
    fDefault: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn SHRegGetBoolUSValueW(
    pszSubKey: ?*u16,
    pszValue: ?*u16,
    fIgnoreHKCU: BOOL,
    fDefault: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn AssocCreate(
    clsid: Guid,
    riid: ?*Guid,
    ppv: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn AssocQueryStringA(
    flags: u32,
    str: ASSOCSTR,
    pszAssoc: ?*i8,
    pszExtra: ?*i8,
    pszOut: ?*i8,
    pcchOut: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn AssocQueryStringW(
    flags: u32,
    str: ASSOCSTR,
    pszAssoc: ?*u16,
    pszExtra: ?*u16,
    pszOut: ?*u16,
    pcchOut: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn AssocQueryStringByKeyA(
    flags: u32,
    str: ASSOCSTR,
    hkAssoc: HKEY,
    pszExtra: ?*i8,
    pszOut: ?*i8,
    pcchOut: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn AssocQueryStringByKeyW(
    flags: u32,
    str: ASSOCSTR,
    hkAssoc: HKEY,
    pszExtra: ?*u16,
    pszOut: ?*u16,
    pcchOut: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn AssocQueryKeyA(
    flags: u32,
    key: ASSOCKEY,
    pszAssoc: ?*i8,
    pszExtra: ?*i8,
    phkeyOut: ?*HKEY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn AssocQueryKeyW(
    flags: u32,
    key: ASSOCKEY,
    pszAssoc: ?*u16,
    pszExtra: ?*u16,
    phkeyOut: ?*HKEY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn AssocIsDangerous(
    pszAssoc: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn AssocGetPerceivedType(
    pszExt: ?*u16,
    ptype: ?*PERCEIVED,
    pflag: ?*u32,
    ppszType: ?*?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn SHOpenRegStreamA(
    hkey: HKEY,
    pszSubkey: ?*i8,
    pszValue: ?*i8,
    grfMode: u32,
) callconv(@import("std").os.windows.WINAPI) IStream;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn SHOpenRegStreamW(
    hkey: HKEY,
    pszSubkey: ?*u16,
    pszValue: ?*u16,
    grfMode: u32,
) callconv(@import("std").os.windows.WINAPI) IStream;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn SHOpenRegStream2A(
    hkey: HKEY,
    pszSubkey: ?*i8,
    pszValue: ?*i8,
    grfMode: u32,
) callconv(@import("std").os.windows.WINAPI) IStream;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn SHOpenRegStream2W(
    hkey: HKEY,
    pszSubkey: ?*u16,
    pszValue: ?*u16,
    grfMode: u32,
) callconv(@import("std").os.windows.WINAPI) IStream;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn SHCreateStreamOnFileA(
    pszFile: ?*i8,
    grfMode: u32,
    ppstm: ?*IStream,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn SHCreateStreamOnFileW(
    pszFile: ?*u16,
    grfMode: u32,
    ppstm: ?*IStream,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn SHCreateStreamOnFileEx(
    pszFile: ?*u16,
    grfMode: u32,
    dwAttributes: u32,
    fCreate: BOOL,
    pstmTemplate: IStream,
    ppstm: ?*IStream,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn SHCreateMemStream(
    pInit: ?*u8,
    cbInit: u32,
) callconv(@import("std").os.windows.WINAPI) IStream;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn GetAcceptLanguagesA(
    pszLanguages: ?*i8,
    pcchLanguages: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn GetAcceptLanguagesW(
    pszLanguages: ?*u16,
    pcchLanguages: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn IUnknown_Set(
    ppunk: ?*IUnknown,
    punk: IUnknown,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn IUnknown_AtomicRelease(
    ppunk: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn IUnknown_GetWindow(
    punk: IUnknown,
    phwnd: ?*HWND,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn IUnknown_SetSite(
    punk: IUnknown,
    punkSite: IUnknown,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn IUnknown_GetSite(
    punk: IUnknown,
    riid: ?*Guid,
    ppv: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn IUnknown_QueryService(
    punk: IUnknown,
    guidService: ?*Guid,
    riid: ?*Guid,
    ppvOut: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn IStream_Read(
    pstm: IStream,
    pv: ?*opaque{},
    cb: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn IStream_Write(
    pstm: IStream,
    pv: ?*opaque{},
    cb: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn IStream_Reset(
    pstm: IStream,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn IStream_Size(
    pstm: IStream,
    pui: ?*ULARGE_INTEGER,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn ConnectToConnectionPoint(
    punk: IUnknown,
    riidEvent: ?*Guid,
    fConnect: BOOL,
    punkTarget: IUnknown,
    pdwCookie: ?*u32,
    ppcpOut: ?*IConnectionPoint,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn IStream_ReadPidl(
    pstm: IStream,
    ppidlOut: ?*?*ITEMIDLIST,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn IStream_WritePidl(
    pstm: IStream,
    pidlWrite: ?*ITEMIDLIST,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn IStream_ReadStr(
    pstm: IStream,
    ppsz: ?*?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn IStream_WriteStr(
    pstm: IStream,
    psz: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn IStream_Copy(
    pstmFrom: IStream,
    pstmTo: IStream,
    cb: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn SHGetViewStatePropertyBag(
    pidl: ?*ITEMIDLIST,
    pszBagName: ?*u16,
    dwFlags: u32,
    riid: ?*Guid,
    ppv: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn SHFormatDateTimeA(
    pft: ?*FILETIME,
    pdwFlags: ?*u32,
    pszBuf: ?*i8,
    cchBuf: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn SHFormatDateTimeW(
    pft: ?*FILETIME,
    pdwFlags: ?*u32,
    pszBuf: ?*u16,
    cchBuf: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn SHAnsiToUnicode(
    pszSrc: ?*i8,
    pwszDst: ?*u16,
    cwchBuf: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn SHAnsiToAnsi(
    pszSrc: ?*i8,
    pszDst: ?*i8,
    cchBuf: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn SHUnicodeToAnsi(
    pwszSrc: ?*u16,
    pszDst: ?*i8,
    cchBuf: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn SHUnicodeToUnicode(
    pwzSrc: ?*u16,
    pwzDst: ?*u16,
    cwchBuf: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn SHMessageBoxCheckA(
    hwnd: HWND,
    pszText: ?*i8,
    pszCaption: ?*i8,
    uType: u32,
    iDefault: i32,
    pszRegVal: ?*i8,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn SHMessageBoxCheckW(
    hwnd: HWND,
    pszText: ?*u16,
    pszCaption: ?*u16,
    uType: u32,
    iDefault: i32,
    pszRegVal: ?*u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn SHSendMessageBroadcastA(
    uMsg: u32,
    wParam: WPARAM,
    lParam: LPARAM,
) callconv(@import("std").os.windows.WINAPI) LRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn SHSendMessageBroadcastW(
    uMsg: u32,
    wParam: WPARAM,
    lParam: LPARAM,
) callconv(@import("std").os.windows.WINAPI) LRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn SHStripMneumonicA(
    pszMenu: ?*i8,
) callconv(@import("std").os.windows.WINAPI) i8;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn SHStripMneumonicW(
    pszMenu: ?*u16,
) callconv(@import("std").os.windows.WINAPI) u16;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn IsOS(
    dwOS: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn SHGlobalCounterGetValue(
    id: SHGLOBALCOUNTER,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn SHGlobalCounterIncrement(
    id: SHGLOBALCOUNTER,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn SHGlobalCounterDecrement(
    id: SHGLOBALCOUNTER,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn SHAllocShared(
    pvData: ?*opaque{},
    dwSize: u32,
    dwProcessId: u32,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// set_last_errror=True (can and should we use this?)
pub extern "SHLWAPI" fn SHFreeShared(
    hData: HANDLE,
    dwProcessId: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn SHLockShared(
    hData: HANDLE,
    dwProcessId: u32,
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=True (can and should we use this?)
pub extern "SHLWAPI" fn SHUnlockShared(
    pvData: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn WhichPlatform(
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn QISearch(
    that: ?*opaque{},
    pqit: ?*QITAB,
    riid: ?*Guid,
    ppv: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn SHIsLowMemoryMachine(
    dwType: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn GetMenuPosFromID(
    hmenu: HMENU,
    id: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn SHGetInverseCMAP(
    pbMap: ?*u8,
    cbMap: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn SHAutoComplete(
    hwndEdit: HWND,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn SHCreateThreadRef(
    pcRef: ?*i32,
    ppunk: ?*IUnknown,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn SHSetThreadRef(
    punk: IUnknown,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn SHGetThreadRef(
    ppunk: ?*IUnknown,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn SHSkipJunction(
    pbc: IBindCtx,
    pclsid: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "SHLWAPI" fn SHCreateThread(
    pfnThreadProc: LPTHREAD_START_ROUTINE,
    pData: ?*opaque{},
    flags: u32,
    pfnCallback: LPTHREAD_START_ROUTINE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "SHLWAPI" fn SHCreateThreadWithHandle(
    pfnThreadProc: LPTHREAD_START_ROUTINE,
    pData: ?*opaque{},
    flags: u32,
    pfnCallback: LPTHREAD_START_ROUTINE,
    pHandle: ?*HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn SHReleaseThreadRef(
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn SHCreateShellPalette(
    hdc: HDC,
) callconv(@import("std").os.windows.WINAPI) HPALETTE;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn ColorRGBToHLS(
    clrRGB: u32,
    pwHue: ?*u16,
    pwLuminance: ?*u16,
    pwSaturation: ?*u16,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn ColorHLSToRGB(
    wHue: u16,
    wLuminance: u16,
    wSaturation: u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn ColorAdjustLuma(
    clrRGB: u32,
    n: i32,
    fScale: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "SHLWAPI" fn IsInternetESCEnabled(
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "hlink" fn HlinkCreateFromMoniker(
    pimkTrgt: IMoniker,
    pwzLocation: ?*u16,
    pwzFriendlyName: ?*u16,
    pihlsite: IHlinkSite,
    dwSiteData: u32,
    piunkOuter: IUnknown,
    riid: ?*Guid,
    ppvObj: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "hlink" fn HlinkCreateFromString(
    pwzTarget: ?*u16,
    pwzLocation: ?*u16,
    pwzFriendlyName: ?*u16,
    pihlsite: IHlinkSite,
    dwSiteData: u32,
    piunkOuter: IUnknown,
    riid: ?*Guid,
    ppvObj: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "hlink" fn HlinkCreateFromData(
    piDataObj: IDataObject,
    pihlsite: IHlinkSite,
    dwSiteData: u32,
    piunkOuter: IUnknown,
    riid: ?*Guid,
    ppvObj: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "hlink" fn HlinkQueryCreateFromData(
    piDataObj: IDataObject,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "hlink" fn HlinkClone(
    pihl: IHlink,
    riid: ?*Guid,
    pihlsiteForClone: IHlinkSite,
    dwSiteData: u32,
    ppvObj: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "hlink" fn HlinkCreateBrowseContext(
    piunkOuter: IUnknown,
    riid: ?*Guid,
    ppvObj: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "hlink" fn HlinkNavigateToStringReference(
    pwzTarget: ?*u16,
    pwzLocation: ?*u16,
    pihlsite: IHlinkSite,
    dwSiteData: u32,
    pihlframe: IHlinkFrame,
    grfHLNF: u32,
    pibc: IBindCtx,
    pibsc: IBindStatusCallback,
    pihlbc: IHlinkBrowseContext,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "hlink" fn HlinkNavigate(
    pihl: IHlink,
    pihlframe: IHlinkFrame,
    grfHLNF: u32,
    pbc: IBindCtx,
    pibsc: IBindStatusCallback,
    pihlbc: IHlinkBrowseContext,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "hlink" fn HlinkOnNavigate(
    pihlframe: IHlinkFrame,
    pihlbc: IHlinkBrowseContext,
    grfHLNF: u32,
    pimkTarget: IMoniker,
    pwzLocation: ?*u16,
    pwzFriendlyName: ?*u16,
    puHLID: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "hlink" fn HlinkUpdateStackItem(
    pihlframe: IHlinkFrame,
    pihlbc: IHlinkBrowseContext,
    uHLID: u32,
    pimkTrgt: IMoniker,
    pwzLocation: ?*u16,
    pwzFriendlyName: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "hlink" fn HlinkOnRenameDocument(
    dwReserved: u32,
    pihlbc: IHlinkBrowseContext,
    pimkOld: IMoniker,
    pimkNew: IMoniker,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "hlink" fn HlinkResolveMonikerForData(
    pimkReference: IMoniker,
    reserved: u32,
    pibc: IBindCtx,
    cFmtetc: u32,
    rgFmtetc: ?*FORMATETC,
    pibsc: IBindStatusCallback,
    pimkBase: IMoniker,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "hlink" fn HlinkResolveStringForData(
    pwzReference: ?*u16,
    reserved: u32,
    pibc: IBindCtx,
    cFmtetc: u32,
    rgFmtetc: ?*FORMATETC,
    pibsc: IBindStatusCallback,
    pimkBase: IMoniker,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "hlink" fn HlinkParseDisplayName(
    pibc: IBindCtx,
    pwzDisplayName: ?*u16,
    fNoForceAbs: BOOL,
    pcchEaten: ?*u32,
    ppimk: ?*IMoniker,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "hlink" fn HlinkCreateExtensionServices(
    pwzAdditionalHeaders: ?*u16,
    phwnd: HWND,
    pszUsername: ?*u16,
    pszPassword: ?*u16,
    piunkOuter: IUnknown,
    riid: ?*Guid,
    ppvObj: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "hlink" fn HlinkPreprocessMoniker(
    pibc: IBindCtx,
    pimkIn: IMoniker,
    ppimkOut: ?*IMoniker,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "hlink" fn OleSaveToStreamEx(
    piunk: IUnknown,
    pistm: IStream,
    fClearDirty: BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "hlink" fn HlinkSetSpecialReference(
    uReference: u32,
    pwzReference: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "hlink" fn HlinkGetSpecialReference(
    uReference: u32,
    ppwzReference: ?*?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "hlink" fn HlinkCreateShortcut(
    grfHLSHORTCUTF: u32,
    pihl: IHlink,
    pwzDir: ?*u16,
    pwzFileName: ?*u16,
    ppwzShortcutFile: ?*?*u16,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "hlink" fn HlinkCreateShortcutFromMoniker(
    grfHLSHORTCUTF: u32,
    pimkTarget: IMoniker,
    pwzLocation: ?*u16,
    pwzDir: ?*u16,
    pwzFileName: ?*u16,
    ppwzShortcutFile: ?*?*u16,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "hlink" fn HlinkCreateShortcutFromString(
    grfHLSHORTCUTF: u32,
    pwzTarget: ?*u16,
    pwzLocation: ?*u16,
    pwzDir: ?*u16,
    pwzFileName: ?*u16,
    ppwzShortcutFile: ?*?*u16,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "hlink" fn HlinkResolveShortcut(
    pwzShortcutFileName: ?*u16,
    pihlsite: IHlinkSite,
    dwSiteData: u32,
    piunkOuter: IUnknown,
    riid: ?*Guid,
    ppvObj: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "hlink" fn HlinkResolveShortcutToMoniker(
    pwzShortcutFileName: ?*u16,
    ppimkTarget: ?*IMoniker,
    ppwzLocation: ?*?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "hlink" fn HlinkResolveShortcutToString(
    pwzShortcutFileName: ?*u16,
    ppwzTarget: ?*?*u16,
    ppwzLocation: ?*?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "hlink" fn HlinkIsShortcut(
    pwzFileName: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "hlink" fn HlinkGetValueFromParams(
    pwzParams: ?*u16,
    pwzName: ?*u16,
    ppwzValue: ?*?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "hlink" fn HlinkTranslateURL(
    pwzURL: ?*u16,
    grfFlags: u32,
    ppwzTranslatedURL: ?*?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-core-path-l1-1-0" fn PathIsUNCEx(
    pszPath: ?*u16,
    ppszServer: ?*?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-core-path-l1-1-0" fn PathCchIsRoot(
    pszPath: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-core-path-l1-1-0" fn PathCchAddBackslashEx(
    pszPath: ?*u16,
    cchPath: ?*opaque{},
    ppszEnd: ?*?*u16,
    pcchRemaining: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-core-path-l1-1-0" fn PathCchAddBackslash(
    pszPath: ?*u16,
    cchPath: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-core-path-l1-1-0" fn PathCchRemoveBackslashEx(
    pszPath: ?*u16,
    cchPath: ?*opaque{},
    ppszEnd: ?*?*u16,
    pcchRemaining: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-core-path-l1-1-0" fn PathCchRemoveBackslash(
    pszPath: ?*u16,
    cchPath: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-core-path-l1-1-0" fn PathCchSkipRoot(
    pszPath: ?*u16,
    ppszRootEnd: ?*?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-core-path-l1-1-0" fn PathCchStripToRoot(
    pszPath: ?*u16,
    cchPath: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-core-path-l1-1-0" fn PathCchRemoveFileSpec(
    pszPath: ?*u16,
    cchPath: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-core-path-l1-1-0" fn PathCchFindExtension(
    pszPath: ?*u16,
    cchPath: ?*opaque{},
    ppszExt: ?*?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-core-path-l1-1-0" fn PathCchAddExtension(
    pszPath: ?*u16,
    cchPath: ?*opaque{},
    pszExt: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-core-path-l1-1-0" fn PathCchRenameExtension(
    pszPath: ?*u16,
    cchPath: ?*opaque{},
    pszExt: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-core-path-l1-1-0" fn PathCchRemoveExtension(
    pszPath: ?*u16,
    cchPath: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-core-path-l1-1-0" fn PathCchCanonicalizeEx(
    pszPathOut: ?*u16,
    cchPathOut: ?*opaque{},
    pszPathIn: ?*u16,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-core-path-l1-1-0" fn PathCchCanonicalize(
    pszPathOut: ?*u16,
    cchPathOut: ?*opaque{},
    pszPathIn: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-core-path-l1-1-0" fn PathCchCombineEx(
    pszPathOut: ?*u16,
    cchPathOut: ?*opaque{},
    pszPathIn: ?*u16,
    pszMore: ?*u16,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-core-path-l1-1-0" fn PathCchCombine(
    pszPathOut: ?*u16,
    cchPathOut: ?*opaque{},
    pszPathIn: ?*u16,
    pszMore: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-core-path-l1-1-0" fn PathCchAppendEx(
    pszPath: ?*u16,
    cchPath: ?*opaque{},
    pszMore: ?*u16,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-core-path-l1-1-0" fn PathCchAppend(
    pszPath: ?*u16,
    cchPath: ?*opaque{},
    pszMore: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-core-path-l1-1-0" fn PathCchStripPrefix(
    pszPath: ?*u16,
    cchPath: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-core-path-l1-1-0" fn PathAllocCombine(
    pszPathIn: ?*u16,
    pszMore: ?*u16,
    dwFlags: u32,
    ppszPathOut: ?*?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-core-path-l1-1-0" fn PathAllocCanonicalize(
    pszPathIn: ?*u16,
    dwFlags: u32,
    ppszPathOut: ?*?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-core-psm-appnotify-l1-1-0" fn RegisterAppStateChangeNotification(
    Routine: PAPPSTATE_CHANGE_ROUTINE,
    Context: ?*opaque{},
    Registration: ?*?*_APPSTATE_REGISTRATION,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-core-psm-appnotify-l1-1-0" fn UnregisterAppStateChangeNotification(
    Registration: ?*_APPSTATE_REGISTRATION,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-core-psm-appnotify-l1-1-1" fn RegisterAppConstrainedChangeNotification(
    Routine: PAPPCONSTRAIN_CHANGE_ROUTINE,
    Context: ?*opaque{},
    Registration: ?*?*_APPCONSTRAIN_REGISTRATION,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-core-psm-appnotify-l1-1-1" fn UnregisterAppConstrainedChangeNotification(
    Registration: ?*_APPCONSTRAIN_REGISTRATION,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=True (can and should we use this?)
pub extern "USERENV" fn LoadUserProfileA(
    hToken: HANDLE,
    lpProfileInfo: ?*PROFILEINFOA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USERENV" fn LoadUserProfileW(
    hToken: HANDLE,
    lpProfileInfo: ?*PROFILEINFOW,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USERENV" fn UnloadUserProfile(
    hToken: HANDLE,
    hProfile: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USERENV" fn GetProfilesDirectoryA(
    lpProfileDir: ?*i8,
    lpcchSize: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USERENV" fn GetProfilesDirectoryW(
    lpProfileDir: ?*u16,
    lpcchSize: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USERENV" fn GetProfileType(
    dwFlags: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USERENV" fn DeleteProfileA(
    lpSidString: ?*i8,
    lpProfilePath: ?*i8,
    lpComputerName: ?*i8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USERENV" fn DeleteProfileW(
    lpSidString: ?*u16,
    lpProfilePath: ?*u16,
    lpComputerName: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "USERENV" fn CreateProfile(
    pszUserSid: ?*u16,
    pszUserName: ?*u16,
    pszProfilePath: ?*u16,
    cchProfilePath: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=True (can and should we use this?)
pub extern "USERENV" fn GetDefaultUserProfileDirectoryA(
    lpProfileDir: ?*i8,
    lpcchSize: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USERENV" fn GetDefaultUserProfileDirectoryW(
    lpProfileDir: ?*u16,
    lpcchSize: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USERENV" fn GetAllUsersProfileDirectoryA(
    lpProfileDir: ?*i8,
    lpcchSize: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USERENV" fn GetAllUsersProfileDirectoryW(
    lpProfileDir: ?*u16,
    lpcchSize: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USERENV" fn GetUserProfileDirectoryA(
    hToken: HANDLE,
    lpProfileDir: ?*i8,
    lpcchSize: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USERENV" fn GetUserProfileDirectoryW(
    hToken: HANDLE,
    lpProfileDir: ?*u16,
    lpcchSize: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USERENV" fn CreateEnvironmentBlock(
    lpEnvironment: ?*?*opaque{},
    hToken: HANDLE,
    bInherit: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USERENV" fn DestroyEnvironmentBlock(
    lpEnvironment: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USERENV" fn ExpandEnvironmentStringsForUserA(
    hToken: HANDLE,
    lpSrc: ?*i8,
    lpDest: ?*i8,
    dwSize: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USERENV" fn ExpandEnvironmentStringsForUserW(
    hToken: HANDLE,
    lpSrc: ?*u16,
    lpDest: ?*u16,
    dwSize: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "USERENV" fn CreateAppContainerProfile(
    pszAppContainerName: ?*u16,
    pszDisplayName: ?*u16,
    pszDescription: ?*u16,
    pCapabilities: ?*SID_AND_ATTRIBUTES,
    dwCapabilityCount: u32,
    ppSidAppContainerSid: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "USERENV" fn DeleteAppContainerProfile(
    pszAppContainerName: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "USERENV" fn GetAppContainerRegistryLocation(
    desiredAccess: u32,
    phAppContainerKey: ?*HKEY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "USERENV" fn GetAppContainerFolderPath(
    pszAppContainerSid: ?*u16,
    ppszPath: ?*?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "USERENV" fn DeriveAppContainerSidFromAppContainerName(
    pszAppContainerName: ?*u16,
    ppsidAppContainerSid: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "USERENV" fn DeriveRestrictedAppContainerSidFromAppContainerSidAndRestrictedName(
    psidAppContainerSid: ?*opaque{},
    pszRestrictedAppContainerName: ?*u16,
    ppsidRestrictedAppContainerSid: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "COMCTL32" fn SetWindowSubclass(
    hWnd: HWND,
    pfnSubclass: SUBCLASSPROC,
    uIdSubclass: ?*opaque{},
    dwRefData: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "COMCTL32" fn GetWindowSubclass(
    hWnd: HWND,
    pfnSubclass: SUBCLASSPROC,
    uIdSubclass: ?*opaque{},
    pdwRefData: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "COMCTL32" fn RemoveWindowSubclass(
    hWnd: HWND,
    pfnSubclass: SUBCLASSPROC,
    uIdSubclass: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "COMCTL32" fn DefSubclassProc(
    hWnd: HWND,
    uMsg: u32,
    wParam: WPARAM,
    lParam: LPARAM,
) callconv(@import("std").os.windows.WINAPI) LRESULT;

//
// Unicode Symbol Aliases
//
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {
        pub const MULTIKEYHELP = MULTIKEYHELPA;
        pub const HELPWININFO = HELPWININFOA;
        pub const DRAGINFO = DRAGINFOA;
        pub const SHFILEOPSTRUCT = SHFILEOPSTRUCTA;
        pub const SHNAMEMAPPING = SHNAMEMAPPINGA;
        pub const SHELLEXECUTEINFO = SHELLEXECUTEINFOA;
        pub const NOTIFYICONDATA = NOTIFYICONDATAA;
        pub const SHFILEINFO = SHFILEINFOA;
        pub const OPEN_PRINTER_PROPS_INFO = OPEN_PRINTER_PROPS_INFOA;
        pub const IShellLink = IShellLinkA;
        pub const IExtractIcon = IExtractIconA;
        pub const IShellExecuteHook = IShellExecuteHookA;
        pub const BROWSEINFO = BROWSEINFOA;
        pub const FILEDESCRIPTOR = FILEDESCRIPTORA;
        pub const FILEGROUPDESCRIPTOR = FILEGROUPDESCRIPTORA;
        pub const SHELLSTATE = SHELLSTATEA;
        pub const INewShortcutHook = INewShortcutHookA;
        pub const ICopyHook = ICopyHookA;
        pub const PARSEDURL = PARSEDURLA;
        pub const NEWCPLINFO = NEWCPLINFOA;
        pub const PROFILEINFO = PROFILEINFOA;
        pub const urlinvokecommandinfo = urlinvokecommandinfoA;
        pub const IUniformResourceLocator = IUniformResourceLocatorA;
        pub const IEnumRegisterWord = IEnumRegisterWordA;
        pub const LOGFONT = LOGFONTA;
        pub const WinHelp = WinHelpA;
        pub const DragQueryFile = DragQueryFileA;
        pub const ShellExecute = ShellExecuteA;
        pub const FindExecutable = FindExecutableA;
        pub const ShellAbout = ShellAboutA;
        pub const ExtractAssociatedIcon = ExtractAssociatedIconA;
        pub const ExtractAssociatedIconEx = ExtractAssociatedIconExA;
        pub const ExtractIcon = ExtractIconA;
        pub const DoEnvironmentSubst = DoEnvironmentSubstA;
        pub const ExtractIconEx = ExtractIconExA;
        pub const SHFileOperation = SHFileOperationA;
        pub const ShellExecuteEx = ShellExecuteExA;
        pub const SHQueryRecycleBin = SHQueryRecycleBinA;
        pub const SHEmptyRecycleBin = SHEmptyRecycleBinA;
        pub const Shell_NotifyIcon = Shell_NotifyIconA;
        pub const SHGetFileInfo = SHGetFileInfoA;
        pub const SHGetDiskFreeSpaceEx = SHGetDiskFreeSpaceExA;
        pub const SHGetNewLinkInfo = SHGetNewLinkInfoA;
        pub const SHInvokePrinterCommand = SHInvokePrinterCommandA;
        pub const ShellMessageBox = ShellMessageBoxA;
        pub const IsLFNDrive = IsLFNDriveA;
        pub const SHGetIconOverlayIndex = SHGetIconOverlayIndexA;
        pub const ILCreateFromPath = ILCreateFromPathA;
        pub const SHGetPathFromIDList = SHGetPathFromIDListA;
        pub const SHCreateDirectoryEx = SHCreateDirectoryExA;
        pub const SHGetSpecialFolderPath = SHGetSpecialFolderPathA;
        pub const SHGetFolderPath = SHGetFolderPathA;
        pub const SHSetFolderPath = SHSetFolderPathA;
        pub const SHGetFolderPathAndSubDir = SHGetFolderPathAndSubDirA;
        pub const SHBrowseForFolder = SHBrowseForFolderA;
        pub const SHUpdateImage = SHUpdateImageA;
        pub const SHGetDataFromIDList = SHGetDataFromIDListA;
        pub const SHDefExtractIcon = SHDefExtractIconA;
        pub const SHPathPrepareForWrite = SHPathPrepareForWriteA;
        pub const PathIsSlow = PathIsSlowA;
        pub const StrChr = StrChrA;
        pub const StrChrI = StrChrIA;
        pub const StrCmpN = StrCmpNA;
        pub const StrCmpNI = StrCmpNIA;
        pub const StrCSpn = StrCSpnA;
        pub const StrCSpnI = StrCSpnIA;
        pub const StrDup = StrDupA;
        pub const StrFormatByteSize = StrFormatByteSizeA;
        pub const StrFormatKBSize = StrFormatKBSizeA;
        pub const StrFromTimeInterval = StrFromTimeIntervalA;
        pub const StrIsIntlEqual = StrIsIntlEqualA;
        pub const StrNCat = StrNCatA;
        pub const StrPBrk = StrPBrkA;
        pub const StrRChr = StrRChrA;
        pub const StrRChrI = StrRChrIA;
        pub const StrRStrI = StrRStrIA;
        pub const StrSpn = StrSpnA;
        pub const StrStr = StrStrA;
        pub const StrStrI = StrStrIA;
        pub const StrToInt = StrToIntA;
        pub const StrToIntEx = StrToIntExA;
        pub const StrToInt64Ex = StrToInt64ExA;
        pub const StrTrim = StrTrimA;
        pub const StrCatBuff = StrCatBuffA;
        pub const ChrCmpI = ChrCmpIA;
        pub const wvnsprintf = wvnsprintfA;
        pub const wnsprintf = wnsprintfA;
        pub const StrRetToStr = StrRetToStrA;
        pub const StrRetToBuf = StrRetToBufA;
        pub const SHStrDup = SHStrDupA;
        pub const IsCharSpace = IsCharSpaceA;
        pub const StrCmpC = StrCmpCA;
        pub const StrCmpIC = StrCmpICA;
        pub const StrCmpNC = StrCmpNCA;
        pub const StrCmpNIC = StrCmpNICA;
        pub const IntlStrEqWorker = IntlStrEqWorkerA;
        pub const PathAddBackslash = PathAddBackslashA;
        pub const PathAddExtension = PathAddExtensionA;
        pub const PathAppend = PathAppendA;
        pub const PathBuildRoot = PathBuildRootA;
        pub const PathCanonicalize = PathCanonicalizeA;
        pub const PathCombine = PathCombineA;
        pub const PathCompactPath = PathCompactPathA;
        pub const PathCompactPathEx = PathCompactPathExA;
        pub const PathCommonPrefix = PathCommonPrefixA;
        pub const PathFileExists = PathFileExistsA;
        pub const PathFindExtension = PathFindExtensionA;
        pub const PathFindFileName = PathFindFileNameA;
        pub const PathFindNextComponent = PathFindNextComponentA;
        pub const PathFindOnPath = PathFindOnPathA;
        pub const PathFindSuffixArray = PathFindSuffixArrayA;
        pub const PathGetArgs = PathGetArgsA;
        pub const PathIsLFNFileSpec = PathIsLFNFileSpecA;
        pub const PathGetCharType = PathGetCharTypeA;
        pub const PathGetDriveNumber = PathGetDriveNumberA;
        pub const PathIsDirectory = PathIsDirectoryA;
        pub const PathIsDirectoryEmpty = PathIsDirectoryEmptyA;
        pub const PathIsFileSpec = PathIsFileSpecA;
        pub const PathIsPrefix = PathIsPrefixA;
        pub const PathIsRelative = PathIsRelativeA;
        pub const PathIsRoot = PathIsRootA;
        pub const PathIsSameRoot = PathIsSameRootA;
        pub const PathIsUNC = PathIsUNCA;
        pub const PathIsNetworkPath = PathIsNetworkPathA;
        pub const PathIsUNCServer = PathIsUNCServerA;
        pub const PathIsUNCServerShare = PathIsUNCServerShareA;
        pub const PathIsContentType = PathIsContentTypeA;
        pub const PathIsURL = PathIsURLA;
        pub const PathMakePretty = PathMakePrettyA;
        pub const PathMatchSpec = PathMatchSpecA;
        pub const PathMatchSpecEx = PathMatchSpecExA;
        pub const PathParseIconLocation = PathParseIconLocationA;
        pub const PathQuoteSpaces = PathQuoteSpacesA;
        pub const PathRelativePathTo = PathRelativePathToA;
        pub const PathRemoveArgs = PathRemoveArgsA;
        pub const PathRemoveBackslash = PathRemoveBackslashA;
        pub const PathRemoveBlanks = PathRemoveBlanksA;
        pub const PathRemoveExtension = PathRemoveExtensionA;
        pub const PathRemoveFileSpec = PathRemoveFileSpecA;
        pub const PathRenameExtension = PathRenameExtensionA;
        pub const PathSearchAndQualify = PathSearchAndQualifyA;
        pub const PathSetDlgItemPath = PathSetDlgItemPathA;
        pub const PathSkipRoot = PathSkipRootA;
        pub const PathStripPath = PathStripPathA;
        pub const PathStripToRoot = PathStripToRootA;
        pub const PathUnquoteSpaces = PathUnquoteSpacesA;
        pub const PathMakeSystemFolder = PathMakeSystemFolderA;
        pub const PathUnmakeSystemFolder = PathUnmakeSystemFolderA;
        pub const PathIsSystemFolder = PathIsSystemFolderA;
        pub const PathUndecorate = PathUndecorateA;
        pub const PathUnExpandEnvStrings = PathUnExpandEnvStringsA;
        pub const UrlCompare = UrlCompareA;
        pub const UrlCombine = UrlCombineA;
        pub const UrlCanonicalize = UrlCanonicalizeA;
        pub const UrlIsOpaque = UrlIsOpaqueA;
        pub const UrlIsNoHistory = UrlIsNoHistoryA;
        pub const UrlIs = UrlIsA;
        pub const UrlGetLocation = UrlGetLocationA;
        pub const UrlUnescape = UrlUnescapeA;
        pub const UrlEscape = UrlEscapeA;
        pub const UrlCreateFromPath = UrlCreateFromPathA;
        pub const PathCreateFromUrl = PathCreateFromUrlA;
        pub const UrlHash = UrlHashA;
        pub const UrlGetPart = UrlGetPartA;
        pub const UrlApplyScheme = UrlApplySchemeA;
        pub const ParseURL = ParseURLA;
        pub const SHDeleteEmptyKey = SHDeleteEmptyKeyA;
        pub const SHDeleteKey = SHDeleteKeyA;
        pub const SHDeleteValue = SHDeleteValueA;
        pub const SHGetValue = SHGetValueA;
        pub const SHSetValue = SHSetValueA;
        pub const SHRegGetValue = SHRegGetValueA;
        pub const SHQueryValueEx = SHQueryValueExA;
        pub const SHEnumKeyEx = SHEnumKeyExA;
        pub const SHEnumValue = SHEnumValueA;
        pub const SHQueryInfoKey = SHQueryInfoKeyA;
        pub const SHCopyKey = SHCopyKeyA;
        pub const SHRegGetPath = SHRegGetPathA;
        pub const SHRegSetPath = SHRegSetPathA;
        pub const SHRegCreateUSKey = SHRegCreateUSKeyA;
        pub const SHRegOpenUSKey = SHRegOpenUSKeyA;
        pub const SHRegQueryUSValue = SHRegQueryUSValueA;
        pub const SHRegWriteUSValue = SHRegWriteUSValueA;
        pub const SHRegDeleteUSValue = SHRegDeleteUSValueA;
        pub const SHRegDeleteEmptyUSKey = SHRegDeleteEmptyUSKeyA;
        pub const SHRegEnumUSKey = SHRegEnumUSKeyA;
        pub const SHRegEnumUSValue = SHRegEnumUSValueA;
        pub const SHRegQueryInfoUSKey = SHRegQueryInfoUSKeyA;
        pub const SHRegGetUSValue = SHRegGetUSValueA;
        pub const SHRegSetUSValue = SHRegSetUSValueA;
        pub const SHRegGetBoolUSValue = SHRegGetBoolUSValueA;
        pub const AssocQueryString = AssocQueryStringA;
        pub const AssocQueryStringByKey = AssocQueryStringByKeyA;
        pub const AssocQueryKey = AssocQueryKeyA;
        pub const SHOpenRegStream = SHOpenRegStreamA;
        pub const SHOpenRegStream2 = SHOpenRegStream2A;
        pub const SHCreateStreamOnFile = SHCreateStreamOnFileA;
        pub const GetAcceptLanguages = GetAcceptLanguagesA;
        pub const SHFormatDateTime = SHFormatDateTimeA;
        pub const SHMessageBoxCheck = SHMessageBoxCheckA;
        pub const SHSendMessageBroadcast = SHSendMessageBroadcastA;
        pub const SHStripMneumonic = SHStripMneumonicA;
        pub const LoadUserProfile = LoadUserProfileA;
        pub const GetProfilesDirectory = GetProfilesDirectoryA;
        pub const DeleteProfile = DeleteProfileA;
        pub const GetDefaultUserProfileDirectory = GetDefaultUserProfileDirectoryA;
        pub const GetAllUsersProfileDirectory = GetAllUsersProfileDirectoryA;
        pub const GetUserProfileDirectory = GetUserProfileDirectoryA;
        pub const ExpandEnvironmentStringsForUser = ExpandEnvironmentStringsForUserA;
    },
    .wide => struct {
        pub const MULTIKEYHELP = MULTIKEYHELPW;
        pub const HELPWININFO = HELPWININFOW;
        pub const DRAGINFO = DRAGINFOW;
        pub const SHFILEOPSTRUCT = SHFILEOPSTRUCTW;
        pub const SHNAMEMAPPING = SHNAMEMAPPINGW;
        pub const SHELLEXECUTEINFO = SHELLEXECUTEINFOW;
        pub const NOTIFYICONDATA = NOTIFYICONDATAW;
        pub const SHFILEINFO = SHFILEINFOW;
        pub const OPEN_PRINTER_PROPS_INFO = OPEN_PRINTER_PROPS_INFOW;
        pub const IShellLink = IShellLinkW;
        pub const IExtractIcon = IExtractIconW;
        pub const IShellExecuteHook = IShellExecuteHookW;
        pub const BROWSEINFO = BROWSEINFOW;
        pub const FILEDESCRIPTOR = FILEDESCRIPTORW;
        pub const FILEGROUPDESCRIPTOR = FILEGROUPDESCRIPTORW;
        pub const SHELLSTATE = SHELLSTATEW;
        pub const INewShortcutHook = INewShortcutHookW;
        pub const ICopyHook = ICopyHookW;
        pub const PARSEDURL = PARSEDURLW;
        pub const NEWCPLINFO = NEWCPLINFOW;
        pub const PROFILEINFO = PROFILEINFOW;
        pub const urlinvokecommandinfo = urlinvokecommandinfoW;
        pub const IUniformResourceLocator = IUniformResourceLocatorW;
        pub const IEnumRegisterWord = IEnumRegisterWordW;
        pub const LOGFONT = LOGFONTW;
        pub const WinHelp = WinHelpW;
        pub const DragQueryFile = DragQueryFileW;
        pub const ShellExecute = ShellExecuteW;
        pub const FindExecutable = FindExecutableW;
        pub const ShellAbout = ShellAboutW;
        pub const ExtractAssociatedIcon = ExtractAssociatedIconW;
        pub const ExtractAssociatedIconEx = ExtractAssociatedIconExW;
        pub const ExtractIcon = ExtractIconW;
        pub const DoEnvironmentSubst = DoEnvironmentSubstW;
        pub const ExtractIconEx = ExtractIconExW;
        pub const SHFileOperation = SHFileOperationW;
        pub const ShellExecuteEx = ShellExecuteExW;
        pub const SHQueryRecycleBin = SHQueryRecycleBinW;
        pub const SHEmptyRecycleBin = SHEmptyRecycleBinW;
        pub const Shell_NotifyIcon = Shell_NotifyIconW;
        pub const SHGetFileInfo = SHGetFileInfoW;
        pub const SHGetDiskFreeSpaceEx = SHGetDiskFreeSpaceExW;
        pub const SHGetNewLinkInfo = SHGetNewLinkInfoW;
        pub const SHInvokePrinterCommand = SHInvokePrinterCommandW;
        pub const ShellMessageBox = ShellMessageBoxW;
        pub const IsLFNDrive = IsLFNDriveW;
        pub const SHGetIconOverlayIndex = SHGetIconOverlayIndexW;
        pub const ILCreateFromPath = ILCreateFromPathW;
        pub const SHGetPathFromIDList = SHGetPathFromIDListW;
        pub const SHCreateDirectoryEx = SHCreateDirectoryExW;
        pub const SHGetSpecialFolderPath = SHGetSpecialFolderPathW;
        pub const SHGetFolderPath = SHGetFolderPathW;
        pub const SHSetFolderPath = SHSetFolderPathW;
        pub const SHGetFolderPathAndSubDir = SHGetFolderPathAndSubDirW;
        pub const SHBrowseForFolder = SHBrowseForFolderW;
        pub const SHUpdateImage = SHUpdateImageW;
        pub const SHGetDataFromIDList = SHGetDataFromIDListW;
        pub const SHDefExtractIcon = SHDefExtractIconW;
        pub const SHPathPrepareForWrite = SHPathPrepareForWriteW;
        pub const PathIsSlow = PathIsSlowW;
        pub const StrChr = StrChrW;
        pub const StrChrI = StrChrIW;
        pub const StrCmpN = StrCmpNW;
        pub const StrCmpNI = StrCmpNIW;
        pub const StrCSpn = StrCSpnW;
        pub const StrCSpnI = StrCSpnIW;
        pub const StrDup = StrDupW;
        pub const StrFormatByteSize = StrFormatByteSizeW;
        pub const StrFormatKBSize = StrFormatKBSizeW;
        pub const StrFromTimeInterval = StrFromTimeIntervalW;
        pub const StrIsIntlEqual = StrIsIntlEqualW;
        pub const StrNCat = StrNCatW;
        pub const StrPBrk = StrPBrkW;
        pub const StrRChr = StrRChrW;
        pub const StrRChrI = StrRChrIW;
        pub const StrRStrI = StrRStrIW;
        pub const StrSpn = StrSpnW;
        pub const StrStr = StrStrW;
        pub const StrStrI = StrStrIW;
        pub const StrToInt = StrToIntW;
        pub const StrToIntEx = StrToIntExW;
        pub const StrToInt64Ex = StrToInt64ExW;
        pub const StrTrim = StrTrimW;
        pub const StrCatBuff = StrCatBuffW;
        pub const ChrCmpI = ChrCmpIW;
        pub const wvnsprintf = wvnsprintfW;
        pub const wnsprintf = wnsprintfW;
        pub const StrRetToStr = StrRetToStrW;
        pub const StrRetToBuf = StrRetToBufW;
        pub const SHStrDup = SHStrDupW;
        pub const IsCharSpace = IsCharSpaceW;
        pub const StrCmpC = StrCmpCW;
        pub const StrCmpIC = StrCmpICW;
        pub const StrCmpNC = StrCmpNCW;
        pub const StrCmpNIC = StrCmpNICW;
        pub const IntlStrEqWorker = IntlStrEqWorkerW;
        pub const PathAddBackslash = PathAddBackslashW;
        pub const PathAddExtension = PathAddExtensionW;
        pub const PathAppend = PathAppendW;
        pub const PathBuildRoot = PathBuildRootW;
        pub const PathCanonicalize = PathCanonicalizeW;
        pub const PathCombine = PathCombineW;
        pub const PathCompactPath = PathCompactPathW;
        pub const PathCompactPathEx = PathCompactPathExW;
        pub const PathCommonPrefix = PathCommonPrefixW;
        pub const PathFileExists = PathFileExistsW;
        pub const PathFindExtension = PathFindExtensionW;
        pub const PathFindFileName = PathFindFileNameW;
        pub const PathFindNextComponent = PathFindNextComponentW;
        pub const PathFindOnPath = PathFindOnPathW;
        pub const PathFindSuffixArray = PathFindSuffixArrayW;
        pub const PathGetArgs = PathGetArgsW;
        pub const PathIsLFNFileSpec = PathIsLFNFileSpecW;
        pub const PathGetCharType = PathGetCharTypeW;
        pub const PathGetDriveNumber = PathGetDriveNumberW;
        pub const PathIsDirectory = PathIsDirectoryW;
        pub const PathIsDirectoryEmpty = PathIsDirectoryEmptyW;
        pub const PathIsFileSpec = PathIsFileSpecW;
        pub const PathIsPrefix = PathIsPrefixW;
        pub const PathIsRelative = PathIsRelativeW;
        pub const PathIsRoot = PathIsRootW;
        pub const PathIsSameRoot = PathIsSameRootW;
        pub const PathIsUNC = PathIsUNCW;
        pub const PathIsNetworkPath = PathIsNetworkPathW;
        pub const PathIsUNCServer = PathIsUNCServerW;
        pub const PathIsUNCServerShare = PathIsUNCServerShareW;
        pub const PathIsContentType = PathIsContentTypeW;
        pub const PathIsURL = PathIsURLW;
        pub const PathMakePretty = PathMakePrettyW;
        pub const PathMatchSpec = PathMatchSpecW;
        pub const PathMatchSpecEx = PathMatchSpecExW;
        pub const PathParseIconLocation = PathParseIconLocationW;
        pub const PathQuoteSpaces = PathQuoteSpacesW;
        pub const PathRelativePathTo = PathRelativePathToW;
        pub const PathRemoveArgs = PathRemoveArgsW;
        pub const PathRemoveBackslash = PathRemoveBackslashW;
        pub const PathRemoveBlanks = PathRemoveBlanksW;
        pub const PathRemoveExtension = PathRemoveExtensionW;
        pub const PathRemoveFileSpec = PathRemoveFileSpecW;
        pub const PathRenameExtension = PathRenameExtensionW;
        pub const PathSearchAndQualify = PathSearchAndQualifyW;
        pub const PathSetDlgItemPath = PathSetDlgItemPathW;
        pub const PathSkipRoot = PathSkipRootW;
        pub const PathStripPath = PathStripPathW;
        pub const PathStripToRoot = PathStripToRootW;
        pub const PathUnquoteSpaces = PathUnquoteSpacesW;
        pub const PathMakeSystemFolder = PathMakeSystemFolderW;
        pub const PathUnmakeSystemFolder = PathUnmakeSystemFolderW;
        pub const PathIsSystemFolder = PathIsSystemFolderW;
        pub const PathUndecorate = PathUndecorateW;
        pub const PathUnExpandEnvStrings = PathUnExpandEnvStringsW;
        pub const UrlCompare = UrlCompareW;
        pub const UrlCombine = UrlCombineW;
        pub const UrlCanonicalize = UrlCanonicalizeW;
        pub const UrlIsOpaque = UrlIsOpaqueW;
        pub const UrlIsNoHistory = UrlIsNoHistoryW;
        pub const UrlIs = UrlIsW;
        pub const UrlGetLocation = UrlGetLocationW;
        pub const UrlUnescape = UrlUnescapeW;
        pub const UrlEscape = UrlEscapeW;
        pub const UrlCreateFromPath = UrlCreateFromPathW;
        pub const PathCreateFromUrl = PathCreateFromUrlW;
        pub const UrlHash = UrlHashW;
        pub const UrlGetPart = UrlGetPartW;
        pub const UrlApplyScheme = UrlApplySchemeW;
        pub const ParseURL = ParseURLW;
        pub const SHDeleteEmptyKey = SHDeleteEmptyKeyW;
        pub const SHDeleteKey = SHDeleteKeyW;
        pub const SHDeleteValue = SHDeleteValueW;
        pub const SHGetValue = SHGetValueW;
        pub const SHSetValue = SHSetValueW;
        pub const SHRegGetValue = SHRegGetValueW;
        pub const SHQueryValueEx = SHQueryValueExW;
        pub const SHEnumKeyEx = SHEnumKeyExW;
        pub const SHEnumValue = SHEnumValueW;
        pub const SHQueryInfoKey = SHQueryInfoKeyW;
        pub const SHCopyKey = SHCopyKeyW;
        pub const SHRegGetPath = SHRegGetPathW;
        pub const SHRegSetPath = SHRegSetPathW;
        pub const SHRegCreateUSKey = SHRegCreateUSKeyW;
        pub const SHRegOpenUSKey = SHRegOpenUSKeyW;
        pub const SHRegQueryUSValue = SHRegQueryUSValueW;
        pub const SHRegWriteUSValue = SHRegWriteUSValueW;
        pub const SHRegDeleteUSValue = SHRegDeleteUSValueW;
        pub const SHRegDeleteEmptyUSKey = SHRegDeleteEmptyUSKeyW;
        pub const SHRegEnumUSKey = SHRegEnumUSKeyW;
        pub const SHRegEnumUSValue = SHRegEnumUSValueW;
        pub const SHRegQueryInfoUSKey = SHRegQueryInfoUSKeyW;
        pub const SHRegGetUSValue = SHRegGetUSValueW;
        pub const SHRegSetUSValue = SHRegSetUSValueW;
        pub const SHRegGetBoolUSValue = SHRegGetBoolUSValueW;
        pub const AssocQueryString = AssocQueryStringW;
        pub const AssocQueryStringByKey = AssocQueryStringByKeyW;
        pub const AssocQueryKey = AssocQueryKeyW;
        pub const SHOpenRegStream = SHOpenRegStreamW;
        pub const SHOpenRegStream2 = SHOpenRegStream2W;
        pub const SHCreateStreamOnFile = SHCreateStreamOnFileW;
        pub const GetAcceptLanguages = GetAcceptLanguagesW;
        pub const SHFormatDateTime = SHFormatDateTimeW;
        pub const SHMessageBoxCheck = SHMessageBoxCheckW;
        pub const SHSendMessageBroadcast = SHSendMessageBroadcastW;
        pub const SHStripMneumonic = SHStripMneumonicW;
        pub const LoadUserProfile = LoadUserProfileW;
        pub const GetProfilesDirectory = GetProfilesDirectoryW;
        pub const DeleteProfile = DeleteProfileW;
        pub const GetDefaultUserProfileDirectory = GetDefaultUserProfileDirectoryW;
        pub const GetAllUsersProfileDirectory = GetAllUsersProfileDirectoryW;
        pub const GetUserProfileDirectory = GetUserProfileDirectoryW;
        pub const ExpandEnvironmentStringsForUser = ExpandEnvironmentStringsForUserW;
    },
    else => if (@import("builtin").is_test) struct {
        pub const MULTIKEYHELP = *opaque{};
        pub const HELPWININFO = *opaque{};
        pub const DRAGINFO = *opaque{};
        pub const SHFILEOPSTRUCT = *opaque{};
        pub const SHNAMEMAPPING = *opaque{};
        pub const SHELLEXECUTEINFO = *opaque{};
        pub const NOTIFYICONDATA = *opaque{};
        pub const SHFILEINFO = *opaque{};
        pub const OPEN_PRINTER_PROPS_INFO = *opaque{};
        pub const IShellLink = *opaque{};
        pub const IExtractIcon = *opaque{};
        pub const IShellExecuteHook = *opaque{};
        pub const BROWSEINFO = *opaque{};
        pub const FILEDESCRIPTOR = *opaque{};
        pub const FILEGROUPDESCRIPTOR = *opaque{};
        pub const SHELLSTATE = *opaque{};
        pub const INewShortcutHook = *opaque{};
        pub const ICopyHook = *opaque{};
        pub const PARSEDURL = *opaque{};
        pub const NEWCPLINFO = *opaque{};
        pub const PROFILEINFO = *opaque{};
        pub const urlinvokecommandinfo = *opaque{};
        pub const IUniformResourceLocator = *opaque{};
        pub const IEnumRegisterWord = *opaque{};
        pub const LOGFONT = *opaque{};
        pub const WinHelp = *opaque{};
        pub const DragQueryFile = *opaque{};
        pub const ShellExecute = *opaque{};
        pub const FindExecutable = *opaque{};
        pub const ShellAbout = *opaque{};
        pub const ExtractAssociatedIcon = *opaque{};
        pub const ExtractAssociatedIconEx = *opaque{};
        pub const ExtractIcon = *opaque{};
        pub const DoEnvironmentSubst = *opaque{};
        pub const ExtractIconEx = *opaque{};
        pub const SHFileOperation = *opaque{};
        pub const ShellExecuteEx = *opaque{};
        pub const SHQueryRecycleBin = *opaque{};
        pub const SHEmptyRecycleBin = *opaque{};
        pub const Shell_NotifyIcon = *opaque{};
        pub const SHGetFileInfo = *opaque{};
        pub const SHGetDiskFreeSpaceEx = *opaque{};
        pub const SHGetNewLinkInfo = *opaque{};
        pub const SHInvokePrinterCommand = *opaque{};
        pub const ShellMessageBox = *opaque{};
        pub const IsLFNDrive = *opaque{};
        pub const SHGetIconOverlayIndex = *opaque{};
        pub const ILCreateFromPath = *opaque{};
        pub const SHGetPathFromIDList = *opaque{};
        pub const SHCreateDirectoryEx = *opaque{};
        pub const SHGetSpecialFolderPath = *opaque{};
        pub const SHGetFolderPath = *opaque{};
        pub const SHSetFolderPath = *opaque{};
        pub const SHGetFolderPathAndSubDir = *opaque{};
        pub const SHBrowseForFolder = *opaque{};
        pub const SHUpdateImage = *opaque{};
        pub const SHGetDataFromIDList = *opaque{};
        pub const SHDefExtractIcon = *opaque{};
        pub const SHPathPrepareForWrite = *opaque{};
        pub const PathIsSlow = *opaque{};
        pub const StrChr = *opaque{};
        pub const StrChrI = *opaque{};
        pub const StrCmpN = *opaque{};
        pub const StrCmpNI = *opaque{};
        pub const StrCSpn = *opaque{};
        pub const StrCSpnI = *opaque{};
        pub const StrDup = *opaque{};
        pub const StrFormatByteSize = *opaque{};
        pub const StrFormatKBSize = *opaque{};
        pub const StrFromTimeInterval = *opaque{};
        pub const StrIsIntlEqual = *opaque{};
        pub const StrNCat = *opaque{};
        pub const StrPBrk = *opaque{};
        pub const StrRChr = *opaque{};
        pub const StrRChrI = *opaque{};
        pub const StrRStrI = *opaque{};
        pub const StrSpn = *opaque{};
        pub const StrStr = *opaque{};
        pub const StrStrI = *opaque{};
        pub const StrToInt = *opaque{};
        pub const StrToIntEx = *opaque{};
        pub const StrToInt64Ex = *opaque{};
        pub const StrTrim = *opaque{};
        pub const StrCatBuff = *opaque{};
        pub const ChrCmpI = *opaque{};
        pub const wvnsprintf = *opaque{};
        pub const wnsprintf = *opaque{};
        pub const StrRetToStr = *opaque{};
        pub const StrRetToBuf = *opaque{};
        pub const SHStrDup = *opaque{};
        pub const IsCharSpace = *opaque{};
        pub const StrCmpC = *opaque{};
        pub const StrCmpIC = *opaque{};
        pub const StrCmpNC = *opaque{};
        pub const StrCmpNIC = *opaque{};
        pub const IntlStrEqWorker = *opaque{};
        pub const PathAddBackslash = *opaque{};
        pub const PathAddExtension = *opaque{};
        pub const PathAppend = *opaque{};
        pub const PathBuildRoot = *opaque{};
        pub const PathCanonicalize = *opaque{};
        pub const PathCombine = *opaque{};
        pub const PathCompactPath = *opaque{};
        pub const PathCompactPathEx = *opaque{};
        pub const PathCommonPrefix = *opaque{};
        pub const PathFileExists = *opaque{};
        pub const PathFindExtension = *opaque{};
        pub const PathFindFileName = *opaque{};
        pub const PathFindNextComponent = *opaque{};
        pub const PathFindOnPath = *opaque{};
        pub const PathFindSuffixArray = *opaque{};
        pub const PathGetArgs = *opaque{};
        pub const PathIsLFNFileSpec = *opaque{};
        pub const PathGetCharType = *opaque{};
        pub const PathGetDriveNumber = *opaque{};
        pub const PathIsDirectory = *opaque{};
        pub const PathIsDirectoryEmpty = *opaque{};
        pub const PathIsFileSpec = *opaque{};
        pub const PathIsPrefix = *opaque{};
        pub const PathIsRelative = *opaque{};
        pub const PathIsRoot = *opaque{};
        pub const PathIsSameRoot = *opaque{};
        pub const PathIsUNC = *opaque{};
        pub const PathIsNetworkPath = *opaque{};
        pub const PathIsUNCServer = *opaque{};
        pub const PathIsUNCServerShare = *opaque{};
        pub const PathIsContentType = *opaque{};
        pub const PathIsURL = *opaque{};
        pub const PathMakePretty = *opaque{};
        pub const PathMatchSpec = *opaque{};
        pub const PathMatchSpecEx = *opaque{};
        pub const PathParseIconLocation = *opaque{};
        pub const PathQuoteSpaces = *opaque{};
        pub const PathRelativePathTo = *opaque{};
        pub const PathRemoveArgs = *opaque{};
        pub const PathRemoveBackslash = *opaque{};
        pub const PathRemoveBlanks = *opaque{};
        pub const PathRemoveExtension = *opaque{};
        pub const PathRemoveFileSpec = *opaque{};
        pub const PathRenameExtension = *opaque{};
        pub const PathSearchAndQualify = *opaque{};
        pub const PathSetDlgItemPath = *opaque{};
        pub const PathSkipRoot = *opaque{};
        pub const PathStripPath = *opaque{};
        pub const PathStripToRoot = *opaque{};
        pub const PathUnquoteSpaces = *opaque{};
        pub const PathMakeSystemFolder = *opaque{};
        pub const PathUnmakeSystemFolder = *opaque{};
        pub const PathIsSystemFolder = *opaque{};
        pub const PathUndecorate = *opaque{};
        pub const PathUnExpandEnvStrings = *opaque{};
        pub const UrlCompare = *opaque{};
        pub const UrlCombine = *opaque{};
        pub const UrlCanonicalize = *opaque{};
        pub const UrlIsOpaque = *opaque{};
        pub const UrlIsNoHistory = *opaque{};
        pub const UrlIs = *opaque{};
        pub const UrlGetLocation = *opaque{};
        pub const UrlUnescape = *opaque{};
        pub const UrlEscape = *opaque{};
        pub const UrlCreateFromPath = *opaque{};
        pub const PathCreateFromUrl = *opaque{};
        pub const UrlHash = *opaque{};
        pub const UrlGetPart = *opaque{};
        pub const UrlApplyScheme = *opaque{};
        pub const ParseURL = *opaque{};
        pub const SHDeleteEmptyKey = *opaque{};
        pub const SHDeleteKey = *opaque{};
        pub const SHDeleteValue = *opaque{};
        pub const SHGetValue = *opaque{};
        pub const SHSetValue = *opaque{};
        pub const SHRegGetValue = *opaque{};
        pub const SHQueryValueEx = *opaque{};
        pub const SHEnumKeyEx = *opaque{};
        pub const SHEnumValue = *opaque{};
        pub const SHQueryInfoKey = *opaque{};
        pub const SHCopyKey = *opaque{};
        pub const SHRegGetPath = *opaque{};
        pub const SHRegSetPath = *opaque{};
        pub const SHRegCreateUSKey = *opaque{};
        pub const SHRegOpenUSKey = *opaque{};
        pub const SHRegQueryUSValue = *opaque{};
        pub const SHRegWriteUSValue = *opaque{};
        pub const SHRegDeleteUSValue = *opaque{};
        pub const SHRegDeleteEmptyUSKey = *opaque{};
        pub const SHRegEnumUSKey = *opaque{};
        pub const SHRegEnumUSValue = *opaque{};
        pub const SHRegQueryInfoUSKey = *opaque{};
        pub const SHRegGetUSValue = *opaque{};
        pub const SHRegSetUSValue = *opaque{};
        pub const SHRegGetBoolUSValue = *opaque{};
        pub const AssocQueryString = *opaque{};
        pub const AssocQueryStringByKey = *opaque{};
        pub const AssocQueryKey = *opaque{};
        pub const SHOpenRegStream = *opaque{};
        pub const SHOpenRegStream2 = *opaque{};
        pub const SHCreateStreamOnFile = *opaque{};
        pub const GetAcceptLanguages = *opaque{};
        pub const SHFormatDateTime = *opaque{};
        pub const SHMessageBoxCheck = *opaque{};
        pub const SHSendMessageBroadcast = *opaque{};
        pub const SHStripMneumonic = *opaque{};
        pub const LoadUserProfile = *opaque{};
        pub const GetProfilesDirectory = *opaque{};
        pub const DeleteProfile = *opaque{};
        pub const GetDefaultUserProfileDirectory = *opaque{};
        pub const GetAllUsersProfileDirectory = *opaque{};
        pub const GetUserProfileDirectory = *opaque{};
        pub const ExpandEnvironmentStringsForUser = *opaque{};
    } else struct {
        pub const MULTIKEYHELP = @compileError("'MULTIKEYHELP' requires that UNICODE be set to true or false in the root module");
        pub const HELPWININFO = @compileError("'HELPWININFO' requires that UNICODE be set to true or false in the root module");
        pub const DRAGINFO = @compileError("'DRAGINFO' requires that UNICODE be set to true or false in the root module");
        pub const SHFILEOPSTRUCT = @compileError("'SHFILEOPSTRUCT' requires that UNICODE be set to true or false in the root module");
        pub const SHNAMEMAPPING = @compileError("'SHNAMEMAPPING' requires that UNICODE be set to true or false in the root module");
        pub const SHELLEXECUTEINFO = @compileError("'SHELLEXECUTEINFO' requires that UNICODE be set to true or false in the root module");
        pub const NOTIFYICONDATA = @compileError("'NOTIFYICONDATA' requires that UNICODE be set to true or false in the root module");
        pub const SHFILEINFO = @compileError("'SHFILEINFO' requires that UNICODE be set to true or false in the root module");
        pub const OPEN_PRINTER_PROPS_INFO = @compileError("'OPEN_PRINTER_PROPS_INFO' requires that UNICODE be set to true or false in the root module");
        pub const IShellLink = @compileError("'IShellLink' requires that UNICODE be set to true or false in the root module");
        pub const IExtractIcon = @compileError("'IExtractIcon' requires that UNICODE be set to true or false in the root module");
        pub const IShellExecuteHook = @compileError("'IShellExecuteHook' requires that UNICODE be set to true or false in the root module");
        pub const BROWSEINFO = @compileError("'BROWSEINFO' requires that UNICODE be set to true or false in the root module");
        pub const FILEDESCRIPTOR = @compileError("'FILEDESCRIPTOR' requires that UNICODE be set to true or false in the root module");
        pub const FILEGROUPDESCRIPTOR = @compileError("'FILEGROUPDESCRIPTOR' requires that UNICODE be set to true or false in the root module");
        pub const SHELLSTATE = @compileError("'SHELLSTATE' requires that UNICODE be set to true or false in the root module");
        pub const INewShortcutHook = @compileError("'INewShortcutHook' requires that UNICODE be set to true or false in the root module");
        pub const ICopyHook = @compileError("'ICopyHook' requires that UNICODE be set to true or false in the root module");
        pub const PARSEDURL = @compileError("'PARSEDURL' requires that UNICODE be set to true or false in the root module");
        pub const NEWCPLINFO = @compileError("'NEWCPLINFO' requires that UNICODE be set to true or false in the root module");
        pub const PROFILEINFO = @compileError("'PROFILEINFO' requires that UNICODE be set to true or false in the root module");
        pub const urlinvokecommandinfo = @compileError("'urlinvokecommandinfo' requires that UNICODE be set to true or false in the root module");
        pub const IUniformResourceLocator = @compileError("'IUniformResourceLocator' requires that UNICODE be set to true or false in the root module");
        pub const IEnumRegisterWord = @compileError("'IEnumRegisterWord' requires that UNICODE be set to true or false in the root module");
        pub const LOGFONT = @compileError("'LOGFONT' requires that UNICODE be set to true or false in the root module");
        pub const WinHelp = @compileError("'WinHelp' requires that UNICODE be set to true or false in the root module");
        pub const DragQueryFile = @compileError("'DragQueryFile' requires that UNICODE be set to true or false in the root module");
        pub const ShellExecute = @compileError("'ShellExecute' requires that UNICODE be set to true or false in the root module");
        pub const FindExecutable = @compileError("'FindExecutable' requires that UNICODE be set to true or false in the root module");
        pub const ShellAbout = @compileError("'ShellAbout' requires that UNICODE be set to true or false in the root module");
        pub const ExtractAssociatedIcon = @compileError("'ExtractAssociatedIcon' requires that UNICODE be set to true or false in the root module");
        pub const ExtractAssociatedIconEx = @compileError("'ExtractAssociatedIconEx' requires that UNICODE be set to true or false in the root module");
        pub const ExtractIcon = @compileError("'ExtractIcon' requires that UNICODE be set to true or false in the root module");
        pub const DoEnvironmentSubst = @compileError("'DoEnvironmentSubst' requires that UNICODE be set to true or false in the root module");
        pub const ExtractIconEx = @compileError("'ExtractIconEx' requires that UNICODE be set to true or false in the root module");
        pub const SHFileOperation = @compileError("'SHFileOperation' requires that UNICODE be set to true or false in the root module");
        pub const ShellExecuteEx = @compileError("'ShellExecuteEx' requires that UNICODE be set to true or false in the root module");
        pub const SHQueryRecycleBin = @compileError("'SHQueryRecycleBin' requires that UNICODE be set to true or false in the root module");
        pub const SHEmptyRecycleBin = @compileError("'SHEmptyRecycleBin' requires that UNICODE be set to true or false in the root module");
        pub const Shell_NotifyIcon = @compileError("'Shell_NotifyIcon' requires that UNICODE be set to true or false in the root module");
        pub const SHGetFileInfo = @compileError("'SHGetFileInfo' requires that UNICODE be set to true or false in the root module");
        pub const SHGetDiskFreeSpaceEx = @compileError("'SHGetDiskFreeSpaceEx' requires that UNICODE be set to true or false in the root module");
        pub const SHGetNewLinkInfo = @compileError("'SHGetNewLinkInfo' requires that UNICODE be set to true or false in the root module");
        pub const SHInvokePrinterCommand = @compileError("'SHInvokePrinterCommand' requires that UNICODE be set to true or false in the root module");
        pub const ShellMessageBox = @compileError("'ShellMessageBox' requires that UNICODE be set to true or false in the root module");
        pub const IsLFNDrive = @compileError("'IsLFNDrive' requires that UNICODE be set to true or false in the root module");
        pub const SHGetIconOverlayIndex = @compileError("'SHGetIconOverlayIndex' requires that UNICODE be set to true or false in the root module");
        pub const ILCreateFromPath = @compileError("'ILCreateFromPath' requires that UNICODE be set to true or false in the root module");
        pub const SHGetPathFromIDList = @compileError("'SHGetPathFromIDList' requires that UNICODE be set to true or false in the root module");
        pub const SHCreateDirectoryEx = @compileError("'SHCreateDirectoryEx' requires that UNICODE be set to true or false in the root module");
        pub const SHGetSpecialFolderPath = @compileError("'SHGetSpecialFolderPath' requires that UNICODE be set to true or false in the root module");
        pub const SHGetFolderPath = @compileError("'SHGetFolderPath' requires that UNICODE be set to true or false in the root module");
        pub const SHSetFolderPath = @compileError("'SHSetFolderPath' requires that UNICODE be set to true or false in the root module");
        pub const SHGetFolderPathAndSubDir = @compileError("'SHGetFolderPathAndSubDir' requires that UNICODE be set to true or false in the root module");
        pub const SHBrowseForFolder = @compileError("'SHBrowseForFolder' requires that UNICODE be set to true or false in the root module");
        pub const SHUpdateImage = @compileError("'SHUpdateImage' requires that UNICODE be set to true or false in the root module");
        pub const SHGetDataFromIDList = @compileError("'SHGetDataFromIDList' requires that UNICODE be set to true or false in the root module");
        pub const SHDefExtractIcon = @compileError("'SHDefExtractIcon' requires that UNICODE be set to true or false in the root module");
        pub const SHPathPrepareForWrite = @compileError("'SHPathPrepareForWrite' requires that UNICODE be set to true or false in the root module");
        pub const PathIsSlow = @compileError("'PathIsSlow' requires that UNICODE be set to true or false in the root module");
        pub const StrChr = @compileError("'StrChr' requires that UNICODE be set to true or false in the root module");
        pub const StrChrI = @compileError("'StrChrI' requires that UNICODE be set to true or false in the root module");
        pub const StrCmpN = @compileError("'StrCmpN' requires that UNICODE be set to true or false in the root module");
        pub const StrCmpNI = @compileError("'StrCmpNI' requires that UNICODE be set to true or false in the root module");
        pub const StrCSpn = @compileError("'StrCSpn' requires that UNICODE be set to true or false in the root module");
        pub const StrCSpnI = @compileError("'StrCSpnI' requires that UNICODE be set to true or false in the root module");
        pub const StrDup = @compileError("'StrDup' requires that UNICODE be set to true or false in the root module");
        pub const StrFormatByteSize = @compileError("'StrFormatByteSize' requires that UNICODE be set to true or false in the root module");
        pub const StrFormatKBSize = @compileError("'StrFormatKBSize' requires that UNICODE be set to true or false in the root module");
        pub const StrFromTimeInterval = @compileError("'StrFromTimeInterval' requires that UNICODE be set to true or false in the root module");
        pub const StrIsIntlEqual = @compileError("'StrIsIntlEqual' requires that UNICODE be set to true or false in the root module");
        pub const StrNCat = @compileError("'StrNCat' requires that UNICODE be set to true or false in the root module");
        pub const StrPBrk = @compileError("'StrPBrk' requires that UNICODE be set to true or false in the root module");
        pub const StrRChr = @compileError("'StrRChr' requires that UNICODE be set to true or false in the root module");
        pub const StrRChrI = @compileError("'StrRChrI' requires that UNICODE be set to true or false in the root module");
        pub const StrRStrI = @compileError("'StrRStrI' requires that UNICODE be set to true or false in the root module");
        pub const StrSpn = @compileError("'StrSpn' requires that UNICODE be set to true or false in the root module");
        pub const StrStr = @compileError("'StrStr' requires that UNICODE be set to true or false in the root module");
        pub const StrStrI = @compileError("'StrStrI' requires that UNICODE be set to true or false in the root module");
        pub const StrToInt = @compileError("'StrToInt' requires that UNICODE be set to true or false in the root module");
        pub const StrToIntEx = @compileError("'StrToIntEx' requires that UNICODE be set to true or false in the root module");
        pub const StrToInt64Ex = @compileError("'StrToInt64Ex' requires that UNICODE be set to true or false in the root module");
        pub const StrTrim = @compileError("'StrTrim' requires that UNICODE be set to true or false in the root module");
        pub const StrCatBuff = @compileError("'StrCatBuff' requires that UNICODE be set to true or false in the root module");
        pub const ChrCmpI = @compileError("'ChrCmpI' requires that UNICODE be set to true or false in the root module");
        pub const wvnsprintf = @compileError("'wvnsprintf' requires that UNICODE be set to true or false in the root module");
        pub const wnsprintf = @compileError("'wnsprintf' requires that UNICODE be set to true or false in the root module");
        pub const StrRetToStr = @compileError("'StrRetToStr' requires that UNICODE be set to true or false in the root module");
        pub const StrRetToBuf = @compileError("'StrRetToBuf' requires that UNICODE be set to true or false in the root module");
        pub const SHStrDup = @compileError("'SHStrDup' requires that UNICODE be set to true or false in the root module");
        pub const IsCharSpace = @compileError("'IsCharSpace' requires that UNICODE be set to true or false in the root module");
        pub const StrCmpC = @compileError("'StrCmpC' requires that UNICODE be set to true or false in the root module");
        pub const StrCmpIC = @compileError("'StrCmpIC' requires that UNICODE be set to true or false in the root module");
        pub const StrCmpNC = @compileError("'StrCmpNC' requires that UNICODE be set to true or false in the root module");
        pub const StrCmpNIC = @compileError("'StrCmpNIC' requires that UNICODE be set to true or false in the root module");
        pub const IntlStrEqWorker = @compileError("'IntlStrEqWorker' requires that UNICODE be set to true or false in the root module");
        pub const PathAddBackslash = @compileError("'PathAddBackslash' requires that UNICODE be set to true or false in the root module");
        pub const PathAddExtension = @compileError("'PathAddExtension' requires that UNICODE be set to true or false in the root module");
        pub const PathAppend = @compileError("'PathAppend' requires that UNICODE be set to true or false in the root module");
        pub const PathBuildRoot = @compileError("'PathBuildRoot' requires that UNICODE be set to true or false in the root module");
        pub const PathCanonicalize = @compileError("'PathCanonicalize' requires that UNICODE be set to true or false in the root module");
        pub const PathCombine = @compileError("'PathCombine' requires that UNICODE be set to true or false in the root module");
        pub const PathCompactPath = @compileError("'PathCompactPath' requires that UNICODE be set to true or false in the root module");
        pub const PathCompactPathEx = @compileError("'PathCompactPathEx' requires that UNICODE be set to true or false in the root module");
        pub const PathCommonPrefix = @compileError("'PathCommonPrefix' requires that UNICODE be set to true or false in the root module");
        pub const PathFileExists = @compileError("'PathFileExists' requires that UNICODE be set to true or false in the root module");
        pub const PathFindExtension = @compileError("'PathFindExtension' requires that UNICODE be set to true or false in the root module");
        pub const PathFindFileName = @compileError("'PathFindFileName' requires that UNICODE be set to true or false in the root module");
        pub const PathFindNextComponent = @compileError("'PathFindNextComponent' requires that UNICODE be set to true or false in the root module");
        pub const PathFindOnPath = @compileError("'PathFindOnPath' requires that UNICODE be set to true or false in the root module");
        pub const PathFindSuffixArray = @compileError("'PathFindSuffixArray' requires that UNICODE be set to true or false in the root module");
        pub const PathGetArgs = @compileError("'PathGetArgs' requires that UNICODE be set to true or false in the root module");
        pub const PathIsLFNFileSpec = @compileError("'PathIsLFNFileSpec' requires that UNICODE be set to true or false in the root module");
        pub const PathGetCharType = @compileError("'PathGetCharType' requires that UNICODE be set to true or false in the root module");
        pub const PathGetDriveNumber = @compileError("'PathGetDriveNumber' requires that UNICODE be set to true or false in the root module");
        pub const PathIsDirectory = @compileError("'PathIsDirectory' requires that UNICODE be set to true or false in the root module");
        pub const PathIsDirectoryEmpty = @compileError("'PathIsDirectoryEmpty' requires that UNICODE be set to true or false in the root module");
        pub const PathIsFileSpec = @compileError("'PathIsFileSpec' requires that UNICODE be set to true or false in the root module");
        pub const PathIsPrefix = @compileError("'PathIsPrefix' requires that UNICODE be set to true or false in the root module");
        pub const PathIsRelative = @compileError("'PathIsRelative' requires that UNICODE be set to true or false in the root module");
        pub const PathIsRoot = @compileError("'PathIsRoot' requires that UNICODE be set to true or false in the root module");
        pub const PathIsSameRoot = @compileError("'PathIsSameRoot' requires that UNICODE be set to true or false in the root module");
        pub const PathIsUNC = @compileError("'PathIsUNC' requires that UNICODE be set to true or false in the root module");
        pub const PathIsNetworkPath = @compileError("'PathIsNetworkPath' requires that UNICODE be set to true or false in the root module");
        pub const PathIsUNCServer = @compileError("'PathIsUNCServer' requires that UNICODE be set to true or false in the root module");
        pub const PathIsUNCServerShare = @compileError("'PathIsUNCServerShare' requires that UNICODE be set to true or false in the root module");
        pub const PathIsContentType = @compileError("'PathIsContentType' requires that UNICODE be set to true or false in the root module");
        pub const PathIsURL = @compileError("'PathIsURL' requires that UNICODE be set to true or false in the root module");
        pub const PathMakePretty = @compileError("'PathMakePretty' requires that UNICODE be set to true or false in the root module");
        pub const PathMatchSpec = @compileError("'PathMatchSpec' requires that UNICODE be set to true or false in the root module");
        pub const PathMatchSpecEx = @compileError("'PathMatchSpecEx' requires that UNICODE be set to true or false in the root module");
        pub const PathParseIconLocation = @compileError("'PathParseIconLocation' requires that UNICODE be set to true or false in the root module");
        pub const PathQuoteSpaces = @compileError("'PathQuoteSpaces' requires that UNICODE be set to true or false in the root module");
        pub const PathRelativePathTo = @compileError("'PathRelativePathTo' requires that UNICODE be set to true or false in the root module");
        pub const PathRemoveArgs = @compileError("'PathRemoveArgs' requires that UNICODE be set to true or false in the root module");
        pub const PathRemoveBackslash = @compileError("'PathRemoveBackslash' requires that UNICODE be set to true or false in the root module");
        pub const PathRemoveBlanks = @compileError("'PathRemoveBlanks' requires that UNICODE be set to true or false in the root module");
        pub const PathRemoveExtension = @compileError("'PathRemoveExtension' requires that UNICODE be set to true or false in the root module");
        pub const PathRemoveFileSpec = @compileError("'PathRemoveFileSpec' requires that UNICODE be set to true or false in the root module");
        pub const PathRenameExtension = @compileError("'PathRenameExtension' requires that UNICODE be set to true or false in the root module");
        pub const PathSearchAndQualify = @compileError("'PathSearchAndQualify' requires that UNICODE be set to true or false in the root module");
        pub const PathSetDlgItemPath = @compileError("'PathSetDlgItemPath' requires that UNICODE be set to true or false in the root module");
        pub const PathSkipRoot = @compileError("'PathSkipRoot' requires that UNICODE be set to true or false in the root module");
        pub const PathStripPath = @compileError("'PathStripPath' requires that UNICODE be set to true or false in the root module");
        pub const PathStripToRoot = @compileError("'PathStripToRoot' requires that UNICODE be set to true or false in the root module");
        pub const PathUnquoteSpaces = @compileError("'PathUnquoteSpaces' requires that UNICODE be set to true or false in the root module");
        pub const PathMakeSystemFolder = @compileError("'PathMakeSystemFolder' requires that UNICODE be set to true or false in the root module");
        pub const PathUnmakeSystemFolder = @compileError("'PathUnmakeSystemFolder' requires that UNICODE be set to true or false in the root module");
        pub const PathIsSystemFolder = @compileError("'PathIsSystemFolder' requires that UNICODE be set to true or false in the root module");
        pub const PathUndecorate = @compileError("'PathUndecorate' requires that UNICODE be set to true or false in the root module");
        pub const PathUnExpandEnvStrings = @compileError("'PathUnExpandEnvStrings' requires that UNICODE be set to true or false in the root module");
        pub const UrlCompare = @compileError("'UrlCompare' requires that UNICODE be set to true or false in the root module");
        pub const UrlCombine = @compileError("'UrlCombine' requires that UNICODE be set to true or false in the root module");
        pub const UrlCanonicalize = @compileError("'UrlCanonicalize' requires that UNICODE be set to true or false in the root module");
        pub const UrlIsOpaque = @compileError("'UrlIsOpaque' requires that UNICODE be set to true or false in the root module");
        pub const UrlIsNoHistory = @compileError("'UrlIsNoHistory' requires that UNICODE be set to true or false in the root module");
        pub const UrlIs = @compileError("'UrlIs' requires that UNICODE be set to true or false in the root module");
        pub const UrlGetLocation = @compileError("'UrlGetLocation' requires that UNICODE be set to true or false in the root module");
        pub const UrlUnescape = @compileError("'UrlUnescape' requires that UNICODE be set to true or false in the root module");
        pub const UrlEscape = @compileError("'UrlEscape' requires that UNICODE be set to true or false in the root module");
        pub const UrlCreateFromPath = @compileError("'UrlCreateFromPath' requires that UNICODE be set to true or false in the root module");
        pub const PathCreateFromUrl = @compileError("'PathCreateFromUrl' requires that UNICODE be set to true or false in the root module");
        pub const UrlHash = @compileError("'UrlHash' requires that UNICODE be set to true or false in the root module");
        pub const UrlGetPart = @compileError("'UrlGetPart' requires that UNICODE be set to true or false in the root module");
        pub const UrlApplyScheme = @compileError("'UrlApplyScheme' requires that UNICODE be set to true or false in the root module");
        pub const ParseURL = @compileError("'ParseURL' requires that UNICODE be set to true or false in the root module");
        pub const SHDeleteEmptyKey = @compileError("'SHDeleteEmptyKey' requires that UNICODE be set to true or false in the root module");
        pub const SHDeleteKey = @compileError("'SHDeleteKey' requires that UNICODE be set to true or false in the root module");
        pub const SHDeleteValue = @compileError("'SHDeleteValue' requires that UNICODE be set to true or false in the root module");
        pub const SHGetValue = @compileError("'SHGetValue' requires that UNICODE be set to true or false in the root module");
        pub const SHSetValue = @compileError("'SHSetValue' requires that UNICODE be set to true or false in the root module");
        pub const SHRegGetValue = @compileError("'SHRegGetValue' requires that UNICODE be set to true or false in the root module");
        pub const SHQueryValueEx = @compileError("'SHQueryValueEx' requires that UNICODE be set to true or false in the root module");
        pub const SHEnumKeyEx = @compileError("'SHEnumKeyEx' requires that UNICODE be set to true or false in the root module");
        pub const SHEnumValue = @compileError("'SHEnumValue' requires that UNICODE be set to true or false in the root module");
        pub const SHQueryInfoKey = @compileError("'SHQueryInfoKey' requires that UNICODE be set to true or false in the root module");
        pub const SHCopyKey = @compileError("'SHCopyKey' requires that UNICODE be set to true or false in the root module");
        pub const SHRegGetPath = @compileError("'SHRegGetPath' requires that UNICODE be set to true or false in the root module");
        pub const SHRegSetPath = @compileError("'SHRegSetPath' requires that UNICODE be set to true or false in the root module");
        pub const SHRegCreateUSKey = @compileError("'SHRegCreateUSKey' requires that UNICODE be set to true or false in the root module");
        pub const SHRegOpenUSKey = @compileError("'SHRegOpenUSKey' requires that UNICODE be set to true or false in the root module");
        pub const SHRegQueryUSValue = @compileError("'SHRegQueryUSValue' requires that UNICODE be set to true or false in the root module");
        pub const SHRegWriteUSValue = @compileError("'SHRegWriteUSValue' requires that UNICODE be set to true or false in the root module");
        pub const SHRegDeleteUSValue = @compileError("'SHRegDeleteUSValue' requires that UNICODE be set to true or false in the root module");
        pub const SHRegDeleteEmptyUSKey = @compileError("'SHRegDeleteEmptyUSKey' requires that UNICODE be set to true or false in the root module");
        pub const SHRegEnumUSKey = @compileError("'SHRegEnumUSKey' requires that UNICODE be set to true or false in the root module");
        pub const SHRegEnumUSValue = @compileError("'SHRegEnumUSValue' requires that UNICODE be set to true or false in the root module");
        pub const SHRegQueryInfoUSKey = @compileError("'SHRegQueryInfoUSKey' requires that UNICODE be set to true or false in the root module");
        pub const SHRegGetUSValue = @compileError("'SHRegGetUSValue' requires that UNICODE be set to true or false in the root module");
        pub const SHRegSetUSValue = @compileError("'SHRegSetUSValue' requires that UNICODE be set to true or false in the root module");
        pub const SHRegGetBoolUSValue = @compileError("'SHRegGetBoolUSValue' requires that UNICODE be set to true or false in the root module");
        pub const AssocQueryString = @compileError("'AssocQueryString' requires that UNICODE be set to true or false in the root module");
        pub const AssocQueryStringByKey = @compileError("'AssocQueryStringByKey' requires that UNICODE be set to true or false in the root module");
        pub const AssocQueryKey = @compileError("'AssocQueryKey' requires that UNICODE be set to true or false in the root module");
        pub const SHOpenRegStream = @compileError("'SHOpenRegStream' requires that UNICODE be set to true or false in the root module");
        pub const SHOpenRegStream2 = @compileError("'SHOpenRegStream2' requires that UNICODE be set to true or false in the root module");
        pub const SHCreateStreamOnFile = @compileError("'SHCreateStreamOnFile' requires that UNICODE be set to true or false in the root module");
        pub const GetAcceptLanguages = @compileError("'GetAcceptLanguages' requires that UNICODE be set to true or false in the root module");
        pub const SHFormatDateTime = @compileError("'SHFormatDateTime' requires that UNICODE be set to true or false in the root module");
        pub const SHMessageBoxCheck = @compileError("'SHMessageBoxCheck' requires that UNICODE be set to true or false in the root module");
        pub const SHSendMessageBroadcast = @compileError("'SHSendMessageBroadcast' requires that UNICODE be set to true or false in the root module");
        pub const SHStripMneumonic = @compileError("'SHStripMneumonic' requires that UNICODE be set to true or false in the root module");
        pub const LoadUserProfile = @compileError("'LoadUserProfile' requires that UNICODE be set to true or false in the root module");
        pub const GetProfilesDirectory = @compileError("'GetProfilesDirectory' requires that UNICODE be set to true or false in the root module");
        pub const DeleteProfile = @compileError("'DeleteProfile' requires that UNICODE be set to true or false in the root module");
        pub const GetDefaultUserProfileDirectory = @compileError("'GetDefaultUserProfileDirectory' requires that UNICODE be set to true or false in the root module");
        pub const GetAllUsersProfileDirectory = @compileError("'GetAllUsersProfileDirectory' requires that UNICODE be set to true or false in the root module");
        pub const GetUserProfileDirectory = @compileError("'GetUserProfileDirectory' requires that UNICODE be set to true or false in the root module");
        pub const ExpandEnvironmentStringsForUser = @compileError("'ExpandEnvironmentStringsForUser' requires that UNICODE be set to true or false in the root module");
    },
};

//
// type imports
//
const Guid = @import("../zig.zig").Guid;
const HANDLE = @import("systemservices.zig").HANDLE;
const POINT = @import("displaydevices.zig").POINT;
const HWND = @import("windowsandmessaging.zig").HWND;
const RECT = @import("displaydevices.zig").RECT;
const PROPERTYKEY = @import("windowspropertiessystem.zig").PROPERTYKEY;
const SIZE = @import("displaydevices.zig").SIZE;
const HBITMAP = @import("gdi.zig").HBITMAP;
const POINTL = @import("displaydevices.zig").POINTL;
const HICON = @import("gdi.zig").HICON;
const HMENU = @import("menusandresources.zig").HMENU;
const IUnknown = @import("com.zig").IUnknown;
const HACCEL = @import("menusandresources.zig").HACCEL;
const HIMAGELIST = @import("controls.zig").HIMAGELIST;
const BFFCALLBACK = @import("activedirectory.zig").BFFCALLBACK;
const LPARAM = @import("windowsandmessaging.zig").LPARAM;
const NETRESOURCEA = @import("security.zig").NETRESOURCEA;
const LPFNADDPROPSHEETPAGE = @import("controls.zig").LPFNADDPROPSHEETPAGE;
const FILETIME = @import("windowsprogramming.zig").FILETIME;
const SYSTEMTIME = @import("windowsprogramming.zig").SYSTEMTIME;
const BYTE_BLOB = @import("com.zig").BYTE_BLOB;
const IWebBrowser2 = @import("windowsprogramming.zig").IWebBrowser2;
const IOleCommandTarget = @import("com.zig").IOleCommandTarget;
const BOOL = @import("systemservices.zig").BOOL;
const COMPOSITIONFORM = @import("intl.zig").COMPOSITIONFORM;
const CANDIDATEFORM = @import("intl.zig").CANDIDATEFORM;
const HIMCC__ = @import("intl.zig").HIMCC__;
const NET_ADDRESS_INFO = @import("iphelper.zig").NET_ADDRESS_INFO;
const HINSTANCE = @import("systemservices.zig").HINSTANCE;
const HRESULT = @import("com.zig").HRESULT;
const ULARGE_INTEGER = @import("systemservices.zig").ULARGE_INTEGER;
const HKEY = @import("windowsprogramming.zig").HKEY;
const IBindCtx = @import("com.zig").IBindCtx;
const IDataObject = @import("com.zig").IDataObject;
const PROPVARIANT = @import("structuredstorage.zig").PROPVARIANT;
const IMalloc = @import("com.zig").IMalloc;
const IStream = @import("structuredstorage.zig").IStream;
const SECURITY_ATTRIBUTES = @import("systemservices.zig").SECURITY_ATTRIBUTES;
const FORMATETC = @import("com.zig").FORMATETC;
const IEnumFORMATETC = @import("com.zig").IEnumFORMATETC;
const IDropSource = @import("com.zig").IDropSource;
const VARIANT = @import("automation.zig").VARIANT;
const LRESULT = @import("systemservices.zig").LRESULT;
const IStorage = @import("structuredstorage.zig").IStorage;
const IMoniker = @import("com.zig").IMoniker;
const IEnumPrivacyRecords = @import("debug.zig").IEnumPrivacyRecords;
const BSTR = @import("automation.zig").BSTR;
const HDC = @import("gdi.zig").HDC;
const LSTATUS = @import("systemservices.zig").LSTATUS;
const IConnectionPoint = @import("com.zig").IConnectionPoint;
const WPARAM = @import("windowsandmessaging.zig").WPARAM;
const LPTHREAD_START_ROUTINE = @import("systemservices.zig").LPTHREAD_START_ROUTINE;
const HPALETTE = @import("gdi.zig").HPALETTE;
const IBindStatusCallback = @import("com.zig").IBindStatusCallback;
const SID_AND_ATTRIBUTES = @import("security.zig").SID_AND_ATTRIBUTES;

test "" {
    const constant_export_count = 49;
    const type_export_count = 918;
    const func_count = 699;
    const unicode_alias_count = 209;
    const type_import_count = 55;
    @setEvalBranchQuota(0
        + constant_export_count
        + type_export_count
        + func_count
        + unicode_alias_count
        + type_import_count
        + 2 // TODO: why do I need these extra 2?
    );
    @import("std").testing.refAllDecls(@This());
}
