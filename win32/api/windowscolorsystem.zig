//! NOTE: this source file is autogenerated, DO NOT MODIFY

//
// constants
//

//
// types
//
// --------------------------------------------------------
// Type: CIEXYZ
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CIEXYZ = extern struct {
    ciexyzX: i32,
    ciexyzY: i32,
    ciexyzZ: i32,
};
// --------------------------------------------------------
// Type: CIEXYZTRIPLE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CIEXYZTRIPLE = extern struct {
    ciexyzRed: CIEXYZ,
    ciexyzGreen: CIEXYZ,
    ciexyzBlue: CIEXYZ,
};
// --------------------------------------------------------
// Type: LOGCOLORSPACEA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const LOGCOLORSPACEA = extern struct {
    lcsSignature: u32,
    lcsVersion: u32,
    lcsSize: u32,
    lcsCSType: i32,
    lcsIntent: i32,
    lcsEndpoints: CIEXYZTRIPLE,
    lcsGammaRed: u32,
    lcsGammaGreen: u32,
    lcsGammaBlue: u32,
    lcsFilename: ?[*]i8,
};
// --------------------------------------------------------
// Type: LOGCOLORSPACEW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const LOGCOLORSPACEW = extern struct {
    lcsSignature: u32,
    lcsVersion: u32,
    lcsSize: u32,
    lcsCSType: i32,
    lcsIntent: i32,
    lcsEndpoints: CIEXYZTRIPLE,
    lcsGammaRed: u32,
    lcsGammaGreen: u32,
    lcsGammaBlue: u32,
    lcsFilename: ?[*]u16,
};
// --------------------------------------------------------
// Type: ICMENUMPROCA
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const ICMENUMPROCA = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: ICMENUMPROCW
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const ICMENUMPROCW = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: XYZColorF
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const XYZColorF = extern struct {
    X: f32,
    Y: f32,
    Z: f32,
};
// --------------------------------------------------------
// Type: JChColorF
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const JChColorF = extern struct {
    J: f32,
    C: f32,
    h: f32,
};
// --------------------------------------------------------
// Type: JabColorF
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const JabColorF = extern struct {
    J: f32,
    a: f32,
    b: f32,
};
// --------------------------------------------------------
// Type: GamutShellTriangle
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const GamutShellTriangle = extern struct {
    aVertexIndex: ?[*]u32,
};
// --------------------------------------------------------
// Type: GamutShell
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const GamutShell = extern struct {
    JMin: f32,
    JMax: f32,
    cVertices: u32,
    cTriangles: u32,
    pVertices: ?*JabColorF,
    pTriangles: ?*GamutShellTriangle,
};
// --------------------------------------------------------
// Type: PrimaryJabColors
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PrimaryJabColors = extern struct {
    red: JabColorF,
    yellow: JabColorF,
    green: JabColorF,
    cyan: JabColorF,
    blue: JabColorF,
    magenta: JabColorF,
    black: JabColorF,
    white: JabColorF,
};
// --------------------------------------------------------
// Type: PrimaryXYZColors
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PrimaryXYZColors = extern struct {
    red: XYZColorF,
    yellow: XYZColorF,
    green: XYZColorF,
    cyan: XYZColorF,
    blue: XYZColorF,
    magenta: XYZColorF,
    black: XYZColorF,
    white: XYZColorF,
};
// --------------------------------------------------------
// Type: GamutBoundaryDescription
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const GamutBoundaryDescription = extern struct {
    pPrimaries: ?*PrimaryJabColors,
    cNeutralSamples: u32,
    pNeutralSamples: ?*JabColorF,
    pReferenceShell: ?*GamutShell,
    pPlausibleShell: ?*GamutShell,
    pPossibleShell: ?*GamutShell,
};
// --------------------------------------------------------
// Type: BlackInformation
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const BlackInformation = extern struct {
    fBlackOnly: BOOL,
    blackWeight: f32,
};
// --------------------------------------------------------
// Type: IDeviceModelPlugIn
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IDeviceModelPlugIn = *opaque{
    // TODO: Method 'Initialize'
    // TODO: Method 'GetNumChannels'
    // TODO: Method 'DeviceToColorimetricColors'
    // TODO: Method 'ColorimetricToDeviceColors'
    // TODO: Method 'ColorimetricToDeviceColorsWithBlack'
    // TODO: Method 'SetTransformDeviceModelInfo'
    // TODO: Method 'GetPrimarySamples'
    // TODO: Method 'GetGamutBoundaryMeshSize'
    // TODO: Method 'GetGamutBoundaryMesh'
    // TODO: Method 'GetNeutralAxisSize'
    // TODO: Method 'GetNeutralAxis'
};
// --------------------------------------------------------
// Type: IGamutMapModelPlugIn
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IGamutMapModelPlugIn = *opaque{
    // TODO: Method 'Initialize'
    // TODO: Method 'SourceToDestinationAppearanceColors'
};
// --------------------------------------------------------
// Type: NAMED_PROFILE_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NAMED_PROFILE_INFO = extern struct {
    dwFlags: u32,
    dwCount: u32,
    dwCountDevCoordinates: u32,
    szPrefix: ?[*]i8,
    szSuffix: ?[*]i8,
};
// --------------------------------------------------------
// Type: GRAYCOLOR
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const GRAYCOLOR = extern struct {
    gray: u16,
};
// --------------------------------------------------------
// Type: RGBCOLOR
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const RGBCOLOR = extern struct {
    red: u16,
    green: u16,
    blue: u16,
};
// --------------------------------------------------------
// Type: CMYKCOLOR
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CMYKCOLOR = extern struct {
    cyan: u16,
    magenta: u16,
    yellow: u16,
    black: u16,
};
// --------------------------------------------------------
// Type: XYZCOLOR
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const XYZCOLOR = extern struct {
    X: u16,
    Y: u16,
    Z: u16,
};
// --------------------------------------------------------
// Type: YxyCOLOR
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const YxyCOLOR = extern struct {
    Y: u16,
    x: u16,
    y: u16,
};
// --------------------------------------------------------
// Type: LabCOLOR
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const LabCOLOR = extern struct {
    L: u16,
    a: u16,
    b: u16,
};
// --------------------------------------------------------
// Type: GENERIC3CHANNEL
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const GENERIC3CHANNEL = extern struct {
    ch1: u16,
    ch2: u16,
    ch3: u16,
};
// --------------------------------------------------------
// Type: NAMEDCOLOR
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NAMEDCOLOR = extern struct {
    dwIndex: u32,
};
// --------------------------------------------------------
// Type: HiFiCOLOR
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HiFiCOLOR = extern struct {
    channel: ?[*]u8,
};
// --------------------------------------------------------
// Type: COLOR
// TypeLayoutAttr: explicit
// not generating the actual code for this type because it has an explicit layout
pub const COLOR = *opaque{
    // --------------------------------------------------------
    // Type: _Anonymous_e__Struct
    // TypeLayoutAttr: sequential
    // TODO: I think this is a struct, but not sure at this point, assuming it is for now
    pub const _Anonymous_e__Struct = extern struct {
        reserved1: u32,
        reserved2: ?*opaque{},
    };
};
// --------------------------------------------------------
// Type: COLORTYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const COLORTYPE = *opaque{
};
// --------------------------------------------------------
// Type: COLORPROFILETYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const COLORPROFILETYPE = *opaque{
};
// --------------------------------------------------------
// Type: COLORPROFILESUBTYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const COLORPROFILESUBTYPE = *opaque{
};
// --------------------------------------------------------
// Type: COLORDATATYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const COLORDATATYPE = *opaque{
};
// --------------------------------------------------------
// Type: BMFORMAT
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const BMFORMAT = *opaque{
};
// --------------------------------------------------------
// Type: PBMCALLBACKFN
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PBMCALLBACKFN = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: LPBMCALLBACKFN
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const LPBMCALLBACKFN = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PROFILEHEADER
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PROFILEHEADER = extern struct {
    phSize: u32,
    phCMMType: u32,
    phVersion: u32,
    phClass: u32,
    phDataColorSpace: u32,
    phConnectionSpace: u32,
    phDateTime: ?[*]u32,
    phSignature: u32,
    phPlatform: u32,
    phProfileFlags: u32,
    phManufacturer: u32,
    phModel: u32,
    phAttributes: ?[*]u32,
    phRenderingIntent: u32,
    phIlluminant: CIEXYZ,
    phCreator: u32,
    phReserved: ?[*]u8,
};
// --------------------------------------------------------
// Type: PROFILE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PROFILE = extern struct {
    dwType: u32,
    pProfileData: ?*opaque{},
    cbDataSize: u32,
};
// --------------------------------------------------------
// Type: ENUMTYPEA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const ENUMTYPEA = extern struct {
    dwSize: u32,
    dwVersion: u32,
    dwFields: u32,
    pDeviceName: ?*i8,
    dwMediaType: u32,
    dwDitheringMode: u32,
    dwResolution: ?[*]u32,
    dwCMMType: u32,
    dwClass: u32,
    dwDataColorSpace: u32,
    dwConnectionSpace: u32,
    dwSignature: u32,
    dwPlatform: u32,
    dwProfileFlags: u32,
    dwManufacturer: u32,
    dwModel: u32,
    dwAttributes: ?[*]u32,
    dwRenderingIntent: u32,
    dwCreator: u32,
    dwDeviceClass: u32,
};
// --------------------------------------------------------
// Type: ENUMTYPEW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const ENUMTYPEW = extern struct {
    dwSize: u32,
    dwVersion: u32,
    dwFields: u32,
    pDeviceName: ?*u16,
    dwMediaType: u32,
    dwDitheringMode: u32,
    dwResolution: ?[*]u32,
    dwCMMType: u32,
    dwClass: u32,
    dwDataColorSpace: u32,
    dwConnectionSpace: u32,
    dwSignature: u32,
    dwPlatform: u32,
    dwProfileFlags: u32,
    dwManufacturer: u32,
    dwModel: u32,
    dwAttributes: ?[*]u32,
    dwRenderingIntent: u32,
    dwCreator: u32,
    dwDeviceClass: u32,
};
// --------------------------------------------------------
// Type: WCS_PROFILE_MANAGEMENT_SCOPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const WCS_PROFILE_MANAGEMENT_SCOPE = *opaque{
};
// --------------------------------------------------------
// Type: PCMSCALLBACKW
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PCMSCALLBACKW = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PCMSCALLBACKA
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PCMSCALLBACKA = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: COLORMATCHSETUPW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const COLORMATCHSETUPW = extern struct {
    dwSize: u32,
    dwVersion: u32,
    dwFlags: u32,
    hwndOwner: HWND,
    pSourceName: ?*u16,
    pDisplayName: ?*u16,
    pPrinterName: ?*u16,
    dwRenderIntent: u32,
    dwProofingIntent: u32,
    pMonitorProfile: ?*u16,
    ccMonitorProfile: u32,
    pPrinterProfile: ?*u16,
    ccPrinterProfile: u32,
    pTargetProfile: ?*u16,
    ccTargetProfile: u32,
    lpfnHook: DLGPROC,
    lParam: LPARAM,
    lpfnApplyCallback: PCMSCALLBACKW,
    lParamApplyCallback: LPARAM,
};
// --------------------------------------------------------
// Type: COLORMATCHSETUPA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const COLORMATCHSETUPA = extern struct {
    dwSize: u32,
    dwVersion: u32,
    dwFlags: u32,
    hwndOwner: HWND,
    pSourceName: ?*i8,
    pDisplayName: ?*i8,
    pPrinterName: ?*i8,
    dwRenderIntent: u32,
    dwProofingIntent: u32,
    pMonitorProfile: ?*i8,
    ccMonitorProfile: u32,
    pPrinterProfile: ?*i8,
    ccPrinterProfile: u32,
    pTargetProfile: ?*i8,
    ccTargetProfile: u32,
    lpfnHook: DLGPROC,
    lParam: LPARAM,
    lpfnApplyCallback: PCMSCALLBACKA,
    lParamApplyCallback: LPARAM,
};
// --------------------------------------------------------
// Type: XYYPoint
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const XYYPoint = extern struct {
    x: f32,
    y: f32,
    Y: f32,
};
// --------------------------------------------------------
// Type: WhitePoint
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const WhitePoint = extern struct {
    type: i32,
    Anonymous: _Anonymous_e__Union,
    CHROMATICITY: i32,
    TEMPERATURE: i32,
    D65: i32,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: DisplayID
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DisplayID = extern struct {
    targetAdapterID: LUID,
    sourceInfoID: u32,
};
// --------------------------------------------------------
// Type: DisplayStateID
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DisplayStateID = extern struct {
    profileID: u32,
    transformID: u32,
    whitepointID: u32,
};
// --------------------------------------------------------
// Type: DisplayTransformLut
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DisplayTransformLut = extern struct {
    red: ?[*]u16,
    green: ?[*]u16,
    blue: ?[*]u16,
};

//
// functions
//

// set_last_errror=False (can and should we use this?)
pub extern "GDI32" fn SetICMMode(
    hdc: HDC,
    mode: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "GDI32" fn CheckColorsInGamut(
    hdc: HDC,
    lpRGBTriple: ?*RGBTRIPLE,
    dlpBuffer: ?*opaque{},
    nCount: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "GDI32" fn GetColorSpace(
    hdc: HDC,
) callconv(@import("std").os.windows.WINAPI) HCOLORSPACE;

// set_last_errror=False (can and should we use this?)
pub extern "GDI32" fn GetLogColorSpaceA(
    hColorSpace: HCOLORSPACE,
    lpBuffer: ?*LOGCOLORSPACEA,
    nSize: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "GDI32" fn GetLogColorSpaceW(
    hColorSpace: HCOLORSPACE,
    lpBuffer: ?*LOGCOLORSPACEW,
    nSize: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "GDI32" fn CreateColorSpaceA(
    lplcs: ?*LOGCOLORSPACEA,
) callconv(@import("std").os.windows.WINAPI) HCOLORSPACE;

// set_last_errror=False (can and should we use this?)
pub extern "GDI32" fn CreateColorSpaceW(
    lplcs: ?*LOGCOLORSPACEW,
) callconv(@import("std").os.windows.WINAPI) HCOLORSPACE;

// set_last_errror=False (can and should we use this?)
pub extern "GDI32" fn SetColorSpace(
    hdc: HDC,
    hcs: HCOLORSPACE,
) callconv(@import("std").os.windows.WINAPI) HCOLORSPACE;

// set_last_errror=False (can and should we use this?)
pub extern "GDI32" fn DeleteColorSpace(
    hcs: HCOLORSPACE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "GDI32" fn GetICMProfileA(
    hdc: HDC,
    pBufSize: ?*u32,
    pszFilename: ?*i8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "GDI32" fn GetICMProfileW(
    hdc: HDC,
    pBufSize: ?*u32,
    pszFilename: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "GDI32" fn SetICMProfileA(
    hdc: HDC,
    lpFileName: ?*i8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "GDI32" fn SetICMProfileW(
    hdc: HDC,
    lpFileName: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "GDI32" fn GetDeviceGammaRamp(
    hdc: HDC,
    lpRamp: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "GDI32" fn SetDeviceGammaRamp(
    hdc: HDC,
    lpRamp: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "GDI32" fn ColorMatchToTarget(
    hdc: HDC,
    hdcTarget: HDC,
    action: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "GDI32" fn EnumICMProfilesA(
    hdc: HDC,
    proc: ICMENUMPROCA,
    param2: LPARAM,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "GDI32" fn EnumICMProfilesW(
    hdc: HDC,
    proc: ICMENUMPROCW,
    param2: LPARAM,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "GDI32" fn UpdateICMRegKeyA(
    reserved: u32,
    lpszCMID: ?*i8,
    lpszFileName: ?*i8,
    command: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "GDI32" fn UpdateICMRegKeyW(
    reserved: u32,
    lpszCMID: ?*u16,
    lpszFileName: ?*u16,
    command: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "GDI32" fn ColorCorrectPalette(
    hdc: HDC,
    hPal: HPALETTE,
    deFirst: u32,
    num: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "mscms" fn OpenColorProfileA(
    pProfile: ?*PROFILE,
    dwDesiredAccess: u32,
    dwShareMode: u32,
    dwCreationMode: u32,
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=False (can and should we use this?)
pub extern "mscms" fn OpenColorProfileW(
    pProfile: ?*PROFILE,
    dwDesiredAccess: u32,
    dwShareMode: u32,
    dwCreationMode: u32,
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=False (can and should we use this?)
pub extern "mscms" fn CloseColorProfile(
    hProfile: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "mscms" fn GetColorProfileFromHandle(
    hProfile: ?*opaque{},
    pProfile: ?*u8,
    pcbProfile: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "mscms" fn IsColorProfileValid(
    hProfile: ?*opaque{},
    pbValid: ?*i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "mscms" fn CreateProfileFromLogColorSpaceA(
    pLogColorSpace: ?*LOGCOLORSPACEA,
    pProfile: ?*?*u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "mscms" fn CreateProfileFromLogColorSpaceW(
    pLogColorSpace: ?*LOGCOLORSPACEW,
    pProfile: ?*?*u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "mscms" fn GetCountColorProfileElements(
    hProfile: ?*opaque{},
    pnElementCount: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "mscms" fn GetColorProfileHeader(
    hProfile: ?*opaque{},
    pHeader: ?*PROFILEHEADER,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "mscms" fn GetColorProfileElementTag(
    hProfile: ?*opaque{},
    dwIndex: u32,
    pTag: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "mscms" fn IsColorProfileTagPresent(
    hProfile: ?*opaque{},
    tag: u32,
    pbPresent: ?*i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "mscms" fn GetColorProfileElement(
    hProfile: ?*opaque{},
    tag: u32,
    dwOffset: u32,
    pcbElement: ?*u32,
    pElement: ?*opaque{},
    pbReference: ?*i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "mscms" fn SetColorProfileHeader(
    hProfile: ?*opaque{},
    pHeader: ?*PROFILEHEADER,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "mscms" fn SetColorProfileElementSize(
    hProfile: ?*opaque{},
    tagType: u32,
    pcbElement: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "mscms" fn SetColorProfileElement(
    hProfile: ?*opaque{},
    tag: u32,
    dwOffset: u32,
    pcbElement: ?*u32,
    pElement: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "mscms" fn SetColorProfileElementReference(
    hProfile: ?*opaque{},
    newTag: u32,
    refTag: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "mscms" fn GetPS2ColorSpaceArray(
    hProfile: ?*opaque{},
    dwIntent: u32,
    dwCSAType: u32,
    pPS2ColorSpaceArray: ?*u8,
    pcbPS2ColorSpaceArray: ?*u32,
    pbBinary: ?*i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "mscms" fn GetPS2ColorRenderingIntent(
    hProfile: ?*opaque{},
    dwIntent: u32,
    pBuffer: ?*u8,
    pcbPS2ColorRenderingIntent: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "mscms" fn GetPS2ColorRenderingDictionary(
    hProfile: ?*opaque{},
    dwIntent: u32,
    pPS2ColorRenderingDictionary: ?*u8,
    pcbPS2ColorRenderingDictionary: ?*u32,
    pbBinary: ?*i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "mscms" fn GetNamedProfileInfo(
    hProfile: ?*opaque{},
    pNamedProfileInfo: ?*NAMED_PROFILE_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "mscms" fn ConvertColorNameToIndex(
    hProfile: ?*opaque{},
    paColorName: ?*?*i8,
    paIndex: ?*u32,
    dwCount: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "mscms" fn ConvertIndexToColorName(
    hProfile: ?*opaque{},
    paIndex: ?*u32,
    paColorName: ?*?*i8,
    dwCount: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "mscms" fn CreateDeviceLinkProfile(
    hProfile: ?*?*opaque{},
    nProfiles: u32,
    padwIntent: ?*u32,
    nIntents: u32,
    dwFlags: u32,
    pProfileData: ?*?*u8,
    indexPreferredCMM: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "mscms" fn CreateColorTransformA(
    pLogColorSpace: ?*LOGCOLORSPACEA,
    hDestProfile: ?*opaque{},
    hTargetProfile: ?*opaque{},
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=False (can and should we use this?)
pub extern "mscms" fn CreateColorTransformW(
    pLogColorSpace: ?*LOGCOLORSPACEW,
    hDestProfile: ?*opaque{},
    hTargetProfile: ?*opaque{},
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=False (can and should we use this?)
pub extern "mscms" fn CreateMultiProfileTransform(
    pahProfiles: ?*?*opaque{},
    nProfiles: u32,
    padwIntent: ?*u32,
    nIntents: u32,
    dwFlags: u32,
    indexPreferredCMM: u32,
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=False (can and should we use this?)
pub extern "mscms" fn DeleteColorTransform(
    hxform: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "mscms" fn TranslateBitmapBits(
    hColorTransform: ?*opaque{},
    pSrcBits: ?*opaque{},
    bmInput: BMFORMAT,
    dwWidth: u32,
    dwHeight: u32,
    dwInputStride: u32,
    pDestBits: ?*opaque{},
    bmOutput: BMFORMAT,
    dwOutputStride: u32,
    pfnCallBack: PBMCALLBACKFN,
    ulCallbackData: LPARAM,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "mscms" fn CheckBitmapBits(
    hColorTransform: ?*opaque{},
    pSrcBits: ?*opaque{},
    bmInput: BMFORMAT,
    dwWidth: u32,
    dwHeight: u32,
    dwStride: u32,
    paResult: ?*u8,
    pfnCallback: PBMCALLBACKFN,
    lpCallbackData: LPARAM,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "mscms" fn TranslateColors(
    hColorTransform: ?*opaque{},
    paInputColors: ?*COLOR,
    nColors: u32,
    ctInput: COLORTYPE,
    paOutputColors: ?*COLOR,
    ctOutput: COLORTYPE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "mscms" fn CheckColors(
    hColorTransform: ?*opaque{},
    paInputColors: ?*COLOR,
    nColors: u32,
    ctInput: COLORTYPE,
    paResult: ?*u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "mscms" fn GetCMMInfo(
    hColorTransform: ?*opaque{},
    param1: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "mscms" fn RegisterCMMA(
    pMachineName: ?*i8,
    cmmID: u32,
    pCMMdll: ?*i8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "mscms" fn RegisterCMMW(
    pMachineName: ?*u16,
    cmmID: u32,
    pCMMdll: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "mscms" fn UnregisterCMMA(
    pMachineName: ?*i8,
    cmmID: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "mscms" fn UnregisterCMMW(
    pMachineName: ?*u16,
    cmmID: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "mscms" fn SelectCMM(
    dwCMMType: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "mscms" fn GetColorDirectoryA(
    pMachineName: ?*i8,
    pBuffer: ?*i8,
    pdwSize: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "mscms" fn GetColorDirectoryW(
    pMachineName: ?*u16,
    pBuffer: ?*u16,
    pdwSize: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "mscms" fn InstallColorProfileA(
    pMachineName: ?*i8,
    pProfileName: ?*i8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "mscms" fn InstallColorProfileW(
    pMachineName: ?*u16,
    pProfileName: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "mscms" fn UninstallColorProfileA(
    pMachineName: ?*i8,
    pProfileName: ?*i8,
    bDelete: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "mscms" fn UninstallColorProfileW(
    pMachineName: ?*u16,
    pProfileName: ?*u16,
    bDelete: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "mscms" fn EnumColorProfilesA(
    pMachineName: ?*i8,
    pEnumRecord: ?*ENUMTYPEA,
    pEnumerationBuffer: ?*u8,
    pdwSizeOfEnumerationBuffer: ?*u32,
    pnProfiles: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "mscms" fn EnumColorProfilesW(
    pMachineName: ?*u16,
    pEnumRecord: ?*ENUMTYPEW,
    pEnumerationBuffer: ?*u8,
    pdwSizeOfEnumerationBuffer: ?*u32,
    pnProfiles: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "mscms" fn SetStandardColorSpaceProfileA(
    pMachineName: ?*i8,
    dwProfileID: u32,
    pProfilename: ?*i8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "mscms" fn SetStandardColorSpaceProfileW(
    pMachineName: ?*u16,
    dwProfileID: u32,
    pProfileName: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "mscms" fn GetStandardColorSpaceProfileA(
    pMachineName: ?*i8,
    dwSCS: u32,
    pBuffer: ?*i8,
    pcbSize: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "mscms" fn GetStandardColorSpaceProfileW(
    pMachineName: ?*u16,
    dwSCS: u32,
    pBuffer: ?*u16,
    pcbSize: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "mscms" fn AssociateColorProfileWithDeviceA(
    pMachineName: ?*i8,
    pProfileName: ?*i8,
    pDeviceName: ?*i8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "mscms" fn AssociateColorProfileWithDeviceW(
    pMachineName: ?*u16,
    pProfileName: ?*u16,
    pDeviceName: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "mscms" fn DisassociateColorProfileFromDeviceA(
    pMachineName: ?*i8,
    pProfileName: ?*i8,
    pDeviceName: ?*i8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "mscms" fn DisassociateColorProfileFromDeviceW(
    pMachineName: ?*u16,
    pProfileName: ?*u16,
    pDeviceName: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "ICMUI" fn SetupColorMatchingW(
    pcms: ?*COLORMATCHSETUPW,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "ICMUI" fn SetupColorMatchingA(
    pcms: ?*COLORMATCHSETUPA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "mscms" fn WcsAssociateColorProfileWithDevice(
    scope: WCS_PROFILE_MANAGEMENT_SCOPE,
    pProfileName: ?*u16,
    pDeviceName: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "mscms" fn WcsDisassociateColorProfileFromDevice(
    scope: WCS_PROFILE_MANAGEMENT_SCOPE,
    pProfileName: ?*u16,
    pDeviceName: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "mscms" fn WcsEnumColorProfilesSize(
    scope: WCS_PROFILE_MANAGEMENT_SCOPE,
    pEnumRecord: ?*ENUMTYPEW,
    pdwSize: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "mscms" fn WcsEnumColorProfiles(
    scope: WCS_PROFILE_MANAGEMENT_SCOPE,
    pEnumRecord: ?*ENUMTYPEW,
    pBuffer: ?*u8,
    dwSize: u32,
    pnProfiles: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "mscms" fn WcsGetDefaultColorProfileSize(
    scope: WCS_PROFILE_MANAGEMENT_SCOPE,
    pDeviceName: ?*u16,
    cptColorProfileType: COLORPROFILETYPE,
    cpstColorProfileSubType: COLORPROFILESUBTYPE,
    dwProfileID: u32,
    pcbProfileName: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "mscms" fn WcsGetDefaultColorProfile(
    scope: WCS_PROFILE_MANAGEMENT_SCOPE,
    pDeviceName: ?*u16,
    cptColorProfileType: COLORPROFILETYPE,
    cpstColorProfileSubType: COLORPROFILESUBTYPE,
    dwProfileID: u32,
    cbProfileName: u32,
    pProfileName: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "mscms" fn WcsSetDefaultColorProfile(
    scope: WCS_PROFILE_MANAGEMENT_SCOPE,
    pDeviceName: ?*u16,
    cptColorProfileType: COLORPROFILETYPE,
    cpstColorProfileSubType: COLORPROFILESUBTYPE,
    dwProfileID: u32,
    pProfileName: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "mscms" fn WcsSetDefaultRenderingIntent(
    scope: WCS_PROFILE_MANAGEMENT_SCOPE,
    dwRenderingIntent: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "mscms" fn WcsGetDefaultRenderingIntent(
    scope: WCS_PROFILE_MANAGEMENT_SCOPE,
    pdwRenderingIntent: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "mscms" fn WcsGetUsePerUserProfiles(
    pDeviceName: ?*u16,
    dwDeviceClass: u32,
    pUsePerUserProfiles: ?*i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "mscms" fn WcsSetUsePerUserProfiles(
    pDeviceName: ?*u16,
    dwDeviceClass: u32,
    usePerUserProfiles: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "mscms" fn WcsTranslateColors(
    hColorTransform: ?*opaque{},
    nColors: u32,
    nInputChannels: u32,
    cdtInput: COLORDATATYPE,
    cbInput: u32,
    pInputData: ?*opaque{},
    nOutputChannels: u32,
    cdtOutput: COLORDATATYPE,
    cbOutput: u32,
    pOutputData: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "mscms" fn WcsCheckColors(
    hColorTransform: ?*opaque{},
    nColors: u32,
    nInputChannels: u32,
    cdtInput: COLORDATATYPE,
    cbInput: u32,
    pInputData: ?*opaque{},
    paResult: ?*u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "ICM32" fn CMCheckColors(
    hcmTransform: ?*opaque{},
    lpaInputColors: ?*COLOR,
    nColors: u32,
    ctInput: COLORTYPE,
    lpaResult: ?*u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "ICM32" fn CMCheckRGBs(
    hcmTransform: ?*opaque{},
    lpSrcBits: ?*opaque{},
    bmInput: BMFORMAT,
    dwWidth: u32,
    dwHeight: u32,
    dwStride: u32,
    lpaResult: ?*u8,
    pfnCallback: PBMCALLBACKFN,
    ulCallbackData: LPARAM,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "ICM32" fn CMConvertColorNameToIndex(
    hProfile: ?*opaque{},
    paColorName: ?*?*i8,
    paIndex: ?*u32,
    dwCount: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "ICM32" fn CMConvertIndexToColorName(
    hProfile: ?*opaque{},
    paIndex: ?*u32,
    paColorName: ?*?*i8,
    dwCount: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "ICM32" fn CMCreateDeviceLinkProfile(
    pahProfiles: ?*?*opaque{},
    nProfiles: u32,
    padwIntents: ?*u32,
    nIntents: u32,
    dwFlags: u32,
    lpProfileData: ?*?*u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "ICM32" fn CMCreateMultiProfileTransform(
    pahProfiles: ?*?*opaque{},
    nProfiles: u32,
    padwIntents: ?*u32,
    nIntents: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=False (can and should we use this?)
pub extern "ICM32" fn CMCreateProfileW(
    lpColorSpace: ?*LOGCOLORSPACEW,
    lpProfileData: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "ICM32" fn CMCreateTransform(
    lpColorSpace: ?*LOGCOLORSPACEA,
    lpDevCharacter: ?*opaque{},
    lpTargetDevCharacter: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=False (can and should we use this?)
pub extern "ICM32" fn CMCreateTransformW(
    lpColorSpace: ?*LOGCOLORSPACEW,
    lpDevCharacter: ?*opaque{},
    lpTargetDevCharacter: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=False (can and should we use this?)
pub extern "ICM32" fn CMCreateTransformExt(
    lpColorSpace: ?*LOGCOLORSPACEA,
    lpDevCharacter: ?*opaque{},
    lpTargetDevCharacter: ?*opaque{},
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=False (can and should we use this?)
pub extern "ICM32" fn CMCheckColorsInGamut(
    hcmTransform: ?*opaque{},
    lpaRGBTriple: ?*RGBTRIPLE,
    lpaResult: ?*u8,
    nCount: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "ICM32" fn CMCreateProfile(
    lpColorSpace: ?*LOGCOLORSPACEA,
    lpProfileData: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "ICM32" fn CMTranslateRGB(
    hcmTransform: ?*opaque{},
    ColorRef: u32,
    lpColorRef: ?*u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "ICM32" fn CMTranslateRGBs(
    hcmTransform: ?*opaque{},
    lpSrcBits: ?*opaque{},
    bmInput: BMFORMAT,
    dwWidth: u32,
    dwHeight: u32,
    dwStride: u32,
    lpDestBits: ?*opaque{},
    bmOutput: BMFORMAT,
    dwTranslateDirection: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "ICM32" fn CMCreateTransformExtW(
    lpColorSpace: ?*LOGCOLORSPACEW,
    lpDevCharacter: ?*opaque{},
    lpTargetDevCharacter: ?*opaque{},
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=False (can and should we use this?)
pub extern "ICM32" fn CMDeleteTransform(
    hcmTransform: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "ICM32" fn CMGetInfo(
    dwInfo: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "ICM32" fn CMGetNamedProfileInfo(
    hProfile: ?*opaque{},
    pNamedProfileInfo: ?*NAMED_PROFILE_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "ICM32" fn CMIsProfileValid(
    hProfile: ?*opaque{},
    lpbValid: ?*i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "ICM32" fn CMTranslateColors(
    hcmTransform: ?*opaque{},
    lpaInputColors: ?*COLOR,
    nColors: u32,
    ctInput: COLORTYPE,
    lpaOutputColors: ?*COLOR,
    ctOutput: COLORTYPE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "ICM32" fn CMTranslateRGBsExt(
    hcmTransform: ?*opaque{},
    lpSrcBits: ?*opaque{},
    bmInput: BMFORMAT,
    dwWidth: u32,
    dwHeight: u32,
    dwInputStride: u32,
    lpDestBits: ?*opaque{},
    bmOutput: BMFORMAT,
    dwOutputStride: u32,
    lpfnCallback: LPBMCALLBACKFN,
    ulCallbackData: LPARAM,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "mscms" fn WcsOpenColorProfileA(
    pCDMPProfile: ?*PROFILE,
    pCAMPProfile: ?*PROFILE,
    pGMMPProfile: ?*PROFILE,
    dwDesireAccess: u32,
    dwShareMode: u32,
    dwCreationMode: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=False (can and should we use this?)
pub extern "mscms" fn WcsOpenColorProfileW(
    pCDMPProfile: ?*PROFILE,
    pCAMPProfile: ?*PROFILE,
    pGMMPProfile: ?*PROFILE,
    dwDesireAccess: u32,
    dwShareMode: u32,
    dwCreationMode: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=False (can and should we use this?)
pub extern "mscms" fn WcsCreateIccProfile(
    hWcsProfile: ?*opaque{},
    dwOptions: u32,
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=False (can and should we use this?)
pub extern "mscms" fn WcsGetCalibrationManagementState(
    pbIsEnabled: ?*i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "mscms" fn WcsSetCalibrationManagementState(
    bIsEnabled: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "mscms" fn ColorAdapterGetSystemModifyWhitePointCaps(
    whitePointAdjCapable: ?*i32,
    isColorOverrideActive: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "mscms" fn ColorAdapterUpdateDisplayGamma(
    displayID: DisplayID,
    displayTransform: ?*DisplayTransformLut,
    internal: BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "mscms" fn ColorAdapterUpdateDeviceProfile(
    displayID: DisplayID,
    profName: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "mscms" fn ColorAdapterGetDisplayCurrentStateID(
    displayID: DisplayID,
    displayStateID: ?*DisplayStateID,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "mscms" fn ColorAdapterGetDisplayTransformData(
    displayID: DisplayID,
    displayTransformLut: ?*DisplayTransformLut,
    transformID: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "mscms" fn ColorAdapterGetDisplayTargetWhitePoint(
    displayID: DisplayID,
    wtpt: ?*WhitePoint,
    transitionTime: ?*u32,
    whitepointID: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "mscms" fn ColorAdapterGetDisplayProfile(
    displayID: DisplayID,
    displayProfile: ?*u16,
    profileID: ?*u32,
    bUseAccurate: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "mscms" fn ColorAdapterGetCurrentProfileCalibration(
    displayID: DisplayID,
    maxCalibrationBlobSize: u32,
    blobSize: ?*u32,
    calibrationBlob: ?*u8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "mscms" fn ColorAdapterRegisterOEMColorService(
    registration: ?*HANDLE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "mscms" fn ColorAdapterUnregisterOEMColorService(
    registration: HANDLE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "mscms" fn ColorProfileAddDisplayAssociation(
    scope: WCS_PROFILE_MANAGEMENT_SCOPE,
    profileName: ?*u16,
    targetAdapterID: LUID,
    sourceID: u32,
    setAsDefault: BOOL,
    associateAsAdvancedColor: BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "mscms" fn ColorProfileRemoveDisplayAssociation(
    scope: WCS_PROFILE_MANAGEMENT_SCOPE,
    profileName: ?*u16,
    targetAdapterID: LUID,
    sourceID: u32,
    dissociateAdvancedColor: BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "mscms" fn ColorProfileSetDisplayDefaultAssociation(
    scope: WCS_PROFILE_MANAGEMENT_SCOPE,
    profileName: ?*u16,
    profileType: COLORPROFILETYPE,
    profileSubType: COLORPROFILESUBTYPE,
    targetAdapterID: LUID,
    sourceID: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "mscms" fn ColorProfileGetDisplayList(
    scope: WCS_PROFILE_MANAGEMENT_SCOPE,
    targetAdapterID: LUID,
    sourceID: u32,
    profileList: ?*?*?*u16,
    profileCount: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "mscms" fn ColorProfileGetDisplayDefault(
    scope: WCS_PROFILE_MANAGEMENT_SCOPE,
    targetAdapterID: LUID,
    sourceID: u32,
    profileType: COLORPROFILETYPE,
    profileSubType: COLORPROFILESUBTYPE,
    profileName: ?*?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "mscms" fn ColorProfileGetDisplayUserScope(
    targetAdapterID: LUID,
    sourceID: u32,
    scope: ?*WCS_PROFILE_MANAGEMENT_SCOPE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

//
// Unicode Symbol Aliases
//
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {
        pub const LOGCOLORSPACE = LOGCOLORSPACEA;
        pub const ICMENUMPROC = ICMENUMPROCA;
        pub const ENUMTYPE = ENUMTYPEA;
        pub const PCMSCALLBACK = PCMSCALLBACKA;
        pub const COLORMATCHSETUP = COLORMATCHSETUPA;
        pub const GetLogColorSpace = GetLogColorSpaceA;
        pub const CreateColorSpace = CreateColorSpaceA;
        pub const GetICMProfile = GetICMProfileA;
        pub const SetICMProfile = SetICMProfileA;
        pub const EnumICMProfiles = EnumICMProfilesA;
        pub const UpdateICMRegKey = UpdateICMRegKeyA;
        pub const OpenColorProfile = OpenColorProfileA;
        pub const CreateProfileFromLogColorSpace = CreateProfileFromLogColorSpaceA;
        pub const CreateColorTransform = CreateColorTransformA;
        pub const RegisterCMM = RegisterCMMA;
        pub const UnregisterCMM = UnregisterCMMA;
        pub const GetColorDirectory = GetColorDirectoryA;
        pub const InstallColorProfile = InstallColorProfileA;
        pub const UninstallColorProfile = UninstallColorProfileA;
        pub const EnumColorProfiles = EnumColorProfilesA;
        pub const SetStandardColorSpaceProfile = SetStandardColorSpaceProfileA;
        pub const GetStandardColorSpaceProfile = GetStandardColorSpaceProfileA;
        pub const AssociateColorProfileWithDevice = AssociateColorProfileWithDeviceA;
        pub const DisassociateColorProfileFromDevice = DisassociateColorProfileFromDeviceA;
        pub const SetupColorMatching = SetupColorMatchingA;
        pub const WcsOpenColorProfile = WcsOpenColorProfileA;
    },
    .wide => struct {
        pub const LOGCOLORSPACE = LOGCOLORSPACEW;
        pub const ICMENUMPROC = ICMENUMPROCW;
        pub const ENUMTYPE = ENUMTYPEW;
        pub const PCMSCALLBACK = PCMSCALLBACKW;
        pub const COLORMATCHSETUP = COLORMATCHSETUPW;
        pub const GetLogColorSpace = GetLogColorSpaceW;
        pub const CreateColorSpace = CreateColorSpaceW;
        pub const GetICMProfile = GetICMProfileW;
        pub const SetICMProfile = SetICMProfileW;
        pub const EnumICMProfiles = EnumICMProfilesW;
        pub const UpdateICMRegKey = UpdateICMRegKeyW;
        pub const OpenColorProfile = OpenColorProfileW;
        pub const CreateProfileFromLogColorSpace = CreateProfileFromLogColorSpaceW;
        pub const CreateColorTransform = CreateColorTransformW;
        pub const RegisterCMM = RegisterCMMW;
        pub const UnregisterCMM = UnregisterCMMW;
        pub const GetColorDirectory = GetColorDirectoryW;
        pub const InstallColorProfile = InstallColorProfileW;
        pub const UninstallColorProfile = UninstallColorProfileW;
        pub const EnumColorProfiles = EnumColorProfilesW;
        pub const SetStandardColorSpaceProfile = SetStandardColorSpaceProfileW;
        pub const GetStandardColorSpaceProfile = GetStandardColorSpaceProfileW;
        pub const AssociateColorProfileWithDevice = AssociateColorProfileWithDeviceW;
        pub const DisassociateColorProfileFromDevice = DisassociateColorProfileFromDeviceW;
        pub const SetupColorMatching = SetupColorMatchingW;
        pub const WcsOpenColorProfile = WcsOpenColorProfileW;
    },
    else => if (@import("builtin").is_test) struct {
        pub const LOGCOLORSPACE = *opaque{};
        pub const ICMENUMPROC = *opaque{};
        pub const ENUMTYPE = *opaque{};
        pub const PCMSCALLBACK = *opaque{};
        pub const COLORMATCHSETUP = *opaque{};
        pub const GetLogColorSpace = *opaque{};
        pub const CreateColorSpace = *opaque{};
        pub const GetICMProfile = *opaque{};
        pub const SetICMProfile = *opaque{};
        pub const EnumICMProfiles = *opaque{};
        pub const UpdateICMRegKey = *opaque{};
        pub const OpenColorProfile = *opaque{};
        pub const CreateProfileFromLogColorSpace = *opaque{};
        pub const CreateColorTransform = *opaque{};
        pub const RegisterCMM = *opaque{};
        pub const UnregisterCMM = *opaque{};
        pub const GetColorDirectory = *opaque{};
        pub const InstallColorProfile = *opaque{};
        pub const UninstallColorProfile = *opaque{};
        pub const EnumColorProfiles = *opaque{};
        pub const SetStandardColorSpaceProfile = *opaque{};
        pub const GetStandardColorSpaceProfile = *opaque{};
        pub const AssociateColorProfileWithDevice = *opaque{};
        pub const DisassociateColorProfileFromDevice = *opaque{};
        pub const SetupColorMatching = *opaque{};
        pub const WcsOpenColorProfile = *opaque{};
    } else struct {
        pub const LOGCOLORSPACE = @compileError("'LOGCOLORSPACE' requires that UNICODE be set to true or false in the root module");
        pub const ICMENUMPROC = @compileError("'ICMENUMPROC' requires that UNICODE be set to true or false in the root module");
        pub const ENUMTYPE = @compileError("'ENUMTYPE' requires that UNICODE be set to true or false in the root module");
        pub const PCMSCALLBACK = @compileError("'PCMSCALLBACK' requires that UNICODE be set to true or false in the root module");
        pub const COLORMATCHSETUP = @compileError("'COLORMATCHSETUP' requires that UNICODE be set to true or false in the root module");
        pub const GetLogColorSpace = @compileError("'GetLogColorSpace' requires that UNICODE be set to true or false in the root module");
        pub const CreateColorSpace = @compileError("'CreateColorSpace' requires that UNICODE be set to true or false in the root module");
        pub const GetICMProfile = @compileError("'GetICMProfile' requires that UNICODE be set to true or false in the root module");
        pub const SetICMProfile = @compileError("'SetICMProfile' requires that UNICODE be set to true or false in the root module");
        pub const EnumICMProfiles = @compileError("'EnumICMProfiles' requires that UNICODE be set to true or false in the root module");
        pub const UpdateICMRegKey = @compileError("'UpdateICMRegKey' requires that UNICODE be set to true or false in the root module");
        pub const OpenColorProfile = @compileError("'OpenColorProfile' requires that UNICODE be set to true or false in the root module");
        pub const CreateProfileFromLogColorSpace = @compileError("'CreateProfileFromLogColorSpace' requires that UNICODE be set to true or false in the root module");
        pub const CreateColorTransform = @compileError("'CreateColorTransform' requires that UNICODE be set to true or false in the root module");
        pub const RegisterCMM = @compileError("'RegisterCMM' requires that UNICODE be set to true or false in the root module");
        pub const UnregisterCMM = @compileError("'UnregisterCMM' requires that UNICODE be set to true or false in the root module");
        pub const GetColorDirectory = @compileError("'GetColorDirectory' requires that UNICODE be set to true or false in the root module");
        pub const InstallColorProfile = @compileError("'InstallColorProfile' requires that UNICODE be set to true or false in the root module");
        pub const UninstallColorProfile = @compileError("'UninstallColorProfile' requires that UNICODE be set to true or false in the root module");
        pub const EnumColorProfiles = @compileError("'EnumColorProfiles' requires that UNICODE be set to true or false in the root module");
        pub const SetStandardColorSpaceProfile = @compileError("'SetStandardColorSpaceProfile' requires that UNICODE be set to true or false in the root module");
        pub const GetStandardColorSpaceProfile = @compileError("'GetStandardColorSpaceProfile' requires that UNICODE be set to true or false in the root module");
        pub const AssociateColorProfileWithDevice = @compileError("'AssociateColorProfileWithDevice' requires that UNICODE be set to true or false in the root module");
        pub const DisassociateColorProfileFromDevice = @compileError("'DisassociateColorProfileFromDevice' requires that UNICODE be set to true or false in the root module");
        pub const SetupColorMatching = @compileError("'SetupColorMatching' requires that UNICODE be set to true or false in the root module");
        pub const WcsOpenColorProfile = @compileError("'WcsOpenColorProfile' requires that UNICODE be set to true or false in the root module");
    },
};

//
// type imports
//
const BOOL = @import("systemservices.zig").BOOL;
const HWND = @import("windowsandmessaging.zig").HWND;
const DLGPROC = @import("windowsandmessaging.zig").DLGPROC;
const LPARAM = @import("windowsandmessaging.zig").LPARAM;
const LUID = @import("kernel.zig").LUID;
const HDC = @import("gdi.zig").HDC;
const RGBTRIPLE = @import("gdi.zig").RGBTRIPLE;
const HCOLORSPACE = @import("gdi.zig").HCOLORSPACE;
const HPALETTE = @import("gdi.zig").HPALETTE;
const HRESULT = @import("com.zig").HRESULT;
const HANDLE = @import("systemservices.zig").HANDLE;

test "" {
    const constant_export_count = 0;
    const type_export_count = 49;
    const func_count = 131;
    const unicode_alias_count = 26;
    const type_import_count = 11;
    @setEvalBranchQuota(0
        + constant_export_count
        + type_export_count
        + func_count
        + unicode_alias_count
        + type_import_count
        + 2 // TODO: why do I need these extra 2?
    );
    @import("std").testing.refAllDecls(@This());
}
