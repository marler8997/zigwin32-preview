//! NOTE: this source file is autogenerated, DO NOT MODIFY

//
// constants
//

//
// types
//
// --------------------------------------------------------
// Type: PNRP_SCOPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PNRP_SCOPE = *opaque{
};
// --------------------------------------------------------
// Type: PNRP_CLOUD_STATE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PNRP_CLOUD_STATE = *opaque{
};
// --------------------------------------------------------
// Type: PNRP_CLOUD_FLAGS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PNRP_CLOUD_FLAGS = *opaque{
};
// --------------------------------------------------------
// Type: PNRP_REGISTERED_ID_STATE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PNRP_REGISTERED_ID_STATE = *opaque{
};
// --------------------------------------------------------
// Type: PNRP_RESOLVE_CRITERIA
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PNRP_RESOLVE_CRITERIA = *opaque{
};
// --------------------------------------------------------
// Type: PNRP_CLOUD_ID
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PNRP_CLOUD_ID = extern struct {
    AddressFamily: i32,
    Scope: PNRP_SCOPE,
    ScopeId: u32,
};
// --------------------------------------------------------
// Type: PNRP_EXTENDED_PAYLOAD_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PNRP_EXTENDED_PAYLOAD_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: PNRPINFO_V1
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PNRPINFO_V1 = extern struct {
    dwSize: u32,
    lpwszIdentity: ?*u16,
    nMaxResolve: u32,
    dwTimeout: u32,
    dwLifetime: u32,
    enResolveCriteria: PNRP_RESOLVE_CRITERIA,
    dwFlags: u32,
    saHint: SOCKET_ADDRESS,
    enNameState: PNRP_REGISTERED_ID_STATE,
};
// --------------------------------------------------------
// Type: PNRPINFO_V2
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PNRPINFO_V2 = extern struct {
    dwSize: u32,
    lpwszIdentity: ?*u16,
    nMaxResolve: u32,
    dwTimeout: u32,
    dwLifetime: u32,
    enResolveCriteria: PNRP_RESOLVE_CRITERIA,
    dwFlags: u32,
    saHint: SOCKET_ADDRESS,
    enNameState: PNRP_REGISTERED_ID_STATE,
    enExtendedPayloadType: PNRP_EXTENDED_PAYLOAD_TYPE,
    Anonymous: _Anonymous_e__Union,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: PNRPCLOUDINFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PNRPCLOUDINFO = extern struct {
    dwSize: u32,
    Cloud: PNRP_CLOUD_ID,
    enCloudState: PNRP_CLOUD_STATE,
    enCloudFlags: PNRP_CLOUD_FLAGS,
};
// --------------------------------------------------------
// Type: PEER_RECORD_CHANGE_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PEER_RECORD_CHANGE_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: PEER_CONNECTION_STATUS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PEER_CONNECTION_STATUS = *opaque{
};
// --------------------------------------------------------
// Type: PEER_CONNECTION_FLAGS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PEER_CONNECTION_FLAGS = *opaque{
};
// --------------------------------------------------------
// Type: PEER_RECORD_FLAGS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PEER_RECORD_FLAGS = *opaque{
};
// --------------------------------------------------------
// Type: PEER_VERSION_DATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PEER_VERSION_DATA = extern struct {
    wVersion: u16,
    wHighestVersion: u16,
};
// --------------------------------------------------------
// Type: PEER_DATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PEER_DATA = extern struct {
    cbData: u32,
    pbData: ?*u8,
};
// --------------------------------------------------------
// Type: PEER_RECORD
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PEER_RECORD = extern struct {
    dwSize: u32,
    type: Guid,
    id: Guid,
    dwVersion: u32,
    dwFlags: u32,
    pwzCreatorId: ?*u16,
    pwzModifiedById: ?*u16,
    pwzAttributes: ?*u16,
    ftCreation: FILETIME,
    ftExpiration: FILETIME,
    ftLastModified: FILETIME,
    securityData: PEER_DATA,
    data: PEER_DATA,
};
// --------------------------------------------------------
// Type: PEER_ADDRESS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PEER_ADDRESS = extern struct {
    dwSize: u32,
    sin6: SOCKADDR_IN6_LH,
};
// --------------------------------------------------------
// Type: PEER_CONNECTION_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PEER_CONNECTION_INFO = extern struct {
    dwSize: u32,
    dwFlags: u32,
    ullConnectionId: u64,
    ullNodeId: u64,
    pwzPeerId: ?*u16,
    address: PEER_ADDRESS,
};
// --------------------------------------------------------
// Type: PEER_EVENT_INCOMING_DATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PEER_EVENT_INCOMING_DATA = extern struct {
    dwSize: u32,
    ullConnectionId: u64,
    type: Guid,
    data: PEER_DATA,
};
// --------------------------------------------------------
// Type: PEER_EVENT_RECORD_CHANGE_DATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PEER_EVENT_RECORD_CHANGE_DATA = extern struct {
    dwSize: u32,
    changeType: PEER_RECORD_CHANGE_TYPE,
    recordId: Guid,
    recordType: Guid,
};
// --------------------------------------------------------
// Type: PEER_EVENT_CONNECTION_CHANGE_DATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PEER_EVENT_CONNECTION_CHANGE_DATA = extern struct {
    dwSize: u32,
    status: PEER_CONNECTION_STATUS,
    ullConnectionId: u64,
    ullNodeId: u64,
    ullNextConnectionId: u64,
    hrConnectionFailedReason: HRESULT,
};
// --------------------------------------------------------
// Type: PEER_EVENT_SYNCHRONIZED_DATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PEER_EVENT_SYNCHRONIZED_DATA = extern struct {
    dwSize: u32,
    recordType: Guid,
};
// --------------------------------------------------------
// Type: PEER_GRAPH_EVENT_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PEER_GRAPH_EVENT_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: PEER_NODE_CHANGE_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PEER_NODE_CHANGE_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: PEER_GRAPH_STATUS_FLAGS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PEER_GRAPH_STATUS_FLAGS = *opaque{
};
// --------------------------------------------------------
// Type: PEER_GRAPH_PROPERTY_FLAGS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PEER_GRAPH_PROPERTY_FLAGS = *opaque{
};
// --------------------------------------------------------
// Type: PEER_GRAPH_SCOPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PEER_GRAPH_SCOPE = *opaque{
};
// --------------------------------------------------------
// Type: PEER_GRAPH_PROPERTIES
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PEER_GRAPH_PROPERTIES = extern struct {
    dwSize: u32,
    dwFlags: u32,
    dwScope: u32,
    dwMaxRecordSize: u32,
    pwzGraphId: ?*u16,
    pwzCreatorId: ?*u16,
    pwzFriendlyName: ?*u16,
    pwzComment: ?*u16,
    ulPresenceLifetime: u32,
    cPresenceMax: u32,
};
// --------------------------------------------------------
// Type: PEER_NODE_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PEER_NODE_INFO = extern struct {
    dwSize: u32,
    ullNodeId: u64,
    pwzPeerId: ?*u16,
    cAddresses: u32,
    pAddresses: ?*PEER_ADDRESS,
    pwzAttributes: ?*u16,
};
// --------------------------------------------------------
// Type: PEER_EVENT_NODE_CHANGE_DATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PEER_EVENT_NODE_CHANGE_DATA = extern struct {
    dwSize: u32,
    changeType: PEER_NODE_CHANGE_TYPE,
    ullNodeId: u64,
    pwzPeerId: ?*u16,
};
// --------------------------------------------------------
// Type: PEER_GRAPH_EVENT_REGISTRATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PEER_GRAPH_EVENT_REGISTRATION = extern struct {
    eventType: PEER_GRAPH_EVENT_TYPE,
    pType: ?*Guid,
};
// --------------------------------------------------------
// Type: PEER_GRAPH_EVENT_DATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PEER_GRAPH_EVENT_DATA = extern struct {
    eventType: PEER_GRAPH_EVENT_TYPE,
    Anonymous: _Anonymous_e__Union,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: PFNPEER_VALIDATE_RECORD
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFNPEER_VALIDATE_RECORD = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PFNPEER_SECURE_RECORD
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFNPEER_SECURE_RECORD = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PFNPEER_FREE_SECURITY_DATA
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFNPEER_FREE_SECURITY_DATA = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PFNPEER_ON_PASSWORD_AUTH_FAILED
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFNPEER_ON_PASSWORD_AUTH_FAILED = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PEER_SECURITY_INTERFACE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PEER_SECURITY_INTERFACE = extern struct {
    dwSize: u32,
    pwzSspFilename: ?*u16,
    pwzPackageName: ?*u16,
    cbSecurityInfo: u32,
    pbSecurityInfo: ?*u8,
    pvContext: ?*opaque{},
    pfnValidateRecord: PFNPEER_VALIDATE_RECORD,
    pfnSecureRecord: PFNPEER_SECURE_RECORD,
    pfnFreeSecurityData: PFNPEER_FREE_SECURITY_DATA,
    pfnAuthFailed: PFNPEER_ON_PASSWORD_AUTH_FAILED,
};
// --------------------------------------------------------
// Type: PEER_GROUP_EVENT_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PEER_GROUP_EVENT_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: PEER_GROUP_STATUS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PEER_GROUP_STATUS = *opaque{
};
// --------------------------------------------------------
// Type: PEER_GROUP_PROPERTY_FLAGS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PEER_GROUP_PROPERTY_FLAGS = *opaque{
};
// --------------------------------------------------------
// Type: PEER_GROUP_AUTHENTICATION_SCHEME
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PEER_GROUP_AUTHENTICATION_SCHEME = *opaque{
};
// --------------------------------------------------------
// Type: PEER_MEMBER_FLAGS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PEER_MEMBER_FLAGS = *opaque{
};
// --------------------------------------------------------
// Type: PEER_MEMBER_CHANGE_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PEER_MEMBER_CHANGE_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: PEER_GROUP_ISSUE_CREDENTIAL_FLAGS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PEER_GROUP_ISSUE_CREDENTIAL_FLAGS = *opaque{
};
// --------------------------------------------------------
// Type: PEER_CREDENTIAL_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PEER_CREDENTIAL_INFO = extern struct {
    dwSize: u32,
    dwFlags: u32,
    pwzFriendlyName: ?*u16,
    pPublicKey: ?*CERT_PUBLIC_KEY_INFO,
    pwzIssuerPeerName: ?*u16,
    pwzIssuerFriendlyName: ?*u16,
    ftValidityStart: FILETIME,
    ftValidityEnd: FILETIME,
    cRoles: u32,
    pRoles: ?*Guid,
};
// --------------------------------------------------------
// Type: PEER_MEMBER
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PEER_MEMBER = extern struct {
    dwSize: u32,
    dwFlags: u32,
    pwzIdentity: ?*u16,
    pwzAttributes: ?*u16,
    ullNodeId: u64,
    cAddresses: u32,
    pAddresses: ?*PEER_ADDRESS,
    pCredentialInfo: ?*PEER_CREDENTIAL_INFO,
};
// --------------------------------------------------------
// Type: PEER_INVITATION_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PEER_INVITATION_INFO = extern struct {
    dwSize: u32,
    dwFlags: u32,
    pwzCloudName: ?*u16,
    dwScope: u32,
    dwCloudFlags: u32,
    pwzGroupPeerName: ?*u16,
    pwzIssuerPeerName: ?*u16,
    pwzSubjectPeerName: ?*u16,
    pwzGroupFriendlyName: ?*u16,
    pwzIssuerFriendlyName: ?*u16,
    pwzSubjectFriendlyName: ?*u16,
    ftValidityStart: FILETIME,
    ftValidityEnd: FILETIME,
    cRoles: u32,
    pRoles: ?*Guid,
    cClassifiers: u32,
    ppwzClassifiers: ?*?*u16,
    pSubjectPublicKey: ?*CERT_PUBLIC_KEY_INFO,
    authScheme: PEER_GROUP_AUTHENTICATION_SCHEME,
};
// --------------------------------------------------------
// Type: PEER_GROUP_PROPERTIES
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PEER_GROUP_PROPERTIES = extern struct {
    dwSize: u32,
    dwFlags: u32,
    pwzCloud: ?*u16,
    pwzClassifier: ?*u16,
    pwzGroupPeerName: ?*u16,
    pwzCreatorPeerName: ?*u16,
    pwzFriendlyName: ?*u16,
    pwzComment: ?*u16,
    ulMemberDataLifetime: u32,
    ulPresenceLifetime: u32,
    dwAuthenticationSchemes: u32,
    pwzGroupPassword: ?*u16,
    groupPasswordRole: Guid,
};
// --------------------------------------------------------
// Type: PEER_EVENT_MEMBER_CHANGE_DATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PEER_EVENT_MEMBER_CHANGE_DATA = extern struct {
    dwSize: u32,
    changeType: PEER_MEMBER_CHANGE_TYPE,
    pwzIdentity: ?*u16,
};
// --------------------------------------------------------
// Type: PEER_GROUP_EVENT_REGISTRATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PEER_GROUP_EVENT_REGISTRATION = extern struct {
    eventType: PEER_GROUP_EVENT_TYPE,
    pType: ?*Guid,
};
// --------------------------------------------------------
// Type: PEER_GROUP_EVENT_DATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PEER_GROUP_EVENT_DATA = extern struct {
    eventType: PEER_GROUP_EVENT_TYPE,
    Anonymous: _Anonymous_e__Union,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: PEER_NAME_PAIR
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PEER_NAME_PAIR = extern struct {
    dwSize: u32,
    pwzPeerName: ?*u16,
    pwzFriendlyName: ?*u16,
};
// --------------------------------------------------------
// Type: PEER_SIGNIN_FLAGS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PEER_SIGNIN_FLAGS = *opaque{
};
// --------------------------------------------------------
// Type: PEER_WATCH_PERMISSION
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PEER_WATCH_PERMISSION = *opaque{
};
// --------------------------------------------------------
// Type: PEER_PUBLICATION_SCOPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PEER_PUBLICATION_SCOPE = *opaque{
};
// --------------------------------------------------------
// Type: PEER_APPLICATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PEER_APPLICATION = extern struct {
    id: Guid,
    data: PEER_DATA,
    pwzDescription: ?*u16,
};
// --------------------------------------------------------
// Type: PEER_OBJECT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PEER_OBJECT = extern struct {
    id: Guid,
    data: PEER_DATA,
    dwPublicationScope: u32,
};
// --------------------------------------------------------
// Type: PEER_CONTACT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PEER_CONTACT = extern struct {
    pwzPeerName: ?*u16,
    pwzNickName: ?*u16,
    pwzDisplayName: ?*u16,
    pwzEmailAddress: ?*u16,
    fWatch: BOOL,
    WatcherPermissions: PEER_WATCH_PERMISSION,
    credentials: PEER_DATA,
};
// --------------------------------------------------------
// Type: PEER_ENDPOINT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PEER_ENDPOINT = extern struct {
    address: PEER_ADDRESS,
    pwzEndpointName: ?*u16,
};
// --------------------------------------------------------
// Type: PEER_PEOPLE_NEAR_ME
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PEER_PEOPLE_NEAR_ME = extern struct {
    pwzNickName: ?*u16,
    endpoint: PEER_ENDPOINT,
    id: Guid,
};
// --------------------------------------------------------
// Type: PEER_INVITATION_RESPONSE_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PEER_INVITATION_RESPONSE_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: PEER_APPLICATION_REGISTRATION_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PEER_APPLICATION_REGISTRATION_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: PEER_INVITATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PEER_INVITATION = extern struct {
    applicationId: Guid,
    applicationData: PEER_DATA,
    pwzMessage: ?*u16,
};
// --------------------------------------------------------
// Type: PEER_INVITATION_RESPONSE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PEER_INVITATION_RESPONSE = extern struct {
    action: PEER_INVITATION_RESPONSE_TYPE,
    pwzMessage: ?*u16,
    hrExtendedInfo: HRESULT,
};
// --------------------------------------------------------
// Type: PEER_APP_LAUNCH_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PEER_APP_LAUNCH_INFO = extern struct {
    pContact: ?*PEER_CONTACT,
    pEndpoint: ?*PEER_ENDPOINT,
    pInvitation: ?*PEER_INVITATION,
};
// --------------------------------------------------------
// Type: PEER_APPLICATION_REGISTRATION_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PEER_APPLICATION_REGISTRATION_INFO = extern struct {
    application: PEER_APPLICATION,
    pwzApplicationToLaunch: ?*u16,
    pwzApplicationArguments: ?*u16,
    dwPublicationScope: u32,
};
// --------------------------------------------------------
// Type: PEER_PRESENCE_STATUS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PEER_PRESENCE_STATUS = *opaque{
};
// --------------------------------------------------------
// Type: PEER_PRESENCE_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PEER_PRESENCE_INFO = extern struct {
    status: PEER_PRESENCE_STATUS,
    pwzDescriptiveText: ?*u16,
};
// --------------------------------------------------------
// Type: PEER_CHANGE_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PEER_CHANGE_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: PEER_COLLAB_EVENT_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PEER_COLLAB_EVENT_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: PEER_COLLAB_EVENT_REGISTRATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PEER_COLLAB_EVENT_REGISTRATION = extern struct {
    eventType: PEER_COLLAB_EVENT_TYPE,
    pInstance: ?*Guid,
};
// --------------------------------------------------------
// Type: PEER_EVENT_WATCHLIST_CHANGED_DATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PEER_EVENT_WATCHLIST_CHANGED_DATA = extern struct {
    pContact: ?*PEER_CONTACT,
    changeType: PEER_CHANGE_TYPE,
};
// --------------------------------------------------------
// Type: PEER_EVENT_PRESENCE_CHANGED_DATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PEER_EVENT_PRESENCE_CHANGED_DATA = extern struct {
    pContact: ?*PEER_CONTACT,
    pEndpoint: ?*PEER_ENDPOINT,
    changeType: PEER_CHANGE_TYPE,
    pPresenceInfo: ?*PEER_PRESENCE_INFO,
};
// --------------------------------------------------------
// Type: PEER_EVENT_APPLICATION_CHANGED_DATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PEER_EVENT_APPLICATION_CHANGED_DATA = extern struct {
    pContact: ?*PEER_CONTACT,
    pEndpoint: ?*PEER_ENDPOINT,
    changeType: PEER_CHANGE_TYPE,
    pApplication: ?*PEER_APPLICATION,
};
// --------------------------------------------------------
// Type: PEER_EVENT_OBJECT_CHANGED_DATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PEER_EVENT_OBJECT_CHANGED_DATA = extern struct {
    pContact: ?*PEER_CONTACT,
    pEndpoint: ?*PEER_ENDPOINT,
    changeType: PEER_CHANGE_TYPE,
    pObject: ?*PEER_OBJECT,
};
// --------------------------------------------------------
// Type: PEER_EVENT_ENDPOINT_CHANGED_DATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PEER_EVENT_ENDPOINT_CHANGED_DATA = extern struct {
    pContact: ?*PEER_CONTACT,
    pEndpoint: ?*PEER_ENDPOINT,
};
// --------------------------------------------------------
// Type: PEER_EVENT_PEOPLE_NEAR_ME_CHANGED_DATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PEER_EVENT_PEOPLE_NEAR_ME_CHANGED_DATA = extern struct {
    changeType: PEER_CHANGE_TYPE,
    pPeopleNearMe: ?*PEER_PEOPLE_NEAR_ME,
};
// --------------------------------------------------------
// Type: PEER_EVENT_REQUEST_STATUS_CHANGED_DATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PEER_EVENT_REQUEST_STATUS_CHANGED_DATA = extern struct {
    pEndpoint: ?*PEER_ENDPOINT,
    hrChange: HRESULT,
};
// --------------------------------------------------------
// Type: PEER_COLLAB_EVENT_DATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PEER_COLLAB_EVENT_DATA = extern struct {
    eventType: PEER_COLLAB_EVENT_TYPE,
    Anonymous: _Anonymous_e__Union,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: PEER_PNRP_ENDPOINT_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PEER_PNRP_ENDPOINT_INFO = extern struct {
    pwzPeerName: ?*u16,
    cAddresses: u32,
    ppAddresses: ?*?*SOCKADDR,
    pwzComment: ?*u16,
    payload: PEER_DATA,
};
// --------------------------------------------------------
// Type: PEER_PNRP_CLOUD_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PEER_PNRP_CLOUD_INFO = extern struct {
    pwzCloudName: ?*u16,
    dwScope: PNRP_SCOPE,
    dwScopeId: u32,
};
// --------------------------------------------------------
// Type: PEER_PNRP_REGISTRATION_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PEER_PNRP_REGISTRATION_INFO = extern struct {
    pwzCloudName: ?*u16,
    pwzPublishingIdentity: ?*u16,
    cAddresses: u32,
    ppAddresses: ?*?*SOCKADDR,
    wPort: u16,
    pwzComment: ?*u16,
    payload: PEER_DATA,
};
// --------------------------------------------------------
// Type: DRT_SCOPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const DRT_SCOPE = *opaque{
};
// --------------------------------------------------------
// Type: DRT_STATUS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const DRT_STATUS = *opaque{
};
// --------------------------------------------------------
// Type: DRT_MATCH_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const DRT_MATCH_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: DRT_LEAFSET_KEY_CHANGE_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const DRT_LEAFSET_KEY_CHANGE_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: DRT_EVENT_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const DRT_EVENT_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: DRT_SECURITY_MODE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const DRT_SECURITY_MODE = *opaque{
};
// --------------------------------------------------------
// Type: DRT_REGISTRATION_STATE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const DRT_REGISTRATION_STATE = *opaque{
};
// --------------------------------------------------------
// Type: DRT_ADDRESS_FLAGS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const DRT_ADDRESS_FLAGS = *opaque{
};
// --------------------------------------------------------
// Type: DRT_DATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DRT_DATA = extern struct {
    cb: u32,
    pb: ?*u8,
};
// --------------------------------------------------------
// Type: DRT_REGISTRATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DRT_REGISTRATION = extern struct {
    key: DRT_DATA,
    appData: DRT_DATA,
};
// --------------------------------------------------------
// Type: DRT_SECURITY_PROVIDER
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DRT_SECURITY_PROVIDER = extern struct {
    pvContext: ?*opaque{},
    Attach: ?*?*?*?*?*?*?*?*?*HRESULT,
    Detach: ?*opaque{},
    RegisterKey: ?*?*?*?*?*?*?*?*?*HRESULT,
    UnregisterKey: ?*?*?*?*?*?*?*?*?*HRESULT,
    ValidateAndUnpackPayload: ?*?*?*?*?*?*?*?*?*HRESULT,
    SecureAndPackPayload: ?*?*?*?*?*?*?*?*?*HRESULT,
    FreeData: ?*opaque{},
    EncryptData: ?*?*?*?*?*?*?*?*?*HRESULT,
    DecryptData: ?*?*?*?*?*?*?*?*?*HRESULT,
    GetSerializedCredential: ?*?*?*?*?*?*?*?*?*HRESULT,
    ValidateRemoteCredential: ?*?*?*?*?*?*?*?*?*HRESULT,
    SignData: ?*?*?*?*?*?*?*?*?*HRESULT,
    VerifyData: ?*?*?*?*?*?*?*?*?*HRESULT,
};
// --------------------------------------------------------
// Type: DRT_BOOTSTRAP_RESOLVE_CALLBACK
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const DRT_BOOTSTRAP_RESOLVE_CALLBACK = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: DRT_BOOTSTRAP_PROVIDER
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DRT_BOOTSTRAP_PROVIDER = extern struct {
    pvContext: ?*opaque{},
    Attach: ?*?*?*?*?*?*?*?*?*HRESULT,
    Detach: ?*opaque{},
    InitResolve: ?*?*?*?*?*?*?*?*?*HRESULT,
    IssueResolve: ?*?*?*?*?*?*?*?*?*HRESULT,
    EndResolve: ?*opaque{},
    Register: ?*?*?*?*?*?*?*?*?*HRESULT,
    Unregister: ?*opaque{},
};
// --------------------------------------------------------
// Type: DRT_SETTINGS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DRT_SETTINGS = extern struct {
    dwSize: u32,
    cbKey: u32,
    bProtocolMajorVersion: u8,
    bProtocolMinorVersion: u8,
    ulMaxRoutingAddresses: u32,
    pwzDrtInstancePrefix: ?*u16,
    hTransport: ?*opaque{},
    pSecurityProvider: ?*DRT_SECURITY_PROVIDER,
    pBootstrapProvider: ?*DRT_BOOTSTRAP_PROVIDER,
    eSecurityMode: DRT_SECURITY_MODE,
};
// --------------------------------------------------------
// Type: DRT_SEARCH_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DRT_SEARCH_INFO = extern struct {
    dwSize: u32,
    fIterative: BOOL,
    fAllowCurrentInstanceMatch: BOOL,
    fAnyMatchInRange: BOOL,
    cMaxEndpoints: u32,
    pMaximumKey: ?*DRT_DATA,
    pMinimumKey: ?*DRT_DATA,
};
// --------------------------------------------------------
// Type: DRT_ADDRESS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DRT_ADDRESS = extern struct {
    socketAddress: SOCKADDR_STORAGE_LH,
    flags: u32,
    nearness: i32,
    latency: u32,
};
// --------------------------------------------------------
// Type: DRT_ADDRESS_LIST
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DRT_ADDRESS_LIST = extern struct {
    AddressCount: u32,
    AddressList: ?[*]DRT_ADDRESS,
};
// --------------------------------------------------------
// Type: DRT_SEARCH_RESULT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DRT_SEARCH_RESULT = extern struct {
    dwSize: u32,
    type: DRT_MATCH_TYPE,
    pvContext: ?*opaque{},
    registration: DRT_REGISTRATION,
};
// --------------------------------------------------------
// Type: DRT_EVENT_DATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DRT_EVENT_DATA = extern struct {
    type: DRT_EVENT_TYPE,
    hr: HRESULT,
    pvContext: ?*opaque{},
    Anonymous: _Anonymous_e__Union,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
        // --------------------------------------------------------
        // Type: _statusChange_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _statusChange_e__Struct = extern struct {
            status: DRT_STATUS,
            bootstrapAddresses: _bootstrapAddresses_e__Struct,
            // --------------------------------------------------------
            // Type: _bootstrapAddresses_e__Struct
            // TypeLayoutAttr: sequential
            // TODO: I think this is a struct, but not sure at this point, assuming it is for now
            pub const _bootstrapAddresses_e__Struct = extern struct {
                cntAddress: u32,
                pAddresses: ?*SOCKADDR_STORAGE_LH,
            };
        };
        // --------------------------------------------------------
        // Type: _leafsetKeyChange_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _leafsetKeyChange_e__Struct = extern struct {
            change: DRT_LEAFSET_KEY_CHANGE_TYPE,
            localKey: DRT_DATA,
            remoteKey: DRT_DATA,
        };
        // --------------------------------------------------------
        // Type: _registrationStateChange_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _registrationStateChange_e__Struct = extern struct {
            state: DRT_REGISTRATION_STATE,
            localKey: DRT_DATA,
        };
    };
};
// --------------------------------------------------------
// Type: PEERDIST_STATUS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PEERDIST_STATUS = *opaque{
};
// --------------------------------------------------------
// Type: PEERDIST_PUBLICATION_OPTIONS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PEERDIST_PUBLICATION_OPTIONS = extern struct {
    dwVersion: u32,
    dwFlags: u32,
};
// --------------------------------------------------------
// Type: PEERDIST_CONTENT_TAG
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PEERDIST_CONTENT_TAG = extern struct {
    Data: ?[*]u8,
};
// --------------------------------------------------------
// Type: PEERDIST_RETRIEVAL_OPTIONS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PEERDIST_RETRIEVAL_OPTIONS = extern struct {
    cbSize: u32,
    dwContentInfoMinVersion: u32,
    dwContentInfoMaxVersion: u32,
    dwReserved: u32,
};
// --------------------------------------------------------
// Type: PEERDIST_STATUS_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PEERDIST_STATUS_INFO = extern struct {
    cbSize: u32,
    status: PEERDIST_STATUS,
    dwMinVer: u32,
    dwMaxVer: u32,
};
// --------------------------------------------------------
// Type: PEERDIST_CLIENT_INFO_BY_HANDLE_CLASS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PEERDIST_CLIENT_INFO_BY_HANDLE_CLASS = *opaque{
};
// --------------------------------------------------------
// Type: PEERDIST_CLIENT_BASIC_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PEERDIST_CLIENT_BASIC_INFO = extern struct {
    fFlashCrowd: BOOL,
};

//
// functions
//

// set_last_errror=False (can and should we use this?)
pub extern "P2PGRAPH" fn PeerGraphStartup(
    wVersionRequested: u16,
    pVersionData: ?*PEER_VERSION_DATA,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2PGRAPH" fn PeerGraphShutdown(
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2PGRAPH" fn PeerGraphFreeData(
    pvData: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "P2PGRAPH" fn PeerGraphGetItemCount(
    hPeerEnum: ?*opaque{},
    pCount: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2PGRAPH" fn PeerGraphGetNextItem(
    hPeerEnum: ?*opaque{},
    pCount: ?*u32,
    pppvItems: ?*?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2PGRAPH" fn PeerGraphEndEnumeration(
    hPeerEnum: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2PGRAPH" fn PeerGraphCreate(
    pGraphProperties: ?*PEER_GRAPH_PROPERTIES,
    pwzDatabaseName: ?*u16,
    pSecurityInterface: ?*PEER_SECURITY_INTERFACE,
    phGraph: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2PGRAPH" fn PeerGraphOpen(
    pwzGraphId: ?*u16,
    pwzPeerId: ?*u16,
    pwzDatabaseName: ?*u16,
    pSecurityInterface: ?*PEER_SECURITY_INTERFACE,
    cRecordTypeSyncPrecedence: u32,
    pRecordTypeSyncPrecedence: ?*Guid,
    phGraph: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2PGRAPH" fn PeerGraphListen(
    hGraph: ?*opaque{},
    dwScope: u32,
    dwScopeId: u32,
    wPort: u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2PGRAPH" fn PeerGraphConnect(
    hGraph: ?*opaque{},
    pwzPeerId: ?*u16,
    pAddress: ?*PEER_ADDRESS,
    pullConnectionId: ?*u64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2PGRAPH" fn PeerGraphClose(
    hGraph: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2PGRAPH" fn PeerGraphDelete(
    pwzGraphId: ?*u16,
    pwzPeerId: ?*u16,
    pwzDatabaseName: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2PGRAPH" fn PeerGraphGetStatus(
    hGraph: ?*opaque{},
    pdwStatus: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2PGRAPH" fn PeerGraphGetProperties(
    hGraph: ?*opaque{},
    ppGraphProperties: ?*?*PEER_GRAPH_PROPERTIES,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2PGRAPH" fn PeerGraphSetProperties(
    hGraph: ?*opaque{},
    pGraphProperties: ?*PEER_GRAPH_PROPERTIES,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2PGRAPH" fn PeerGraphRegisterEvent(
    hGraph: ?*opaque{},
    hEvent: HANDLE,
    cEventRegistrations: u32,
    pEventRegistrations: ?*PEER_GRAPH_EVENT_REGISTRATION,
    phPeerEvent: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2PGRAPH" fn PeerGraphUnregisterEvent(
    hPeerEvent: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2PGRAPH" fn PeerGraphGetEventData(
    hPeerEvent: ?*opaque{},
    ppEventData: ?*?*PEER_GRAPH_EVENT_DATA,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2PGRAPH" fn PeerGraphGetRecord(
    hGraph: ?*opaque{},
    pRecordId: ?*Guid,
    ppRecord: ?*?*PEER_RECORD,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2PGRAPH" fn PeerGraphAddRecord(
    hGraph: ?*opaque{},
    pRecord: ?*PEER_RECORD,
    pRecordId: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2PGRAPH" fn PeerGraphUpdateRecord(
    hGraph: ?*opaque{},
    pRecord: ?*PEER_RECORD,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2PGRAPH" fn PeerGraphDeleteRecord(
    hGraph: ?*opaque{},
    pRecordId: ?*Guid,
    fLocal: BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2PGRAPH" fn PeerGraphEnumRecords(
    hGraph: ?*opaque{},
    pRecordType: ?*Guid,
    pwzPeerId: ?*u16,
    phPeerEnum: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2PGRAPH" fn PeerGraphSearchRecords(
    hGraph: ?*opaque{},
    pwzCriteria: ?*u16,
    phPeerEnum: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2PGRAPH" fn PeerGraphExportDatabase(
    hGraph: ?*opaque{},
    pwzFilePath: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2PGRAPH" fn PeerGraphImportDatabase(
    hGraph: ?*opaque{},
    pwzFilePath: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2PGRAPH" fn PeerGraphValidateDeferredRecords(
    hGraph: ?*opaque{},
    cRecordIds: u32,
    pRecordIds: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2PGRAPH" fn PeerGraphOpenDirectConnection(
    hGraph: ?*opaque{},
    pwzPeerId: ?*u16,
    pAddress: ?*PEER_ADDRESS,
    pullConnectionId: ?*u64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2PGRAPH" fn PeerGraphSendData(
    hGraph: ?*opaque{},
    ullConnectionId: u64,
    pType: ?*Guid,
    cbData: u32,
    pvData: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2PGRAPH" fn PeerGraphCloseDirectConnection(
    hGraph: ?*opaque{},
    ullConnectionId: u64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2PGRAPH" fn PeerGraphEnumConnections(
    hGraph: ?*opaque{},
    dwFlags: u32,
    phPeerEnum: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2PGRAPH" fn PeerGraphEnumNodes(
    hGraph: ?*opaque{},
    pwzPeerId: ?*u16,
    phPeerEnum: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2PGRAPH" fn PeerGraphSetPresence(
    hGraph: ?*opaque{},
    fPresent: BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2PGRAPH" fn PeerGraphGetNodeInfo(
    hGraph: ?*opaque{},
    ullNodeId: u64,
    ppNodeInfo: ?*?*PEER_NODE_INFO,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2PGRAPH" fn PeerGraphSetNodeAttributes(
    hGraph: ?*opaque{},
    pwzAttributes: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2PGRAPH" fn PeerGraphPeerTimeToUniversalTime(
    hGraph: ?*opaque{},
    pftPeerTime: ?*FILETIME,
    pftUniversalTime: ?*FILETIME,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2PGRAPH" fn PeerGraphUniversalTimeToPeerTime(
    hGraph: ?*opaque{},
    pftUniversalTime: ?*FILETIME,
    pftPeerTime: ?*FILETIME,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2P" fn PeerFreeData(
    pvData: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "P2P" fn PeerGetItemCount(
    hPeerEnum: ?*opaque{},
    pCount: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2P" fn PeerGetNextItem(
    hPeerEnum: ?*opaque{},
    pCount: ?*u32,
    pppvItems: ?*?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2P" fn PeerEndEnumeration(
    hPeerEnum: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2P" fn PeerGroupStartup(
    wVersionRequested: u16,
    pVersionData: ?*PEER_VERSION_DATA,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2P" fn PeerGroupShutdown(
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2P" fn PeerGroupCreate(
    pProperties: ?*PEER_GROUP_PROPERTIES,
    phGroup: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2P" fn PeerGroupOpen(
    pwzIdentity: ?*u16,
    pwzGroupPeerName: ?*u16,
    pwzCloud: ?*u16,
    phGroup: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2P" fn PeerGroupJoin(
    pwzIdentity: ?*u16,
    pwzInvitation: ?*u16,
    pwzCloud: ?*u16,
    phGroup: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2P" fn PeerGroupPasswordJoin(
    pwzIdentity: ?*u16,
    pwzInvitation: ?*u16,
    pwzPassword: ?*u16,
    pwzCloud: ?*u16,
    phGroup: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2P" fn PeerGroupConnect(
    hGroup: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2P" fn PeerGroupConnectByAddress(
    hGroup: ?*opaque{},
    cAddresses: u32,
    pAddresses: ?*PEER_ADDRESS,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2P" fn PeerGroupClose(
    hGroup: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2P" fn PeerGroupDelete(
    pwzIdentity: ?*u16,
    pwzGroupPeerName: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2P" fn PeerGroupCreateInvitation(
    hGroup: ?*opaque{},
    pwzIdentityInfo: ?*u16,
    pftExpiration: ?*FILETIME,
    cRoles: u32,
    pRoles: ?*Guid,
    ppwzInvitation: ?*?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2P" fn PeerGroupCreatePasswordInvitation(
    hGroup: ?*opaque{},
    ppwzInvitation: ?*?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2P" fn PeerGroupParseInvitation(
    pwzInvitation: ?*u16,
    ppInvitationInfo: ?*?*PEER_INVITATION_INFO,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2P" fn PeerGroupGetStatus(
    hGroup: ?*opaque{},
    pdwStatus: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2P" fn PeerGroupGetProperties(
    hGroup: ?*opaque{},
    ppProperties: ?*?*PEER_GROUP_PROPERTIES,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2P" fn PeerGroupSetProperties(
    hGroup: ?*opaque{},
    pProperties: ?*PEER_GROUP_PROPERTIES,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2P" fn PeerGroupEnumMembers(
    hGroup: ?*opaque{},
    dwFlags: u32,
    pwzIdentity: ?*u16,
    phPeerEnum: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2P" fn PeerGroupOpenDirectConnection(
    hGroup: ?*opaque{},
    pwzIdentity: ?*u16,
    pAddress: ?*PEER_ADDRESS,
    pullConnectionId: ?*u64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2P" fn PeerGroupCloseDirectConnection(
    hGroup: ?*opaque{},
    ullConnectionId: u64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2P" fn PeerGroupEnumConnections(
    hGroup: ?*opaque{},
    dwFlags: u32,
    phPeerEnum: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2P" fn PeerGroupSendData(
    hGroup: ?*opaque{},
    ullConnectionId: u64,
    pType: ?*Guid,
    cbData: u32,
    pvData: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2P" fn PeerGroupRegisterEvent(
    hGroup: ?*opaque{},
    hEvent: HANDLE,
    cEventRegistration: u32,
    pEventRegistrations: ?*PEER_GROUP_EVENT_REGISTRATION,
    phPeerEvent: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2P" fn PeerGroupUnregisterEvent(
    hPeerEvent: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2P" fn PeerGroupGetEventData(
    hPeerEvent: ?*opaque{},
    ppEventData: ?*?*PEER_GROUP_EVENT_DATA,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2P" fn PeerGroupGetRecord(
    hGroup: ?*opaque{},
    pRecordId: ?*Guid,
    ppRecord: ?*?*PEER_RECORD,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2P" fn PeerGroupAddRecord(
    hGroup: ?*opaque{},
    pRecord: ?*PEER_RECORD,
    pRecordId: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2P" fn PeerGroupUpdateRecord(
    hGroup: ?*opaque{},
    pRecord: ?*PEER_RECORD,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2P" fn PeerGroupDeleteRecord(
    hGroup: ?*opaque{},
    pRecordId: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2P" fn PeerGroupEnumRecords(
    hGroup: ?*opaque{},
    pRecordType: ?*Guid,
    phPeerEnum: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2P" fn PeerGroupSearchRecords(
    hGroup: ?*opaque{},
    pwzCriteria: ?*u16,
    phPeerEnum: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2P" fn PeerGroupExportDatabase(
    hGroup: ?*opaque{},
    pwzFilePath: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2P" fn PeerGroupImportDatabase(
    hGroup: ?*opaque{},
    pwzFilePath: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2P" fn PeerGroupIssueCredentials(
    hGroup: ?*opaque{},
    pwzSubjectIdentity: ?*u16,
    pCredentialInfo: ?*PEER_CREDENTIAL_INFO,
    dwFlags: u32,
    ppwzInvitation: ?*?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2P" fn PeerGroupExportConfig(
    hGroup: ?*opaque{},
    pwzPassword: ?*u16,
    ppwzXML: ?*?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2P" fn PeerGroupImportConfig(
    pwzXML: ?*u16,
    pwzPassword: ?*u16,
    fOverwrite: BOOL,
    ppwzIdentity: ?*?*u16,
    ppwzGroup: ?*?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2P" fn PeerGroupPeerTimeToUniversalTime(
    hGroup: ?*opaque{},
    pftPeerTime: ?*FILETIME,
    pftUniversalTime: ?*FILETIME,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2P" fn PeerGroupUniversalTimeToPeerTime(
    hGroup: ?*opaque{},
    pftUniversalTime: ?*FILETIME,
    pftPeerTime: ?*FILETIME,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2P" fn PeerGroupResumePasswordAuthentication(
    hGroup: ?*opaque{},
    hPeerEventHandle: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2P" fn PeerIdentityCreate(
    pwzClassifier: ?*u16,
    pwzFriendlyName: ?*u16,
    hCryptProv: ?*opaque{},
    ppwzIdentity: ?*?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2P" fn PeerIdentityGetFriendlyName(
    pwzIdentity: ?*u16,
    ppwzFriendlyName: ?*?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2P" fn PeerIdentitySetFriendlyName(
    pwzIdentity: ?*u16,
    pwzFriendlyName: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2P" fn PeerIdentityGetCryptKey(
    pwzIdentity: ?*u16,
    phCryptProv: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2P" fn PeerIdentityDelete(
    pwzIdentity: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2P" fn PeerEnumIdentities(
    phPeerEnum: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2P" fn PeerEnumGroups(
    pwzIdentity: ?*u16,
    phPeerEnum: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2P" fn PeerCreatePeerName(
    pwzIdentity: ?*u16,
    pwzClassifier: ?*u16,
    ppwzPeerName: ?*?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2P" fn PeerIdentityGetXML(
    pwzIdentity: ?*u16,
    ppwzIdentityXML: ?*?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2P" fn PeerIdentityExport(
    pwzIdentity: ?*u16,
    pwzPassword: ?*u16,
    ppwzExportXML: ?*?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2P" fn PeerIdentityImport(
    pwzImportXML: ?*u16,
    pwzPassword: ?*u16,
    ppwzIdentity: ?*?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2P" fn PeerIdentityGetDefault(
    ppwzPeerName: ?*?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2P" fn PeerCollabStartup(
    wVersionRequested: u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2P" fn PeerCollabShutdown(
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2P" fn PeerCollabSignin(
    hwndParent: HWND,
    dwSigninOptions: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2P" fn PeerCollabSignout(
    dwSigninOptions: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2P" fn PeerCollabGetSigninOptions(
    pdwSigninOptions: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2P" fn PeerCollabAsyncInviteContact(
    pcContact: ?*PEER_CONTACT,
    pcEndpoint: ?*PEER_ENDPOINT,
    pcInvitation: ?*PEER_INVITATION,
    hEvent: HANDLE,
    phInvitation: ?*HANDLE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2P" fn PeerCollabGetInvitationResponse(
    hInvitation: HANDLE,
    ppInvitationResponse: ?*?*PEER_INVITATION_RESPONSE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2P" fn PeerCollabCancelInvitation(
    hInvitation: HANDLE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2P" fn PeerCollabCloseHandle(
    hInvitation: HANDLE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2P" fn PeerCollabInviteContact(
    pcContact: ?*PEER_CONTACT,
    pcEndpoint: ?*PEER_ENDPOINT,
    pcInvitation: ?*PEER_INVITATION,
    ppResponse: ?*?*PEER_INVITATION_RESPONSE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2P" fn PeerCollabAsyncInviteEndpoint(
    pcEndpoint: ?*PEER_ENDPOINT,
    pcInvitation: ?*PEER_INVITATION,
    hEvent: HANDLE,
    phInvitation: ?*HANDLE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2P" fn PeerCollabInviteEndpoint(
    pcEndpoint: ?*PEER_ENDPOINT,
    pcInvitation: ?*PEER_INVITATION,
    ppResponse: ?*?*PEER_INVITATION_RESPONSE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2P" fn PeerCollabGetAppLaunchInfo(
    ppLaunchInfo: ?*?*PEER_APP_LAUNCH_INFO,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2P" fn PeerCollabRegisterApplication(
    pcApplication: ?*PEER_APPLICATION_REGISTRATION_INFO,
    registrationType: PEER_APPLICATION_REGISTRATION_TYPE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2P" fn PeerCollabUnregisterApplication(
    pApplicationId: ?*Guid,
    registrationType: PEER_APPLICATION_REGISTRATION_TYPE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2P" fn PeerCollabGetApplicationRegistrationInfo(
    pApplicationId: ?*Guid,
    registrationType: PEER_APPLICATION_REGISTRATION_TYPE,
    ppApplication: ?*?*PEER_APPLICATION_REGISTRATION_INFO,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2P" fn PeerCollabEnumApplicationRegistrationInfo(
    registrationType: PEER_APPLICATION_REGISTRATION_TYPE,
    phPeerEnum: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2P" fn PeerCollabGetPresenceInfo(
    pcEndpoint: ?*PEER_ENDPOINT,
    ppPresenceInfo: ?*?*PEER_PRESENCE_INFO,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2P" fn PeerCollabEnumApplications(
    pcEndpoint: ?*PEER_ENDPOINT,
    pApplicationId: ?*Guid,
    phPeerEnum: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2P" fn PeerCollabEnumObjects(
    pcEndpoint: ?*PEER_ENDPOINT,
    pObjectId: ?*Guid,
    phPeerEnum: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2P" fn PeerCollabEnumEndpoints(
    pcContact: ?*PEER_CONTACT,
    phPeerEnum: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2P" fn PeerCollabRefreshEndpointData(
    pcEndpoint: ?*PEER_ENDPOINT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2P" fn PeerCollabDeleteEndpointData(
    pcEndpoint: ?*PEER_ENDPOINT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2P" fn PeerCollabQueryContactData(
    pcEndpoint: ?*PEER_ENDPOINT,
    ppwzContactData: ?*?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2P" fn PeerCollabSubscribeEndpointData(
    pcEndpoint: ?*PEER_ENDPOINT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2P" fn PeerCollabUnsubscribeEndpointData(
    pcEndpoint: ?*PEER_ENDPOINT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2P" fn PeerCollabSetPresenceInfo(
    pcPresenceInfo: ?*PEER_PRESENCE_INFO,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2P" fn PeerCollabGetEndpointName(
    ppwzEndpointName: ?*?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2P" fn PeerCollabSetEndpointName(
    pwzEndpointName: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2P" fn PeerCollabSetObject(
    pcObject: ?*PEER_OBJECT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2P" fn PeerCollabDeleteObject(
    pObjectId: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2P" fn PeerCollabRegisterEvent(
    hEvent: HANDLE,
    cEventRegistration: u32,
    pEventRegistrations: ?*PEER_COLLAB_EVENT_REGISTRATION,
    phPeerEvent: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2P" fn PeerCollabGetEventData(
    hPeerEvent: ?*opaque{},
    ppEventData: ?*?*PEER_COLLAB_EVENT_DATA,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2P" fn PeerCollabUnregisterEvent(
    hPeerEvent: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2P" fn PeerCollabEnumPeopleNearMe(
    phPeerEnum: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2P" fn PeerCollabAddContact(
    pwzContactData: ?*u16,
    ppContact: ?*?*PEER_CONTACT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2P" fn PeerCollabDeleteContact(
    pwzPeerName: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2P" fn PeerCollabGetContact(
    pwzPeerName: ?*u16,
    ppContact: ?*?*PEER_CONTACT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2P" fn PeerCollabUpdateContact(
    pContact: ?*PEER_CONTACT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2P" fn PeerCollabEnumContacts(
    phPeerEnum: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2P" fn PeerCollabExportContact(
    pwzPeerName: ?*u16,
    ppwzContactData: ?*?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2P" fn PeerCollabParseContact(
    pwzContactData: ?*u16,
    ppContact: ?*?*PEER_CONTACT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2P" fn PeerNameToPeerHostName(
    pwzPeerName: ?*u16,
    ppwzHostName: ?*?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2P" fn PeerHostNameToPeerName(
    pwzHostName: ?*u16,
    ppwzPeerName: ?*?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2P" fn PeerPnrpStartup(
    wVersionRequested: u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2P" fn PeerPnrpShutdown(
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2P" fn PeerPnrpRegister(
    pcwzPeerName: ?*u16,
    pRegistrationInfo: ?*PEER_PNRP_REGISTRATION_INFO,
    phRegistration: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2P" fn PeerPnrpUpdateRegistration(
    hRegistration: ?*opaque{},
    pRegistrationInfo: ?*PEER_PNRP_REGISTRATION_INFO,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2P" fn PeerPnrpUnregister(
    hRegistration: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2P" fn PeerPnrpResolve(
    pcwzPeerName: ?*u16,
    pcwzCloudName: ?*u16,
    pcEndpoints: ?*u32,
    ppEndpoints: ?*?*PEER_PNRP_ENDPOINT_INFO,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2P" fn PeerPnrpStartResolve(
    pcwzPeerName: ?*u16,
    pcwzCloudName: ?*u16,
    cMaxEndpoints: u32,
    hEvent: HANDLE,
    phResolve: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2P" fn PeerPnrpGetCloudInfo(
    pcNumClouds: ?*u32,
    ppCloudInfo: ?*?*PEER_PNRP_CLOUD_INFO,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2P" fn PeerPnrpGetEndpoint(
    hResolve: ?*opaque{},
    ppEndpoint: ?*?*PEER_PNRP_ENDPOINT_INFO,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "P2P" fn PeerPnrpEndResolve(
    hResolve: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "drtprov" fn DrtCreatePnrpBootstrapResolver(
    fPublish: BOOL,
    pwzPeerName: ?*u16,
    pwzCloudName: ?*u16,
    pwzPublishingIdentity: ?*u16,
    ppResolver: ?*?*DRT_BOOTSTRAP_PROVIDER,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "drtprov" fn DrtDeletePnrpBootstrapResolver(
    pResolver: ?*DRT_BOOTSTRAP_PROVIDER,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "drtprov" fn DrtCreateDnsBootstrapResolver(
    port: u16,
    pwszAddress: ?*u16,
    ppModule: ?*?*DRT_BOOTSTRAP_PROVIDER,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "drtprov" fn DrtDeleteDnsBootstrapResolver(
    pResolver: ?*DRT_BOOTSTRAP_PROVIDER,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "drttransport" fn DrtCreateIpv6UdpTransport(
    scope: DRT_SCOPE,
    dwScopeId: u32,
    dwLocalityThreshold: u32,
    pwPort: ?*u16,
    phTransport: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "drttransport" fn DrtDeleteIpv6UdpTransport(
    hTransport: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "drtprov" fn DrtCreateDerivedKeySecurityProvider(
    pRootCert: ?*CERT_CONTEXT,
    pLocalCert: ?*CERT_CONTEXT,
    ppSecurityProvider: ?*?*DRT_SECURITY_PROVIDER,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "drtprov" fn DrtCreateDerivedKey(
    pLocalCert: ?*CERT_CONTEXT,
    pKey: ?*DRT_DATA,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "drtprov" fn DrtDeleteDerivedKeySecurityProvider(
    pSecurityProvider: ?*DRT_SECURITY_PROVIDER,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "drtprov" fn DrtCreateNullSecurityProvider(
    ppSecurityProvider: ?*?*DRT_SECURITY_PROVIDER,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "drtprov" fn DrtDeleteNullSecurityProvider(
    pSecurityProvider: ?*DRT_SECURITY_PROVIDER,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "drt" fn DrtOpen(
    pSettings: ?*DRT_SETTINGS,
    hEvent: HANDLE,
    pvContext: ?*opaque{},
    phDrt: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "drt" fn DrtClose(
    hDrt: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "drt" fn DrtGetEventDataSize(
    hDrt: ?*opaque{},
    pulEventDataLen: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "drt" fn DrtGetEventData(
    hDrt: ?*opaque{},
    ulEventDataLen: u32,
    pEventData: ?*DRT_EVENT_DATA,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "drt" fn DrtRegisterKey(
    hDrt: ?*opaque{},
    pRegistration: ?*DRT_REGISTRATION,
    pvKeyContext: ?*opaque{},
    phKeyRegistration: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "drt" fn DrtUpdateKey(
    hKeyRegistration: ?*opaque{},
    pAppData: ?*DRT_DATA,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "drt" fn DrtUnregisterKey(
    hKeyRegistration: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "drt" fn DrtStartSearch(
    hDrt: ?*opaque{},
    pKey: ?*DRT_DATA,
    pInfo: ?*DRT_SEARCH_INFO,
    timeout: u32,
    hEvent: HANDLE,
    pvContext: ?*opaque{},
    hSearchContext: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "drt" fn DrtContinueSearch(
    hSearchContext: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "drt" fn DrtGetSearchResultSize(
    hSearchContext: ?*opaque{},
    pulSearchResultSize: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "drt" fn DrtGetSearchResult(
    hSearchContext: ?*opaque{},
    ulSearchResultSize: u32,
    pSearchResult: ?*DRT_SEARCH_RESULT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "drt" fn DrtGetSearchPathSize(
    hSearchContext: ?*opaque{},
    pulSearchPathSize: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "drt" fn DrtGetSearchPath(
    hSearchContext: ?*opaque{},
    ulSearchPathSize: u32,
    pSearchPath: ?*DRT_ADDRESS_LIST,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "drt" fn DrtEndSearch(
    hSearchContext: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "drt" fn DrtGetInstanceName(
    hDrt: ?*opaque{},
    ulcbInstanceNameSize: u32,
    pwzDrtInstanceName: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "drt" fn DrtGetInstanceNameSize(
    hDrt: ?*opaque{},
    pulcbInstanceNameSize: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "PeerDist" fn PeerDistStartup(
    dwVersionRequested: u32,
    phPeerDist: ?*?*opaque{},
    pdwSupportedVersion: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "PeerDist" fn PeerDistShutdown(
    hPeerDist: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "PeerDist" fn PeerDistGetStatus(
    hPeerDist: ?*opaque{},
    pPeerDistStatus: ?*PEERDIST_STATUS,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "PeerDist" fn PeerDistRegisterForStatusChangeNotification(
    hPeerDist: ?*opaque{},
    hCompletionPort: HANDLE,
    ulCompletionKey: ?*opaque{},
    lpOverlapped: ?*OVERLAPPED,
    pPeerDistStatus: ?*PEERDIST_STATUS,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "PeerDist" fn PeerDistUnregisterForStatusChangeNotification(
    hPeerDist: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "PeerDist" fn PeerDistServerPublishStream(
    hPeerDist: ?*opaque{},
    cbContentIdentifier: u32,
    pContentIdentifier: ?*u8,
    cbContentLength: u64,
    pPublishOptions: ?*PEERDIST_PUBLICATION_OPTIONS,
    hCompletionPort: HANDLE,
    ulCompletionKey: ?*opaque{},
    phStream: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "PeerDist" fn PeerDistServerPublishAddToStream(
    hPeerDist: ?*opaque{},
    hStream: ?*opaque{},
    cbNumberOfBytes: u32,
    pBuffer: ?*u8,
    lpOverlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "PeerDist" fn PeerDistServerPublishCompleteStream(
    hPeerDist: ?*opaque{},
    hStream: ?*opaque{},
    lpOverlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "PeerDist" fn PeerDistServerCloseStreamHandle(
    hPeerDist: ?*opaque{},
    hStream: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "PeerDist" fn PeerDistServerUnpublish(
    hPeerDist: ?*opaque{},
    cbContentIdentifier: u32,
    pContentIdentifier: ?*u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "PeerDist" fn PeerDistServerOpenContentInformation(
    hPeerDist: ?*opaque{},
    cbContentIdentifier: u32,
    pContentIdentifier: ?*u8,
    ullContentOffset: u64,
    cbContentLength: u64,
    hCompletionPort: HANDLE,
    ulCompletionKey: ?*opaque{},
    phContentInfo: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "PeerDist" fn PeerDistServerRetrieveContentInformation(
    hPeerDist: ?*opaque{},
    hContentInfo: ?*opaque{},
    cbMaxNumberOfBytes: u32,
    pBuffer: ?*u8,
    lpOverlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "PeerDist" fn PeerDistServerCloseContentInformation(
    hPeerDist: ?*opaque{},
    hContentInfo: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "PeerDist" fn PeerDistServerCancelAsyncOperation(
    hPeerDist: ?*opaque{},
    cbContentIdentifier: u32,
    pContentIdentifier: ?*u8,
    pOverlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "PeerDist" fn PeerDistClientOpenContent(
    hPeerDist: ?*opaque{},
    pContentTag: ?*PEERDIST_CONTENT_TAG,
    hCompletionPort: HANDLE,
    ulCompletionKey: ?*opaque{},
    phContentHandle: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "PeerDist" fn PeerDistClientCloseContent(
    hPeerDist: ?*opaque{},
    hContentHandle: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "PeerDist" fn PeerDistClientAddContentInformation(
    hPeerDist: ?*opaque{},
    hContentHandle: ?*opaque{},
    cbNumberOfBytes: u32,
    pBuffer: ?*u8,
    lpOverlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "PeerDist" fn PeerDistClientCompleteContentInformation(
    hPeerDist: ?*opaque{},
    hContentHandle: ?*opaque{},
    lpOverlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "PeerDist" fn PeerDistClientAddData(
    hPeerDist: ?*opaque{},
    hContentHandle: ?*opaque{},
    cbNumberOfBytes: u32,
    pBuffer: ?*u8,
    lpOverlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "PeerDist" fn PeerDistClientBlockRead(
    hPeerDist: ?*opaque{},
    hContentHandle: ?*opaque{},
    cbMaxNumberOfBytes: u32,
    pBuffer: ?*u8,
    dwTimeoutInMilliseconds: u32,
    lpOverlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "PeerDist" fn PeerDistClientStreamRead(
    hPeerDist: ?*opaque{},
    hContentHandle: ?*opaque{},
    cbMaxNumberOfBytes: u32,
    pBuffer: ?*u8,
    dwTimeoutInMilliseconds: u32,
    lpOverlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "PeerDist" fn PeerDistClientFlushContent(
    hPeerDist: ?*opaque{},
    pContentTag: ?*PEERDIST_CONTENT_TAG,
    hCompletionPort: HANDLE,
    ulCompletionKey: ?*opaque{},
    lpOverlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "PeerDist" fn PeerDistClientCancelAsyncOperation(
    hPeerDist: ?*opaque{},
    hContentHandle: ?*opaque{},
    pOverlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "PeerDist" fn PeerDistGetStatusEx(
    hPeerDist: ?*opaque{},
    pPeerDistStatus: ?*PEERDIST_STATUS_INFO,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "PeerDist" fn PeerDistRegisterForStatusChangeNotificationEx(
    hPeerDist: ?*opaque{},
    hCompletionPort: HANDLE,
    ulCompletionKey: ?*opaque{},
    lpOverlapped: ?*OVERLAPPED,
    pPeerDistStatus: ?*PEERDIST_STATUS_INFO,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "PeerDist" fn PeerDistGetOverlappedResult(
    lpOverlapped: ?*OVERLAPPED,
    lpNumberOfBytesTransferred: ?*u32,
    bWait: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "PeerDist" fn PeerDistServerOpenContentInformationEx(
    hPeerDist: ?*opaque{},
    cbContentIdentifier: u32,
    pContentIdentifier: ?*u8,
    ullContentOffset: u64,
    cbContentLength: u64,
    pRetrievalOptions: ?*PEERDIST_RETRIEVAL_OPTIONS,
    hCompletionPort: HANDLE,
    ulCompletionKey: ?*opaque{},
    phContentInfo: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "PeerDist" fn PeerDistClientGetInformationByHandle(
    hPeerDist: ?*opaque{},
    hContentHandle: ?*opaque{},
    PeerDistClientInfoClass: PEERDIST_CLIENT_INFO_BY_HANDLE_CLASS,
    dwBufferSize: u32,
    lpInformation: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) u32;

//
// Unicode Symbol Aliases
//
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {
    },
    .wide => struct {
    },
    else => if (@import("builtin").is_test) struct {
    } else struct {
    },
};

//
// type imports
//
const Guid = @import("../zig.zig").Guid;
const SOCKET_ADDRESS = @import("winsock.zig").SOCKET_ADDRESS;
const FILETIME = @import("windowsprogramming.zig").FILETIME;
const SOCKADDR_IN6_LH = @import("networkdrivers.zig").SOCKADDR_IN6_LH;
const HRESULT = @import("com.zig").HRESULT;
const CERT_PUBLIC_KEY_INFO = @import("security.zig").CERT_PUBLIC_KEY_INFO;
const BOOL = @import("systemservices.zig").BOOL;
const SOCKADDR = @import("winsock.zig").SOCKADDR;
const SOCKADDR_STORAGE_LH = @import("networkdrivers.zig").SOCKADDR_STORAGE_LH;
const HANDLE = @import("systemservices.zig").HANDLE;
const HWND = @import("windowsandmessaging.zig").HWND;
const CERT_CONTEXT = @import("security.zig").CERT_CONTEXT;
const OVERLAPPED = @import("systemservices.zig").OVERLAPPED;

test "" {
    const constant_export_count = 0;
    const type_export_count = 109;
    const func_count = 200;
    const unicode_alias_count = 0;
    const type_import_count = 13;
    @setEvalBranchQuota(0
        + constant_export_count
        + type_export_count
        + func_count
        + unicode_alias_count
        + type_import_count
        + 2 // TODO: why do I need these extra 2?
    );
    @import("std").testing.refAllDecls(@This());
}
