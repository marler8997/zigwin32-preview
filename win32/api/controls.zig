//! NOTE: this source file is autogenerated, DO NOT MODIFY

//
// constants
//

//
// types
//
// --------------------------------------------------------
// Type: EDITWORDBREAKPROCA
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const EDITWORDBREAKPROCA = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: EDITWORDBREAKPROCW
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const EDITWORDBREAKPROCW = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: NMHDR
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NMHDR = extern struct {
    hwndFrom: HWND,
    idFrom: ?*opaque{},
    code: u32,
};
// --------------------------------------------------------
// Type: MEASUREITEMSTRUCT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const MEASUREITEMSTRUCT = extern struct {
    CtlType: u32,
    CtlID: u32,
    itemID: u32,
    itemWidth: u32,
    itemHeight: u32,
    itemData: ?*opaque{},
};
// --------------------------------------------------------
// Type: DRAWITEMSTRUCT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DRAWITEMSTRUCT = extern struct {
    CtlType: u32,
    CtlID: u32,
    itemID: u32,
    itemAction: u32,
    itemState: u32,
    hwndItem: HWND,
    hDC: HDC,
    rcItem: RECT,
    itemData: ?*opaque{},
};
// --------------------------------------------------------
// Type: DELETEITEMSTRUCT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DELETEITEMSTRUCT = extern struct {
    CtlType: u32,
    CtlID: u32,
    itemID: u32,
    hwndItem: HWND,
    itemData: ?*opaque{},
};
// --------------------------------------------------------
// Type: COMPAREITEMSTRUCT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const COMPAREITEMSTRUCT = extern struct {
    CtlType: u32,
    CtlID: u32,
    hwndItem: HWND,
    itemID1: u32,
    itemData1: ?*opaque{},
    itemID2: u32,
    itemData2: ?*opaque{},
    dwLocaleId: u32,
};
// --------------------------------------------------------
// Type: POINTER_FEEDBACK_MODE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const POINTER_FEEDBACK_MODE = *opaque{
};
// --------------------------------------------------------
// Type: USAGE_PROPERTIES
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const USAGE_PROPERTIES = extern struct {
    level: u16,
    page: u16,
    usage: u16,
    logicalMinimum: i32,
    logicalMaximum: i32,
    unit: u16,
    exponent: u16,
    count: u8,
    physicalMinimum: i32,
    physicalMaximum: i32,
};
// --------------------------------------------------------
// Type: POINTER_TYPE_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const POINTER_TYPE_INFO = extern struct {
    type: u32,
    Anonymous: _Anonymous_e__Union,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: INPUT_INJECTION_VALUE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const INPUT_INJECTION_VALUE = extern struct {
    page: u16,
    usage: u16,
    value: i32,
    index: u16,
};
// --------------------------------------------------------
// Type: TOUCH_HIT_TESTING_PROXIMITY_EVALUATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TOUCH_HIT_TESTING_PROXIMITY_EVALUATION = extern struct {
    score: u16,
    adjustedPoint: POINT,
};
// --------------------------------------------------------
// Type: TOUCH_HIT_TESTING_INPUT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TOUCH_HIT_TESTING_INPUT = extern struct {
    pointerId: u32,
    point: POINT,
    boundingBox: RECT,
    nonOccludedBoundingBox: RECT,
    orientation: u32,
};
// --------------------------------------------------------
// Type: FEEDBACK_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const FEEDBACK_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: SCROLLINFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SCROLLINFO = extern struct {
    cbSize: u32,
    fMask: u32,
    nMin: i32,
    nMax: i32,
    nPage: u32,
    nPos: i32,
    nTrackPos: i32,
};
// --------------------------------------------------------
// Type: SCROLLBARINFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SCROLLBARINFO = extern struct {
    cbSize: u32,
    rcScrollBar: RECT,
    dxyLineButton: i32,
    xyThumbTop: i32,
    xyThumbBottom: i32,
    reserved: i32,
    rgstate: ?[*]u32,
};
// --------------------------------------------------------
// Type: COMBOBOXINFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const COMBOBOXINFO = extern struct {
    cbSize: u32,
    rcItem: RECT,
    rcButton: RECT,
    stateButton: u32,
    hwndCombo: HWND,
    hwndItem: HWND,
    hwndList: HWND,
};
// --------------------------------------------------------
// Type: POINTER_DEVICE_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const POINTER_DEVICE_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: POINTER_DEVICE_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const POINTER_DEVICE_INFO = extern struct {
    displayOrientation: u32,
    device: HANDLE,
    pointerDeviceType: POINTER_DEVICE_TYPE,
    monitor: ?*opaque{},
    startingCursorId: u32,
    maxActiveContacts: u16,
    productString: ?[*]u16,
};
// --------------------------------------------------------
// Type: POINTER_DEVICE_PROPERTY
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const POINTER_DEVICE_PROPERTY = extern struct {
    logicalMin: i32,
    logicalMax: i32,
    physicalMin: i32,
    physicalMax: i32,
    unit: u32,
    unitExponent: u32,
    usagePageId: u16,
    usageId: u16,
};
// --------------------------------------------------------
// Type: POINTER_DEVICE_CURSOR_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const POINTER_DEVICE_CURSOR_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: POINTER_DEVICE_CURSOR_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const POINTER_DEVICE_CURSOR_INFO = extern struct {
    cursorId: u32,
    cursor: POINTER_DEVICE_CURSOR_TYPE,
};
// --------------------------------------------------------
// Type: INPUT_MESSAGE_DEVICE_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const INPUT_MESSAGE_DEVICE_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: INPUT_MESSAGE_ORIGIN_ID
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const INPUT_MESSAGE_ORIGIN_ID = *opaque{
};
// --------------------------------------------------------
// Type: INPUT_MESSAGE_SOURCE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const INPUT_MESSAGE_SOURCE = extern struct {
    deviceType: INPUT_MESSAGE_DEVICE_TYPE,
    originId: INPUT_MESSAGE_ORIGIN_ID,
};
// --------------------------------------------------------
// Type: HIMAGELIST
// TypeLayoutAttr: sequential
// RAIIFree 'ImageList_Destroy' (TODO: can we use this information?)
pub const HIMAGELIST = ?*opaque{};
// --------------------------------------------------------
// Type: HPROPSHEETPAGE
// TypeLayoutAttr: sequential
// RAIIFree 'DestroyPropertySheetPage' (TODO: can we use this information?)
pub const HPROPSHEETPAGE = ?*opaque{};
// --------------------------------------------------------
// Type: CRGB
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CRGB = extern struct {
    bRed: u8,
    bGreen: u8,
    bBlue: u8,
    bExtra: u8,
};
// --------------------------------------------------------
// Type: _PSP
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const _PSP = opaque {
};
// --------------------------------------------------------
// Type: LPFNPSPCALLBACKA
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const LPFNPSPCALLBACKA = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: LPFNPSPCALLBACKW
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const LPFNPSPCALLBACKW = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PROPSHEETPAGEA_V1
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PROPSHEETPAGEA_V1 = extern struct {
    dwSize: u32,
    dwFlags: u32,
    hInstance: HINSTANCE,
    Anonymous1: _Anonymous1_e__Union,
    Anonymous2: _Anonymous2_e__Union,
    pszTitle: ?*i8,
    pfnDlgProc: DLGPROC,
    lParam: LPARAM,
    pfnCallback: LPFNPSPCALLBACKA,
    pcRefParent: ?*u32,
    // --------------------------------------------------------
    // Type: _Anonymous2_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous2_e__Union = *opaque{
    };
    // --------------------------------------------------------
    // Type: _Anonymous1_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous1_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: PROPSHEETPAGEA_V2
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PROPSHEETPAGEA_V2 = extern struct {
    dwSize: u32,
    dwFlags: u32,
    hInstance: HINSTANCE,
    Anonymous1: _Anonymous1_e__Union,
    Anonymous2: _Anonymous2_e__Union,
    pszTitle: ?*i8,
    pfnDlgProc: DLGPROC,
    lParam: LPARAM,
    pfnCallback: LPFNPSPCALLBACKA,
    pcRefParent: ?*u32,
    pszHeaderTitle: ?*i8,
    pszHeaderSubTitle: ?*i8,
    // --------------------------------------------------------
    // Type: _Anonymous2_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous2_e__Union = *opaque{
    };
    // --------------------------------------------------------
    // Type: _Anonymous1_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous1_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: PROPSHEETPAGEA_V3
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PROPSHEETPAGEA_V3 = extern struct {
    dwSize: u32,
    dwFlags: u32,
    hInstance: HINSTANCE,
    Anonymous1: _Anonymous1_e__Union,
    Anonymous2: _Anonymous2_e__Union,
    pszTitle: ?*i8,
    pfnDlgProc: DLGPROC,
    lParam: LPARAM,
    pfnCallback: LPFNPSPCALLBACKA,
    pcRefParent: ?*u32,
    pszHeaderTitle: ?*i8,
    pszHeaderSubTitle: ?*i8,
    hActCtx: HANDLE,
    // --------------------------------------------------------
    // Type: _Anonymous2_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous2_e__Union = *opaque{
    };
    // --------------------------------------------------------
    // Type: _Anonymous1_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous1_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: PROPSHEETPAGEA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PROPSHEETPAGEA = extern struct {
    dwSize: u32,
    dwFlags: u32,
    hInstance: HINSTANCE,
    Anonymous1: _Anonymous1_e__Union,
    Anonymous2: _Anonymous2_e__Union,
    pszTitle: ?*i8,
    pfnDlgProc: DLGPROC,
    lParam: LPARAM,
    pfnCallback: LPFNPSPCALLBACKA,
    pcRefParent: ?*u32,
    pszHeaderTitle: ?*i8,
    pszHeaderSubTitle: ?*i8,
    hActCtx: HANDLE,
    Anonymous3: _Anonymous3_e__Union,
    // --------------------------------------------------------
    // Type: _Anonymous2_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous2_e__Union = *opaque{
    };
    // --------------------------------------------------------
    // Type: _Anonymous3_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous3_e__Union = *opaque{
    };
    // --------------------------------------------------------
    // Type: _Anonymous1_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous1_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: PROPSHEETPAGEW_V1
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PROPSHEETPAGEW_V1 = extern struct {
    dwSize: u32,
    dwFlags: u32,
    hInstance: HINSTANCE,
    Anonymous1: _Anonymous1_e__Union,
    Anonymous2: _Anonymous2_e__Union,
    pszTitle: ?*u16,
    pfnDlgProc: DLGPROC,
    lParam: LPARAM,
    pfnCallback: LPFNPSPCALLBACKW,
    pcRefParent: ?*u32,
    // --------------------------------------------------------
    // Type: _Anonymous1_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous1_e__Union = *opaque{
    };
    // --------------------------------------------------------
    // Type: _Anonymous2_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous2_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: PROPSHEETPAGEW_V2
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PROPSHEETPAGEW_V2 = extern struct {
    dwSize: u32,
    dwFlags: u32,
    hInstance: HINSTANCE,
    Anonymous1: _Anonymous1_e__Union,
    Anonymous2: _Anonymous2_e__Union,
    pszTitle: ?*u16,
    pfnDlgProc: DLGPROC,
    lParam: LPARAM,
    pfnCallback: LPFNPSPCALLBACKW,
    pcRefParent: ?*u32,
    pszHeaderTitle: ?*u16,
    pszHeaderSubTitle: ?*u16,
    // --------------------------------------------------------
    // Type: _Anonymous1_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous1_e__Union = *opaque{
    };
    // --------------------------------------------------------
    // Type: _Anonymous2_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous2_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: PROPSHEETPAGEW_V3
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PROPSHEETPAGEW_V3 = extern struct {
    dwSize: u32,
    dwFlags: u32,
    hInstance: HINSTANCE,
    Anonymous1: _Anonymous1_e__Union,
    Anonymous2: _Anonymous2_e__Union,
    pszTitle: ?*u16,
    pfnDlgProc: DLGPROC,
    lParam: LPARAM,
    pfnCallback: LPFNPSPCALLBACKW,
    pcRefParent: ?*u32,
    pszHeaderTitle: ?*u16,
    pszHeaderSubTitle: ?*u16,
    hActCtx: HANDLE,
    // --------------------------------------------------------
    // Type: _Anonymous1_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous1_e__Union = *opaque{
    };
    // --------------------------------------------------------
    // Type: _Anonymous2_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous2_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: PROPSHEETPAGEW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PROPSHEETPAGEW = extern struct {
    dwSize: u32,
    dwFlags: u32,
    hInstance: HINSTANCE,
    Anonymous1: _Anonymous1_e__Union,
    Anonymous2: _Anonymous2_e__Union,
    pszTitle: ?*u16,
    pfnDlgProc: DLGPROC,
    lParam: LPARAM,
    pfnCallback: LPFNPSPCALLBACKW,
    pcRefParent: ?*u32,
    pszHeaderTitle: ?*u16,
    pszHeaderSubTitle: ?*u16,
    hActCtx: HANDLE,
    Anonymous3: _Anonymous3_e__Union,
    // --------------------------------------------------------
    // Type: _Anonymous3_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous3_e__Union = *opaque{
    };
    // --------------------------------------------------------
    // Type: _Anonymous1_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous1_e__Union = *opaque{
    };
    // --------------------------------------------------------
    // Type: _Anonymous2_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous2_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: PFNPROPSHEETCALLBACK
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFNPROPSHEETCALLBACK = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PROPSHEETHEADERA_V1
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PROPSHEETHEADERA_V1 = extern struct {
    dwSize: u32,
    dwFlags: u32,
    hwndParent: HWND,
    hInstance: HINSTANCE,
    Anonymous1: _Anonymous1_e__Union,
    pszCaption: ?*i8,
    nPages: u32,
    Anonymous2: _Anonymous2_e__Union,
    Anonymous3: _Anonymous3_e__Union,
    pfnCallback: PFNPROPSHEETCALLBACK,
    // --------------------------------------------------------
    // Type: _Anonymous2_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous2_e__Union = *opaque{
    };
    // --------------------------------------------------------
    // Type: _Anonymous3_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous3_e__Union = *opaque{
    };
    // --------------------------------------------------------
    // Type: _Anonymous1_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous1_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: PROPSHEETHEADERA_V2
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PROPSHEETHEADERA_V2 = extern struct {
    dwSize: u32,
    dwFlags: u32,
    hwndParent: HWND,
    hInstance: HINSTANCE,
    Anonymous1: _Anonymous1_e__Union,
    pszCaption: ?*i8,
    nPages: u32,
    Anonymous2: _Anonymous2_e__Union,
    Anonymous3: _Anonymous3_e__Union,
    pfnCallback: PFNPROPSHEETCALLBACK,
    Anonymous4: _Anonymous4_e__Union,
    hplWatermark: HPALETTE,
    Anonymous5: _Anonymous5_e__Union,
    // --------------------------------------------------------
    // Type: _Anonymous5_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous5_e__Union = *opaque{
    };
    // --------------------------------------------------------
    // Type: _Anonymous3_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous3_e__Union = *opaque{
    };
    // --------------------------------------------------------
    // Type: _Anonymous1_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous1_e__Union = *opaque{
    };
    // --------------------------------------------------------
    // Type: _Anonymous4_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous4_e__Union = *opaque{
    };
    // --------------------------------------------------------
    // Type: _Anonymous2_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous2_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: PROPSHEETHEADERW_V1
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PROPSHEETHEADERW_V1 = extern struct {
    dwSize: u32,
    dwFlags: u32,
    hwndParent: HWND,
    hInstance: HINSTANCE,
    Anonymous1: _Anonymous1_e__Union,
    pszCaption: ?*u16,
    nPages: u32,
    Anonymous2: _Anonymous2_e__Union,
    Anonymous3: _Anonymous3_e__Union,
    pfnCallback: PFNPROPSHEETCALLBACK,
    // --------------------------------------------------------
    // Type: _Anonymous2_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous2_e__Union = *opaque{
    };
    // --------------------------------------------------------
    // Type: _Anonymous3_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous3_e__Union = *opaque{
    };
    // --------------------------------------------------------
    // Type: _Anonymous1_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous1_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: PROPSHEETHEADERW_V2
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PROPSHEETHEADERW_V2 = extern struct {
    dwSize: u32,
    dwFlags: u32,
    hwndParent: HWND,
    hInstance: HINSTANCE,
    Anonymous1: _Anonymous1_e__Union,
    pszCaption: ?*u16,
    nPages: u32,
    Anonymous2: _Anonymous2_e__Union,
    Anonymous3: _Anonymous3_e__Union,
    pfnCallback: PFNPROPSHEETCALLBACK,
    Anonymous4: _Anonymous4_e__Union,
    hplWatermark: HPALETTE,
    Anonymous5: _Anonymous5_e__Union,
    // --------------------------------------------------------
    // Type: _Anonymous5_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous5_e__Union = *opaque{
    };
    // --------------------------------------------------------
    // Type: _Anonymous3_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous3_e__Union = *opaque{
    };
    // --------------------------------------------------------
    // Type: _Anonymous1_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous1_e__Union = *opaque{
    };
    // --------------------------------------------------------
    // Type: _Anonymous4_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous4_e__Union = *opaque{
    };
    // --------------------------------------------------------
    // Type: _Anonymous2_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous2_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: LPFNADDPROPSHEETPAGE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const LPFNADDPROPSHEETPAGE = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: LPFNADDPROPSHEETPAGES
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const LPFNADDPROPSHEETPAGES = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PSHNOTIFY
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PSHNOTIFY = extern struct {
    hdr: NMHDR,
    lParam: LPARAM,
};
// --------------------------------------------------------
// Type: INITCOMMONCONTROLSEX
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const INITCOMMONCONTROLSEX = extern struct {
    dwSize: u32,
    dwICC: u32,
};
// --------------------------------------------------------
// Type: COLORSCHEME
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const COLORSCHEME = extern struct {
    dwSize: u32,
    clrBtnHighlight: u32,
    clrBtnShadow: u32,
};
// --------------------------------------------------------
// Type: NMTOOLTIPSCREATED
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NMTOOLTIPSCREATED = extern struct {
    hdr: NMHDR,
    hwndToolTips: HWND,
};
// --------------------------------------------------------
// Type: NMMOUSE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NMMOUSE = extern struct {
    hdr: NMHDR,
    dwItemSpec: ?*opaque{},
    dwItemData: ?*opaque{},
    pt: POINT,
    dwHitInfo: LPARAM,
};
// --------------------------------------------------------
// Type: NMOBJECTNOTIFY
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NMOBJECTNOTIFY = extern struct {
    hdr: NMHDR,
    iItem: i32,
    piid: ?*Guid,
    pObject: ?*opaque{},
    hResult: HRESULT,
    dwFlags: u32,
};
// --------------------------------------------------------
// Type: NMKEY
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NMKEY = extern struct {
    hdr: NMHDR,
    nVKey: u32,
    uFlags: u32,
};
// --------------------------------------------------------
// Type: NMCHAR
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NMCHAR = extern struct {
    hdr: NMHDR,
    ch: u32,
    dwItemPrev: u32,
    dwItemNext: u32,
};
// --------------------------------------------------------
// Type: NMCUSTOMTEXT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NMCUSTOMTEXT = extern struct {
    hdr: NMHDR,
    hDC: HDC,
    lpString: ?*u16,
    nCount: i32,
    lpRect: ?*RECT,
    uFormat: u32,
    fLink: BOOL,
};
// --------------------------------------------------------
// Type: NMCUSTOMDRAW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NMCUSTOMDRAW = extern struct {
    hdr: NMHDR,
    dwDrawStage: u32,
    hdc: HDC,
    rc: RECT,
    dwItemSpec: ?*opaque{},
    uItemState: u32,
    lItemlParam: LPARAM,
};
// --------------------------------------------------------
// Type: NMTTCUSTOMDRAW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NMTTCUSTOMDRAW = extern struct {
    nmcd: NMCUSTOMDRAW,
    uDrawFlags: u32,
};
// --------------------------------------------------------
// Type: NMCUSTOMSPLITRECTINFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NMCUSTOMSPLITRECTINFO = extern struct {
    hdr: NMHDR,
    rcClient: RECT,
    rcButton: RECT,
    rcSplit: RECT,
};
// --------------------------------------------------------
// Type: _IMAGELIST
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const _IMAGELIST = opaque {
};
// --------------------------------------------------------
// Type: IMAGELISTDRAWPARAMS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const IMAGELISTDRAWPARAMS = extern struct {
    cbSize: u32,
    himl: HIMAGELIST,
    i: i32,
    hdcDst: HDC,
    x: i32,
    y: i32,
    cx: i32,
    cy: i32,
    xBitmap: i32,
    yBitmap: i32,
    rgbBk: u32,
    rgbFg: u32,
    fStyle: u32,
    dwRop: u32,
    fState: u32,
    Frame: u32,
    crEffect: u32,
};
// --------------------------------------------------------
// Type: IMAGEINFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const IMAGEINFO = extern struct {
    hbmImage: HBITMAP,
    hbmMask: HBITMAP,
    Unused1: i32,
    Unused2: i32,
    rcImage: RECT,
};
// --------------------------------------------------------
// Type: HD_TEXTFILTERA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HD_TEXTFILTERA = extern struct {
    pszText: ?*i8,
    cchTextMax: i32,
};
// --------------------------------------------------------
// Type: HD_TEXTFILTERW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HD_TEXTFILTERW = extern struct {
    pszText: ?*u16,
    cchTextMax: i32,
};
// --------------------------------------------------------
// Type: HDITEMA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HDITEMA = extern struct {
    mask: u32,
    cxy: i32,
    pszText: ?*i8,
    hbm: HBITMAP,
    cchTextMax: i32,
    fmt: i32,
    lParam: LPARAM,
    iImage: i32,
    iOrder: i32,
    type: u32,
    pvFilter: ?*opaque{},
    state: u32,
};
// --------------------------------------------------------
// Type: HDITEMW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HDITEMW = extern struct {
    mask: u32,
    cxy: i32,
    pszText: ?*u16,
    hbm: HBITMAP,
    cchTextMax: i32,
    fmt: i32,
    lParam: LPARAM,
    iImage: i32,
    iOrder: i32,
    type: u32,
    pvFilter: ?*opaque{},
    state: u32,
};
// --------------------------------------------------------
// Type: HDLAYOUT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HDLAYOUT = extern struct {
    prc: ?*RECT,
    pwpos: ?*WINDOWPOS,
};
// --------------------------------------------------------
// Type: HDHITTESTINFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HDHITTESTINFO = extern struct {
    pt: POINT,
    flags: u32,
    iItem: i32,
};
// --------------------------------------------------------
// Type: NMHEADERA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NMHEADERA = extern struct {
    hdr: NMHDR,
    iItem: i32,
    iButton: i32,
    pitem: ?*HDITEMA,
};
// --------------------------------------------------------
// Type: NMHEADERW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NMHEADERW = extern struct {
    hdr: NMHDR,
    iItem: i32,
    iButton: i32,
    pitem: ?*HDITEMW,
};
// --------------------------------------------------------
// Type: NMHDDISPINFOW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NMHDDISPINFOW = extern struct {
    hdr: NMHDR,
    iItem: i32,
    mask: u32,
    pszText: ?*u16,
    cchTextMax: i32,
    iImage: i32,
    lParam: LPARAM,
};
// --------------------------------------------------------
// Type: NMHDDISPINFOA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NMHDDISPINFOA = extern struct {
    hdr: NMHDR,
    iItem: i32,
    mask: u32,
    pszText: ?*i8,
    cchTextMax: i32,
    iImage: i32,
    lParam: LPARAM,
};
// --------------------------------------------------------
// Type: NMHDFILTERBTNCLICK
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NMHDFILTERBTNCLICK = extern struct {
    hdr: NMHDR,
    iItem: i32,
    rc: RECT,
};
// --------------------------------------------------------
// Type: TBBUTTON
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TBBUTTON = extern struct {
    iBitmap: i32,
    idCommand: i32,
    fsState: u8,
    fsStyle: u8,
    bReserved: ?[*]u8,
    dwData: ?*opaque{},
    iString: ?*opaque{},
};
// --------------------------------------------------------
// Type: COLORMAP
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const COLORMAP = extern struct {
    from: u32,
    to: u32,
};
// --------------------------------------------------------
// Type: NMTBCUSTOMDRAW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NMTBCUSTOMDRAW = extern struct {
    nmcd: NMCUSTOMDRAW,
    hbrMonoDither: HBRUSH,
    hbrLines: HBRUSH,
    hpenLines: HPEN,
    clrText: u32,
    clrMark: u32,
    clrTextHighlight: u32,
    clrBtnFace: u32,
    clrBtnHighlight: u32,
    clrHighlightHotTrack: u32,
    rcText: RECT,
    nStringBkMode: i32,
    nHLStringBkMode: i32,
    iListGap: i32,
};
// --------------------------------------------------------
// Type: TBADDBITMAP
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TBADDBITMAP = extern struct {
    hInst: HINSTANCE,
    nID: ?*opaque{},
};
// --------------------------------------------------------
// Type: TBSAVEPARAMSA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TBSAVEPARAMSA = extern struct {
    hkr: HKEY,
    pszSubKey: ?*i8,
    pszValueName: ?*i8,
};
// --------------------------------------------------------
// Type: TBSAVEPARAMSW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TBSAVEPARAMSW = extern struct {
    hkr: HKEY,
    pszSubKey: ?*u16,
    pszValueName: ?*u16,
};
// --------------------------------------------------------
// Type: TBINSERTMARK
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TBINSERTMARK = extern struct {
    iButton: i32,
    dwFlags: u32,
};
// --------------------------------------------------------
// Type: TBREPLACEBITMAP
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TBREPLACEBITMAP = extern struct {
    hInstOld: HINSTANCE,
    nIDOld: ?*opaque{},
    hInstNew: HINSTANCE,
    nIDNew: ?*opaque{},
    nButtons: i32,
};
// --------------------------------------------------------
// Type: TBBUTTONINFOA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TBBUTTONINFOA = extern struct {
    cbSize: u32,
    dwMask: u32,
    idCommand: i32,
    iImage: i32,
    fsState: u8,
    fsStyle: u8,
    cx: u16,
    lParam: ?*opaque{},
    pszText: ?*i8,
    cchText: i32,
};
// --------------------------------------------------------
// Type: TBBUTTONINFOW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TBBUTTONINFOW = extern struct {
    cbSize: u32,
    dwMask: u32,
    idCommand: i32,
    iImage: i32,
    fsState: u8,
    fsStyle: u8,
    cx: u16,
    lParam: ?*opaque{},
    pszText: ?*u16,
    cchText: i32,
};
// --------------------------------------------------------
// Type: TBMETRICS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TBMETRICS = extern struct {
    cbSize: u32,
    dwMask: u32,
    cxPad: i32,
    cyPad: i32,
    cxBarPad: i32,
    cyBarPad: i32,
    cxButtonSpacing: i32,
    cyButtonSpacing: i32,
};
// --------------------------------------------------------
// Type: NMTBHOTITEM
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NMTBHOTITEM = extern struct {
    hdr: NMHDR,
    idOld: i32,
    idNew: i32,
    dwFlags: u32,
};
// --------------------------------------------------------
// Type: NMTBSAVE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NMTBSAVE = extern struct {
    hdr: NMHDR,
    pData: ?*u32,
    pCurrent: ?*u32,
    cbData: u32,
    iItem: i32,
    cButtons: i32,
    tbButton: TBBUTTON,
};
// --------------------------------------------------------
// Type: NMTBRESTORE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NMTBRESTORE = extern struct {
    hdr: NMHDR,
    pData: ?*u32,
    pCurrent: ?*u32,
    cbData: u32,
    iItem: i32,
    cButtons: i32,
    cbBytesPerRecord: i32,
    tbButton: TBBUTTON,
};
// --------------------------------------------------------
// Type: NMTBGETINFOTIPA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NMTBGETINFOTIPA = extern struct {
    hdr: NMHDR,
    pszText: ?*i8,
    cchTextMax: i32,
    iItem: i32,
    lParam: LPARAM,
};
// --------------------------------------------------------
// Type: NMTBGETINFOTIPW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NMTBGETINFOTIPW = extern struct {
    hdr: NMHDR,
    pszText: ?*u16,
    cchTextMax: i32,
    iItem: i32,
    lParam: LPARAM,
};
// --------------------------------------------------------
// Type: NMTBDISPINFOA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NMTBDISPINFOA = extern struct {
    hdr: NMHDR,
    dwMask: u32,
    idCommand: i32,
    lParam: ?*opaque{},
    iImage: i32,
    pszText: ?*i8,
    cchText: i32,
};
// --------------------------------------------------------
// Type: NMTBDISPINFOW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NMTBDISPINFOW = extern struct {
    hdr: NMHDR,
    dwMask: u32,
    idCommand: i32,
    lParam: ?*opaque{},
    iImage: i32,
    pszText: ?*u16,
    cchText: i32,
};
// --------------------------------------------------------
// Type: NMTOOLBARA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NMTOOLBARA = extern struct {
    hdr: NMHDR,
    iItem: i32,
    tbButton: TBBUTTON,
    cchText: i32,
    pszText: ?*i8,
    rcButton: RECT,
};
// --------------------------------------------------------
// Type: NMTOOLBARW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NMTOOLBARW = extern struct {
    hdr: NMHDR,
    iItem: i32,
    tbButton: TBBUTTON,
    cchText: i32,
    pszText: ?*u16,
    rcButton: RECT,
};
// --------------------------------------------------------
// Type: REBARINFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const REBARINFO = extern struct {
    cbSize: u32,
    fMask: u32,
    himl: HIMAGELIST,
};
// --------------------------------------------------------
// Type: REBARBANDINFOA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const REBARBANDINFOA = extern struct {
    cbSize: u32,
    fMask: u32,
    fStyle: u32,
    clrFore: u32,
    clrBack: u32,
    lpText: ?*i8,
    cch: u32,
    iImage: i32,
    hwndChild: HWND,
    cxMinChild: u32,
    cyMinChild: u32,
    cx: u32,
    hbmBack: HBITMAP,
    wID: u32,
    cyChild: u32,
    cyMaxChild: u32,
    cyIntegral: u32,
    cxIdeal: u32,
    lParam: LPARAM,
    cxHeader: u32,
    rcChevronLocation: RECT,
    uChevronState: u32,
};
// --------------------------------------------------------
// Type: REBARBANDINFOW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const REBARBANDINFOW = extern struct {
    cbSize: u32,
    fMask: u32,
    fStyle: u32,
    clrFore: u32,
    clrBack: u32,
    lpText: ?*u16,
    cch: u32,
    iImage: i32,
    hwndChild: HWND,
    cxMinChild: u32,
    cyMinChild: u32,
    cx: u32,
    hbmBack: HBITMAP,
    wID: u32,
    cyChild: u32,
    cyMaxChild: u32,
    cyIntegral: u32,
    cxIdeal: u32,
    lParam: LPARAM,
    cxHeader: u32,
    rcChevronLocation: RECT,
    uChevronState: u32,
};
// --------------------------------------------------------
// Type: NMREBARCHILDSIZE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NMREBARCHILDSIZE = extern struct {
    hdr: NMHDR,
    uBand: u32,
    wID: u32,
    rcChild: RECT,
    rcBand: RECT,
};
// --------------------------------------------------------
// Type: NMREBAR
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NMREBAR = extern struct {
    hdr: NMHDR,
    dwMask: u32,
    uBand: u32,
    fStyle: u32,
    wID: u32,
    lParam: LPARAM,
};
// --------------------------------------------------------
// Type: NMRBAUTOSIZE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NMRBAUTOSIZE = extern struct {
    hdr: NMHDR,
    fChanged: BOOL,
    rcTarget: RECT,
    rcActual: RECT,
};
// --------------------------------------------------------
// Type: NMREBARCHEVRON
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NMREBARCHEVRON = extern struct {
    hdr: NMHDR,
    uBand: u32,
    wID: u32,
    lParam: LPARAM,
    rc: RECT,
    lParamNM: LPARAM,
};
// --------------------------------------------------------
// Type: NMREBARSPLITTER
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NMREBARSPLITTER = extern struct {
    hdr: NMHDR,
    rcSizing: RECT,
};
// --------------------------------------------------------
// Type: NMREBARAUTOBREAK
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NMREBARAUTOBREAK = extern struct {
    hdr: NMHDR,
    uBand: u32,
    wID: u32,
    lParam: LPARAM,
    uMsg: u32,
    fStyleCurrent: u32,
    fAutoBreak: BOOL,
};
// --------------------------------------------------------
// Type: RBHITTESTINFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const RBHITTESTINFO = extern struct {
    pt: POINT,
    flags: u32,
    iBand: i32,
};
// --------------------------------------------------------
// Type: TTTOOLINFOA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TTTOOLINFOA = extern struct {
    cbSize: u32,
    uFlags: u32,
    hwnd: HWND,
    uId: ?*opaque{},
    rect: RECT,
    hinst: HINSTANCE,
    lpszText: ?*i8,
    lParam: LPARAM,
    lpReserved: ?*opaque{},
};
// --------------------------------------------------------
// Type: TTTOOLINFOW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TTTOOLINFOW = extern struct {
    cbSize: u32,
    uFlags: u32,
    hwnd: HWND,
    uId: ?*opaque{},
    rect: RECT,
    hinst: HINSTANCE,
    lpszText: ?*u16,
    lParam: LPARAM,
    lpReserved: ?*opaque{},
};
// --------------------------------------------------------
// Type: TTGETTITLE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TTGETTITLE = extern struct {
    dwSize: u32,
    uTitleBitmap: u32,
    cch: u32,
    pszTitle: ?*u16,
};
// --------------------------------------------------------
// Type: TTHITTESTINFOA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TTHITTESTINFOA = extern struct {
    hwnd: HWND,
    pt: POINT,
    ti: TTTOOLINFOA,
};
// --------------------------------------------------------
// Type: TTHITTESTINFOW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TTHITTESTINFOW = extern struct {
    hwnd: HWND,
    pt: POINT,
    ti: TTTOOLINFOW,
};
// --------------------------------------------------------
// Type: NMTTDISPINFOA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NMTTDISPINFOA = extern struct {
    hdr: NMHDR,
    lpszText: ?*i8,
    szText: ?[*]i8,
    hinst: HINSTANCE,
    uFlags: u32,
    lParam: LPARAM,
};
// --------------------------------------------------------
// Type: NMTTDISPINFOW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NMTTDISPINFOW = extern struct {
    hdr: NMHDR,
    lpszText: ?*u16,
    szText: ?[*]u16,
    hinst: HINSTANCE,
    uFlags: u32,
    lParam: LPARAM,
};
// --------------------------------------------------------
// Type: NMTRBTHUMBPOSCHANGING
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NMTRBTHUMBPOSCHANGING = extern struct {
    hdr: NMHDR,
    dwPos: u32,
    nReason: i32,
};
// --------------------------------------------------------
// Type: DRAGLISTINFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DRAGLISTINFO = extern struct {
    uNotification: u32,
    hWnd: HWND,
    ptCursor: POINT,
};
// --------------------------------------------------------
// Type: UDACCEL
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const UDACCEL = extern struct {
    nSec: u32,
    nInc: u32,
};
// --------------------------------------------------------
// Type: NMUPDOWN
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NMUPDOWN = extern struct {
    hdr: NMHDR,
    iPos: i32,
    iDelta: i32,
};
// --------------------------------------------------------
// Type: PBRANGE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PBRANGE = extern struct {
    iLow: i32,
    iHigh: i32,
};
// --------------------------------------------------------
// Type: LITEM
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const LITEM = extern struct {
    mask: u32,
    iLink: i32,
    state: u32,
    stateMask: u32,
    szID: ?[*]u16,
    szUrl: ?[*]u16,
};
// --------------------------------------------------------
// Type: LHITTESTINFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const LHITTESTINFO = extern struct {
    pt: POINT,
    item: LITEM,
};
// --------------------------------------------------------
// Type: NMLINK
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NMLINK = extern struct {
    hdr: NMHDR,
    item: LITEM,
};
// --------------------------------------------------------
// Type: LVITEMA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const LVITEMA = extern struct {
    mask: u32,
    iItem: i32,
    iSubItem: i32,
    state: u32,
    stateMask: u32,
    pszText: ?*i8,
    cchTextMax: i32,
    iImage: i32,
    lParam: LPARAM,
    iIndent: i32,
    iGroupId: i32,
    cColumns: u32,
    puColumns: ?*u32,
    piColFmt: ?*i32,
    iGroup: i32,
};
// --------------------------------------------------------
// Type: LVITEMW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const LVITEMW = extern struct {
    mask: u32,
    iItem: i32,
    iSubItem: i32,
    state: u32,
    stateMask: u32,
    pszText: ?*u16,
    cchTextMax: i32,
    iImage: i32,
    lParam: LPARAM,
    iIndent: i32,
    iGroupId: i32,
    cColumns: u32,
    puColumns: ?*u32,
    piColFmt: ?*i32,
    iGroup: i32,
};
// --------------------------------------------------------
// Type: LVFINDINFOA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const LVFINDINFOA = extern struct {
    flags: u32,
    psz: ?*i8,
    lParam: LPARAM,
    pt: POINT,
    vkDirection: u32,
};
// --------------------------------------------------------
// Type: LVFINDINFOW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const LVFINDINFOW = extern struct {
    flags: u32,
    psz: ?*u16,
    lParam: LPARAM,
    pt: POINT,
    vkDirection: u32,
};
// --------------------------------------------------------
// Type: LVHITTESTINFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const LVHITTESTINFO = extern struct {
    pt: POINT,
    flags: u32,
    iItem: i32,
    iSubItem: i32,
    iGroup: i32,
};
// --------------------------------------------------------
// Type: LVCOLUMNA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const LVCOLUMNA = extern struct {
    mask: u32,
    fmt: i32,
    cx: i32,
    pszText: ?*i8,
    cchTextMax: i32,
    iSubItem: i32,
    iImage: i32,
    iOrder: i32,
    cxMin: i32,
    cxDefault: i32,
    cxIdeal: i32,
};
// --------------------------------------------------------
// Type: LVCOLUMNW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const LVCOLUMNW = extern struct {
    mask: u32,
    fmt: i32,
    cx: i32,
    pszText: ?*u16,
    cchTextMax: i32,
    iSubItem: i32,
    iImage: i32,
    iOrder: i32,
    cxMin: i32,
    cxDefault: i32,
    cxIdeal: i32,
};
// --------------------------------------------------------
// Type: PFNLVCOMPARE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFNLVCOMPARE = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: LVBKIMAGEA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const LVBKIMAGEA = extern struct {
    ulFlags: u32,
    hbm: HBITMAP,
    pszImage: ?*i8,
    cchImageMax: u32,
    xOffsetPercent: i32,
    yOffsetPercent: i32,
};
// --------------------------------------------------------
// Type: LVBKIMAGEW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const LVBKIMAGEW = extern struct {
    ulFlags: u32,
    hbm: HBITMAP,
    pszImage: ?*u16,
    cchImageMax: u32,
    xOffsetPercent: i32,
    yOffsetPercent: i32,
};
// --------------------------------------------------------
// Type: LVGROUP
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const LVGROUP = extern struct {
    cbSize: u32,
    mask: u32,
    pszHeader: ?*u16,
    cchHeader: i32,
    pszFooter: ?*u16,
    cchFooter: i32,
    iGroupId: i32,
    stateMask: u32,
    state: u32,
    uAlign: u32,
    pszSubtitle: ?*u16,
    cchSubtitle: u32,
    pszTask: ?*u16,
    cchTask: u32,
    pszDescriptionTop: ?*u16,
    cchDescriptionTop: u32,
    pszDescriptionBottom: ?*u16,
    cchDescriptionBottom: u32,
    iTitleImage: i32,
    iExtendedImage: i32,
    iFirstItem: i32,
    cItems: u32,
    pszSubsetTitle: ?*u16,
    cchSubsetTitle: u32,
};
// --------------------------------------------------------
// Type: LVGROUPMETRICS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const LVGROUPMETRICS = extern struct {
    cbSize: u32,
    mask: u32,
    Left: u32,
    Top: u32,
    Right: u32,
    Bottom: u32,
    crLeft: u32,
    crTop: u32,
    crRight: u32,
    crBottom: u32,
    crHeader: u32,
    crFooter: u32,
};
// --------------------------------------------------------
// Type: PFNLVGROUPCOMPARE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFNLVGROUPCOMPARE = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: LVINSERTGROUPSORTED
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const LVINSERTGROUPSORTED = extern struct {
    pfnGroupCompare: PFNLVGROUPCOMPARE,
    pvData: ?*opaque{},
    lvGroup: LVGROUP,
};
// --------------------------------------------------------
// Type: LVTILEVIEWINFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const LVTILEVIEWINFO = extern struct {
    cbSize: u32,
    dwMask: u32,
    dwFlags: u32,
    sizeTile: SIZE,
    cLines: i32,
    rcLabelMargin: RECT,
};
// --------------------------------------------------------
// Type: LVTILEINFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const LVTILEINFO = extern struct {
    cbSize: u32,
    iItem: i32,
    cColumns: u32,
    puColumns: ?*u32,
    piColFmt: ?*i32,
};
// --------------------------------------------------------
// Type: LVINSERTMARK
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const LVINSERTMARK = extern struct {
    cbSize: u32,
    dwFlags: u32,
    iItem: i32,
    dwReserved: u32,
};
// --------------------------------------------------------
// Type: LVSETINFOTIP
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const LVSETINFOTIP = extern struct {
    cbSize: u32,
    dwFlags: u32,
    pszText: ?*u16,
    iItem: i32,
    iSubItem: i32,
};
// --------------------------------------------------------
// Type: LVFOOTERINFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const LVFOOTERINFO = extern struct {
    mask: u32,
    pszText: ?*u16,
    cchTextMax: i32,
    cItems: u32,
};
// --------------------------------------------------------
// Type: LVFOOTERITEM
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const LVFOOTERITEM = extern struct {
    mask: u32,
    iItem: i32,
    pszText: ?*u16,
    cchTextMax: i32,
    state: u32,
    stateMask: u32,
};
// --------------------------------------------------------
// Type: LVITEMINDEX
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const LVITEMINDEX = extern struct {
    iItem: i32,
    iGroup: i32,
};
// --------------------------------------------------------
// Type: NMLISTVIEW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NMLISTVIEW = extern struct {
    hdr: NMHDR,
    iItem: i32,
    iSubItem: i32,
    uNewState: u32,
    uOldState: u32,
    uChanged: u32,
    ptAction: POINT,
    lParam: LPARAM,
};
// --------------------------------------------------------
// Type: NMITEMACTIVATE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NMITEMACTIVATE = extern struct {
    hdr: NMHDR,
    iItem: i32,
    iSubItem: i32,
    uNewState: u32,
    uOldState: u32,
    uChanged: u32,
    ptAction: POINT,
    lParam: LPARAM,
    uKeyFlags: u32,
};
// --------------------------------------------------------
// Type: NMLVCUSTOMDRAW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NMLVCUSTOMDRAW = extern struct {
    nmcd: NMCUSTOMDRAW,
    clrText: u32,
    clrTextBk: u32,
    iSubItem: i32,
    dwItemType: u32,
    clrFace: u32,
    iIconEffect: i32,
    iIconPhase: i32,
    iPartId: i32,
    iStateId: i32,
    rcText: RECT,
    uAlign: u32,
};
// --------------------------------------------------------
// Type: NMLVCACHEHINT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NMLVCACHEHINT = extern struct {
    hdr: NMHDR,
    iFrom: i32,
    iTo: i32,
};
// --------------------------------------------------------
// Type: NMLVFINDITEMA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NMLVFINDITEMA = extern struct {
    hdr: NMHDR,
    iStart: i32,
    lvfi: LVFINDINFOA,
};
// --------------------------------------------------------
// Type: NMLVFINDITEMW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NMLVFINDITEMW = extern struct {
    hdr: NMHDR,
    iStart: i32,
    lvfi: LVFINDINFOW,
};
// --------------------------------------------------------
// Type: NMLVODSTATECHANGE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NMLVODSTATECHANGE = extern struct {
    hdr: NMHDR,
    iFrom: i32,
    iTo: i32,
    uNewState: u32,
    uOldState: u32,
};
// --------------------------------------------------------
// Type: NMLVDISPINFOA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NMLVDISPINFOA = extern struct {
    hdr: NMHDR,
    item: LVITEMA,
};
// --------------------------------------------------------
// Type: NMLVDISPINFOW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NMLVDISPINFOW = extern struct {
    hdr: NMHDR,
    item: LVITEMW,
};
// --------------------------------------------------------
// Type: NMLVKEYDOWN
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const NMLVKEYDOWN = *opaque{
};
// --------------------------------------------------------
// Type: NMLVLINK
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NMLVLINK = extern struct {
    hdr: NMHDR,
    link: LITEM,
    iItem: i32,
    iSubItem: i32,
};
// --------------------------------------------------------
// Type: NMLVGETINFOTIPA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NMLVGETINFOTIPA = extern struct {
    hdr: NMHDR,
    dwFlags: u32,
    pszText: ?*i8,
    cchTextMax: i32,
    iItem: i32,
    iSubItem: i32,
    lParam: LPARAM,
};
// --------------------------------------------------------
// Type: NMLVGETINFOTIPW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NMLVGETINFOTIPW = extern struct {
    hdr: NMHDR,
    dwFlags: u32,
    pszText: ?*u16,
    cchTextMax: i32,
    iItem: i32,
    iSubItem: i32,
    lParam: LPARAM,
};
// --------------------------------------------------------
// Type: NMLVSCROLL
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NMLVSCROLL = extern struct {
    hdr: NMHDR,
    dx: i32,
    dy: i32,
};
// --------------------------------------------------------
// Type: NMLVEMPTYMARKUP
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NMLVEMPTYMARKUP = extern struct {
    hdr: NMHDR,
    dwFlags: u32,
    szMarkup: ?[*]u16,
};
// --------------------------------------------------------
// Type: _TREEITEM
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const _TREEITEM = opaque {
};
// --------------------------------------------------------
// Type: NMTVSTATEIMAGECHANGING
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NMTVSTATEIMAGECHANGING = extern struct {
    hdr: NMHDR,
    hti: ?*_TREEITEM,
    iOldStateImageIndex: i32,
    iNewStateImageIndex: i32,
};
// --------------------------------------------------------
// Type: TVITEMA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TVITEMA = extern struct {
    mask: u32,
    hItem: ?*_TREEITEM,
    state: u32,
    stateMask: u32,
    pszText: ?*i8,
    cchTextMax: i32,
    iImage: i32,
    iSelectedImage: i32,
    cChildren: i32,
    lParam: LPARAM,
};
// --------------------------------------------------------
// Type: TVITEMW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TVITEMW = extern struct {
    mask: u32,
    hItem: ?*_TREEITEM,
    state: u32,
    stateMask: u32,
    pszText: ?*u16,
    cchTextMax: i32,
    iImage: i32,
    iSelectedImage: i32,
    cChildren: i32,
    lParam: LPARAM,
};
// --------------------------------------------------------
// Type: TVITEMEXA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TVITEMEXA = extern struct {
    mask: u32,
    hItem: ?*_TREEITEM,
    state: u32,
    stateMask: u32,
    pszText: ?*i8,
    cchTextMax: i32,
    iImage: i32,
    iSelectedImage: i32,
    cChildren: i32,
    lParam: LPARAM,
    iIntegral: i32,
    uStateEx: u32,
    hwnd: HWND,
    iExpandedImage: i32,
    iReserved: i32,
};
// --------------------------------------------------------
// Type: TVITEMEXW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TVITEMEXW = extern struct {
    mask: u32,
    hItem: ?*_TREEITEM,
    state: u32,
    stateMask: u32,
    pszText: ?*u16,
    cchTextMax: i32,
    iImage: i32,
    iSelectedImage: i32,
    cChildren: i32,
    lParam: LPARAM,
    iIntegral: i32,
    uStateEx: u32,
    hwnd: HWND,
    iExpandedImage: i32,
    iReserved: i32,
};
// --------------------------------------------------------
// Type: TVINSERTSTRUCTA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TVINSERTSTRUCTA = extern struct {
    hParent: ?*_TREEITEM,
    hInsertAfter: ?*_TREEITEM,
    Anonymous: _Anonymous_e__Union,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: TVINSERTSTRUCTW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TVINSERTSTRUCTW = extern struct {
    hParent: ?*_TREEITEM,
    hInsertAfter: ?*_TREEITEM,
    Anonymous: _Anonymous_e__Union,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: TVHITTESTINFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TVHITTESTINFO = extern struct {
    pt: POINT,
    flags: u32,
    hItem: ?*_TREEITEM,
};
// --------------------------------------------------------
// Type: TVITEMPART
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const TVITEMPART = *opaque{
};
// --------------------------------------------------------
// Type: TVGETITEMPARTRECTINFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TVGETITEMPARTRECTINFO = extern struct {
    hti: ?*_TREEITEM,
    prc: ?*RECT,
    partID: TVITEMPART,
};
// --------------------------------------------------------
// Type: PFNTVCOMPARE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFNTVCOMPARE = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: TVSORTCB
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TVSORTCB = extern struct {
    hParent: ?*_TREEITEM,
    lpfnCompare: PFNTVCOMPARE,
    lParam: LPARAM,
};
// --------------------------------------------------------
// Type: NMTREEVIEWA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NMTREEVIEWA = extern struct {
    hdr: NMHDR,
    action: u32,
    itemOld: TVITEMA,
    itemNew: TVITEMA,
    ptDrag: POINT,
};
// --------------------------------------------------------
// Type: NMTREEVIEWW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NMTREEVIEWW = extern struct {
    hdr: NMHDR,
    action: u32,
    itemOld: TVITEMW,
    itemNew: TVITEMW,
    ptDrag: POINT,
};
// --------------------------------------------------------
// Type: NMTVDISPINFOA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NMTVDISPINFOA = extern struct {
    hdr: NMHDR,
    item: TVITEMA,
};
// --------------------------------------------------------
// Type: NMTVDISPINFOW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NMTVDISPINFOW = extern struct {
    hdr: NMHDR,
    item: TVITEMW,
};
// --------------------------------------------------------
// Type: NMTVDISPINFOEXA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NMTVDISPINFOEXA = extern struct {
    hdr: NMHDR,
    item: TVITEMEXA,
};
// --------------------------------------------------------
// Type: NMTVDISPINFOEXW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NMTVDISPINFOEXW = extern struct {
    hdr: NMHDR,
    item: TVITEMEXW,
};
// --------------------------------------------------------
// Type: NMTVKEYDOWN
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const NMTVKEYDOWN = *opaque{
};
// --------------------------------------------------------
// Type: NMTVCUSTOMDRAW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NMTVCUSTOMDRAW = extern struct {
    nmcd: NMCUSTOMDRAW,
    clrText: u32,
    clrTextBk: u32,
    iLevel: i32,
};
// --------------------------------------------------------
// Type: NMTVGETINFOTIPA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NMTVGETINFOTIPA = extern struct {
    hdr: NMHDR,
    pszText: ?*i8,
    cchTextMax: i32,
    hItem: ?*_TREEITEM,
    lParam: LPARAM,
};
// --------------------------------------------------------
// Type: NMTVGETINFOTIPW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NMTVGETINFOTIPW = extern struct {
    hdr: NMHDR,
    pszText: ?*u16,
    cchTextMax: i32,
    hItem: ?*_TREEITEM,
    lParam: LPARAM,
};
// --------------------------------------------------------
// Type: NMTVITEMCHANGE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NMTVITEMCHANGE = extern struct {
    hdr: NMHDR,
    uChanged: u32,
    hItem: ?*_TREEITEM,
    uStateNew: u32,
    uStateOld: u32,
    lParam: LPARAM,
};
// --------------------------------------------------------
// Type: NMTVASYNCDRAW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NMTVASYNCDRAW = extern struct {
    hdr: NMHDR,
    pimldp: ?*IMAGELISTDRAWPARAMS,
    hr: HRESULT,
    hItem: ?*_TREEITEM,
    lParam: LPARAM,
    dwRetFlags: u32,
    iRetImageIndex: i32,
};
// --------------------------------------------------------
// Type: COMBOBOXEXITEMA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const COMBOBOXEXITEMA = extern struct {
    mask: u32,
    iItem: ?*opaque{},
    pszText: ?*i8,
    cchTextMax: i32,
    iImage: i32,
    iSelectedImage: i32,
    iOverlay: i32,
    iIndent: i32,
    lParam: LPARAM,
};
// --------------------------------------------------------
// Type: COMBOBOXEXITEMW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const COMBOBOXEXITEMW = extern struct {
    mask: u32,
    iItem: ?*opaque{},
    pszText: ?*u16,
    cchTextMax: i32,
    iImage: i32,
    iSelectedImage: i32,
    iOverlay: i32,
    iIndent: i32,
    lParam: LPARAM,
};
// --------------------------------------------------------
// Type: NMCOMBOBOXEXA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NMCOMBOBOXEXA = extern struct {
    hdr: NMHDR,
    ceItem: COMBOBOXEXITEMA,
};
// --------------------------------------------------------
// Type: NMCOMBOBOXEXW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NMCOMBOBOXEXW = extern struct {
    hdr: NMHDR,
    ceItem: COMBOBOXEXITEMW,
};
// --------------------------------------------------------
// Type: NMCBEDRAGBEGINW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NMCBEDRAGBEGINW = extern struct {
    hdr: NMHDR,
    iItemid: i32,
    szText: ?[*]u16,
};
// --------------------------------------------------------
// Type: NMCBEDRAGBEGINA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NMCBEDRAGBEGINA = extern struct {
    hdr: NMHDR,
    iItemid: i32,
    szText: ?[*]i8,
};
// --------------------------------------------------------
// Type: NMCBEENDEDITW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NMCBEENDEDITW = extern struct {
    hdr: NMHDR,
    fChanged: BOOL,
    iNewSelection: i32,
    szText: ?[*]u16,
    iWhy: i32,
};
// --------------------------------------------------------
// Type: NMCBEENDEDITA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NMCBEENDEDITA = extern struct {
    hdr: NMHDR,
    fChanged: BOOL,
    iNewSelection: i32,
    szText: ?[*]i8,
    iWhy: i32,
};
// --------------------------------------------------------
// Type: TCITEMHEADERA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TCITEMHEADERA = extern struct {
    mask: u32,
    lpReserved1: u32,
    lpReserved2: u32,
    pszText: ?*i8,
    cchTextMax: i32,
    iImage: i32,
};
// --------------------------------------------------------
// Type: TCITEMHEADERW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TCITEMHEADERW = extern struct {
    mask: u32,
    lpReserved1: u32,
    lpReserved2: u32,
    pszText: ?*u16,
    cchTextMax: i32,
    iImage: i32,
};
// --------------------------------------------------------
// Type: TCITEMA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TCITEMA = extern struct {
    mask: u32,
    dwState: u32,
    dwStateMask: u32,
    pszText: ?*i8,
    cchTextMax: i32,
    iImage: i32,
    lParam: LPARAM,
};
// --------------------------------------------------------
// Type: TCITEMW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TCITEMW = extern struct {
    mask: u32,
    dwState: u32,
    dwStateMask: u32,
    pszText: ?*u16,
    cchTextMax: i32,
    iImage: i32,
    lParam: LPARAM,
};
// --------------------------------------------------------
// Type: TCHITTESTINFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TCHITTESTINFO = extern struct {
    pt: POINT,
    flags: u32,
};
// --------------------------------------------------------
// Type: NMTCKEYDOWN
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const NMTCKEYDOWN = *opaque{
};
// --------------------------------------------------------
// Type: MCHITTESTINFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const MCHITTESTINFO = extern struct {
    cbSize: u32,
    pt: POINT,
    uHit: u32,
    st: SYSTEMTIME,
    rc: RECT,
    iOffset: i32,
    iRow: i32,
    iCol: i32,
};
// --------------------------------------------------------
// Type: MCGRIDINFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const MCGRIDINFO = extern struct {
    cbSize: u32,
    dwPart: u32,
    dwFlags: u32,
    iCalendar: i32,
    iRow: i32,
    iCol: i32,
    bSelected: BOOL,
    stStart: SYSTEMTIME,
    stEnd: SYSTEMTIME,
    rc: RECT,
    pszName: ?*u16,
    cchName: ?*opaque{},
};
// --------------------------------------------------------
// Type: NMSELCHANGE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NMSELCHANGE = extern struct {
    nmhdr: NMHDR,
    stSelStart: SYSTEMTIME,
    stSelEnd: SYSTEMTIME,
};
// --------------------------------------------------------
// Type: NMDAYSTATE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NMDAYSTATE = extern struct {
    nmhdr: NMHDR,
    stStart: SYSTEMTIME,
    cDayState: i32,
    prgDayState: ?*u32,
};
// --------------------------------------------------------
// Type: NMVIEWCHANGE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NMVIEWCHANGE = extern struct {
    nmhdr: NMHDR,
    dwOldView: u32,
    dwNewView: u32,
};
// --------------------------------------------------------
// Type: DATETIMEPICKERINFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DATETIMEPICKERINFO = extern struct {
    cbSize: u32,
    rcCheck: RECT,
    stateCheck: u32,
    rcButton: RECT,
    stateButton: u32,
    hwndEdit: HWND,
    hwndUD: HWND,
    hwndDropDown: HWND,
};
// --------------------------------------------------------
// Type: NMDATETIMECHANGE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NMDATETIMECHANGE = extern struct {
    nmhdr: NMHDR,
    dwFlags: u32,
    st: SYSTEMTIME,
};
// --------------------------------------------------------
// Type: NMDATETIMESTRINGA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NMDATETIMESTRINGA = extern struct {
    nmhdr: NMHDR,
    pszUserString: ?*i8,
    st: SYSTEMTIME,
    dwFlags: u32,
};
// --------------------------------------------------------
// Type: NMDATETIMESTRINGW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NMDATETIMESTRINGW = extern struct {
    nmhdr: NMHDR,
    pszUserString: ?*u16,
    st: SYSTEMTIME,
    dwFlags: u32,
};
// --------------------------------------------------------
// Type: NMDATETIMEWMKEYDOWNA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NMDATETIMEWMKEYDOWNA = extern struct {
    nmhdr: NMHDR,
    nVirtKey: i32,
    pszFormat: ?*i8,
    st: SYSTEMTIME,
};
// --------------------------------------------------------
// Type: NMDATETIMEWMKEYDOWNW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NMDATETIMEWMKEYDOWNW = extern struct {
    nmhdr: NMHDR,
    nVirtKey: i32,
    pszFormat: ?*u16,
    st: SYSTEMTIME,
};
// --------------------------------------------------------
// Type: NMDATETIMEFORMATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NMDATETIMEFORMATA = extern struct {
    nmhdr: NMHDR,
    pszFormat: ?*i8,
    st: SYSTEMTIME,
    pszDisplay: ?*i8,
    szDisplay: ?[*]i8,
};
// --------------------------------------------------------
// Type: NMDATETIMEFORMATW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NMDATETIMEFORMATW = extern struct {
    nmhdr: NMHDR,
    pszFormat: ?*u16,
    st: SYSTEMTIME,
    pszDisplay: ?*u16,
    szDisplay: ?[*]u16,
};
// --------------------------------------------------------
// Type: NMDATETIMEFORMATQUERYA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NMDATETIMEFORMATQUERYA = extern struct {
    nmhdr: NMHDR,
    pszFormat: ?*i8,
    szMax: SIZE,
};
// --------------------------------------------------------
// Type: NMDATETIMEFORMATQUERYW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NMDATETIMEFORMATQUERYW = extern struct {
    nmhdr: NMHDR,
    pszFormat: ?*u16,
    szMax: SIZE,
};
// --------------------------------------------------------
// Type: NMIPADDRESS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NMIPADDRESS = extern struct {
    hdr: NMHDR,
    iField: i32,
    iValue: i32,
};
// --------------------------------------------------------
// Type: NMPGSCROLL
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const NMPGSCROLL = *opaque{
};
// --------------------------------------------------------
// Type: NMPGCALCSIZE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NMPGCALCSIZE = extern struct {
    hdr: NMHDR,
    dwFlag: u32,
    iWidth: i32,
    iHeight: i32,
};
// --------------------------------------------------------
// Type: NMPGHOTITEM
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NMPGHOTITEM = extern struct {
    hdr: NMHDR,
    idOld: i32,
    idNew: i32,
    dwFlags: u32,
};
// --------------------------------------------------------
// Type: BUTTON_IMAGELIST
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const BUTTON_IMAGELIST = extern struct {
    himl: HIMAGELIST,
    margin: RECT,
    uAlign: u32,
};
// --------------------------------------------------------
// Type: NMBCHOTITEM
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NMBCHOTITEM = extern struct {
    hdr: NMHDR,
    dwFlags: u32,
};
// --------------------------------------------------------
// Type: BUTTON_SPLITINFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const BUTTON_SPLITINFO = extern struct {
    mask: u32,
    himlGlyph: HIMAGELIST,
    uSplitStyle: u32,
    size: SIZE,
};
// --------------------------------------------------------
// Type: NMBCDROPDOWN
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NMBCDROPDOWN = extern struct {
    hdr: NMHDR,
    rcButton: RECT,
};
// --------------------------------------------------------
// Type: EDITBALLOONTIP
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const EDITBALLOONTIP = extern struct {
    cbStruct: u32,
    pszTitle: ?*u16,
    pszText: ?*u16,
    ttiIcon: i32,
};
// --------------------------------------------------------
// Type: EC_ENDOFLINE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const EC_ENDOFLINE = *opaque{
};
// --------------------------------------------------------
// Type: EC_SEARCHWEB_ENTRYPOINT
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const EC_SEARCHWEB_ENTRYPOINT = *opaque{
};
// --------------------------------------------------------
// Type: NMSEARCHWEB
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NMSEARCHWEB = extern struct {
    hdr: NMHDR,
    entrypoint: EC_SEARCHWEB_ENTRYPOINT,
    hasQueryText: BOOL,
    invokeSucceeded: BOOL,
};
// --------------------------------------------------------
// Type: PFTASKDIALOGCALLBACK
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFTASKDIALOGCALLBACK = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: _TASKDIALOG_FLAGS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const _TASKDIALOG_FLAGS = *opaque{
};
// --------------------------------------------------------
// Type: TASKDIALOG_MESSAGES
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const TASKDIALOG_MESSAGES = *opaque{
};
// --------------------------------------------------------
// Type: TASKDIALOG_NOTIFICATIONS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const TASKDIALOG_NOTIFICATIONS = *opaque{
};
// --------------------------------------------------------
// Type: TASKDIALOG_BUTTON
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const TASKDIALOG_BUTTON = *opaque{
};
// --------------------------------------------------------
// Type: TASKDIALOG_ELEMENTS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const TASKDIALOG_ELEMENTS = *opaque{
};
// --------------------------------------------------------
// Type: TASKDIALOG_ICON_ELEMENTS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const TASKDIALOG_ICON_ELEMENTS = *opaque{
};
// --------------------------------------------------------
// Type: _TASKDIALOG_COMMON_BUTTON_FLAGS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const _TASKDIALOG_COMMON_BUTTON_FLAGS = *opaque{
};
// --------------------------------------------------------
// Type: TASKDIALOGCONFIG
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const TASKDIALOGCONFIG = *opaque{
    // --------------------------------------------------------
    // Type: _Anonymous2_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous2_e__Union = *opaque{
    };
    // --------------------------------------------------------
    // Type: _Anonymous1_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous1_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: PFNDAENUMCALLBACK
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFNDAENUMCALLBACK = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PFNDAENUMCALLBACKCONST
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFNDAENUMCALLBACKCONST = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PFNDACOMPARE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFNDACOMPARE = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PFNDACOMPARECONST
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFNDACOMPARECONST = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: _DSA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const _DSA = opaque {
};
// --------------------------------------------------------
// Type: _DPA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const _DPA = opaque {
};
// --------------------------------------------------------
// Type: DPASTREAMINFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DPASTREAMINFO = extern struct {
    iPos: i32,
    pvItem: ?*opaque{},
};
// --------------------------------------------------------
// Type: PFNDPASTREAM
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFNDPASTREAM = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PFNDPAMERGE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFNDPAMERGE = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PFNDPAMERGECONST
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFNDPAMERGECONST = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: _LI_METRIC
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const _LI_METRIC = *opaque{
};
// --------------------------------------------------------
// Type: ImageList
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const ImageList = opaque {
};
// --------------------------------------------------------
// Type: IImageList
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IImageList = *opaque{
    // TODO: Method 'Add'
    // TODO: Method 'ReplaceIcon'
    // TODO: Method 'SetOverlayImage'
    // TODO: Method 'Replace'
    // TODO: Method 'AddMasked'
    // TODO: Method 'Draw'
    // TODO: Method 'Remove'
    // TODO: Method 'GetIcon'
    // TODO: Method 'GetImageInfo'
    // TODO: Method 'Copy'
    // TODO: Method 'Merge'
    // TODO: Method 'Clone'
    // TODO: Method 'GetImageRect'
    // TODO: Method 'GetIconSize'
    // TODO: Method 'SetIconSize'
    // TODO: Method 'GetImageCount'
    // TODO: Method 'SetImageCount'
    // TODO: Method 'SetBkColor'
    // TODO: Method 'GetBkColor'
    // TODO: Method 'BeginDrag'
    // TODO: Method 'EndDrag'
    // TODO: Method 'DragEnter'
    // TODO: Method 'DragLeave'
    // TODO: Method 'DragMove'
    // TODO: Method 'SetDragCursorImage'
    // TODO: Method 'DragShowNolock'
    // TODO: Method 'GetDragImage'
    // TODO: Method 'GetItemFlags'
    // TODO: Method 'GetOverlayImage'
};
// --------------------------------------------------------
// Type: IMAGELISTSTATS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const IMAGELISTSTATS = extern struct {
    cbSize: u32,
    cAlloc: i32,
    cUsed: i32,
    cStandby: i32,
};
// --------------------------------------------------------
// Type: IImageList2
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IImageList2 = *opaque{
    // TODO: Method 'Resize'
    // TODO: Method 'GetOriginalSize'
    // TODO: Method 'SetOriginalSize'
    // TODO: Method 'SetCallback'
    // TODO: Method 'GetCallback'
    // TODO: Method 'ForceImagePresent'
    // TODO: Method 'DiscardImages'
    // TODO: Method 'PreloadImages'
    // TODO: Method 'GetStatistics'
    // TODO: Method 'Initialize'
    // TODO: Method 'Replace2'
    // TODO: Method 'ReplaceFromImageList'
};
// --------------------------------------------------------
// Type: TEXTMODE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const TEXTMODE = *opaque{
};
// --------------------------------------------------------
// Type: IMECOMPTEXT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const IMECOMPTEXT = extern struct {
    cb: i32,
    flags: u32,
};
// --------------------------------------------------------
// Type: TABLEROWPARMS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TABLEROWPARMS = extern struct {
    cbRow: u8,
    cbCell: u8,
    cCell: u8,
    cRow: u8,
    dxCellMargin: i32,
    dxIndent: i32,
    dyHeight: i32,
    _bitfield: u32,
    cpStartRow: i32,
    bTableLevel: u8,
    iCell: u8,
};
// --------------------------------------------------------
// Type: TABLECELLPARMS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TABLECELLPARMS = extern struct {
    dxWidth: i32,
    _bitfield: u16,
    wShading: u16,
    dxBrdrLeft: i16,
    dyBrdrTop: i16,
    dxBrdrRight: i16,
    dyBrdrBottom: i16,
    crBrdrLeft: u32,
    crBrdrTop: u32,
    crBrdrRight: u32,
    crBrdrBottom: u32,
    crBackPat: u32,
    crForePat: u32,
};
// --------------------------------------------------------
// Type: AutoCorrectProc
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const AutoCorrectProc = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: RICHEDIT_IMAGE_PARAMETERS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const RICHEDIT_IMAGE_PARAMETERS = extern struct {
    xWidth: i32,
    yHeight: i32,
    Ascent: i32,
    Type: i32,
    pwszAlternateText: ?*u16,
    pIStream: IStream,
};
// --------------------------------------------------------
// Type: ENDCOMPOSITIONNOTIFY
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const ENDCOMPOSITIONNOTIFY = extern struct {
    nmhdr: NMHDR,
    dwCode: u32,
};
// --------------------------------------------------------
// Type: EDITWORDBREAKPROCEX
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const EDITWORDBREAKPROCEX = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: CHARFORMATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CHARFORMATA = extern struct {
    cbSize: u32,
    dwMask: u32,
    dwEffects: u32,
    yHeight: i32,
    yOffset: i32,
    crTextColor: u32,
    bCharSet: u8,
    bPitchAndFamily: u8,
    szFaceName: ?[*]i8,
};
// --------------------------------------------------------
// Type: CHARFORMATW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CHARFORMATW = extern struct {
    cbSize: u32,
    dwMask: u32,
    dwEffects: u32,
    yHeight: i32,
    yOffset: i32,
    crTextColor: u32,
    bCharSet: u8,
    bPitchAndFamily: u8,
    szFaceName: ?[*]u16,
};
// --------------------------------------------------------
// Type: CHARFORMAT2W
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CHARFORMAT2W = extern struct {
    __AnonymousBase_richedit_L711_C23: CHARFORMATW,
    wWeight: u16,
    sSpacing: i16,
    crBackColor: u32,
    lcid: u32,
    Anonymous: _Anonymous_e__Union,
    sStyle: i16,
    wKerning: u16,
    bUnderlineType: u8,
    bAnimation: u8,
    bRevAuthor: u8,
    bUnderlineColor: u8,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: CHARFORMAT2A
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CHARFORMAT2A = extern struct {
    __AnonymousBase_richedit_L736_C23: CHARFORMATA,
    wWeight: u16,
    sSpacing: i16,
    crBackColor: u32,
    lcid: u32,
    Anonymous: _Anonymous_e__Union,
    sStyle: i16,
    wKerning: u16,
    bUnderlineType: u8,
    bAnimation: u8,
    bRevAuthor: u8,
    bUnderlineColor: u8,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: CHARRANGE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CHARRANGE = extern struct {
    cpMin: i32,
    cpMax: i32,
};
// --------------------------------------------------------
// Type: TEXTRANGEA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TEXTRANGEA = extern struct {
    chrg: CHARRANGE,
    lpstrText: ?*i8,
};
// --------------------------------------------------------
// Type: TEXTRANGEW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TEXTRANGEW = extern struct {
    chrg: CHARRANGE,
    lpstrText: ?*u16,
};
// --------------------------------------------------------
// Type: EDITSTREAMCALLBACK
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const EDITSTREAMCALLBACK = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: EDITSTREAM
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const EDITSTREAM = extern struct {
    dwCookie: ?*opaque{},
    dwError: u32,
    pfnCallback: EDITSTREAMCALLBACK,
};
// --------------------------------------------------------
// Type: FINDTEXTA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const FINDTEXTA = extern struct {
    chrg: CHARRANGE,
    lpstrText: ?*i8,
};
// --------------------------------------------------------
// Type: FINDTEXTW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const FINDTEXTW = extern struct {
    chrg: CHARRANGE,
    lpstrText: ?*u16,
};
// --------------------------------------------------------
// Type: FINDTEXTEXA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const FINDTEXTEXA = extern struct {
    chrg: CHARRANGE,
    lpstrText: ?*i8,
    chrgText: CHARRANGE,
};
// --------------------------------------------------------
// Type: FINDTEXTEXW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const FINDTEXTEXW = extern struct {
    chrg: CHARRANGE,
    lpstrText: ?*u16,
    chrgText: CHARRANGE,
};
// --------------------------------------------------------
// Type: FORMATRANGE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const FORMATRANGE = extern struct {
    hdc: HDC,
    hdcTarget: HDC,
    rc: RECT,
    rcPage: RECT,
    chrg: CHARRANGE,
};
// --------------------------------------------------------
// Type: PARAFORMAT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PARAFORMAT = extern struct {
    cbSize: u32,
    dwMask: u32,
    wNumbering: u16,
    Anonymous: _Anonymous_e__Union,
    dxStartIndent: i32,
    dxRightIndent: i32,
    dxOffset: i32,
    wAlignment: u16,
    cTabCount: i16,
    rgxTabs: ?[*]i32,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: PARAFORMAT2
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PARAFORMAT2 = extern struct {
    __AnonymousBase_richedit_L1149_C22: PARAFORMAT,
    dySpaceBefore: i32,
    dySpaceAfter: i32,
    dyLineSpacing: i32,
    sStyle: i16,
    bLineSpacingRule: u8,
    bOutlineLevel: u8,
    wShadingWeight: u16,
    wShadingStyle: u16,
    wNumberingStart: u16,
    wNumberingStyle: u16,
    wNumberingTab: u16,
    wBorderSpace: u16,
    wBorderWidth: u16,
    wBorders: u16,
};
// --------------------------------------------------------
// Type: MSGFILTER
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const MSGFILTER = extern struct {
    nmhdr: NMHDR,
    msg: u32,
    wParam: WPARAM,
    lParam: LPARAM,
};
// --------------------------------------------------------
// Type: REQRESIZE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const REQRESIZE = extern struct {
    nmhdr: NMHDR,
    rc: RECT,
};
// --------------------------------------------------------
// Type: SELCHANGE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SELCHANGE = extern struct {
    nmhdr: NMHDR,
    chrg: CHARRANGE,
    seltyp: u16,
};
// --------------------------------------------------------
// Type: _grouptypingchange
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const _grouptypingchange = extern struct {
    nmhdr: NMHDR,
    fGroupTyping: BOOL,
};
// --------------------------------------------------------
// Type: CLIPBOARDFORMAT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CLIPBOARDFORMAT = extern struct {
    nmhdr: NMHDR,
    cf: u16,
};
// --------------------------------------------------------
// Type: GETCONTEXTMENUEX
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const GETCONTEXTMENUEX = extern struct {
    chrg: CHARRANGE,
    dwFlags: u32,
    pt: POINT,
    pvReserved: ?*opaque{},
};
// --------------------------------------------------------
// Type: ENDROPFILES
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const ENDROPFILES = extern struct {
    nmhdr: NMHDR,
    hDrop: HANDLE,
    cp: i32,
    fProtected: BOOL,
};
// --------------------------------------------------------
// Type: ENPROTECTED
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const ENPROTECTED = extern struct {
    nmhdr: NMHDR,
    msg: u32,
    wParam: WPARAM,
    lParam: LPARAM,
    chrg: CHARRANGE,
};
// --------------------------------------------------------
// Type: ENSAVECLIPBOARD
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const ENSAVECLIPBOARD = extern struct {
    nmhdr: NMHDR,
    cObjectCount: i32,
    cch: i32,
};
// --------------------------------------------------------
// Type: ENOLEOPFAILED
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const ENOLEOPFAILED = extern struct {
    nmhdr: NMHDR,
    iob: i32,
    lOper: i32,
    hr: HRESULT,
};
// --------------------------------------------------------
// Type: OBJECTPOSITIONS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const OBJECTPOSITIONS = extern struct {
    nmhdr: NMHDR,
    cObjectCount: i32,
    pcpPositions: ?*i32,
};
// --------------------------------------------------------
// Type: ENLINK
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const ENLINK = extern struct {
    nmhdr: NMHDR,
    msg: u32,
    wParam: WPARAM,
    lParam: LPARAM,
    chrg: CHARRANGE,
};
// --------------------------------------------------------
// Type: ENLOWFIRTF
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const ENLOWFIRTF = extern struct {
    nmhdr: NMHDR,
    szControl: ?*i8,
};
// --------------------------------------------------------
// Type: ENCORRECTTEXT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const ENCORRECTTEXT = extern struct {
    nmhdr: NMHDR,
    chrg: CHARRANGE,
    seltyp: u16,
};
// --------------------------------------------------------
// Type: PUNCTUATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PUNCTUATION = extern struct {
    iSize: u32,
    szPunctuation: ?*i8,
};
// --------------------------------------------------------
// Type: COMPCOLOR
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const COMPCOLOR = extern struct {
    crText: u32,
    crBackground: u32,
    dwEffects: u32,
};
// --------------------------------------------------------
// Type: REPASTESPECIAL
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const REPASTESPECIAL = extern struct {
    dwAspect: u32,
    dwParam: ?*opaque{},
};
// --------------------------------------------------------
// Type: UNDONAMEID
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UNDONAMEID = *opaque{
};
// --------------------------------------------------------
// Type: SETTEXTEX
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SETTEXTEX = extern struct {
    flags: u32,
    codepage: u32,
};
// --------------------------------------------------------
// Type: GETTEXTEX
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const GETTEXTEX = extern struct {
    cb: u32,
    flags: u32,
    codepage: u32,
    lpDefaultChar: ?*i8,
    lpUsedDefChar: ?*i32,
};
// --------------------------------------------------------
// Type: GETTEXTLENGTHEX
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const GETTEXTLENGTHEX = extern struct {
    flags: u32,
    codepage: u32,
};
// --------------------------------------------------------
// Type: BIDIOPTIONS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const BIDIOPTIONS = extern struct {
    cbSize: u32,
    wMask: u16,
    wEffects: u16,
};
// --------------------------------------------------------
// Type: KHYPH
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const KHYPH = *opaque{
};
// --------------------------------------------------------
// Type: hyphresult
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const hyphresult = extern struct {
    khyph: KHYPH,
    ichHyph: i32,
    chHyph: u16,
};
// --------------------------------------------------------
// Type: HYPHENATEINFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HYPHENATEINFO = extern struct {
    cbSize: i16,
    dxHyphenateZone: i16,
    pfnHyphenate: ?*opaque{},
};
// --------------------------------------------------------
// Type: tomConstants
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const tomConstants = *opaque{
};
// --------------------------------------------------------
// Type: OBJECTTYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const OBJECTTYPE = *opaque{
};
// --------------------------------------------------------
// Type: MANCODE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const MANCODE = *opaque{
};
// --------------------------------------------------------
// Type: ITextDocument
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ITextDocument = *opaque{
    // TODO: Method 'GetName'
    // TODO: Method 'GetSelection'
    // TODO: Method 'GetStoryCount'
    // TODO: Method 'GetStoryRanges'
    // TODO: Method 'GetSaved'
    // TODO: Method 'SetSaved'
    // TODO: Method 'GetDefaultTabStop'
    // TODO: Method 'SetDefaultTabStop'
    // TODO: Method 'New'
    // TODO: Method 'Open'
    // TODO: Method 'Save'
    // TODO: Method 'Freeze'
    // TODO: Method 'Unfreeze'
    // TODO: Method 'BeginEditCollection'
    // TODO: Method 'EndEditCollection'
    // TODO: Method 'Undo'
    // TODO: Method 'Redo'
    // TODO: Method 'Range'
    // TODO: Method 'RangeFromPoint'
};
// --------------------------------------------------------
// Type: ITextRange
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ITextRange = *opaque{
    // TODO: Method 'GetText'
    // TODO: Method 'SetText'
    // TODO: Method 'GetChar'
    // TODO: Method 'SetChar'
    // TODO: Method 'GetDuplicate'
    // TODO: Method 'GetFormattedText'
    // TODO: Method 'SetFormattedText'
    // TODO: Method 'GetStart'
    // TODO: Method 'SetStart'
    // TODO: Method 'GetEnd'
    // TODO: Method 'SetEnd'
    // TODO: Method 'GetFont'
    // TODO: Method 'SetFont'
    // TODO: Method 'GetPara'
    // TODO: Method 'SetPara'
    // TODO: Method 'GetStoryLength'
    // TODO: Method 'GetStoryType'
    // TODO: Method 'Collapse'
    // TODO: Method 'Expand'
    // TODO: Method 'GetIndex'
    // TODO: Method 'SetIndex'
    // TODO: Method 'SetRange'
    // TODO: Method 'InRange'
    // TODO: Method 'InStory'
    // TODO: Method 'IsEqual'
    // TODO: Method 'Select'
    // TODO: Method 'StartOf'
    // TODO: Method 'EndOf'
    // TODO: Method 'Move'
    // TODO: Method 'MoveStart'
    // TODO: Method 'MoveEnd'
    // TODO: Method 'MoveWhile'
    // TODO: Method 'MoveStartWhile'
    // TODO: Method 'MoveEndWhile'
    // TODO: Method 'MoveUntil'
    // TODO: Method 'MoveStartUntil'
    // TODO: Method 'MoveEndUntil'
    // TODO: Method 'FindTextA'
    // TODO: Method 'FindTextStart'
    // TODO: Method 'FindTextEnd'
    // TODO: Method 'Delete'
    // TODO: Method 'Cut'
    // TODO: Method 'Copy'
    // TODO: Method 'Paste'
    // TODO: Method 'CanPaste'
    // TODO: Method 'CanEdit'
    // TODO: Method 'ChangeCase'
    // TODO: Method 'GetPoint'
    // TODO: Method 'SetPoint'
    // TODO: Method 'ScrollIntoView'
    // TODO: Method 'GetEmbeddedObject'
};
// --------------------------------------------------------
// Type: ITextSelection
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ITextSelection = *opaque{
    // TODO: Method 'GetFlags'
    // TODO: Method 'SetFlags'
    // TODO: Method 'GetType'
    // TODO: Method 'MoveLeft'
    // TODO: Method 'MoveRight'
    // TODO: Method 'MoveUp'
    // TODO: Method 'MoveDown'
    // TODO: Method 'HomeKey'
    // TODO: Method 'EndKey'
    // TODO: Method 'TypeText'
};
// --------------------------------------------------------
// Type: ITextFont
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ITextFont = *opaque{
    // TODO: Method 'GetDuplicate'
    // TODO: Method 'SetDuplicate'
    // TODO: Method 'CanChange'
    // TODO: Method 'IsEqual'
    // TODO: Method 'Reset'
    // TODO: Method 'GetStyle'
    // TODO: Method 'SetStyle'
    // TODO: Method 'GetAllCaps'
    // TODO: Method 'SetAllCaps'
    // TODO: Method 'GetAnimation'
    // TODO: Method 'SetAnimation'
    // TODO: Method 'GetBackColor'
    // TODO: Method 'SetBackColor'
    // TODO: Method 'GetBold'
    // TODO: Method 'SetBold'
    // TODO: Method 'GetEmboss'
    // TODO: Method 'SetEmboss'
    // TODO: Method 'GetForeColor'
    // TODO: Method 'SetForeColor'
    // TODO: Method 'GetHidden'
    // TODO: Method 'SetHidden'
    // TODO: Method 'GetEngrave'
    // TODO: Method 'SetEngrave'
    // TODO: Method 'GetItalic'
    // TODO: Method 'SetItalic'
    // TODO: Method 'GetKerning'
    // TODO: Method 'SetKerning'
    // TODO: Method 'GetLanguageID'
    // TODO: Method 'SetLanguageID'
    // TODO: Method 'GetName'
    // TODO: Method 'SetName'
    // TODO: Method 'GetOutline'
    // TODO: Method 'SetOutline'
    // TODO: Method 'GetPosition'
    // TODO: Method 'SetPosition'
    // TODO: Method 'GetProtected'
    // TODO: Method 'SetProtected'
    // TODO: Method 'GetShadow'
    // TODO: Method 'SetShadow'
    // TODO: Method 'GetSize'
    // TODO: Method 'SetSize'
    // TODO: Method 'GetSmallCaps'
    // TODO: Method 'SetSmallCaps'
    // TODO: Method 'GetSpacing'
    // TODO: Method 'SetSpacing'
    // TODO: Method 'GetStrikeThrough'
    // TODO: Method 'SetStrikeThrough'
    // TODO: Method 'GetSubscript'
    // TODO: Method 'SetSubscript'
    // TODO: Method 'GetSuperscript'
    // TODO: Method 'SetSuperscript'
    // TODO: Method 'GetUnderline'
    // TODO: Method 'SetUnderline'
    // TODO: Method 'GetWeight'
    // TODO: Method 'SetWeight'
};
// --------------------------------------------------------
// Type: ITextPara
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ITextPara = *opaque{
    // TODO: Method 'GetDuplicate'
    // TODO: Method 'SetDuplicate'
    // TODO: Method 'CanChange'
    // TODO: Method 'IsEqual'
    // TODO: Method 'Reset'
    // TODO: Method 'GetStyle'
    // TODO: Method 'SetStyle'
    // TODO: Method 'GetAlignment'
    // TODO: Method 'SetAlignment'
    // TODO: Method 'GetHyphenation'
    // TODO: Method 'SetHyphenation'
    // TODO: Method 'GetFirstLineIndent'
    // TODO: Method 'GetKeepTogether'
    // TODO: Method 'SetKeepTogether'
    // TODO: Method 'GetKeepWithNext'
    // TODO: Method 'SetKeepWithNext'
    // TODO: Method 'GetLeftIndent'
    // TODO: Method 'GetLineSpacing'
    // TODO: Method 'GetLineSpacingRule'
    // TODO: Method 'GetListAlignment'
    // TODO: Method 'SetListAlignment'
    // TODO: Method 'GetListLevelIndex'
    // TODO: Method 'SetListLevelIndex'
    // TODO: Method 'GetListStart'
    // TODO: Method 'SetListStart'
    // TODO: Method 'GetListTab'
    // TODO: Method 'SetListTab'
    // TODO: Method 'GetListType'
    // TODO: Method 'SetListType'
    // TODO: Method 'GetNoLineNumber'
    // TODO: Method 'SetNoLineNumber'
    // TODO: Method 'GetPageBreakBefore'
    // TODO: Method 'SetPageBreakBefore'
    // TODO: Method 'GetRightIndent'
    // TODO: Method 'SetRightIndent'
    // TODO: Method 'SetIndents'
    // TODO: Method 'SetLineSpacing'
    // TODO: Method 'GetSpaceAfter'
    // TODO: Method 'SetSpaceAfter'
    // TODO: Method 'GetSpaceBefore'
    // TODO: Method 'SetSpaceBefore'
    // TODO: Method 'GetWidowControl'
    // TODO: Method 'SetWidowControl'
    // TODO: Method 'GetTabCount'
    // TODO: Method 'AddTab'
    // TODO: Method 'ClearAllTabs'
    // TODO: Method 'DeleteTab'
    // TODO: Method 'GetTab'
};
// --------------------------------------------------------
// Type: ITextStoryRanges
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ITextStoryRanges = *opaque{
    // TODO: Method '_NewEnum'
    // TODO: Method 'Item'
    // TODO: Method 'GetCount'
};
// --------------------------------------------------------
// Type: ITextDocument2
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ITextDocument2 = *opaque{
    // TODO: Method 'GetCaretType'
    // TODO: Method 'SetCaretType'
    // TODO: Method 'GetDisplays'
    // TODO: Method 'GetDocumentFont'
    // TODO: Method 'SetDocumentFont'
    // TODO: Method 'GetDocumentPara'
    // TODO: Method 'SetDocumentPara'
    // TODO: Method 'GetEastAsianFlags'
    // TODO: Method 'GetGenerator'
    // TODO: Method 'SetIMEInProgress'
    // TODO: Method 'GetNotificationMode'
    // TODO: Method 'SetNotificationMode'
    // TODO: Method 'GetSelection2'
    // TODO: Method 'GetStoryRanges2'
    // TODO: Method 'GetTypographyOptions'
    // TODO: Method 'GetVersion'
    // TODO: Method 'GetWindow'
    // TODO: Method 'AttachMsgFilter'
    // TODO: Method 'CheckTextLimit'
    // TODO: Method 'GetCallManager'
    // TODO: Method 'GetClientRect'
    // TODO: Method 'GetEffectColor'
    // TODO: Method 'GetImmContext'
    // TODO: Method 'GetPreferredFont'
    // TODO: Method 'GetProperty'
    // TODO: Method 'GetStrings'
    // TODO: Method 'Notify'
    // TODO: Method 'Range2'
    // TODO: Method 'RangeFromPoint2'
    // TODO: Method 'ReleaseCallManager'
    // TODO: Method 'ReleaseImmContext'
    // TODO: Method 'SetEffectColor'
    // TODO: Method 'SetProperty'
    // TODO: Method 'SetTypographyOptions'
    // TODO: Method 'SysBeep'
    // TODO: Method 'Update'
    // TODO: Method 'UpdateWindow'
    // TODO: Method 'GetMathProperties'
    // TODO: Method 'SetMathProperties'
    // TODO: Method 'GetActiveStory'
    // TODO: Method 'SetActiveStory'
    // TODO: Method 'GetMainStory'
    // TODO: Method 'GetNewStory'
    // TODO: Method 'GetStory'
};
// --------------------------------------------------------
// Type: ITextRange2
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ITextRange2 = *opaque{
    // TODO: Method 'GetCch'
    // TODO: Method 'GetCells'
    // TODO: Method 'GetColumn'
    // TODO: Method 'GetCount'
    // TODO: Method 'GetDuplicate2'
    // TODO: Method 'GetFont2'
    // TODO: Method 'SetFont2'
    // TODO: Method 'GetFormattedText2'
    // TODO: Method 'SetFormattedText2'
    // TODO: Method 'GetGravity'
    // TODO: Method 'SetGravity'
    // TODO: Method 'GetPara2'
    // TODO: Method 'SetPara2'
    // TODO: Method 'GetRow'
    // TODO: Method 'GetStartPara'
    // TODO: Method 'GetTable'
    // TODO: Method 'GetURL'
    // TODO: Method 'SetURL'
    // TODO: Method 'AddSubrange'
    // TODO: Method 'BuildUpMath'
    // TODO: Method 'DeleteSubrange'
    // TODO: Method 'Find'
    // TODO: Method 'GetChar2'
    // TODO: Method 'GetDropCap'
    // TODO: Method 'GetInlineObject'
    // TODO: Method 'GetProperty'
    // TODO: Method 'GetRect'
    // TODO: Method 'GetSubrange'
    // TODO: Method 'GetText2'
    // TODO: Method 'HexToUnicode'
    // TODO: Method 'InsertTable'
    // TODO: Method 'Linearize'
    // TODO: Method 'SetActiveSubrange'
    // TODO: Method 'SetDropCap'
    // TODO: Method 'SetProperty'
    // TODO: Method 'SetText2'
    // TODO: Method 'UnicodeToHex'
    // TODO: Method 'SetInlineObject'
    // TODO: Method 'GetMathFunctionType'
    // TODO: Method 'InsertImage'
};
// --------------------------------------------------------
// Type: ITextSelection2
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ITextSelection2 = *opaque{
};
// --------------------------------------------------------
// Type: ITextFont2
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ITextFont2 = *opaque{
    // TODO: Method 'GetCount'
    // TODO: Method 'GetAutoLigatures'
    // TODO: Method 'SetAutoLigatures'
    // TODO: Method 'GetAutospaceAlpha'
    // TODO: Method 'SetAutospaceAlpha'
    // TODO: Method 'GetAutospaceNumeric'
    // TODO: Method 'SetAutospaceNumeric'
    // TODO: Method 'GetAutospaceParens'
    // TODO: Method 'SetAutospaceParens'
    // TODO: Method 'GetCharRep'
    // TODO: Method 'SetCharRep'
    // TODO: Method 'GetCompressionMode'
    // TODO: Method 'SetCompressionMode'
    // TODO: Method 'GetCookie'
    // TODO: Method 'SetCookie'
    // TODO: Method 'GetDoubleStrike'
    // TODO: Method 'SetDoubleStrike'
    // TODO: Method 'GetDuplicate2'
    // TODO: Method 'SetDuplicate2'
    // TODO: Method 'GetLinkType'
    // TODO: Method 'GetMathZone'
    // TODO: Method 'SetMathZone'
    // TODO: Method 'GetModWidthPairs'
    // TODO: Method 'SetModWidthPairs'
    // TODO: Method 'GetModWidthSpace'
    // TODO: Method 'SetModWidthSpace'
    // TODO: Method 'GetOldNumbers'
    // TODO: Method 'SetOldNumbers'
    // TODO: Method 'GetOverlapping'
    // TODO: Method 'SetOverlapping'
    // TODO: Method 'GetPositionSubSuper'
    // TODO: Method 'SetPositionSubSuper'
    // TODO: Method 'GetScaling'
    // TODO: Method 'SetScaling'
    // TODO: Method 'GetSpaceExtension'
    // TODO: Method 'SetSpaceExtension'
    // TODO: Method 'GetUnderlinePositionMode'
    // TODO: Method 'SetUnderlinePositionMode'
    // TODO: Method 'GetEffects'
    // TODO: Method 'GetEffects2'
    // TODO: Method 'GetProperty'
    // TODO: Method 'GetPropertyInfo'
    // TODO: Method 'IsEqual2'
    // TODO: Method 'SetEffects'
    // TODO: Method 'SetEffects2'
    // TODO: Method 'SetProperty'
};
// --------------------------------------------------------
// Type: ITextPara2
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ITextPara2 = *opaque{
    // TODO: Method 'GetBorders'
    // TODO: Method 'GetDuplicate2'
    // TODO: Method 'SetDuplicate2'
    // TODO: Method 'GetFontAlignment'
    // TODO: Method 'SetFontAlignment'
    // TODO: Method 'GetHangingPunctuation'
    // TODO: Method 'SetHangingPunctuation'
    // TODO: Method 'GetSnapToGrid'
    // TODO: Method 'SetSnapToGrid'
    // TODO: Method 'GetTrimPunctuationAtStart'
    // TODO: Method 'SetTrimPunctuationAtStart'
    // TODO: Method 'GetEffects'
    // TODO: Method 'GetProperty'
    // TODO: Method 'IsEqual2'
    // TODO: Method 'SetEffects'
    // TODO: Method 'SetProperty'
};
// --------------------------------------------------------
// Type: ITextStoryRanges2
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ITextStoryRanges2 = *opaque{
    // TODO: Method 'Item2'
};
// --------------------------------------------------------
// Type: ITextStory
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ITextStory = *opaque{
    // TODO: Method 'GetActive'
    // TODO: Method 'SetActive'
    // TODO: Method 'GetDisplay'
    // TODO: Method 'GetIndex'
    // TODO: Method 'GetType'
    // TODO: Method 'SetType'
    // TODO: Method 'GetProperty'
    // TODO: Method 'GetRange'
    // TODO: Method 'GetText'
    // TODO: Method 'SetFormattedText'
    // TODO: Method 'SetProperty'
    // TODO: Method 'SetText'
};
// --------------------------------------------------------
// Type: ITextStrings
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ITextStrings = *opaque{
    // TODO: Method 'Item'
    // TODO: Method 'GetCount'
    // TODO: Method 'Add'
    // TODO: Method 'Append'
    // TODO: Method 'Cat2'
    // TODO: Method 'CatTop2'
    // TODO: Method 'DeleteRange'
    // TODO: Method 'EncodeFunction'
    // TODO: Method 'GetCch'
    // TODO: Method 'InsertNullStr'
    // TODO: Method 'MoveBoundary'
    // TODO: Method 'PrefixTop'
    // TODO: Method 'Remove'
    // TODO: Method 'SetFormattedText'
    // TODO: Method 'SetOpCp'
    // TODO: Method 'SuffixTop'
    // TODO: Method 'Swap'
};
// --------------------------------------------------------
// Type: ITextRow
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ITextRow = *opaque{
    // TODO: Method 'GetAlignment'
    // TODO: Method 'SetAlignment'
    // TODO: Method 'GetCellCount'
    // TODO: Method 'SetCellCount'
    // TODO: Method 'GetCellCountCache'
    // TODO: Method 'SetCellCountCache'
    // TODO: Method 'GetCellIndex'
    // TODO: Method 'SetCellIndex'
    // TODO: Method 'GetCellMargin'
    // TODO: Method 'SetCellMargin'
    // TODO: Method 'GetHeight'
    // TODO: Method 'SetHeight'
    // TODO: Method 'GetIndent'
    // TODO: Method 'SetIndent'
    // TODO: Method 'GetKeepTogether'
    // TODO: Method 'SetKeepTogether'
    // TODO: Method 'GetKeepWithNext'
    // TODO: Method 'SetKeepWithNext'
    // TODO: Method 'GetNestLevel'
    // TODO: Method 'GetRTL'
    // TODO: Method 'SetRTL'
    // TODO: Method 'GetCellAlignment'
    // TODO: Method 'SetCellAlignment'
    // TODO: Method 'GetCellColorBack'
    // TODO: Method 'SetCellColorBack'
    // TODO: Method 'GetCellColorFore'
    // TODO: Method 'SetCellColorFore'
    // TODO: Method 'GetCellMergeFlags'
    // TODO: Method 'SetCellMergeFlags'
    // TODO: Method 'GetCellShading'
    // TODO: Method 'SetCellShading'
    // TODO: Method 'GetCellVerticalText'
    // TODO: Method 'SetCellVerticalText'
    // TODO: Method 'GetCellWidth'
    // TODO: Method 'SetCellWidth'
    // TODO: Method 'GetCellBorderColors'
    // TODO: Method 'GetCellBorderWidths'
    // TODO: Method 'SetCellBorderColors'
    // TODO: Method 'SetCellBorderWidths'
    // TODO: Method 'Apply'
    // TODO: Method 'CanChange'
    // TODO: Method 'GetProperty'
    // TODO: Method 'Insert'
    // TODO: Method 'IsEqual'
    // TODO: Method 'Reset'
    // TODO: Method 'SetProperty'
};
// --------------------------------------------------------
// Type: ITextDisplays
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ITextDisplays = *opaque{
};
// --------------------------------------------------------
// Type: ITextDocument2Old
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ITextDocument2Old = *opaque{
    // TODO: Method 'AttachMsgFilter'
    // TODO: Method 'SetEffectColor'
    // TODO: Method 'GetEffectColor'
    // TODO: Method 'GetCaretType'
    // TODO: Method 'SetCaretType'
    // TODO: Method 'GetImmContext'
    // TODO: Method 'ReleaseImmContext'
    // TODO: Method 'GetPreferredFont'
    // TODO: Method 'GetNotificationMode'
    // TODO: Method 'SetNotificationMode'
    // TODO: Method 'GetClientRect'
    // TODO: Method 'GetSelection2'
    // TODO: Method 'GetWindow'
    // TODO: Method 'GetFEFlags'
    // TODO: Method 'UpdateWindow'
    // TODO: Method 'CheckTextLimit'
    // TODO: Method 'IMEInProgress'
    // TODO: Method 'SysBeep'
    // TODO: Method 'Update'
    // TODO: Method 'Notify'
    // TODO: Method 'GetDocumentFont'
    // TODO: Method 'GetDocumentPara'
    // TODO: Method 'GetCallManager'
    // TODO: Method 'ReleaseCallManager'
};
// --------------------------------------------------------
// Type: REOBJECT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const REOBJECT = extern struct {
    cbStruct: u32,
    cp: i32,
    clsid: Guid,
    poleobj: IOleObject,
    pstg: IStorage,
    polesite: IOleClientSite,
    sizel: SIZE,
    dvaspect: u32,
    dwFlags: u32,
    dwUser: u32,
};
// --------------------------------------------------------
// Type: IRichEditOle
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IRichEditOle = *opaque{
    // TODO: Method 'GetClientSite'
    // TODO: Method 'GetObjectCount'
    // TODO: Method 'GetLinkCount'
    // TODO: Method 'GetObjectA'
    // TODO: Method 'InsertObject'
    // TODO: Method 'ConvertObject'
    // TODO: Method 'ActivateAs'
    // TODO: Method 'SetHostNames'
    // TODO: Method 'SetLinkAvailable'
    // TODO: Method 'SetDvaspect'
    // TODO: Method 'HandsOffStorage'
    // TODO: Method 'SaveCompleted'
    // TODO: Method 'InPlaceDeactivate'
    // TODO: Method 'ContextSensitiveHelp'
    // TODO: Method 'GetClipboardData'
    // TODO: Method 'ImportDataObject'
};
// --------------------------------------------------------
// Type: IRichEditOleCallback
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IRichEditOleCallback = *opaque{
    // TODO: Method 'GetNewStorage'
    // TODO: Method 'GetInPlaceContext'
    // TODO: Method 'ShowContainerUI'
    // TODO: Method 'QueryInsertObject'
    // TODO: Method 'DeleteObject'
    // TODO: Method 'QueryAcceptData'
    // TODO: Method 'ContextSensitiveHelp'
    // TODO: Method 'GetClipboardData'
    // TODO: Method 'GetDragDropEffect'
    // TODO: Method 'GetContextMenu'
};
// --------------------------------------------------------
// Type: TXTBACKSTYLE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const TXTBACKSTYLE = *opaque{
};
// --------------------------------------------------------
// Type: TXTHITRESULT
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const TXTHITRESULT = *opaque{
};
// --------------------------------------------------------
// Type: TXTNATURALSIZE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const TXTNATURALSIZE = *opaque{
};
// --------------------------------------------------------
// Type: TXTVIEW
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const TXTVIEW = *opaque{
};
// --------------------------------------------------------
// Type: CHANGETYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const CHANGETYPE = *opaque{
};
// --------------------------------------------------------
// Type: CHANGENOTIFY
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CHANGENOTIFY = extern struct {
    dwChangeType: u32,
    pvCookieData: ?*opaque{},
};
// --------------------------------------------------------
// Type: ITextServices
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ITextServices = *opaque{
    // TODO: Method 'TxSendMessage'
    // TODO: Method 'TxDraw'
    // TODO: Method 'TxGetHScroll'
    // TODO: Method 'TxGetVScroll'
    // TODO: Method 'OnTxSetCursor'
    // TODO: Method 'TxQueryHitPoint'
    // TODO: Method 'OnTxInPlaceActivate'
    // TODO: Method 'OnTxInPlaceDeactivate'
    // TODO: Method 'OnTxUIActivate'
    // TODO: Method 'OnTxUIDeactivate'
    // TODO: Method 'TxGetText'
    // TODO: Method 'TxSetText'
    // TODO: Method 'TxGetCurTargetX'
    // TODO: Method 'TxGetBaseLinePos'
    // TODO: Method 'TxGetNaturalSize'
    // TODO: Method 'TxGetDropTarget'
    // TODO: Method 'OnTxPropertyBitsChange'
    // TODO: Method 'TxGetCachedSize'
};
// --------------------------------------------------------
// Type: CARET_FLAGS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const CARET_FLAGS = *opaque{
};
// --------------------------------------------------------
// Type: CARET_INFO
// TypeLayoutAttr: explicit
// not generating the actual code for this type because it has an explicit layout
pub const CARET_INFO = *opaque{
};
// --------------------------------------------------------
// Type: ITextHost
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ITextHost = *opaque{
    // TODO: Method 'TxGetDC'
    // TODO: Method 'TxReleaseDC'
    // TODO: Method 'TxShowScrollBar'
    // TODO: Method 'TxEnableScrollBar'
    // TODO: Method 'TxSetScrollRange'
    // TODO: Method 'TxSetScrollPos'
    // TODO: Method 'TxInvalidateRect'
    // TODO: Method 'TxViewChange'
    // TODO: Method 'TxCreateCaret'
    // TODO: Method 'TxShowCaret'
    // TODO: Method 'TxSetCaretPos'
    // TODO: Method 'TxSetTimer'
    // TODO: Method 'TxKillTimer'
    // TODO: Method 'TxScrollWindowEx'
    // TODO: Method 'TxSetCapture'
    // TODO: Method 'TxSetFocus'
    // TODO: Method 'TxSetCursor'
    // TODO: Method 'TxScreenToClient'
    // TODO: Method 'TxClientToScreen'
    // TODO: Method 'TxActivate'
    // TODO: Method 'TxDeactivate'
    // TODO: Method 'TxGetClientRect'
    // TODO: Method 'TxGetViewInset'
    // TODO: Method 'TxGetCharFormat'
    // TODO: Method 'TxGetParaFormat'
    // TODO: Method 'TxGetSysColor'
    // TODO: Method 'TxGetBackStyle'
    // TODO: Method 'TxGetMaxLength'
    // TODO: Method 'TxGetScrollBars'
    // TODO: Method 'TxGetPasswordChar'
    // TODO: Method 'TxGetAcceleratorPos'
    // TODO: Method 'TxGetExtent'
    // TODO: Method 'OnTxCharFormatChange'
    // TODO: Method 'OnTxParaFormatChange'
    // TODO: Method 'TxGetPropertyBits'
    // TODO: Method 'TxNotify'
    // TODO: Method 'TxImmGetContext'
    // TODO: Method 'TxImmReleaseContext'
    // TODO: Method 'TxGetSelectionBarWidth'
};
// --------------------------------------------------------
// Type: IRicheditWindowlessAccessibility
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IRicheditWindowlessAccessibility = *opaque{
    // TODO: Method 'CreateProvider'
};
// --------------------------------------------------------
// Type: IRichEditUiaInformation
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IRichEditUiaInformation = *opaque{
    // TODO: Method 'GetBoundaryRectangle'
    // TODO: Method 'IsVisible'
};
// --------------------------------------------------------
// Type: IRicheditUiaOverrides
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IRicheditUiaOverrides = *opaque{
    // TODO: Method 'GetPropertyOverrideValue'
};
// --------------------------------------------------------
// Type: PCreateTextServices
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PCreateTextServices = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PShutdownTextServices
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PShutdownTextServices = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: ITextHost2
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ITextHost2 = *opaque{
    // TODO: Method 'TxIsDoubleClickPending'
    // TODO: Method 'TxGetWindow'
    // TODO: Method 'TxSetForegroundWindow'
    // TODO: Method 'TxGetPalette'
    // TODO: Method 'TxGetEastAsianFlags'
    // TODO: Method 'TxSetCursor2'
    // TODO: Method 'TxFreeTextServicesNotification'
    // TODO: Method 'TxGetEditStyle'
    // TODO: Method 'TxGetWindowStyles'
    // TODO: Method 'TxShowDropCaret'
    // TODO: Method 'TxDestroyCaret'
    // TODO: Method 'TxGetHorzExtent'
};
// --------------------------------------------------------
// Type: ITextServices2
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ITextServices2 = *opaque{
    // TODO: Method 'TxGetNaturalSize2'
    // TODO: Method 'TxDrawD2D'
};
// --------------------------------------------------------
// Type: TA_PROPERTY
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const TA_PROPERTY = *opaque{
};
// --------------------------------------------------------
// Type: TA_PROPERTY_FLAG
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const TA_PROPERTY_FLAG = *opaque{
};
// --------------------------------------------------------
// Type: TA_TRANSFORM_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const TA_TRANSFORM_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: TA_TRANSFORM_FLAG
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const TA_TRANSFORM_FLAG = *opaque{
};
// --------------------------------------------------------
// Type: TA_TRANSFORM
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TA_TRANSFORM = extern struct {
    eTransformType: TA_TRANSFORM_TYPE,
    dwTimingFunctionId: u32,
    dwStartTime: u32,
    dwDurationTime: u32,
    eFlags: TA_TRANSFORM_FLAG,
};
// --------------------------------------------------------
// Type: TA_TRANSFORM_2D
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TA_TRANSFORM_2D = extern struct {
    header: TA_TRANSFORM,
    rX: f32,
    rY: f32,
    rInitialX: f32,
    rInitialY: f32,
    rOriginX: f32,
    rOriginY: f32,
};
// --------------------------------------------------------
// Type: TA_TRANSFORM_OPACITY
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TA_TRANSFORM_OPACITY = extern struct {
    header: TA_TRANSFORM,
    rOpacity: f32,
    rInitialOpacity: f32,
};
// --------------------------------------------------------
// Type: TA_TRANSFORM_CLIP
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TA_TRANSFORM_CLIP = extern struct {
    header: TA_TRANSFORM,
    rLeft: f32,
    rTop: f32,
    rRight: f32,
    rBottom: f32,
    rInitialLeft: f32,
    rInitialTop: f32,
    rInitialRight: f32,
    rInitialBottom: f32,
};
// --------------------------------------------------------
// Type: TA_TIMINGFUNCTION_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const TA_TIMINGFUNCTION_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: TA_TIMINGFUNCTION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TA_TIMINGFUNCTION = extern struct {
    eTimingFunctionType: TA_TIMINGFUNCTION_TYPE,
};
// --------------------------------------------------------
// Type: TA_CUBIC_BEZIER
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TA_CUBIC_BEZIER = extern struct {
    header: TA_TIMINGFUNCTION,
    rX0: f32,
    rY0: f32,
    rX1: f32,
    rY1: f32,
};
// --------------------------------------------------------
// Type: DTBGOPTS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DTBGOPTS = extern struct {
    dwSize: u32,
    dwFlags: u32,
    rcClip: RECT,
};
// --------------------------------------------------------
// Type: THEMESIZE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const THEMESIZE = *opaque{
};
// --------------------------------------------------------
// Type: MARGINS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const MARGINS = extern struct {
    cxLeftWidth: i32,
    cxRightWidth: i32,
    cyTopHeight: i32,
    cyBottomHeight: i32,
};
// --------------------------------------------------------
// Type: INTLIST
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const INTLIST = extern struct {
    iValueCount: i32,
    iValues: ?[*]i32,
};
// --------------------------------------------------------
// Type: PROPERTYORIGIN
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PROPERTYORIGIN = *opaque{
};
// --------------------------------------------------------
// Type: WINDOWTHEMEATTRIBUTETYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const WINDOWTHEMEATTRIBUTETYPE = *opaque{
};
// --------------------------------------------------------
// Type: WTA_OPTIONS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const WTA_OPTIONS = extern struct {
    dwFlags: u32,
    dwMask: u32,
};
// --------------------------------------------------------
// Type: DTT_CALLBACK_PROC
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const DTT_CALLBACK_PROC = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: DTTOPTS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DTTOPTS = extern struct {
    dwSize: u32,
    dwFlags: u32,
    crText: u32,
    crBorder: u32,
    crShadow: u32,
    iTextShadowType: i32,
    ptShadowOffset: POINT,
    iBorderSize: i32,
    iFontPropId: i32,
    iColorPropId: i32,
    iStateId: i32,
    fApplyOverlay: BOOL,
    iGlowSize: i32,
    pfnDrawTextCallback: DTT_CALLBACK_PROC,
    lParam: LPARAM,
};
// --------------------------------------------------------
// Type: BP_BUFFERFORMAT
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const BP_BUFFERFORMAT = *opaque{
};
// --------------------------------------------------------
// Type: BP_ANIMATIONSTYLE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const BP_ANIMATIONSTYLE = *opaque{
};
// --------------------------------------------------------
// Type: BP_ANIMATIONPARAMS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const BP_ANIMATIONPARAMS = extern struct {
    cbSize: u32,
    dwFlags: u32,
    style: BP_ANIMATIONSTYLE,
    dwDuration: u32,
};
// --------------------------------------------------------
// Type: BP_PAINTPARAMS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const BP_PAINTPARAMS = extern struct {
    cbSize: u32,
    dwFlags: u32,
    prcExclude: ?*RECT,
    pBlendFunction: ?*BLENDFUNCTION,
};

//
// functions
//

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn CheckDlgButton(
    hDlg: HWND,
    nIDButton: i32,
    uCheck: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn CheckRadioButton(
    hDlg: HWND,
    nIDFirstButton: i32,
    nIDLastButton: i32,
    nIDCheckButton: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn IsDlgButtonChecked(
    hDlg: HWND,
    nIDButton: i32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn IsCharLowerW(
    ch: u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn InitializeTouchInjection(
    maxCount: u32,
    dwMode: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn InjectTouchInput(
    count: u32,
    contacts: ?*POINTER_TOUCH_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn CreateSyntheticPointerDevice(
    pointerType: u32,
    maxCount: u32,
    mode: POINTER_FEEDBACK_MODE,
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn InjectSyntheticPointerInput(
    device: ?*opaque{},
    pointerInfo: ?*POINTER_TYPE_INFO,
    count: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn DestroySyntheticPointerDevice(
    device: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn RegisterTouchHitTestingWindow(
    hwnd: HWND,
    value: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn EvaluateProximityToRect(
    controlBoundingBox: ?*RECT,
    pHitTestingInput: ?*TOUCH_HIT_TESTING_INPUT,
    pProximityEval: ?*TOUCH_HIT_TESTING_PROXIMITY_EVALUATION,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn EvaluateProximityToPolygon(
    numVertices: u32,
    controlPolygon: ?*POINT,
    pHitTestingInput: ?*TOUCH_HIT_TESTING_INPUT,
    pProximityEval: ?*TOUCH_HIT_TESTING_PROXIMITY_EVALUATION,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn PackTouchHitTestingProximityEvaluation(
    pHitTestingInput: ?*TOUCH_HIT_TESTING_INPUT,
    pProximityEval: ?*TOUCH_HIT_TESTING_PROXIMITY_EVALUATION,
) callconv(@import("std").os.windows.WINAPI) LRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn GetWindowFeedbackSetting(
    hwnd: HWND,
    feedback: FEEDBACK_TYPE,
    dwFlags: u32,
    pSize: ?*u32,
    config: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn SetWindowFeedbackSetting(
    hwnd: HWND,
    feedback: FEEDBACK_TYPE,
    dwFlags: u32,
    size: u32,
    configuration: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn ScrollWindow(
    hWnd: HWND,
    XAmount: i32,
    YAmount: i32,
    lpRect: ?*RECT,
    lpClipRect: ?*RECT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn ScrollDC(
    hDC: HDC,
    dx: i32,
    dy: i32,
    lprcScroll: ?*RECT,
    lprcClip: ?*RECT,
    hrgnUpdate: HRGN,
    lprcUpdate: ?*RECT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn ScrollWindowEx(
    hWnd: HWND,
    dx: i32,
    dy: i32,
    prcScroll: ?*RECT,
    prcClip: ?*RECT,
    hrgnUpdate: HRGN,
    prcUpdate: ?*RECT,
    flags: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn SetScrollPos(
    hWnd: HWND,
    nBar: i32,
    nPos: i32,
    bRedraw: BOOL,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn GetScrollPos(
    hWnd: HWND,
    nBar: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn SetScrollRange(
    hWnd: HWND,
    nBar: i32,
    nMinPos: i32,
    nMaxPos: i32,
    bRedraw: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn GetScrollRange(
    hWnd: HWND,
    nBar: i32,
    lpMinPos: ?*i32,
    lpMaxPos: ?*i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn ShowScrollBar(
    hWnd: HWND,
    wBar: i32,
    bShow: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn EnableScrollBar(
    hWnd: HWND,
    wSBflags: u32,
    wArrows: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn DlgDirListA(
    hDlg: HWND,
    lpPathSpec: ?*i8,
    nIDListBox: i32,
    nIDStaticPath: i32,
    uFileType: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn DlgDirListW(
    hDlg: HWND,
    lpPathSpec: ?*u16,
    nIDListBox: i32,
    nIDStaticPath: i32,
    uFileType: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn DlgDirSelectExA(
    hwndDlg: HWND,
    lpString: ?*i8,
    chCount: i32,
    idListBox: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn DlgDirSelectExW(
    hwndDlg: HWND,
    lpString: ?*u16,
    chCount: i32,
    idListBox: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn DlgDirListComboBoxA(
    hDlg: HWND,
    lpPathSpec: ?*i8,
    nIDComboBox: i32,
    nIDStaticPath: i32,
    uFiletype: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn DlgDirListComboBoxW(
    hDlg: HWND,
    lpPathSpec: ?*u16,
    nIDComboBox: i32,
    nIDStaticPath: i32,
    uFiletype: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn DlgDirSelectComboBoxExA(
    hwndDlg: HWND,
    lpString: ?*i8,
    cchOut: i32,
    idComboBox: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn DlgDirSelectComboBoxExW(
    hwndDlg: HWND,
    lpString: ?*u16,
    cchOut: i32,
    idComboBox: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn SetScrollInfo(
    hwnd: HWND,
    nBar: i32,
    lpsi: ?*SCROLLINFO,
    redraw: BOOL,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn GetScrollInfo(
    hwnd: HWND,
    nBar: i32,
    lpsi: ?*SCROLLINFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn GetScrollBarInfo(
    hwnd: HWND,
    idObject: i32,
    psbi: ?*SCROLLBARINFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn GetComboBoxInfo(
    hwndCombo: HWND,
    pcbi: ?*COMBOBOXINFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn GetListBoxInfo(
    hwnd: HWND,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn GetPointerDevices(
    deviceCount: ?*u32,
    pointerDevices: ?*POINTER_DEVICE_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn GetPointerDevice(
    device: HANDLE,
    pointerDevice: ?*POINTER_DEVICE_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn GetPointerDeviceProperties(
    device: HANDLE,
    propertyCount: ?*u32,
    pointerProperties: ?*POINTER_DEVICE_PROPERTY,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn RegisterPointerDeviceNotifications(
    window: HWND,
    notifyRange: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn GetPointerDeviceRects(
    device: HANDLE,
    pointerDeviceRect: ?*RECT,
    displayRect: ?*RECT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn GetPointerDeviceCursors(
    device: HANDLE,
    cursorCount: ?*u32,
    deviceCursors: ?*POINTER_DEVICE_CURSOR_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn GetRawPointerDeviceData(
    pointerId: u32,
    historyCount: u32,
    propertiesCount: u32,
    pProperties: ?*POINTER_DEVICE_PROPERTY,
    pValues: ?*i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn GetCurrentInputMessageSource(
    inputMessageSource: ?*INPUT_MESSAGE_SOURCE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn GetCIMSSM(
    inputMessageSource: ?*INPUT_MESSAGE_SOURCE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "COMCTL32" fn CreatePropertySheetPageA(
    constPropSheetPagePointer: ?*PROPSHEETPAGEA,
) callconv(@import("std").os.windows.WINAPI) HPROPSHEETPAGE;

// set_last_errror=False (can and should we use this?)
pub extern "COMCTL32" fn CreatePropertySheetPageW(
    constPropSheetPagePointer: ?*PROPSHEETPAGEW,
) callconv(@import("std").os.windows.WINAPI) HPROPSHEETPAGE;

// set_last_errror=False (can and should we use this?)
pub extern "COMCTL32" fn DestroyPropertySheetPage(
    param0: HPROPSHEETPAGE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "COMCTL32" fn PropertySheetA(
    param0: ?*PROPSHEETHEADERA_V2,
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=True (can and should we use this?)
pub extern "COMCTL32" fn PropertySheetW(
    param0: ?*PROPSHEETHEADERW_V2,
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=False (can and should we use this?)
pub extern "COMCTL32" fn InitCommonControls(
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "COMCTL32" fn InitCommonControlsEx(
    picce: ?*INITCOMMONCONTROLSEX,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "COMCTL32" fn ImageList_Create(
    cx: i32,
    cy: i32,
    flags: u32,
    cInitial: i32,
    cGrow: i32,
) callconv(@import("std").os.windows.WINAPI) HIMAGELIST;

// set_last_errror=False (can and should we use this?)
pub extern "COMCTL32" fn ImageList_Destroy(
    himl: HIMAGELIST,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "COMCTL32" fn ImageList_GetImageCount(
    himl: HIMAGELIST,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "COMCTL32" fn ImageList_SetImageCount(
    himl: HIMAGELIST,
    uNewCount: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "COMCTL32" fn ImageList_Add(
    himl: HIMAGELIST,
    hbmImage: HBITMAP,
    hbmMask: HBITMAP,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "COMCTL32" fn ImageList_ReplaceIcon(
    himl: HIMAGELIST,
    i: i32,
    hicon: HICON,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "COMCTL32" fn ImageList_SetBkColor(
    himl: HIMAGELIST,
    clrBk: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "COMCTL32" fn ImageList_GetBkColor(
    himl: HIMAGELIST,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "COMCTL32" fn ImageList_SetOverlayImage(
    himl: HIMAGELIST,
    iImage: i32,
    iOverlay: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "COMCTL32" fn ImageList_Draw(
    himl: HIMAGELIST,
    i: i32,
    hdcDst: HDC,
    x: i32,
    y: i32,
    fStyle: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "COMCTL32" fn ImageList_Replace(
    himl: HIMAGELIST,
    i: i32,
    hbmImage: HBITMAP,
    hbmMask: HBITMAP,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "COMCTL32" fn ImageList_AddMasked(
    himl: HIMAGELIST,
    hbmImage: HBITMAP,
    crMask: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "COMCTL32" fn ImageList_DrawEx(
    himl: HIMAGELIST,
    i: i32,
    hdcDst: HDC,
    x: i32,
    y: i32,
    dx: i32,
    dy: i32,
    rgbBk: u32,
    rgbFg: u32,
    fStyle: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "COMCTL32" fn ImageList_DrawIndirect(
    pimldp: ?*IMAGELISTDRAWPARAMS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "COMCTL32" fn ImageList_Remove(
    himl: HIMAGELIST,
    i: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "COMCTL32" fn ImageList_GetIcon(
    himl: HIMAGELIST,
    i: i32,
    flags: u32,
) callconv(@import("std").os.windows.WINAPI) HICON;

// set_last_errror=False (can and should we use this?)
pub extern "COMCTL32" fn ImageList_LoadImageA(
    hi: HINSTANCE,
    lpbmp: ?*i8,
    cx: i32,
    cGrow: i32,
    crMask: u32,
    uType: u32,
    uFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HIMAGELIST;

// set_last_errror=False (can and should we use this?)
pub extern "COMCTL32" fn ImageList_LoadImageW(
    hi: HINSTANCE,
    lpbmp: ?*u16,
    cx: i32,
    cGrow: i32,
    crMask: u32,
    uType: u32,
    uFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HIMAGELIST;

// set_last_errror=False (can and should we use this?)
pub extern "COMCTL32" fn ImageList_Copy(
    himlDst: HIMAGELIST,
    iDst: i32,
    himlSrc: HIMAGELIST,
    iSrc: i32,
    uFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "COMCTL32" fn ImageList_BeginDrag(
    himlTrack: HIMAGELIST,
    iTrack: i32,
    dxHotspot: i32,
    dyHotspot: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "COMCTL32" fn ImageList_EndDrag(
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "COMCTL32" fn ImageList_DragEnter(
    hwndLock: HWND,
    x: i32,
    y: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "COMCTL32" fn ImageList_DragLeave(
    hwndLock: HWND,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "COMCTL32" fn ImageList_DragMove(
    x: i32,
    y: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "COMCTL32" fn ImageList_SetDragCursorImage(
    himlDrag: HIMAGELIST,
    iDrag: i32,
    dxHotspot: i32,
    dyHotspot: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "COMCTL32" fn ImageList_DragShowNolock(
    fShow: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "COMCTL32" fn ImageList_GetDragImage(
    ppt: ?*POINT,
    pptHotspot: ?*POINT,
) callconv(@import("std").os.windows.WINAPI) HIMAGELIST;

// set_last_errror=False (can and should we use this?)
pub extern "COMCTL32" fn ImageList_Read(
    pstm: IStream,
) callconv(@import("std").os.windows.WINAPI) HIMAGELIST;

// set_last_errror=False (can and should we use this?)
pub extern "COMCTL32" fn ImageList_Write(
    himl: HIMAGELIST,
    pstm: IStream,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "COMCTL32" fn ImageList_ReadEx(
    dwFlags: u32,
    pstm: IStream,
    riid: ?*Guid,
    ppv: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "COMCTL32" fn ImageList_WriteEx(
    himl: HIMAGELIST,
    dwFlags: u32,
    pstm: IStream,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "COMCTL32" fn ImageList_GetIconSize(
    himl: HIMAGELIST,
    cx: ?*i32,
    cy: ?*i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "COMCTL32" fn ImageList_SetIconSize(
    himl: HIMAGELIST,
    cx: i32,
    cy: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "COMCTL32" fn ImageList_GetImageInfo(
    himl: HIMAGELIST,
    i: i32,
    pImageInfo: ?*IMAGEINFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "COMCTL32" fn ImageList_Merge(
    himl1: HIMAGELIST,
    i1: i32,
    himl2: HIMAGELIST,
    i2: i32,
    dx: i32,
    dy: i32,
) callconv(@import("std").os.windows.WINAPI) HIMAGELIST;

// set_last_errror=False (can and should we use this?)
pub extern "COMCTL32" fn ImageList_Duplicate(
    himl: HIMAGELIST,
) callconv(@import("std").os.windows.WINAPI) HIMAGELIST;

// set_last_errror=False (can and should we use this?)
pub extern "COMCTL32" fn HIMAGELIST_QueryInterface(
    himl: HIMAGELIST,
    riid: ?*Guid,
    ppv: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=True (can and should we use this?)
pub extern "COMCTL32" fn CreateToolbarEx(
    hwnd: HWND,
    ws: u32,
    wID: u32,
    nBitmaps: i32,
    hBMInst: HINSTANCE,
    wBMID: ?*opaque{},
    lpButtons: ?*TBBUTTON,
    iNumButtons: i32,
    dxButton: i32,
    dyButton: i32,
    dxBitmap: i32,
    dyBitmap: i32,
    uStructSize: u32,
) callconv(@import("std").os.windows.WINAPI) HWND;

// set_last_errror=True (can and should we use this?)
pub extern "COMCTL32" fn CreateMappedBitmap(
    hInstance: HINSTANCE,
    idBitmap: ?*opaque{},
    wFlags: u32,
    lpColorMap: ?*COLORMAP,
    iNumMaps: i32,
) callconv(@import("std").os.windows.WINAPI) HBITMAP;

// set_last_errror=False (can and should we use this?)
pub extern "COMCTL32" fn DrawStatusTextA(
    hDC: HDC,
    lprc: ?*RECT,
    pszText: ?*i8,
    uFlags: u32,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "COMCTL32" fn DrawStatusTextW(
    hDC: HDC,
    lprc: ?*RECT,
    pszText: ?*u16,
    uFlags: u32,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=True (can and should we use this?)
pub extern "COMCTL32" fn CreateStatusWindowA(
    style: i32,
    lpszText: ?*i8,
    hwndParent: HWND,
    wID: u32,
) callconv(@import("std").os.windows.WINAPI) HWND;

// set_last_errror=True (can and should we use this?)
pub extern "COMCTL32" fn CreateStatusWindowW(
    style: i32,
    lpszText: ?*u16,
    hwndParent: HWND,
    wID: u32,
) callconv(@import("std").os.windows.WINAPI) HWND;

// set_last_errror=False (can and should we use this?)
pub extern "COMCTL32" fn MenuHelp(
    uMsg: u32,
    wParam: WPARAM,
    lParam: LPARAM,
    hMainMenu: HMENU,
    hInst: HINSTANCE,
    hwndStatus: HWND,
    lpwIDs: ?*u32,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "COMCTL32" fn ShowHideMenuCtl(
    hWnd: HWND,
    uFlags: ?*opaque{},
    lpInfo: ?*i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "COMCTL32" fn GetEffectiveClientRect(
    hWnd: HWND,
    lprc: ?*RECT,
    lpInfo: ?*i32,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "COMCTL32" fn MakeDragList(
    hLB: HWND,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "COMCTL32" fn DrawInsert(
    handParent: HWND,
    hLB: HWND,
    nItem: i32,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "COMCTL32" fn LBItemFromPt(
    hLB: HWND,
    pt: POINT,
    bAutoScroll: BOOL,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "COMCTL32" fn CreateUpDownControl(
    dwStyle: u32,
    x: i32,
    y: i32,
    cx: i32,
    cy: i32,
    hParent: HWND,
    nID: i32,
    hInst: HINSTANCE,
    hBuddy: HWND,
    nUpper: i32,
    nLower: i32,
    nPos: i32,
) callconv(@import("std").os.windows.WINAPI) HWND;

// set_last_errror=False (can and should we use this?)
pub extern "COMCTL32" fn TaskDialogIndirect(
    pTaskConfig: ?*TASKDIALOGCONFIG,
    pnButton: ?*i32,
    pnRadioButton: ?*i32,
    pfVerificationFlagChecked: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "COMCTL32" fn TaskDialog(
    hwndOwner: HWND,
    hInstance: HINSTANCE,
    pszWindowTitle: ?*u16,
    pszMainInstruction: ?*u16,
    pszContent: ?*u16,
    dwCommonButtons: i32,
    pszIcon: ?*u16,
    pnButton: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "COMCTL32" fn InitMUILanguage(
    uiLang: u16,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "COMCTL32" fn GetMUILanguage(
) callconv(@import("std").os.windows.WINAPI) u16;

// set_last_errror=False (can and should we use this?)
pub extern "COMCTL32" fn DSA_Create(
    cbItem: i32,
    cItemGrow: i32,
) callconv(@import("std").os.windows.WINAPI) ?*_DSA;

// set_last_errror=False (can and should we use this?)
pub extern "COMCTL32" fn DSA_Destroy(
    hdsa: ?*_DSA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "COMCTL32" fn DSA_DestroyCallback(
    hdsa: ?*_DSA,
    pfnCB: PFNDAENUMCALLBACK,
    pData: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "COMCTL32" fn DSA_DeleteItem(
    hdsa: ?*_DSA,
    i: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "COMCTL32" fn DSA_DeleteAllItems(
    hdsa: ?*_DSA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "COMCTL32" fn DSA_EnumCallback(
    hdsa: ?*_DSA,
    pfnCB: PFNDAENUMCALLBACK,
    pData: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "COMCTL32" fn DSA_InsertItem(
    hdsa: ?*_DSA,
    i: i32,
    pitem: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "COMCTL32" fn DSA_GetItemPtr(
    hdsa: ?*_DSA,
    i: i32,
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=False (can and should we use this?)
pub extern "COMCTL32" fn DSA_GetItem(
    hdsa: ?*_DSA,
    i: i32,
    pitem: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "COMCTL32" fn DSA_SetItem(
    hdsa: ?*_DSA,
    i: i32,
    pitem: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "COMCTL32" fn DSA_Clone(
    hdsa: ?*_DSA,
) callconv(@import("std").os.windows.WINAPI) ?*_DSA;

// set_last_errror=False (can and should we use this?)
pub extern "COMCTL32" fn DSA_GetSize(
    hdsa: ?*_DSA,
) callconv(@import("std").os.windows.WINAPI) u64;

// set_last_errror=False (can and should we use this?)
pub extern "COMCTL32" fn DSA_Sort(
    pdsa: ?*_DSA,
    pfnCompare: PFNDACOMPARE,
    lParam: LPARAM,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "COMCTL32" fn DPA_Create(
    cItemGrow: i32,
) callconv(@import("std").os.windows.WINAPI) ?*_DPA;

// set_last_errror=False (can and should we use this?)
pub extern "COMCTL32" fn DPA_CreateEx(
    cpGrow: i32,
    hheap: HANDLE,
) callconv(@import("std").os.windows.WINAPI) ?*_DPA;

// set_last_errror=False (can and should we use this?)
pub extern "COMCTL32" fn DPA_Clone(
    hdpa: ?*_DPA,
    hdpaNew: ?*_DPA,
) callconv(@import("std").os.windows.WINAPI) ?*_DPA;

// set_last_errror=False (can and should we use this?)
pub extern "COMCTL32" fn DPA_Destroy(
    hdpa: ?*_DPA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "COMCTL32" fn DPA_DestroyCallback(
    hdpa: ?*_DPA,
    pfnCB: PFNDAENUMCALLBACK,
    pData: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "COMCTL32" fn DPA_DeletePtr(
    hdpa: ?*_DPA,
    i: i32,
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=False (can and should we use this?)
pub extern "COMCTL32" fn DPA_DeleteAllPtrs(
    hdpa: ?*_DPA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "COMCTL32" fn DPA_EnumCallback(
    hdpa: ?*_DPA,
    pfnCB: PFNDAENUMCALLBACK,
    pData: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "COMCTL32" fn DPA_Grow(
    pdpa: ?*_DPA,
    cp: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "COMCTL32" fn DPA_InsertPtr(
    hdpa: ?*_DPA,
    i: i32,
    p: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "COMCTL32" fn DPA_SetPtr(
    hdpa: ?*_DPA,
    i: i32,
    p: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "COMCTL32" fn DPA_GetPtr(
    hdpa: ?*_DPA,
    i: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=False (can and should we use this?)
pub extern "COMCTL32" fn DPA_GetPtrIndex(
    hdpa: ?*_DPA,
    p: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "COMCTL32" fn DPA_GetSize(
    hdpa: ?*_DPA,
) callconv(@import("std").os.windows.WINAPI) u64;

// set_last_errror=False (can and should we use this?)
pub extern "COMCTL32" fn DPA_Sort(
    hdpa: ?*_DPA,
    pfnCompare: PFNDACOMPARE,
    lParam: LPARAM,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "COMCTL32" fn DPA_LoadStream(
    phdpa: ?*?*_DPA,
    pfn: PFNDPASTREAM,
    pstream: IStream,
    pvInstData: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "COMCTL32" fn DPA_SaveStream(
    hdpa: ?*_DPA,
    pfn: PFNDPASTREAM,
    pstream: IStream,
    pvInstData: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "COMCTL32" fn DPA_Merge(
    hdpaDest: ?*_DPA,
    hdpaSrc: ?*_DPA,
    dwFlags: u32,
    pfnCompare: PFNDACOMPARE,
    pfnMerge: PFNDPAMERGE,
    lParam: LPARAM,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "COMCTL32" fn DPA_Search(
    hdpa: ?*_DPA,
    pFind: ?*opaque{},
    iStart: i32,
    pfnCompare: PFNDACOMPARE,
    lParam: LPARAM,
    options: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "COMCTL32" fn Str_SetPtrW(
    ppsz: ?*?*u16,
    psz: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "COMCTL32" fn FlatSB_EnableScrollBar(
    param0: HWND,
    param1: i32,
    param2: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "COMCTL32" fn FlatSB_ShowScrollBar(
    param0: HWND,
    code: i32,
    param2: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "COMCTL32" fn FlatSB_GetScrollRange(
    param0: HWND,
    code: i32,
    param2: ?*i32,
    param3: ?*i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "COMCTL32" fn FlatSB_GetScrollInfo(
    param0: HWND,
    code: i32,
    param2: ?*SCROLLINFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "COMCTL32" fn FlatSB_GetScrollPos(
    param0: HWND,
    code: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "COMCTL32" fn FlatSB_GetScrollProp(
    param0: HWND,
    propIndex: i32,
    param2: ?*i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "COMCTL32" fn FlatSB_SetScrollPos(
    param0: HWND,
    code: i32,
    pos: i32,
    fRedraw: BOOL,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "COMCTL32" fn FlatSB_SetScrollInfo(
    param0: HWND,
    code: i32,
    psi: ?*SCROLLINFO,
    fRedraw: BOOL,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "COMCTL32" fn FlatSB_SetScrollRange(
    param0: HWND,
    code: i32,
    min: i32,
    max: i32,
    fRedraw: BOOL,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "COMCTL32" fn FlatSB_SetScrollProp(
    param0: HWND,
    index: u32,
    newValue: ?*opaque{},
    param3: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "COMCTL32" fn InitializeFlatSB(
    param0: HWND,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "COMCTL32" fn UninitializeFlatSB(
    param0: HWND,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "COMCTL32" fn LoadIconMetric(
    hinst: HINSTANCE,
    pszName: ?*u16,
    lims: i32,
    phico: ?*HICON,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "COMCTL32" fn LoadIconWithScaleDown(
    hinst: HINSTANCE,
    pszName: ?*u16,
    cx: i32,
    cy: i32,
    phico: ?*HICON,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "COMCTL32" fn DrawShadowText(
    hdc: HDC,
    pszText: ?*u16,
    cch: u32,
    prc: ?*RECT,
    dwFlags: u32,
    crText: u32,
    crShadow: u32,
    ixOffset: i32,
    iyOffset: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "COMCTL32" fn ImageList_CoCreateInstance(
    rclsid: ?*Guid,
    punkOuter: IUnknown,
    riid: ?*Guid,
    ppv: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "UXTHEME" fn GetThemeAnimationProperty(
    hTheme: ?*opaque{},
    iStoryboardId: i32,
    iTargetId: i32,
    eProperty: TA_PROPERTY,
    pvProperty: ?*opaque{},
    cbSize: u32,
    pcbSizeOut: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "UXTHEME" fn GetThemeAnimationTransform(
    hTheme: ?*opaque{},
    iStoryboardId: i32,
    iTargetId: i32,
    dwTransformIndex: u32,
    pTransform: ?*TA_TRANSFORM,
    cbSize: u32,
    pcbSizeOut: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "UXTHEME" fn GetThemeTimingFunction(
    hTheme: ?*opaque{},
    iTimingFunctionId: i32,
    pTimingFunction: ?*TA_TIMINGFUNCTION,
    cbSize: u32,
    pcbSizeOut: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "UXTHEME" fn OpenThemeData(
    hwnd: HWND,
    pszClassList: ?*u16,
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=False (can and should we use this?)
pub extern "UXTHEME" fn OpenThemeDataEx(
    hwnd: HWND,
    pszClassList: ?*u16,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=False (can and should we use this?)
pub extern "UXTHEME" fn CloseThemeData(
    hTheme: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "UXTHEME" fn DrawThemeBackground(
    hTheme: ?*opaque{},
    hdc: HDC,
    iPartId: i32,
    iStateId: i32,
    pRect: ?*RECT,
    pClipRect: ?*RECT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "UXTHEME" fn DrawThemeBackgroundEx(
    hTheme: ?*opaque{},
    hdc: HDC,
    iPartId: i32,
    iStateId: i32,
    pRect: ?*RECT,
    pOptions: ?*DTBGOPTS,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "UxTheme" fn DrawThemeText(
    hTheme: ?*opaque{},
    hdc: HDC,
    iPartId: i32,
    iStateId: i32,
    pszText: ?*u16,
    cchText: i32,
    dwTextFlags: u32,
    dwTextFlags2: u32,
    pRect: ?*RECT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "UXTHEME" fn GetThemeBackgroundContentRect(
    hTheme: ?*opaque{},
    hdc: HDC,
    iPartId: i32,
    iStateId: i32,
    pBoundingRect: ?*RECT,
    pContentRect: ?*RECT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "UXTHEME" fn GetThemeBackgroundExtent(
    hTheme: ?*opaque{},
    hdc: HDC,
    iPartId: i32,
    iStateId: i32,
    pContentRect: ?*RECT,
    pExtentRect: ?*RECT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "UxTheme" fn GetThemeBackgroundRegion(
    hTheme: ?*opaque{},
    hdc: HDC,
    iPartId: i32,
    iStateId: i32,
    pRect: ?*RECT,
    pRegion: ?*HRGN,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "UXTHEME" fn GetThemePartSize(
    hTheme: ?*opaque{},
    hdc: HDC,
    iPartId: i32,
    iStateId: i32,
    prc: ?*RECT,
    eSize: THEMESIZE,
    psz: ?*SIZE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "UxTheme" fn GetThemeTextExtent(
    hTheme: ?*opaque{},
    hdc: HDC,
    iPartId: i32,
    iStateId: i32,
    pszText: ?*u16,
    cchCharCount: i32,
    dwTextFlags: u32,
    pBoundingRect: ?*RECT,
    pExtentRect: ?*RECT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "UxTheme" fn GetThemeTextMetrics(
    hTheme: ?*opaque{},
    hdc: HDC,
    iPartId: i32,
    iStateId: i32,
    ptm: ?*TEXTMETRICW,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "UxTheme" fn HitTestThemeBackground(
    hTheme: ?*opaque{},
    hdc: HDC,
    iPartId: i32,
    iStateId: i32,
    dwOptions: u32,
    pRect: ?*RECT,
    hrgn: HRGN,
    ptTest: POINT,
    pwHitTestCode: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "UxTheme" fn DrawThemeEdge(
    hTheme: ?*opaque{},
    hdc: HDC,
    iPartId: i32,
    iStateId: i32,
    pDestRect: ?*RECT,
    uEdge: u32,
    uFlags: u32,
    pContentRect: ?*RECT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "UxTheme" fn DrawThemeIcon(
    hTheme: ?*opaque{},
    hdc: HDC,
    iPartId: i32,
    iStateId: i32,
    pRect: ?*RECT,
    himl: HIMAGELIST,
    iImageIndex: i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "UXTHEME" fn IsThemePartDefined(
    hTheme: ?*opaque{},
    iPartId: i32,
    iStateId: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "UxTheme" fn IsThemeBackgroundPartiallyTransparent(
    hTheme: ?*opaque{},
    iPartId: i32,
    iStateId: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "UXTHEME" fn GetThemeColor(
    hTheme: ?*opaque{},
    iPartId: i32,
    iStateId: i32,
    iPropId: i32,
    pColor: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "UXTHEME" fn GetThemeMetric(
    hTheme: ?*opaque{},
    hdc: HDC,
    iPartId: i32,
    iStateId: i32,
    iPropId: i32,
    piVal: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "UxTheme" fn GetThemeString(
    hTheme: ?*opaque{},
    iPartId: i32,
    iStateId: i32,
    iPropId: i32,
    pszBuff: ?*u16,
    cchMaxBuffChars: i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "UxTheme" fn GetThemeBool(
    hTheme: ?*opaque{},
    iPartId: i32,
    iStateId: i32,
    iPropId: i32,
    pfVal: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "UXTHEME" fn GetThemeInt(
    hTheme: ?*opaque{},
    iPartId: i32,
    iStateId: i32,
    iPropId: i32,
    piVal: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "UXTHEME" fn GetThemeEnumValue(
    hTheme: ?*opaque{},
    iPartId: i32,
    iStateId: i32,
    iPropId: i32,
    piVal: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "UXTHEME" fn GetThemePosition(
    hTheme: ?*opaque{},
    iPartId: i32,
    iStateId: i32,
    iPropId: i32,
    pPoint: ?*POINT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "UXTHEME" fn GetThemeFont(
    hTheme: ?*opaque{},
    hdc: HDC,
    iPartId: i32,
    iStateId: i32,
    iPropId: i32,
    pFont: ?*LOGFONTW,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "UXTHEME" fn GetThemeRect(
    hTheme: ?*opaque{},
    iPartId: i32,
    iStateId: i32,
    iPropId: i32,
    pRect: ?*RECT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "UXTHEME" fn GetThemeMargins(
    hTheme: ?*opaque{},
    hdc: HDC,
    iPartId: i32,
    iStateId: i32,
    iPropId: i32,
    prc: ?*RECT,
    pMargins: ?*MARGINS,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "UxTheme" fn GetThemeIntList(
    hTheme: ?*opaque{},
    iPartId: i32,
    iStateId: i32,
    iPropId: i32,
    pIntList: ?*INTLIST,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "UxTheme" fn GetThemePropertyOrigin(
    hTheme: ?*opaque{},
    iPartId: i32,
    iStateId: i32,
    iPropId: i32,
    pOrigin: ?*PROPERTYORIGIN,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "UXTHEME" fn SetWindowTheme(
    hwnd: HWND,
    pszSubAppName: ?*u16,
    pszSubIdList: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "UxTheme" fn GetThemeFilename(
    hTheme: ?*opaque{},
    iPartId: i32,
    iStateId: i32,
    iPropId: i32,
    pszThemeFileName: ?*u16,
    cchMaxBuffChars: i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "UxTheme" fn GetThemeSysColor(
    hTheme: ?*opaque{},
    iColorId: i32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "UxTheme" fn GetThemeSysColorBrush(
    hTheme: ?*opaque{},
    iColorId: i32,
) callconv(@import("std").os.windows.WINAPI) HBRUSH;

// set_last_errror=False (can and should we use this?)
pub extern "UxTheme" fn GetThemeSysBool(
    hTheme: ?*opaque{},
    iBoolId: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "UxTheme" fn GetThemeSysSize(
    hTheme: ?*opaque{},
    iSizeId: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "UxTheme" fn GetThemeSysFont(
    hTheme: ?*opaque{},
    iFontId: i32,
    plf: ?*LOGFONTW,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "UxTheme" fn GetThemeSysString(
    hTheme: ?*opaque{},
    iStringId: i32,
    pszStringBuff: ?*u16,
    cchMaxStringChars: i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "UxTheme" fn GetThemeSysInt(
    hTheme: ?*opaque{},
    iIntId: i32,
    piValue: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "UXTHEME" fn IsThemeActive(
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "UXTHEME" fn IsAppThemed(
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "UXTHEME" fn GetWindowTheme(
    hwnd: HWND,
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=False (can and should we use this?)
pub extern "UxTheme" fn EnableThemeDialogTexture(
    hwnd: HWND,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "UxTheme" fn IsThemeDialogTextureEnabled(
    hwnd: HWND,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "UXTHEME" fn GetThemeAppProperties(
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "UxTheme" fn SetThemeAppProperties(
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "UXTHEME" fn GetCurrentThemeName(
    pszThemeFileName: ?*u16,
    cchMaxNameChars: i32,
    pszColorBuff: ?*u16,
    cchMaxColorChars: i32,
    pszSizeBuff: ?*u16,
    cchMaxSizeChars: i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "UxTheme" fn GetThemeDocumentationProperty(
    pszThemeName: ?*u16,
    pszPropertyName: ?*u16,
    pszValueBuff: ?*u16,
    cchMaxValChars: i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "UXTHEME" fn DrawThemeParentBackground(
    hwnd: HWND,
    hdc: HDC,
    prc: ?*RECT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "UxTheme" fn EnableTheming(
    fEnable: BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "UxTheme" fn DrawThemeParentBackgroundEx(
    hwnd: HWND,
    hdc: HDC,
    dwFlags: u32,
    prc: ?*RECT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "UXTHEME" fn SetWindowThemeAttribute(
    hwnd: HWND,
    eAttribute: WINDOWTHEMEATTRIBUTETYPE,
    pvAttribute: ?*opaque{},
    cbAttribute: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "UXTHEME" fn DrawThemeTextEx(
    hTheme: ?*opaque{},
    hdc: HDC,
    iPartId: i32,
    iStateId: i32,
    pszText: ?*u16,
    cchText: i32,
    dwTextFlags: u32,
    pRect: ?*RECT,
    pOptions: ?*DTTOPTS,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "UXTHEME" fn GetThemeBitmap(
    hTheme: ?*opaque{},
    iPartId: i32,
    iStateId: i32,
    iPropId: i32,
    dwFlags: u32,
    phBitmap: ?*HBITMAP,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "UXTHEME" fn GetThemeStream(
    hTheme: ?*opaque{},
    iPartId: i32,
    iStateId: i32,
    iPropId: i32,
    ppvStream: ?*?*opaque{},
    pcbStream: ?*u32,
    hInst: HINSTANCE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "UXTHEME" fn BufferedPaintInit(
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "UXTHEME" fn BufferedPaintUnInit(
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=True (can and should we use this?)
pub extern "UXTHEME" fn BeginBufferedPaint(
    hdcTarget: HDC,
    prcTarget: ?*RECT,
    dwFormat: BP_BUFFERFORMAT,
    pPaintParams: ?*BP_PAINTPARAMS,
    phdc: ?*HDC,
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=False (can and should we use this?)
pub extern "UXTHEME" fn EndBufferedPaint(
    hBufferedPaint: ?*opaque{},
    fUpdateTarget: BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "UxTheme" fn GetBufferedPaintTargetRect(
    hBufferedPaint: ?*opaque{},
    prc: ?*RECT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "UxTheme" fn GetBufferedPaintTargetDC(
    hBufferedPaint: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HDC;

// set_last_errror=False (can and should we use this?)
pub extern "UxTheme" fn GetBufferedPaintDC(
    hBufferedPaint: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HDC;

// set_last_errror=False (can and should we use this?)
pub extern "UXTHEME" fn GetBufferedPaintBits(
    hBufferedPaint: ?*opaque{},
    ppbBuffer: ?*?*RGBQUAD,
    pcxRow: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "UXTHEME" fn BufferedPaintClear(
    hBufferedPaint: ?*opaque{},
    prc: ?*RECT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "UxTheme" fn BufferedPaintSetAlpha(
    hBufferedPaint: ?*opaque{},
    prc: ?*RECT,
    alpha: u8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "UXTHEME" fn BufferedPaintStopAllAnimations(
    hwnd: HWND,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "UxTheme" fn BeginBufferedAnimation(
    hwnd: HWND,
    hdcTarget: HDC,
    prcTarget: ?*RECT,
    dwFormat: BP_BUFFERFORMAT,
    pPaintParams: ?*BP_PAINTPARAMS,
    pAnimationParams: ?*BP_ANIMATIONPARAMS,
    phdcFrom: ?*HDC,
    phdcTo: ?*HDC,
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=False (can and should we use this?)
pub extern "UxTheme" fn EndBufferedAnimation(
    hbpAnimation: ?*opaque{},
    fUpdateTarget: BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "UxTheme" fn BufferedPaintRenderAnimation(
    hwnd: HWND,
    hdcTarget: HDC,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "UXTHEME" fn IsCompositionActive(
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "UxTheme" fn GetThemeTransitionDuration(
    hTheme: ?*opaque{},
    iPartId: i32,
    iStateIdFrom: i32,
    iStateIdTo: i32,
    iPropId: i32,
    pdwDuration: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

//
// Unicode Symbol Aliases
//
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {
        pub const EDITWORDBREAKPROC = EDITWORDBREAKPROCA;
        pub const LPFNPSPCALLBACK = LPFNPSPCALLBACKA;
        pub const PROPSHEETPAGE = PROPSHEETPAGEA;
        pub const HD_TEXTFILTER = HD_TEXTFILTERA;
        pub const HDITEM = HDITEMA;
        pub const NMHEADER = NMHEADERA;
        pub const NMHDDISPINFO = NMHDDISPINFOA;
        pub const TBSAVEPARAMS = TBSAVEPARAMSA;
        pub const TBBUTTONINFO = TBBUTTONINFOA;
        pub const NMTBGETINFOTIP = NMTBGETINFOTIPA;
        pub const NMTBDISPINFO = NMTBDISPINFOA;
        pub const NMTOOLBAR = NMTOOLBARA;
        pub const REBARBANDINFO = REBARBANDINFOA;
        pub const TTTOOLINFO = TTTOOLINFOA;
        pub const TTHITTESTINFO = TTHITTESTINFOA;
        pub const NMTTDISPINFO = NMTTDISPINFOA;
        pub const LVITEM = LVITEMA;
        pub const LVFINDINFO = LVFINDINFOA;
        pub const LVCOLUMN = LVCOLUMNA;
        pub const LVBKIMAGE = LVBKIMAGEA;
        pub const NMLVFINDITEM = NMLVFINDITEMA;
        pub const NMLVDISPINFO = NMLVDISPINFOA;
        pub const NMLVGETINFOTIP = NMLVGETINFOTIPA;
        pub const TVITEM = TVITEMA;
        pub const TVITEMEX = TVITEMEXA;
        pub const TVINSERTSTRUCT = TVINSERTSTRUCTA;
        pub const NMTREEVIEW = NMTREEVIEWA;
        pub const NMTVDISPINFO = NMTVDISPINFOA;
        pub const NMTVDISPINFOEX = NMTVDISPINFOEXA;
        pub const NMTVGETINFOTIP = NMTVGETINFOTIPA;
        pub const COMBOBOXEXITEM = COMBOBOXEXITEMA;
        pub const NMCOMBOBOXEX = NMCOMBOBOXEXA;
        pub const NMCBEDRAGBEGIN = NMCBEDRAGBEGINA;
        pub const NMCBEENDEDIT = NMCBEENDEDITA;
        pub const TCITEMHEADER = TCITEMHEADERA;
        pub const TCITEM = TCITEMA;
        pub const NMDATETIMESTRING = NMDATETIMESTRINGA;
        pub const NMDATETIMEWMKEYDOWN = NMDATETIMEWMKEYDOWNA;
        pub const NMDATETIMEFORMAT = NMDATETIMEFORMATA;
        pub const NMDATETIMEFORMATQUERY = NMDATETIMEFORMATQUERYA;
        pub const CHARFORMAT = CHARFORMATA;
        pub const CHARFORMAT2 = CHARFORMAT2A;
        pub const TEXTRANGE = TEXTRANGEA;
        pub const FINDTEXT = FINDTEXTA;
        pub const FINDTEXTEX = FINDTEXTEXA;
        pub const DlgDirList = DlgDirListA;
        pub const DlgDirSelectEx = DlgDirSelectExA;
        pub const DlgDirListComboBox = DlgDirListComboBoxA;
        pub const DlgDirSelectComboBoxEx = DlgDirSelectComboBoxExA;
        pub const CreatePropertySheetPage = CreatePropertySheetPageA;
        pub const PropertySheet = PropertySheetA;
        pub const ImageList_LoadImage = ImageList_LoadImageA;
        pub const DrawStatusText = DrawStatusTextA;
        pub const CreateStatusWindow = CreateStatusWindowA;
    },
    .wide => struct {
        pub const EDITWORDBREAKPROC = EDITWORDBREAKPROCW;
        pub const LPFNPSPCALLBACK = LPFNPSPCALLBACKW;
        pub const PROPSHEETPAGE = PROPSHEETPAGEW;
        pub const HD_TEXTFILTER = HD_TEXTFILTERW;
        pub const HDITEM = HDITEMW;
        pub const NMHEADER = NMHEADERW;
        pub const NMHDDISPINFO = NMHDDISPINFOW;
        pub const TBSAVEPARAMS = TBSAVEPARAMSW;
        pub const TBBUTTONINFO = TBBUTTONINFOW;
        pub const NMTBGETINFOTIP = NMTBGETINFOTIPW;
        pub const NMTBDISPINFO = NMTBDISPINFOW;
        pub const NMTOOLBAR = NMTOOLBARW;
        pub const REBARBANDINFO = REBARBANDINFOW;
        pub const TTTOOLINFO = TTTOOLINFOW;
        pub const TTHITTESTINFO = TTHITTESTINFOW;
        pub const NMTTDISPINFO = NMTTDISPINFOW;
        pub const LVITEM = LVITEMW;
        pub const LVFINDINFO = LVFINDINFOW;
        pub const LVCOLUMN = LVCOLUMNW;
        pub const LVBKIMAGE = LVBKIMAGEW;
        pub const NMLVFINDITEM = NMLVFINDITEMW;
        pub const NMLVDISPINFO = NMLVDISPINFOW;
        pub const NMLVGETINFOTIP = NMLVGETINFOTIPW;
        pub const TVITEM = TVITEMW;
        pub const TVITEMEX = TVITEMEXW;
        pub const TVINSERTSTRUCT = TVINSERTSTRUCTW;
        pub const NMTREEVIEW = NMTREEVIEWW;
        pub const NMTVDISPINFO = NMTVDISPINFOW;
        pub const NMTVDISPINFOEX = NMTVDISPINFOEXW;
        pub const NMTVGETINFOTIP = NMTVGETINFOTIPW;
        pub const COMBOBOXEXITEM = COMBOBOXEXITEMW;
        pub const NMCOMBOBOXEX = NMCOMBOBOXEXW;
        pub const NMCBEDRAGBEGIN = NMCBEDRAGBEGINW;
        pub const NMCBEENDEDIT = NMCBEENDEDITW;
        pub const TCITEMHEADER = TCITEMHEADERW;
        pub const TCITEM = TCITEMW;
        pub const NMDATETIMESTRING = NMDATETIMESTRINGW;
        pub const NMDATETIMEWMKEYDOWN = NMDATETIMEWMKEYDOWNW;
        pub const NMDATETIMEFORMAT = NMDATETIMEFORMATW;
        pub const NMDATETIMEFORMATQUERY = NMDATETIMEFORMATQUERYW;
        pub const CHARFORMAT = CHARFORMATW;
        pub const CHARFORMAT2 = CHARFORMAT2W;
        pub const TEXTRANGE = TEXTRANGEW;
        pub const FINDTEXT = FINDTEXTW;
        pub const FINDTEXTEX = FINDTEXTEXW;
        pub const DlgDirList = DlgDirListW;
        pub const DlgDirSelectEx = DlgDirSelectExW;
        pub const DlgDirListComboBox = DlgDirListComboBoxW;
        pub const DlgDirSelectComboBoxEx = DlgDirSelectComboBoxExW;
        pub const CreatePropertySheetPage = CreatePropertySheetPageW;
        pub const PropertySheet = PropertySheetW;
        pub const ImageList_LoadImage = ImageList_LoadImageW;
        pub const DrawStatusText = DrawStatusTextW;
        pub const CreateStatusWindow = CreateStatusWindowW;
    },
    else => if (@import("builtin").is_test) struct {
        pub const EDITWORDBREAKPROC = *opaque{};
        pub const LPFNPSPCALLBACK = *opaque{};
        pub const PROPSHEETPAGE = *opaque{};
        pub const HD_TEXTFILTER = *opaque{};
        pub const HDITEM = *opaque{};
        pub const NMHEADER = *opaque{};
        pub const NMHDDISPINFO = *opaque{};
        pub const TBSAVEPARAMS = *opaque{};
        pub const TBBUTTONINFO = *opaque{};
        pub const NMTBGETINFOTIP = *opaque{};
        pub const NMTBDISPINFO = *opaque{};
        pub const NMTOOLBAR = *opaque{};
        pub const REBARBANDINFO = *opaque{};
        pub const TTTOOLINFO = *opaque{};
        pub const TTHITTESTINFO = *opaque{};
        pub const NMTTDISPINFO = *opaque{};
        pub const LVITEM = *opaque{};
        pub const LVFINDINFO = *opaque{};
        pub const LVCOLUMN = *opaque{};
        pub const LVBKIMAGE = *opaque{};
        pub const NMLVFINDITEM = *opaque{};
        pub const NMLVDISPINFO = *opaque{};
        pub const NMLVGETINFOTIP = *opaque{};
        pub const TVITEM = *opaque{};
        pub const TVITEMEX = *opaque{};
        pub const TVINSERTSTRUCT = *opaque{};
        pub const NMTREEVIEW = *opaque{};
        pub const NMTVDISPINFO = *opaque{};
        pub const NMTVDISPINFOEX = *opaque{};
        pub const NMTVGETINFOTIP = *opaque{};
        pub const COMBOBOXEXITEM = *opaque{};
        pub const NMCOMBOBOXEX = *opaque{};
        pub const NMCBEDRAGBEGIN = *opaque{};
        pub const NMCBEENDEDIT = *opaque{};
        pub const TCITEMHEADER = *opaque{};
        pub const TCITEM = *opaque{};
        pub const NMDATETIMESTRING = *opaque{};
        pub const NMDATETIMEWMKEYDOWN = *opaque{};
        pub const NMDATETIMEFORMAT = *opaque{};
        pub const NMDATETIMEFORMATQUERY = *opaque{};
        pub const CHARFORMAT = *opaque{};
        pub const CHARFORMAT2 = *opaque{};
        pub const TEXTRANGE = *opaque{};
        pub const FINDTEXT = *opaque{};
        pub const FINDTEXTEX = *opaque{};
        pub const DlgDirList = *opaque{};
        pub const DlgDirSelectEx = *opaque{};
        pub const DlgDirListComboBox = *opaque{};
        pub const DlgDirSelectComboBoxEx = *opaque{};
        pub const CreatePropertySheetPage = *opaque{};
        pub const PropertySheet = *opaque{};
        pub const ImageList_LoadImage = *opaque{};
        pub const DrawStatusText = *opaque{};
        pub const CreateStatusWindow = *opaque{};
    } else struct {
        pub const EDITWORDBREAKPROC = @compileError("'EDITWORDBREAKPROC' requires that UNICODE be set to true or false in the root module");
        pub const LPFNPSPCALLBACK = @compileError("'LPFNPSPCALLBACK' requires that UNICODE be set to true or false in the root module");
        pub const PROPSHEETPAGE = @compileError("'PROPSHEETPAGE' requires that UNICODE be set to true or false in the root module");
        pub const HD_TEXTFILTER = @compileError("'HD_TEXTFILTER' requires that UNICODE be set to true or false in the root module");
        pub const HDITEM = @compileError("'HDITEM' requires that UNICODE be set to true or false in the root module");
        pub const NMHEADER = @compileError("'NMHEADER' requires that UNICODE be set to true or false in the root module");
        pub const NMHDDISPINFO = @compileError("'NMHDDISPINFO' requires that UNICODE be set to true or false in the root module");
        pub const TBSAVEPARAMS = @compileError("'TBSAVEPARAMS' requires that UNICODE be set to true or false in the root module");
        pub const TBBUTTONINFO = @compileError("'TBBUTTONINFO' requires that UNICODE be set to true or false in the root module");
        pub const NMTBGETINFOTIP = @compileError("'NMTBGETINFOTIP' requires that UNICODE be set to true or false in the root module");
        pub const NMTBDISPINFO = @compileError("'NMTBDISPINFO' requires that UNICODE be set to true or false in the root module");
        pub const NMTOOLBAR = @compileError("'NMTOOLBAR' requires that UNICODE be set to true or false in the root module");
        pub const REBARBANDINFO = @compileError("'REBARBANDINFO' requires that UNICODE be set to true or false in the root module");
        pub const TTTOOLINFO = @compileError("'TTTOOLINFO' requires that UNICODE be set to true or false in the root module");
        pub const TTHITTESTINFO = @compileError("'TTHITTESTINFO' requires that UNICODE be set to true or false in the root module");
        pub const NMTTDISPINFO = @compileError("'NMTTDISPINFO' requires that UNICODE be set to true or false in the root module");
        pub const LVITEM = @compileError("'LVITEM' requires that UNICODE be set to true or false in the root module");
        pub const LVFINDINFO = @compileError("'LVFINDINFO' requires that UNICODE be set to true or false in the root module");
        pub const LVCOLUMN = @compileError("'LVCOLUMN' requires that UNICODE be set to true or false in the root module");
        pub const LVBKIMAGE = @compileError("'LVBKIMAGE' requires that UNICODE be set to true or false in the root module");
        pub const NMLVFINDITEM = @compileError("'NMLVFINDITEM' requires that UNICODE be set to true or false in the root module");
        pub const NMLVDISPINFO = @compileError("'NMLVDISPINFO' requires that UNICODE be set to true or false in the root module");
        pub const NMLVGETINFOTIP = @compileError("'NMLVGETINFOTIP' requires that UNICODE be set to true or false in the root module");
        pub const TVITEM = @compileError("'TVITEM' requires that UNICODE be set to true or false in the root module");
        pub const TVITEMEX = @compileError("'TVITEMEX' requires that UNICODE be set to true or false in the root module");
        pub const TVINSERTSTRUCT = @compileError("'TVINSERTSTRUCT' requires that UNICODE be set to true or false in the root module");
        pub const NMTREEVIEW = @compileError("'NMTREEVIEW' requires that UNICODE be set to true or false in the root module");
        pub const NMTVDISPINFO = @compileError("'NMTVDISPINFO' requires that UNICODE be set to true or false in the root module");
        pub const NMTVDISPINFOEX = @compileError("'NMTVDISPINFOEX' requires that UNICODE be set to true or false in the root module");
        pub const NMTVGETINFOTIP = @compileError("'NMTVGETINFOTIP' requires that UNICODE be set to true or false in the root module");
        pub const COMBOBOXEXITEM = @compileError("'COMBOBOXEXITEM' requires that UNICODE be set to true or false in the root module");
        pub const NMCOMBOBOXEX = @compileError("'NMCOMBOBOXEX' requires that UNICODE be set to true or false in the root module");
        pub const NMCBEDRAGBEGIN = @compileError("'NMCBEDRAGBEGIN' requires that UNICODE be set to true or false in the root module");
        pub const NMCBEENDEDIT = @compileError("'NMCBEENDEDIT' requires that UNICODE be set to true or false in the root module");
        pub const TCITEMHEADER = @compileError("'TCITEMHEADER' requires that UNICODE be set to true or false in the root module");
        pub const TCITEM = @compileError("'TCITEM' requires that UNICODE be set to true or false in the root module");
        pub const NMDATETIMESTRING = @compileError("'NMDATETIMESTRING' requires that UNICODE be set to true or false in the root module");
        pub const NMDATETIMEWMKEYDOWN = @compileError("'NMDATETIMEWMKEYDOWN' requires that UNICODE be set to true or false in the root module");
        pub const NMDATETIMEFORMAT = @compileError("'NMDATETIMEFORMAT' requires that UNICODE be set to true or false in the root module");
        pub const NMDATETIMEFORMATQUERY = @compileError("'NMDATETIMEFORMATQUERY' requires that UNICODE be set to true or false in the root module");
        pub const CHARFORMAT = @compileError("'CHARFORMAT' requires that UNICODE be set to true or false in the root module");
        pub const CHARFORMAT2 = @compileError("'CHARFORMAT2' requires that UNICODE be set to true or false in the root module");
        pub const TEXTRANGE = @compileError("'TEXTRANGE' requires that UNICODE be set to true or false in the root module");
        pub const FINDTEXT = @compileError("'FINDTEXT' requires that UNICODE be set to true or false in the root module");
        pub const FINDTEXTEX = @compileError("'FINDTEXTEX' requires that UNICODE be set to true or false in the root module");
        pub const DlgDirList = @compileError("'DlgDirList' requires that UNICODE be set to true or false in the root module");
        pub const DlgDirSelectEx = @compileError("'DlgDirSelectEx' requires that UNICODE be set to true or false in the root module");
        pub const DlgDirListComboBox = @compileError("'DlgDirListComboBox' requires that UNICODE be set to true or false in the root module");
        pub const DlgDirSelectComboBoxEx = @compileError("'DlgDirSelectComboBoxEx' requires that UNICODE be set to true or false in the root module");
        pub const CreatePropertySheetPage = @compileError("'CreatePropertySheetPage' requires that UNICODE be set to true or false in the root module");
        pub const PropertySheet = @compileError("'PropertySheet' requires that UNICODE be set to true or false in the root module");
        pub const ImageList_LoadImage = @compileError("'ImageList_LoadImage' requires that UNICODE be set to true or false in the root module");
        pub const DrawStatusText = @compileError("'DrawStatusText' requires that UNICODE be set to true or false in the root module");
        pub const CreateStatusWindow = @compileError("'CreateStatusWindow' requires that UNICODE be set to true or false in the root module");
    },
};

//
// type imports
//
const Guid = @import("../zig.zig").Guid;
const HWND = @import("windowsandmessaging.zig").HWND;
const HDC = @import("gdi.zig").HDC;
const RECT = @import("displaydevices.zig").RECT;
const POINT = @import("displaydevices.zig").POINT;
const HANDLE = @import("systemservices.zig").HANDLE;
const HINSTANCE = @import("systemservices.zig").HINSTANCE;
const DLGPROC = @import("windowsandmessaging.zig").DLGPROC;
const LPARAM = @import("windowsandmessaging.zig").LPARAM;
const HPALETTE = @import("gdi.zig").HPALETTE;
const HRESULT = @import("com.zig").HRESULT;
const BOOL = @import("systemservices.zig").BOOL;
const HBITMAP = @import("gdi.zig").HBITMAP;
const WINDOWPOS = @import("windowsandmessaging.zig").WINDOWPOS;
const HBRUSH = @import("gdi.zig").HBRUSH;
const HPEN = @import("gdi.zig").HPEN;
const HKEY = @import("windowsprogramming.zig").HKEY;
const SIZE = @import("displaydevices.zig").SIZE;
const SYSTEMTIME = @import("windowsprogramming.zig").SYSTEMTIME;
const IStream = @import("structuredstorage.zig").IStream;
const WPARAM = @import("windowsandmessaging.zig").WPARAM;
const IOleObject = @import("com.zig").IOleObject;
const IStorage = @import("structuredstorage.zig").IStorage;
const IOleClientSite = @import("com.zig").IOleClientSite;
const BLENDFUNCTION = @import("gdi.zig").BLENDFUNCTION;
const POINTER_TOUCH_INFO = @import("pointerinput.zig").POINTER_TOUCH_INFO;
const LRESULT = @import("systemservices.zig").LRESULT;
const HRGN = @import("gdi.zig").HRGN;
const HICON = @import("gdi.zig").HICON;
const HMENU = @import("menusandresources.zig").HMENU;
const IUnknown = @import("com.zig").IUnknown;
const TEXTMETRICW = @import("gdi.zig").TEXTMETRICW;
const LOGFONTW = @import("shell.zig").LOGFONTW;
const RGBQUAD = @import("gdi.zig").RGBQUAD;

test "" {
    const constant_export_count = 0;
    const type_export_count = 356;
    const func_count = 229;
    const unicode_alias_count = 54;
    const type_import_count = 34;
    @setEvalBranchQuota(0
        + constant_export_count
        + type_export_count
        + func_count
        + unicode_alias_count
        + type_import_count
        + 2 // TODO: why do I need these extra 2?
    );
    @import("std").testing.refAllDecls(@This());
}
