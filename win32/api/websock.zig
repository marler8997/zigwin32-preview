//! NOTE: this source file is autogenerated, DO NOT MODIFY

//
// constants
//

//
// types
//
// --------------------------------------------------------
// Type: WEB_SOCKET_HANDLE__
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const WEB_SOCKET_HANDLE__ = extern struct {
    unused: i32,
};
// --------------------------------------------------------
// Type: WEB_SOCKET_CLOSE_STATUS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const WEB_SOCKET_CLOSE_STATUS = *opaque{
};
// --------------------------------------------------------
// Type: WEB_SOCKET_PROPERTY_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const WEB_SOCKET_PROPERTY_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: WEB_SOCKET_ACTION_QUEUE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const WEB_SOCKET_ACTION_QUEUE = *opaque{
};
// --------------------------------------------------------
// Type: WEB_SOCKET_BUFFER_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const WEB_SOCKET_BUFFER_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: WEB_SOCKET_ACTION
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const WEB_SOCKET_ACTION = *opaque{
};
// --------------------------------------------------------
// Type: WEB_SOCKET_PROPERTY
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const WEB_SOCKET_PROPERTY = extern struct {
    Type: WEB_SOCKET_PROPERTY_TYPE,
    pvValue: ?*opaque{},
    ulValueSize: u32,
};
// --------------------------------------------------------
// Type: WEB_SOCKET_HTTP_HEADER
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const WEB_SOCKET_HTTP_HEADER = extern struct {
    pcName: ?*i8,
    ulNameLength: u32,
    pcValue: ?*i8,
    ulValueLength: u32,
};
// --------------------------------------------------------
// Type: WEB_SOCKET_BUFFER
// TypeLayoutAttr: explicit
// not generating the actual code for this type because it has an explicit layout
pub const WEB_SOCKET_BUFFER = *opaque{
    // --------------------------------------------------------
    // Type: _CloseStatus_e__Struct
    // TypeLayoutAttr: sequential
    // TODO: I think this is a struct, but not sure at this point, assuming it is for now
    pub const _CloseStatus_e__Struct = extern struct {
        pbReason: ?*u8,
        ulReasonLength: u32,
        usStatus: u16,
    };
    // --------------------------------------------------------
    // Type: _Data_e__Struct
    // TypeLayoutAttr: sequential
    // TODO: I think this is a struct, but not sure at this point, assuming it is for now
    pub const _Data_e__Struct = extern struct {
        pbBuffer: ?*u8,
        ulBufferLength: u32,
    };
};

//
// functions
//

// set_last_errror=False (can and should we use this?)
pub extern "websocket" fn WebSocketCreateClientHandle(
    pProperties: ?*WEB_SOCKET_PROPERTY,
    ulPropertyCount: u32,
    phWebSocket: ?*?*WEB_SOCKET_HANDLE__,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "websocket" fn WebSocketBeginClientHandshake(
    hWebSocket: ?*WEB_SOCKET_HANDLE__,
    pszSubprotocols: ?*?*i8,
    ulSubprotocolCount: u32,
    pszExtensions: ?*?*i8,
    ulExtensionCount: u32,
    pInitialHeaders: ?*WEB_SOCKET_HTTP_HEADER,
    ulInitialHeaderCount: u32,
    pAdditionalHeaders: ?*?*WEB_SOCKET_HTTP_HEADER,
    pulAdditionalHeaderCount: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "websocket" fn WebSocketEndClientHandshake(
    hWebSocket: ?*WEB_SOCKET_HANDLE__,
    pResponseHeaders: ?*WEB_SOCKET_HTTP_HEADER,
    ulReponseHeaderCount: u32,
    pulSelectedExtensions: ?*u32,
    pulSelectedExtensionCount: ?*u32,
    pulSelectedSubprotocol: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "websocket" fn WebSocketCreateServerHandle(
    pProperties: ?*WEB_SOCKET_PROPERTY,
    ulPropertyCount: u32,
    phWebSocket: ?*?*WEB_SOCKET_HANDLE__,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "websocket" fn WebSocketBeginServerHandshake(
    hWebSocket: ?*WEB_SOCKET_HANDLE__,
    pszSubprotocolSelected: ?*i8,
    pszExtensionSelected: ?*?*i8,
    ulExtensionSelectedCount: u32,
    pRequestHeaders: ?*WEB_SOCKET_HTTP_HEADER,
    ulRequestHeaderCount: u32,
    pResponseHeaders: ?*?*WEB_SOCKET_HTTP_HEADER,
    pulResponseHeaderCount: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "websocket" fn WebSocketEndServerHandshake(
    hWebSocket: ?*WEB_SOCKET_HANDLE__,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "websocket" fn WebSocketSend(
    hWebSocket: ?*WEB_SOCKET_HANDLE__,
    BufferType: WEB_SOCKET_BUFFER_TYPE,
    pBuffer: ?*WEB_SOCKET_BUFFER,
    Context: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "websocket" fn WebSocketReceive(
    hWebSocket: ?*WEB_SOCKET_HANDLE__,
    pBuffer: ?*WEB_SOCKET_BUFFER,
    pvContext: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "websocket" fn WebSocketGetAction(
    hWebSocket: ?*WEB_SOCKET_HANDLE__,
    eActionQueue: WEB_SOCKET_ACTION_QUEUE,
    pDataBuffers: ?*WEB_SOCKET_BUFFER,
    pulDataBufferCount: ?*u32,
    pAction: ?*WEB_SOCKET_ACTION,
    pBufferType: ?*WEB_SOCKET_BUFFER_TYPE,
    pvApplicationContext: ?*?*opaque{},
    pvActionContext: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "websocket" fn WebSocketCompleteAction(
    hWebSocket: ?*WEB_SOCKET_HANDLE__,
    pvActionContext: ?*opaque{},
    ulBytesTransferred: u32,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "websocket" fn WebSocketAbortHandle(
    hWebSocket: ?*WEB_SOCKET_HANDLE__,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "websocket" fn WebSocketDeleteHandle(
    hWebSocket: ?*WEB_SOCKET_HANDLE__,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "websocket" fn WebSocketGetGlobalProperty(
    eType: WEB_SOCKET_PROPERTY_TYPE,
    pvValue: ?*opaque{},
    ulSize: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

//
// Unicode Symbol Aliases
//
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {
    },
    .wide => struct {
    },
    else => if (@import("builtin").is_test) struct {
    } else struct {
    },
};

//
// type imports
//
const HRESULT = @import("com.zig").HRESULT;

test "" {
    const constant_export_count = 0;
    const type_export_count = 9;
    const func_count = 13;
    const unicode_alias_count = 0;
    const type_import_count = 1;
    @setEvalBranchQuota(0
        + constant_export_count
        + type_export_count
        + func_count
        + unicode_alias_count
        + type_import_count
        + 2 // TODO: why do I need these extra 2?
    );
    @import("std").testing.refAllDecls(@This());
}
