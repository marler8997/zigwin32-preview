//! NOTE: this source file is autogenerated, DO NOT MODIFY

//
// constants
//

//
// types
//
// --------------------------------------------------------
// Type: FilterFindHandle
// TypeLayoutAttr: sequential
// RAIIFree 'FilterFindClose' (TODO: can we use this information?)
pub const FilterFindHandle = ?*opaque{};
// --------------------------------------------------------
// Type: FilterInstanceFindHandle
// TypeLayoutAttr: sequential
// RAIIFree 'FilterInstanceFindClose' (TODO: can we use this information?)
pub const FilterInstanceFindHandle = ?*opaque{};
// --------------------------------------------------------
// Type: FilterVolumeFindHandle
// TypeLayoutAttr: sequential
// RAIIFree 'FilterVolumeFindClose' (TODO: can we use this information?)
pub const FilterVolumeFindHandle = ?*opaque{};
// --------------------------------------------------------
// Type: FilterVolumeInstanceFindHandle
// TypeLayoutAttr: sequential
// RAIIFree 'FilterVolumeInstanceFindClose' (TODO: can we use this information?)
pub const FilterVolumeInstanceFindHandle = ?*opaque{};
// --------------------------------------------------------
// Type: HFILTER
// TypeLayoutAttr: sequential
// RAIIFree 'FilterClose' (TODO: can we use this information?)
pub const HFILTER = ?*opaque{};
// --------------------------------------------------------
// Type: HFILTER_INSTANCE
// TypeLayoutAttr: sequential
// RAIIFree 'FilterInstanceClose' (TODO: can we use this information?)
pub const HFILTER_INSTANCE = ?*opaque{};
// --------------------------------------------------------
// Type: FLT_FILESYSTEM_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const FLT_FILESYSTEM_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: FILTER_INFORMATION_CLASS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const FILTER_INFORMATION_CLASS = *opaque{
};
// --------------------------------------------------------
// Type: FILTER_FULL_INFORMATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const FILTER_FULL_INFORMATION = extern struct {
    NextEntryOffset: u32,
    FrameID: u32,
    NumberOfInstances: u32,
    FilterNameLength: u16,
    FilterNameBuffer: ?[*]u16,
};
// --------------------------------------------------------
// Type: FILTER_AGGREGATE_BASIC_INFORMATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const FILTER_AGGREGATE_BASIC_INFORMATION = extern struct {
    NextEntryOffset: u32,
    Flags: u32,
    Type: _Type_e__Union,
    // --------------------------------------------------------
    // Type: _Type_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Type_e__Union = *opaque{
        // --------------------------------------------------------
        // Type: _MiniFilter_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _MiniFilter_e__Struct = extern struct {
            FrameID: u32,
            NumberOfInstances: u32,
            FilterNameLength: u16,
            FilterNameBufferOffset: u16,
            FilterAltitudeLength: u16,
            FilterAltitudeBufferOffset: u16,
        };
        // --------------------------------------------------------
        // Type: _LegacyFilter_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _LegacyFilter_e__Struct = extern struct {
            FilterNameLength: u16,
            FilterNameBufferOffset: u16,
        };
    };
};
// --------------------------------------------------------
// Type: FILTER_AGGREGATE_STANDARD_INFORMATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const FILTER_AGGREGATE_STANDARD_INFORMATION = extern struct {
    NextEntryOffset: u32,
    Flags: u32,
    Type: _Type_e__Union,
    // --------------------------------------------------------
    // Type: _Type_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Type_e__Union = *opaque{
        // --------------------------------------------------------
        // Type: _MiniFilter_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _MiniFilter_e__Struct = extern struct {
            Flags: u32,
            FrameID: u32,
            NumberOfInstances: u32,
            FilterNameLength: u16,
            FilterNameBufferOffset: u16,
            FilterAltitudeLength: u16,
            FilterAltitudeBufferOffset: u16,
        };
        // --------------------------------------------------------
        // Type: _LegacyFilter_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _LegacyFilter_e__Struct = extern struct {
            Flags: u32,
            FilterNameLength: u16,
            FilterNameBufferOffset: u16,
            FilterAltitudeLength: u16,
            FilterAltitudeBufferOffset: u16,
        };
    };
};
// --------------------------------------------------------
// Type: FILTER_VOLUME_INFORMATION_CLASS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const FILTER_VOLUME_INFORMATION_CLASS = *opaque{
};
// --------------------------------------------------------
// Type: FILTER_VOLUME_BASIC_INFORMATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const FILTER_VOLUME_BASIC_INFORMATION = extern struct {
    FilterVolumeNameLength: u16,
    FilterVolumeName: ?[*]u16,
};
// --------------------------------------------------------
// Type: FILTER_VOLUME_STANDARD_INFORMATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const FILTER_VOLUME_STANDARD_INFORMATION = extern struct {
    NextEntryOffset: u32,
    Flags: u32,
    FrameID: u32,
    FileSystemType: FLT_FILESYSTEM_TYPE,
    FilterVolumeNameLength: u16,
    FilterVolumeName: ?[*]u16,
};
// --------------------------------------------------------
// Type: INSTANCE_INFORMATION_CLASS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const INSTANCE_INFORMATION_CLASS = *opaque{
};
// --------------------------------------------------------
// Type: INSTANCE_BASIC_INFORMATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const INSTANCE_BASIC_INFORMATION = extern struct {
    NextEntryOffset: u32,
    InstanceNameLength: u16,
    InstanceNameBufferOffset: u16,
};
// --------------------------------------------------------
// Type: INSTANCE_PARTIAL_INFORMATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const INSTANCE_PARTIAL_INFORMATION = extern struct {
    NextEntryOffset: u32,
    InstanceNameLength: u16,
    InstanceNameBufferOffset: u16,
    AltitudeLength: u16,
    AltitudeBufferOffset: u16,
};
// --------------------------------------------------------
// Type: INSTANCE_FULL_INFORMATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const INSTANCE_FULL_INFORMATION = extern struct {
    NextEntryOffset: u32,
    InstanceNameLength: u16,
    InstanceNameBufferOffset: u16,
    AltitudeLength: u16,
    AltitudeBufferOffset: u16,
    VolumeNameLength: u16,
    VolumeNameBufferOffset: u16,
    FilterNameLength: u16,
    FilterNameBufferOffset: u16,
};
// --------------------------------------------------------
// Type: INSTANCE_AGGREGATE_STANDARD_INFORMATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const INSTANCE_AGGREGATE_STANDARD_INFORMATION = extern struct {
    NextEntryOffset: u32,
    Flags: u32,
    Type: _Type_e__Union,
    // --------------------------------------------------------
    // Type: _Type_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Type_e__Union = *opaque{
        // --------------------------------------------------------
        // Type: _MiniFilter_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _MiniFilter_e__Struct = extern struct {
            Flags: u32,
            FrameID: u32,
            VolumeFileSystemType: FLT_FILESYSTEM_TYPE,
            InstanceNameLength: u16,
            InstanceNameBufferOffset: u16,
            AltitudeLength: u16,
            AltitudeBufferOffset: u16,
            VolumeNameLength: u16,
            VolumeNameBufferOffset: u16,
            FilterNameLength: u16,
            FilterNameBufferOffset: u16,
            SupportedFeatures: u32,
        };
        // --------------------------------------------------------
        // Type: _LegacyFilter_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _LegacyFilter_e__Struct = extern struct {
            Flags: u32,
            AltitudeLength: u16,
            AltitudeBufferOffset: u16,
            VolumeNameLength: u16,
            VolumeNameBufferOffset: u16,
            FilterNameLength: u16,
            FilterNameBufferOffset: u16,
            SupportedFeatures: u32,
        };
    };
};
// --------------------------------------------------------
// Type: FILTER_MESSAGE_HEADER
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const FILTER_MESSAGE_HEADER = extern struct {
    ReplyLength: u32,
    MessageId: u64,
};
// --------------------------------------------------------
// Type: FILTER_REPLY_HEADER
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const FILTER_REPLY_HEADER = extern struct {
    Status: NTSTATUS,
    MessageId: u64,
};

//
// functions
//

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn RtlCaptureStackBackTrace(
    FramesToSkip: u32,
    FramesToCapture: u32,
    BackTrace: ?*?*opaque{},
    BackTraceHash: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u16;

// set_last_errror=False (can and should we use this?)
pub extern "FLTLIB" fn FilterLoad(
    lpFilterName: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "FLTLIB" fn FilterUnload(
    lpFilterName: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "FLTLIB" fn FilterCreate(
    lpFilterName: ?*u16,
    hFilter: ?*HFILTER,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "FLTLIB" fn FilterClose(
    hFilter: HFILTER,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "FLTLIB" fn FilterInstanceCreate(
    lpFilterName: ?*u16,
    lpVolumeName: ?*u16,
    lpInstanceName: ?*u16,
    hInstance: ?*HFILTER_INSTANCE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "FLTLIB" fn FilterInstanceClose(
    hInstance: HFILTER_INSTANCE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "FLTLIB" fn FilterAttach(
    lpFilterName: ?*u16,
    lpVolumeName: ?*u16,
    lpInstanceName: ?*u16,
    dwCreatedInstanceNameLength: u32,
    lpCreatedInstanceName: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "FLTLIB" fn FilterAttachAtAltitude(
    lpFilterName: ?*u16,
    lpVolumeName: ?*u16,
    lpAltitude: ?*u16,
    lpInstanceName: ?*u16,
    dwCreatedInstanceNameLength: u32,
    lpCreatedInstanceName: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "FLTLIB" fn FilterDetach(
    lpFilterName: ?*u16,
    lpVolumeName: ?*u16,
    lpInstanceName: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "FLTLIB" fn FilterFindFirst(
    dwInformationClass: FILTER_INFORMATION_CLASS,
    lpBuffer: ?*opaque{},
    dwBufferSize: u32,
    lpBytesReturned: ?*u32,
    lpFilterFind: ?*FilterFindHandle,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "FLTLIB" fn FilterFindNext(
    hFilterFind: HANDLE,
    dwInformationClass: FILTER_INFORMATION_CLASS,
    lpBuffer: ?*opaque{},
    dwBufferSize: u32,
    lpBytesReturned: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "FLTLIB" fn FilterFindClose(
    hFilterFind: HANDLE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "FLTLIB" fn FilterVolumeFindFirst(
    dwInformationClass: FILTER_VOLUME_INFORMATION_CLASS,
    lpBuffer: ?*opaque{},
    dwBufferSize: u32,
    lpBytesReturned: ?*u32,
    lpVolumeFind: ?*FilterVolumeFindHandle,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "FLTLIB" fn FilterVolumeFindNext(
    hVolumeFind: HANDLE,
    dwInformationClass: FILTER_VOLUME_INFORMATION_CLASS,
    lpBuffer: ?*opaque{},
    dwBufferSize: u32,
    lpBytesReturned: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "FLTLIB" fn FilterVolumeFindClose(
    hVolumeFind: HANDLE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "FLTLIB" fn FilterInstanceFindFirst(
    lpFilterName: ?*u16,
    dwInformationClass: INSTANCE_INFORMATION_CLASS,
    lpBuffer: ?*opaque{},
    dwBufferSize: u32,
    lpBytesReturned: ?*u32,
    lpFilterInstanceFind: ?*FilterInstanceFindHandle,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "FLTLIB" fn FilterInstanceFindNext(
    hFilterInstanceFind: HANDLE,
    dwInformationClass: INSTANCE_INFORMATION_CLASS,
    lpBuffer: ?*opaque{},
    dwBufferSize: u32,
    lpBytesReturned: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "FLTLIB" fn FilterInstanceFindClose(
    hFilterInstanceFind: HANDLE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "FLTLIB" fn FilterVolumeInstanceFindFirst(
    lpVolumeName: ?*u16,
    dwInformationClass: INSTANCE_INFORMATION_CLASS,
    lpBuffer: ?*opaque{},
    dwBufferSize: u32,
    lpBytesReturned: ?*u32,
    lpVolumeInstanceFind: ?*FilterVolumeInstanceFindHandle,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "FLTLIB" fn FilterVolumeInstanceFindNext(
    hVolumeInstanceFind: HANDLE,
    dwInformationClass: INSTANCE_INFORMATION_CLASS,
    lpBuffer: ?*opaque{},
    dwBufferSize: u32,
    lpBytesReturned: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "FLTLIB" fn FilterVolumeInstanceFindClose(
    hVolumeInstanceFind: HANDLE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "FLTLIB" fn FilterGetInformation(
    hFilter: HFILTER,
    dwInformationClass: FILTER_INFORMATION_CLASS,
    lpBuffer: ?*opaque{},
    dwBufferSize: u32,
    lpBytesReturned: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "FLTLIB" fn FilterInstanceGetInformation(
    hInstance: HFILTER_INSTANCE,
    dwInformationClass: INSTANCE_INFORMATION_CLASS,
    lpBuffer: ?*opaque{},
    dwBufferSize: u32,
    lpBytesReturned: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "FLTLIB" fn FilterConnectCommunicationPort(
    lpPortName: ?*u16,
    dwOptions: u32,
    lpContext: ?*opaque{},
    wSizeOfContext: u16,
    lpSecurityAttributes: ?*SECURITY_ATTRIBUTES,
    hPort: ?*HANDLE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "FLTLIB" fn FilterSendMessage(
    hPort: HANDLE,
    lpInBuffer: ?*opaque{},
    dwInBufferSize: u32,
    lpOutBuffer: ?*opaque{},
    dwOutBufferSize: u32,
    lpBytesReturned: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "FLTLIB" fn FilterGetMessage(
    hPort: HANDLE,
    lpMessageBuffer: ?*FILTER_MESSAGE_HEADER,
    dwMessageBufferSize: u32,
    lpOverlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "FLTLIB" fn FilterReplyMessage(
    hPort: HANDLE,
    lpReplyBuffer: ?*FILTER_REPLY_HEADER,
    dwReplyBufferSize: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "FLTLIB" fn FilterGetDosName(
    lpVolumeName: ?*u16,
    lpDosName: ?*u16,
    dwDosNameBufferSize: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

//
// Unicode Symbol Aliases
//
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {
    },
    .wide => struct {
    },
    else => if (@import("builtin").is_test) struct {
    } else struct {
    },
};

//
// type imports
//
const NTSTATUS = @import("systemservices.zig").NTSTATUS;
const HRESULT = @import("com.zig").HRESULT;
const HANDLE = @import("systemservices.zig").HANDLE;
const SECURITY_ATTRIBUTES = @import("systemservices.zig").SECURITY_ATTRIBUTES;
const OVERLAPPED = @import("systemservices.zig").OVERLAPPED;

test "" {
    const constant_export_count = 0;
    const type_export_count = 21;
    const func_count = 29;
    const unicode_alias_count = 0;
    const type_import_count = 5;
    @setEvalBranchQuota(0
        + constant_export_count
        + type_export_count
        + func_count
        + unicode_alias_count
        + type_import_count
        + 2 // TODO: why do I need these extra 2?
    );
    @import("std").testing.refAllDecls(@This());
}
