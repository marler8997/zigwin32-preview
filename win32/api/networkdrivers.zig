//! NOTE: this source file is autogenerated, DO NOT MODIFY

//
// constants
//

//
// types
//
// --------------------------------------------------------
// Type: L2_NOTIFICATION_DATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const L2_NOTIFICATION_DATA = extern struct {
    NotificationSource: u32,
    NotificationCode: u32,
    InterfaceGuid: Guid,
    dwDataSize: u32,
    pData: ?*opaque{},
};
// --------------------------------------------------------
// Type: NET_IF_OPER_STATUS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const NET_IF_OPER_STATUS = *opaque{
};
// --------------------------------------------------------
// Type: NET_IF_ADMIN_STATUS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const NET_IF_ADMIN_STATUS = *opaque{
};
// --------------------------------------------------------
// Type: NET_IF_CONNECTION_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const NET_IF_CONNECTION_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: TUNNEL_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const TUNNEL_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: NET_IF_ACCESS_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const NET_IF_ACCESS_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: NET_IF_DIRECTION_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const NET_IF_DIRECTION_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: NET_IF_MEDIA_CONNECT_STATE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const NET_IF_MEDIA_CONNECT_STATE = *opaque{
};
// --------------------------------------------------------
// Type: NET_IF_MEDIA_DUPLEX_STATE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const NET_IF_MEDIA_DUPLEX_STATE = *opaque{
};
// --------------------------------------------------------
// Type: NET_PHYSICAL_LOCATION_LH
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NET_PHYSICAL_LOCATION_LH = extern struct {
    BusNumber: u32,
    SlotNumber: u32,
    FunctionNumber: u32,
};
// --------------------------------------------------------
// Type: IF_COUNTED_STRING_LH
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const IF_COUNTED_STRING_LH = extern struct {
    Length: u16,
    String: ?[*]u16,
};
// --------------------------------------------------------
// Type: NDIS_INTERFACE_INFORMATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NDIS_INTERFACE_INFORMATION = extern struct {
    ifOperStatus: NET_IF_OPER_STATUS,
    ifOperStatusFlags: u32,
    MediaConnectState: NET_IF_MEDIA_CONNECT_STATE,
    MediaDuplexState: NET_IF_MEDIA_DUPLEX_STATE,
    ifMtu: u32,
    ifPromiscuousMode: u8,
    ifDeviceWakeUpEnable: u8,
    XmitLinkSpeed: u64,
    RcvLinkSpeed: u64,
    ifLastChange: u64,
    ifCounterDiscontinuityTime: u64,
    ifInUnknownProtos: u64,
    ifInDiscards: u64,
    ifInErrors: u64,
    ifHCInOctets: u64,
    ifHCInUcastPkts: u64,
    ifHCInMulticastPkts: u64,
    ifHCInBroadcastPkts: u64,
    ifHCOutOctets: u64,
    ifHCOutUcastPkts: u64,
    ifHCOutMulticastPkts: u64,
    ifHCOutBroadcastPkts: u64,
    ifOutErrors: u64,
    ifOutDiscards: u64,
    ifHCInUcastOctets: u64,
    ifHCInMulticastOctets: u64,
    ifHCInBroadcastOctets: u64,
    ifHCOutUcastOctets: u64,
    ifHCOutMulticastOctets: u64,
    ifHCOutBroadcastOctets: u64,
    CompartmentId: u32,
    SupportedStatistics: u32,
};
// --------------------------------------------------------
// Type: MIB_IF_TABLE_LEVEL
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const MIB_IF_TABLE_LEVEL = *opaque{
};
// --------------------------------------------------------
// Type: SOCKET_ADDRESS_LIST
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SOCKET_ADDRESS_LIST = extern struct {
    iAddressCount: i32,
    Address: ?[*]SOCKET_ADDRESS,
};
// --------------------------------------------------------
// Type: SOCKADDR_STORAGE_LH
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SOCKADDR_STORAGE_LH = extern struct {
    ss_family: u16,
    __ss_pad1: ?[*]i8,
    __ss_align: i64,
    __ss_pad2: ?[*]i8,
};
// --------------------------------------------------------
// Type: SOCKADDR_IN6_LH
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SOCKADDR_IN6_LH = extern struct {
    sin6_family: u16,
    sin6_port: u16,
    sin6_flowinfo: u32,
    sin6_addr: in6_addr,
    Anonymous: _Anonymous_e__Union,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: NL_ROUTE_PROTOCOL
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const NL_ROUTE_PROTOCOL = *opaque{
};
// --------------------------------------------------------
// Type: NL_ADDRESS_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const NL_ADDRESS_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: NL_ROUTE_ORIGIN
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const NL_ROUTE_ORIGIN = *opaque{
};
// --------------------------------------------------------
// Type: NL_NEIGHBOR_STATE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const NL_NEIGHBOR_STATE = *opaque{
};
// --------------------------------------------------------
// Type: NL_LINK_LOCAL_ADDRESS_BEHAVIOR
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const NL_LINK_LOCAL_ADDRESS_BEHAVIOR = *opaque{
};
// --------------------------------------------------------
// Type: NL_ROUTER_DISCOVERY_BEHAVIOR
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const NL_ROUTER_DISCOVERY_BEHAVIOR = *opaque{
};

//
// functions
//

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn GetCurrentThreadCompartmentId(
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn SetCurrentThreadCompartmentId(
    CompartmentId: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn GetSessionCompartmentId(
    SessionId: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn SetSessionCompartmentId(
    SessionId: u32,
    CompartmentId: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn GetNetworkInformation(
    NetworkGuid: ?*Guid,
    CompartmentId: ?*u32,
    SiteId: ?*u32,
    NetworkName: ?*u16,
    Length: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn SetNetworkInformation(
    NetworkGuid: ?*Guid,
    CompartmentId: u32,
    NetworkName: ?*u16,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

//
// Unicode Symbol Aliases
//
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {
    },
    .wide => struct {
    },
    else => if (@import("builtin").is_test) struct {
    } else struct {
    },
};

//
// type imports
//
const Guid = @import("../zig.zig").Guid;
const SOCKET_ADDRESS = @import("winsock.zig").SOCKET_ADDRESS;
const in6_addr = @import("winsock.zig").in6_addr;
const NTSTATUS = @import("systemservices.zig").NTSTATUS;

test "" {
    const constant_export_count = 0;
    const type_export_count = 22;
    const func_count = 6;
    const unicode_alias_count = 0;
    const type_import_count = 4;
    @setEvalBranchQuota(0
        + constant_export_count
        + type_export_count
        + func_count
        + unicode_alias_count
        + type_import_count
        + 2 // TODO: why do I need these extra 2?
    );
    @import("std").testing.refAllDecls(@This());
}
