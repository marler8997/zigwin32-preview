//! NOTE: this source file is autogenerated, DO NOT MODIFY

//
// constants
//
pub const UITER_UNKNOWN_INDEX : i32 = -2;
pub const UTEXT_PROVIDER_LENGTH_IS_EXPENSIVE : i32 = 1;
pub const UTEXT_PROVIDER_STABLE_CHUNKS : i32 = 2;
pub const UTEXT_PROVIDER_WRITABLE : i32 = 3;
pub const UTEXT_PROVIDER_HAS_META_DATA : i32 = 4;
pub const UTEXT_PROVIDER_OWNS_TEXT : i32 = 5;
pub const UTEXT_MAGIC : i32 = 878368812;
pub const USET_IGNORE_SPACE : i32 = 1;
pub const USET_CASE_INSENSITIVE : i32 = 2;
pub const USET_ADD_CASE_MAPPINGS : i32 = 4;
pub const USET_SERIALIZED_STATIC_ARRAY_CAPACITY : i32 = 8;
pub const U_PARSE_CONTEXT_LEN : i32 = 16;
pub const UIDNA_DEFAULT : i32 = 0;
pub const UIDNA_USE_STD3_RULES : i32 = 2;
pub const UIDNA_CHECK_BIDI : i32 = 4;
pub const UIDNA_CHECK_CONTEXTJ : i32 = 8;
pub const UIDNA_NONTRANSITIONAL_TO_ASCII : i32 = 16;
pub const UIDNA_NONTRANSITIONAL_TO_UNICODE : i32 = 32;
pub const UIDNA_CHECK_CONTEXTO : i32 = 64;
pub const UIDNA_ERROR_EMPTY_LABEL : i32 = 1;
pub const UIDNA_ERROR_LABEL_TOO_LONG : i32 = 2;
pub const UIDNA_ERROR_DOMAIN_NAME_TOO_LONG : i32 = 4;
pub const UIDNA_ERROR_LEADING_HYPHEN : i32 = 8;
pub const UIDNA_ERROR_TRAILING_HYPHEN : i32 = 16;
pub const UIDNA_ERROR_HYPHEN_3_4 : i32 = 32;
pub const UIDNA_ERROR_LEADING_COMBINING_MARK : i32 = 64;
pub const UIDNA_ERROR_DISALLOWED : i32 = 128;
pub const UIDNA_ERROR_PUNYCODE : i32 = 256;
pub const UIDNA_ERROR_LABEL_HAS_DOT : i32 = 512;
pub const UIDNA_ERROR_INVALID_ACE_LABEL : i32 = 1024;
pub const UIDNA_ERROR_BIDI : i32 = 2048;
pub const UIDNA_ERROR_CONTEXTJ : i32 = 4096;
pub const UIDNA_ERROR_CONTEXTO_PUNCTUATION : i32 = 8192;
pub const UIDNA_ERROR_CONTEXTO_DIGITS : i32 = 16384;

//
// types
//
// --------------------------------------------------------
// Type: FONTSIGNATURE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const FONTSIGNATURE = extern struct {
    fsUsb: ?[*]u32,
    fsCsb: ?[*]u32,
};
// --------------------------------------------------------
// Type: CHARSETINFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CHARSETINFO = extern struct {
    ciCharset: u32,
    ciACP: u32,
    fs: FONTSIGNATURE,
};
// --------------------------------------------------------
// Type: LOCALESIGNATURE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const LOCALESIGNATURE = extern struct {
    lsUsb: ?[*]u32,
    lsCsbDefault: ?[*]u32,
    lsCsbSupported: ?[*]u32,
};
// --------------------------------------------------------
// Type: CPINFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CPINFO = extern struct {
    MaxCharSize: u32,
    DefaultChar: ?[*]u8,
    LeadByte: ?[*]u8,
};
// --------------------------------------------------------
// Type: CPINFOEXA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CPINFOEXA = extern struct {
    MaxCharSize: u32,
    DefaultChar: ?[*]u8,
    LeadByte: ?[*]u8,
    UnicodeDefaultChar: u16,
    CodePage: u32,
    CodePageName: ?[*]i8,
};
// --------------------------------------------------------
// Type: CPINFOEXW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CPINFOEXW = extern struct {
    MaxCharSize: u32,
    DefaultChar: ?[*]u8,
    LeadByte: ?[*]u8,
    UnicodeDefaultChar: u16,
    CodePage: u32,
    CodePageName: ?[*]u16,
};
// --------------------------------------------------------
// Type: NUMBERFMTA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NUMBERFMTA = extern struct {
    NumDigits: u32,
    LeadingZero: u32,
    Grouping: u32,
    lpDecimalSep: ?*i8,
    lpThousandSep: ?*i8,
    NegativeOrder: u32,
};
// --------------------------------------------------------
// Type: NUMBERFMTW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NUMBERFMTW = extern struct {
    NumDigits: u32,
    LeadingZero: u32,
    Grouping: u32,
    lpDecimalSep: ?*u16,
    lpThousandSep: ?*u16,
    NegativeOrder: u32,
};
// --------------------------------------------------------
// Type: CURRENCYFMTA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CURRENCYFMTA = extern struct {
    NumDigits: u32,
    LeadingZero: u32,
    Grouping: u32,
    lpDecimalSep: ?*i8,
    lpThousandSep: ?*i8,
    NegativeOrder: u32,
    PositiveOrder: u32,
    lpCurrencySymbol: ?*i8,
};
// --------------------------------------------------------
// Type: CURRENCYFMTW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CURRENCYFMTW = extern struct {
    NumDigits: u32,
    LeadingZero: u32,
    Grouping: u32,
    lpDecimalSep: ?*u16,
    lpThousandSep: ?*u16,
    NegativeOrder: u32,
    PositiveOrder: u32,
    lpCurrencySymbol: ?*u16,
};
// --------------------------------------------------------
// Type: SYSNLS_FUNCTION
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const SYSNLS_FUNCTION = *opaque{
};
// --------------------------------------------------------
// Type: NLSVERSIONINFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NLSVERSIONINFO = extern struct {
    dwNLSVersionInfoSize: u32,
    dwNLSVersion: u32,
    dwDefinedVersion: u32,
    dwEffectiveId: u32,
    guidCustomVersion: Guid,
};
// --------------------------------------------------------
// Type: NLSVERSIONINFOEX
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NLSVERSIONINFOEX = extern struct {
    dwNLSVersionInfoSize: u32,
    dwNLSVersion: u32,
    dwDefinedVersion: u32,
    dwEffectiveId: u32,
    guidCustomVersion: Guid,
};
// --------------------------------------------------------
// Type: SYSGEOTYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const SYSGEOTYPE = *opaque{
};
// --------------------------------------------------------
// Type: SYSGEOCLASS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const SYSGEOCLASS = *opaque{
};
// --------------------------------------------------------
// Type: LOCALE_ENUMPROCA
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const LOCALE_ENUMPROCA = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: LOCALE_ENUMPROCW
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const LOCALE_ENUMPROCW = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: NORM_FORM
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const NORM_FORM = *opaque{
};
// --------------------------------------------------------
// Type: LANGUAGEGROUP_ENUMPROCA
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const LANGUAGEGROUP_ENUMPROCA = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: LANGGROUPLOCALE_ENUMPROCA
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const LANGGROUPLOCALE_ENUMPROCA = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: UILANGUAGE_ENUMPROCA
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UILANGUAGE_ENUMPROCA = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: CODEPAGE_ENUMPROCA
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const CODEPAGE_ENUMPROCA = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: DATEFMT_ENUMPROCA
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const DATEFMT_ENUMPROCA = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: DATEFMT_ENUMPROCEXA
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const DATEFMT_ENUMPROCEXA = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: TIMEFMT_ENUMPROCA
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const TIMEFMT_ENUMPROCA = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: CALINFO_ENUMPROCA
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const CALINFO_ENUMPROCA = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: CALINFO_ENUMPROCEXA
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const CALINFO_ENUMPROCEXA = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: LANGUAGEGROUP_ENUMPROCW
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const LANGUAGEGROUP_ENUMPROCW = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: LANGGROUPLOCALE_ENUMPROCW
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const LANGGROUPLOCALE_ENUMPROCW = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: UILANGUAGE_ENUMPROCW
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UILANGUAGE_ENUMPROCW = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: CODEPAGE_ENUMPROCW
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const CODEPAGE_ENUMPROCW = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: DATEFMT_ENUMPROCW
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const DATEFMT_ENUMPROCW = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: DATEFMT_ENUMPROCEXW
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const DATEFMT_ENUMPROCEXW = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: TIMEFMT_ENUMPROCW
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const TIMEFMT_ENUMPROCW = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: CALINFO_ENUMPROCW
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const CALINFO_ENUMPROCW = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: CALINFO_ENUMPROCEXW
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const CALINFO_ENUMPROCEXW = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: GEO_ENUMPROC
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const GEO_ENUMPROC = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: GEO_ENUMNAMEPROC
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const GEO_ENUMNAMEPROC = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: FILEMUIINFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const FILEMUIINFO = extern struct {
    dwSize: u32,
    dwVersion: u32,
    dwFileType: u32,
    pChecksum: ?[*]u8,
    pServiceChecksum: ?[*]u8,
    dwLanguageNameOffset: u32,
    dwTypeIDMainSize: u32,
    dwTypeIDMainOffset: u32,
    dwTypeNameMainOffset: u32,
    dwTypeIDMUISize: u32,
    dwTypeIDMUIOffset: u32,
    dwTypeNameMUIOffset: u32,
    abBuffer: ?[*]u8,
};
// --------------------------------------------------------
// Type: HSAVEDUILANGUAGES__
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HSAVEDUILANGUAGES__ = extern struct {
    unused: i32,
};
// --------------------------------------------------------
// Type: CALINFO_ENUMPROCEXEX
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const CALINFO_ENUMPROCEXEX = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: DATEFMT_ENUMPROCEXEX
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const DATEFMT_ENUMPROCEXEX = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: TIMEFMT_ENUMPROCEX
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const TIMEFMT_ENUMPROCEX = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: LOCALE_ENUMPROCEX
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const LOCALE_ENUMPROCEX = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: HIMC__
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HIMC__ = extern struct {
    unused: i32,
};
// --------------------------------------------------------
// Type: HIMCC__
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HIMCC__ = extern struct {
    unused: i32,
};
// --------------------------------------------------------
// Type: COMPOSITIONFORM
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const COMPOSITIONFORM = extern struct {
    dwStyle: u32,
    ptCurrentPos: POINT,
    rcArea: RECT,
};
// --------------------------------------------------------
// Type: CANDIDATEFORM
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CANDIDATEFORM = extern struct {
    dwIndex: u32,
    dwStyle: u32,
    ptCurrentPos: POINT,
    rcArea: RECT,
};
// --------------------------------------------------------
// Type: CANDIDATELIST
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CANDIDATELIST = extern struct {
    dwSize: u32,
    dwStyle: u32,
    dwCount: u32,
    dwSelection: u32,
    dwPageStart: u32,
    dwPageSize: u32,
    dwOffset: ?[*]u32,
};
// --------------------------------------------------------
// Type: REGISTERWORDA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const REGISTERWORDA = extern struct {
    lpReading: ?*i8,
    lpWord: ?*i8,
};
// --------------------------------------------------------
// Type: REGISTERWORDW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const REGISTERWORDW = extern struct {
    lpReading: ?*u16,
    lpWord: ?*u16,
};
// --------------------------------------------------------
// Type: RECONVERTSTRING
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const RECONVERTSTRING = extern struct {
    dwSize: u32,
    dwVersion: u32,
    dwStrLen: u32,
    dwStrOffset: u32,
    dwCompStrLen: u32,
    dwCompStrOffset: u32,
    dwTargetStrLen: u32,
    dwTargetStrOffset: u32,
};
// --------------------------------------------------------
// Type: STYLEBUFA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const STYLEBUFA = extern struct {
    dwStyle: u32,
    szDescription: ?[*]i8,
};
// --------------------------------------------------------
// Type: STYLEBUFW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const STYLEBUFW = extern struct {
    dwStyle: u32,
    szDescription: ?[*]u16,
};
// --------------------------------------------------------
// Type: IMEMENUITEMINFOA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const IMEMENUITEMINFOA = extern struct {
    cbSize: u32,
    fType: u32,
    fState: u32,
    wID: u32,
    hbmpChecked: HBITMAP,
    hbmpUnchecked: HBITMAP,
    dwItemData: u32,
    szString: ?[*]i8,
    hbmpItem: HBITMAP,
};
// --------------------------------------------------------
// Type: IMEMENUITEMINFOW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const IMEMENUITEMINFOW = extern struct {
    cbSize: u32,
    fType: u32,
    fState: u32,
    wID: u32,
    hbmpChecked: HBITMAP,
    hbmpUnchecked: HBITMAP,
    dwItemData: u32,
    szString: ?[*]u16,
    hbmpItem: HBITMAP,
};
// --------------------------------------------------------
// Type: IMECHARPOSITION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const IMECHARPOSITION = extern struct {
    dwSize: u32,
    dwCharPos: u32,
    pt: POINT,
    cLineHeight: u32,
    rcDocument: RECT,
};
// --------------------------------------------------------
// Type: IMCENUMPROC
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const IMCENUMPROC = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: REGISTERWORDENUMPROCA
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const REGISTERWORDENUMPROCA = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: REGISTERWORDENUMPROCW
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const REGISTERWORDENUMPROCW = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PFN_MAPPINGCALLBACKPROC
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFN_MAPPINGCALLBACKPROC = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: MAPPING_SERVICE_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const MAPPING_SERVICE_INFO = extern struct {
    Size: ?*opaque{},
    pszCopyright: ?*u16,
    wMajorVersion: u16,
    wMinorVersion: u16,
    wBuildVersion: u16,
    wStepVersion: u16,
    dwInputContentTypesCount: u32,
    prgInputContentTypes: ?*?*u16,
    dwOutputContentTypesCount: u32,
    prgOutputContentTypes: ?*?*u16,
    dwInputLanguagesCount: u32,
    prgInputLanguages: ?*?*u16,
    dwOutputLanguagesCount: u32,
    prgOutputLanguages: ?*?*u16,
    dwInputScriptsCount: u32,
    prgInputScripts: ?*?*u16,
    dwOutputScriptsCount: u32,
    prgOutputScripts: ?*?*u16,
    guid: Guid,
    pszCategory: ?*u16,
    pszDescription: ?*u16,
    dwPrivateDataSize: u32,
    pPrivateData: ?*opaque{},
    pContext: ?*opaque{},
    _bitfield: u32,
};
// --------------------------------------------------------
// Type: MAPPING_ENUM_OPTIONS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const MAPPING_ENUM_OPTIONS = extern struct {
    Size: ?*opaque{},
    pszCategory: ?*u16,
    pszInputLanguage: ?*u16,
    pszOutputLanguage: ?*u16,
    pszInputScript: ?*u16,
    pszOutputScript: ?*u16,
    pszInputContentType: ?*u16,
    pszOutputContentType: ?*u16,
    pGuid: ?*Guid,
    _bitfield: u32,
};
// --------------------------------------------------------
// Type: MAPPING_OPTIONS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const MAPPING_OPTIONS = extern struct {
    Size: ?*opaque{},
    pszInputLanguage: ?*u16,
    pszOutputLanguage: ?*u16,
    pszInputScript: ?*u16,
    pszOutputScript: ?*u16,
    pszInputContentType: ?*u16,
    pszOutputContentType: ?*u16,
    pszUILanguage: ?*u16,
    pfnRecognizeCallback: PFN_MAPPINGCALLBACKPROC,
    pRecognizeCallerData: ?*opaque{},
    dwRecognizeCallerDataSize: u32,
    pfnActionCallback: PFN_MAPPINGCALLBACKPROC,
    pActionCallerData: ?*opaque{},
    dwActionCallerDataSize: u32,
    dwServiceFlag: u32,
    _bitfield: u32,
};
// --------------------------------------------------------
// Type: MAPPING_DATA_RANGE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const MAPPING_DATA_RANGE = extern struct {
    dwStartIndex: u32,
    dwEndIndex: u32,
    pszDescription: ?*u16,
    dwDescriptionLength: u32,
    pData: ?*opaque{},
    dwDataSize: u32,
    pszContentType: ?*u16,
    prgActionIds: ?*?*u16,
    dwActionsCount: u32,
    prgActionDisplayNames: ?*?*u16,
};
// --------------------------------------------------------
// Type: MAPPING_PROPERTY_BAG
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const MAPPING_PROPERTY_BAG = extern struct {
    Size: ?*opaque{},
    prgResultRanges: ?*MAPPING_DATA_RANGE,
    dwRangesCount: u32,
    pServiceData: ?*opaque{},
    dwServiceDataSize: u32,
    pCallerData: ?*opaque{},
    dwCallerDataSize: u32,
    pContext: ?*opaque{},
};
// --------------------------------------------------------
// Type: SpellCheckerFactory
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const SpellCheckerFactory = opaque {
};
// --------------------------------------------------------
// Type: WORDLIST_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const WORDLIST_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: CORRECTIVE_ACTION
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const CORRECTIVE_ACTION = *opaque{
};
// --------------------------------------------------------
// Type: ISpellingError
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ISpellingError = *opaque{
    // TODO: Method 'get_StartIndex'
    // TODO: Method 'get_Length'
    // TODO: Method 'get_CorrectiveAction'
    // TODO: Method 'get_Replacement'
};
// --------------------------------------------------------
// Type: IEnumSpellingError
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IEnumSpellingError = *opaque{
    // TODO: Method 'Next'
};
// --------------------------------------------------------
// Type: IOptionDescription
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IOptionDescription = *opaque{
    // TODO: Method 'get_Id'
    // TODO: Method 'get_Heading'
    // TODO: Method 'get_Description'
    // TODO: Method 'get_Labels'
};
// --------------------------------------------------------
// Type: ISpellCheckerChangedEventHandler
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ISpellCheckerChangedEventHandler = *opaque{
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: ISpellChecker
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ISpellChecker = *opaque{
    // TODO: Method 'get_LanguageTag'
    // TODO: Method 'Check'
    // TODO: Method 'Suggest'
    // TODO: Method 'Add'
    // TODO: Method 'Ignore'
    // TODO: Method 'AutoCorrect'
    // TODO: Method 'GetOptionValue'
    // TODO: Method 'get_OptionIds'
    // TODO: Method 'get_Id'
    // TODO: Method 'get_LocalizedName'
    // TODO: Method 'add_SpellCheckerChanged'
    // TODO: Method 'remove_SpellCheckerChanged'
    // TODO: Method 'GetOptionDescription'
    // TODO: Method 'ComprehensiveCheck'
};
// --------------------------------------------------------
// Type: ISpellChecker2
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ISpellChecker2 = *opaque{
    // TODO: Method 'Remove'
};
// --------------------------------------------------------
// Type: ISpellCheckerFactory
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ISpellCheckerFactory = *opaque{
    // TODO: Method 'get_SupportedLanguages'
    // TODO: Method 'IsSupported'
    // TODO: Method 'CreateSpellChecker'
};
// --------------------------------------------------------
// Type: IUserDictionariesRegistrar
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IUserDictionariesRegistrar = *opaque{
    // TODO: Method 'RegisterUserDictionary'
    // TODO: Method 'UnregisterUserDictionary'
};
// --------------------------------------------------------
// Type: ISpellCheckProvider
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ISpellCheckProvider = *opaque{
    // TODO: Method 'get_LanguageTag'
    // TODO: Method 'Check'
    // TODO: Method 'Suggest'
    // TODO: Method 'GetOptionValue'
    // TODO: Method 'SetOptionValue'
    // TODO: Method 'get_OptionIds'
    // TODO: Method 'get_Id'
    // TODO: Method 'get_LocalizedName'
    // TODO: Method 'GetOptionDescription'
    // TODO: Method 'InitializeWordlist'
};
// --------------------------------------------------------
// Type: IComprehensiveSpellCheckProvider
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IComprehensiveSpellCheckProvider = *opaque{
    // TODO: Method 'ComprehensiveCheck'
};
// --------------------------------------------------------
// Type: ISpellCheckProviderFactory
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ISpellCheckProviderFactory = *opaque{
    // TODO: Method 'get_SupportedLanguages'
    // TODO: Method 'IsSupported'
    // TODO: Method 'CreateSpellCheckProvider'
};
// --------------------------------------------------------
// Type: IFEClassFactory
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IFEClassFactory = *opaque{
};
// --------------------------------------------------------
// Type: IMEDLG
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const IMEDLG = *opaque{
};
// --------------------------------------------------------
// Type: IFECommon
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IFECommon = *opaque{
    // TODO: Method 'IsDefaultIME'
    // TODO: Method 'SetDefaultIME'
    // TODO: Method 'InvokeWordRegDialog'
    // TODO: Method 'InvokeDictToolDialog'
};
// --------------------------------------------------------
// Type: WDD
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const WDD = *opaque{
    // --------------------------------------------------------
    // Type: _Anonymous2_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous2_e__Union = *opaque{
    };
    // --------------------------------------------------------
    // Type: _Anonymous1_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous1_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: MORRSLT
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const MORRSLT = *opaque{
    // --------------------------------------------------------
    // Type: _Anonymous2_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous2_e__Union = *opaque{
    };
    // --------------------------------------------------------
    // Type: _Anonymous3_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous3_e__Union = *opaque{
    };
    // --------------------------------------------------------
    // Type: _Anonymous1_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous1_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: IFELanguage
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IFELanguage = *opaque{
    // TODO: Method 'Open'
    // TODO: Method 'Close'
    // TODO: Method 'GetJMorphResult'
    // TODO: Method 'GetConversionModeCaps'
    // TODO: Method 'GetPhonetic'
    // TODO: Method 'GetConversion'
};
// --------------------------------------------------------
// Type: IMEREG
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const IMEREG = *opaque{
};
// --------------------------------------------------------
// Type: IMEFMT
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const IMEFMT = *opaque{
};
// --------------------------------------------------------
// Type: IMEUCT
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const IMEUCT = *opaque{
};
// --------------------------------------------------------
// Type: IMEWRD
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const IMEWRD = *opaque{
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
        // --------------------------------------------------------
        // Type: _Anonymous_e__Struct
        // TypeLayoutAttr: sequential
        // not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
        pub const _Anonymous_e__Struct = *opaque{
        };
    };
};
// --------------------------------------------------------
// Type: IMESHF
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const IMESHF = *opaque{
};
// --------------------------------------------------------
// Type: POSTBL
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const POSTBL = *opaque{
};
// --------------------------------------------------------
// Type: IMEREL
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const IMEREL = *opaque{
};
// --------------------------------------------------------
// Type: IMEDP
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const IMEDP = *opaque{
};
// --------------------------------------------------------
// Type: PFNLOG
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFNLOG = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: IFEDictionary
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IFEDictionary = *opaque{
    // TODO: Method 'Open'
    // TODO: Method 'Close'
    // TODO: Method 'GetHeader'
    // TODO: Method 'DisplayProperty'
    // TODO: Method 'GetPosTable'
    // TODO: Method 'GetWords'
    // TODO: Method 'NextWords'
    // TODO: Method 'Create'
    // TODO: Method 'SetHeader'
    // TODO: Method 'ExistWord'
    // TODO: Method 'ExistDependency'
    // TODO: Method 'RegisterWord'
    // TODO: Method 'RegisterDependency'
    // TODO: Method 'GetDependencies'
    // TODO: Method 'NextDependencies'
    // TODO: Method 'ConvertFromOldMSIME'
    // TODO: Method 'ConvertFromUserToSys'
};
// --------------------------------------------------------
// Type: IMEKMSINIT
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const IMEKMSINIT = *opaque{
};
// --------------------------------------------------------
// Type: IMEKMSKEY
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const IMEKMSKEY = *opaque{
    // --------------------------------------------------------
    // Type: _Anonymous1_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous1_e__Union = *opaque{
    };
    // --------------------------------------------------------
    // Type: _Anonymous2_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous2_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: IMEKMS
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const IMEKMS = *opaque{
};
// --------------------------------------------------------
// Type: IMEKMSNTFY
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const IMEKMSNTFY = *opaque{
};
// --------------------------------------------------------
// Type: IMEKMSKMP
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const IMEKMSKMP = *opaque{
};
// --------------------------------------------------------
// Type: IMEKMSINVK
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const IMEKMSINVK = *opaque{
};
// --------------------------------------------------------
// Type: IMEKMSFUNCDESC
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const IMEKMSFUNCDESC = *opaque{
};
// --------------------------------------------------------
// Type: fpCreateIFECommonInstanceType
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const fpCreateIFECommonInstanceType = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: fpCreateIFELanguageInstanceType
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const fpCreateIFELanguageInstanceType = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: fpCreateIFEDictionaryInstanceType
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const fpCreateIFEDictionaryInstanceType = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: COMPOSITIONSTRING
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const COMPOSITIONSTRING = extern struct {
    dwSize: u32,
    dwCompReadAttrLen: u32,
    dwCompReadAttrOffset: u32,
    dwCompReadClauseLen: u32,
    dwCompReadClauseOffset: u32,
    dwCompReadStrLen: u32,
    dwCompReadStrOffset: u32,
    dwCompAttrLen: u32,
    dwCompAttrOffset: u32,
    dwCompClauseLen: u32,
    dwCompClauseOffset: u32,
    dwCompStrLen: u32,
    dwCompStrOffset: u32,
    dwCursorPos: u32,
    dwDeltaStart: u32,
    dwResultReadClauseLen: u32,
    dwResultReadClauseOffset: u32,
    dwResultReadStrLen: u32,
    dwResultReadStrOffset: u32,
    dwResultClauseLen: u32,
    dwResultClauseOffset: u32,
    dwResultStrLen: u32,
    dwResultStrOffset: u32,
    dwPrivateSize: u32,
    dwPrivateOffset: u32,
};
// --------------------------------------------------------
// Type: GUIDELINE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const GUIDELINE = extern struct {
    dwSize: u32,
    dwLevel: u32,
    dwIndex: u32,
    dwStrLen: u32,
    dwStrOffset: u32,
    dwPrivateSize: u32,
    dwPrivateOffset: u32,
};
// --------------------------------------------------------
// Type: TRANSMSG
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TRANSMSG = extern struct {
    message: u32,
    wParam: WPARAM,
    lParam: LPARAM,
};
// --------------------------------------------------------
// Type: TRANSMSGLIST
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TRANSMSGLIST = extern struct {
    uMsgCount: u32,
    TransMsg: ?[*]TRANSMSG,
};
// --------------------------------------------------------
// Type: CANDIDATEINFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CANDIDATEINFO = extern struct {
    dwSize: u32,
    dwCount: u32,
    dwOffset: ?[*]u32,
    dwPrivateSize: u32,
    dwPrivateOffset: u32,
};
// --------------------------------------------------------
// Type: INPUTCONTEXT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const INPUTCONTEXT = extern struct {
    hWnd: HWND,
    fOpen: BOOL,
    ptStatusWndPos: POINT,
    ptSoftKbdPos: POINT,
    fdwConversion: u32,
    fdwSentence: u32,
    lfFont: _lfFont_e__Union,
    cfCompForm: COMPOSITIONFORM,
    cfCandForm: ?[*]CANDIDATEFORM,
    hCompStr: ?*HIMCC__,
    hCandInfo: ?*HIMCC__,
    hGuideLine: ?*HIMCC__,
    hPrivate: ?*HIMCC__,
    dwNumMsgBuf: u32,
    hMsgBuf: ?*HIMCC__,
    fdwInit: u32,
    dwReserve: ?[*]u32,
    // --------------------------------------------------------
    // Type: _lfFont_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _lfFont_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: IMEINFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const IMEINFO = extern struct {
    dwPrivateDataSize: u32,
    fdwProperty: u32,
    fdwConversionCaps: u32,
    fdwSentenceCaps: u32,
    fdwUICaps: u32,
    fdwSCSCaps: u32,
    fdwSelectCaps: u32,
};
// --------------------------------------------------------
// Type: SOFTKBDDATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SOFTKBDDATA = extern struct {
    uCount: u32,
    wCode: ?[*]u16,
};
// --------------------------------------------------------
// Type: APPLETIDLIST
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const APPLETIDLIST = extern struct {
    count: i32,
    pIIDList: ?*Guid,
};
// --------------------------------------------------------
// Type: IMESTRINGCANDIDATE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const IMESTRINGCANDIDATE = extern struct {
    uCount: u32,
    lpwstr: ?[*]?*u16,
};
// --------------------------------------------------------
// Type: IMEITEM
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const IMEITEM = extern struct {
    cbSize: i32,
    iType: i32,
    lpItemData: ?*opaque{},
};
// --------------------------------------------------------
// Type: IMEITEMCANDIDATE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const IMEITEMCANDIDATE = extern struct {
    uCount: u32,
    imeItem: ?[*]IMEITEM,
};
// --------------------------------------------------------
// Type: tabIMESTRINGINFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const tabIMESTRINGINFO = extern struct {
    dwFarEastId: u32,
    lpwstr: ?*u16,
};
// --------------------------------------------------------
// Type: tabIMEFAREASTINFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const tabIMEFAREASTINFO = extern struct {
    dwSize: u32,
    dwType: u32,
    dwData: ?[*]u32,
};
// --------------------------------------------------------
// Type: IMESTRINGCANDIDATEINFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const IMESTRINGCANDIDATEINFO = extern struct {
    dwFarEastId: u32,
    lpFarEastInfo: ?*tabIMEFAREASTINFO,
    fInfoMask: u32,
    iSelIndex: i32,
    uCount: u32,
    lpwstr: ?[*]?*u16,
};
// --------------------------------------------------------
// Type: IMECOMPOSITIONSTRINGINFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const IMECOMPOSITIONSTRINGINFO = extern struct {
    iCompStrLen: i32,
    iCaretPos: i32,
    iEditStart: i32,
    iEditLen: i32,
    iTargetStart: i32,
    iTargetLen: i32,
};
// --------------------------------------------------------
// Type: IMECHARINFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const IMECHARINFO = extern struct {
    wch: u16,
    dwCharInfo: u32,
};
// --------------------------------------------------------
// Type: IMEAPPLETCFG
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const IMEAPPLETCFG = extern struct {
    dwConfig: u32,
    wchTitle: ?[*]u16,
    wchTitleFontFace: ?[*]u16,
    dwCharSet: u32,
    iCategory: i32,
    hIcon: HICON,
    langID: u16,
    dummy: u16,
    lReserved1: LPARAM,
};
// --------------------------------------------------------
// Type: IMEAPPLETUI
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const IMEAPPLETUI = extern struct {
    hwnd: HWND,
    dwStyle: u32,
    width: i32,
    height: i32,
    minWidth: i32,
    minHeight: i32,
    maxWidth: i32,
    maxHeight: i32,
    lReserved1: LPARAM,
    lReserved2: LPARAM,
};
// --------------------------------------------------------
// Type: APPLYCANDEXPARAM
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const APPLYCANDEXPARAM = extern struct {
    dwSize: u32,
    lpwstrDisplay: ?*u16,
    lpwstrReading: ?*u16,
    dwReserved: u32,
};
// --------------------------------------------------------
// Type: IImeSpecifyApplets
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IImeSpecifyApplets = *opaque{
    // TODO: Method 'GetAppletIIDList'
};
// --------------------------------------------------------
// Type: IImePadApplet
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IImePadApplet = *opaque{
    // TODO: Method 'Initialize'
    // TODO: Method 'Terminate'
    // TODO: Method 'GetAppletConfig'
    // TODO: Method 'CreateUI'
    // TODO: Method 'Notify'
};
// --------------------------------------------------------
// Type: IImePad
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IImePad = *opaque{
    // TODO: Method 'Request'
};
// --------------------------------------------------------
// Type: IImePlugInDictDictionaryList
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IImePlugInDictDictionaryList = *opaque{
    // TODO: Method 'GetDictionariesInUse'
    // TODO: Method 'DeleteDictionary'
};
// --------------------------------------------------------
// Type: SCRIPT_CONTROL
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SCRIPT_CONTROL = extern struct {
    _bitfield: u32,
};
// --------------------------------------------------------
// Type: SCRIPT_STATE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SCRIPT_STATE = extern struct {
    _bitfield: u16,
};
// --------------------------------------------------------
// Type: SCRIPT_ANALYSIS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SCRIPT_ANALYSIS = extern struct {
    _bitfield: u16,
    s: SCRIPT_STATE,
};
// --------------------------------------------------------
// Type: SCRIPT_ITEM
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SCRIPT_ITEM = extern struct {
    iCharPos: i32,
    a: SCRIPT_ANALYSIS,
};
// --------------------------------------------------------
// Type: SCRIPT_JUSTIFY
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const SCRIPT_JUSTIFY = *opaque{
};
// --------------------------------------------------------
// Type: SCRIPT_VISATTR
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SCRIPT_VISATTR = extern struct {
    _bitfield: u16,
};
// --------------------------------------------------------
// Type: GOFFSET
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const GOFFSET = extern struct {
    du: i32,
    dv: i32,
};
// --------------------------------------------------------
// Type: SCRIPT_LOGATTR
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SCRIPT_LOGATTR = extern struct {
    _bitfield: u8,
};
// --------------------------------------------------------
// Type: SCRIPT_PROPERTIES
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SCRIPT_PROPERTIES = extern struct {
    _bitfield1: u32,
    _bitfield2: u32,
};
// --------------------------------------------------------
// Type: SCRIPT_FONTPROPERTIES
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SCRIPT_FONTPROPERTIES = extern struct {
    cBytes: i32,
    wgBlank: u16,
    wgDefault: u16,
    wgInvalid: u16,
    wgKashida: u16,
    iKashidaWidth: i32,
};
// --------------------------------------------------------
// Type: SCRIPT_TABDEF
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SCRIPT_TABDEF = extern struct {
    cTabStops: i32,
    iScale: i32,
    pTabStops: ?*i32,
    iTabOrigin: i32,
};
// --------------------------------------------------------
// Type: SCRIPT_DIGITSUBSTITUTE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SCRIPT_DIGITSUBSTITUTE = extern struct {
    _bitfield1: u32,
    _bitfield2: u32,
    dwReserved: u32,
};
// --------------------------------------------------------
// Type: opentype_feature_record
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const opentype_feature_record = extern struct {
    tagFeature: u32,
    lParameter: i32,
};
// --------------------------------------------------------
// Type: textrange_properties
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const textrange_properties = extern struct {
    potfRecords: ?*opentype_feature_record,
    cotfRecords: i32,
};
// --------------------------------------------------------
// Type: script_charprop
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const script_charprop = extern struct {
    _bitfield: u16,
};
// --------------------------------------------------------
// Type: script_glyphprop
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const script_glyphprop = extern struct {
    sva: SCRIPT_VISATTR,
    reserved: u16,
};
// --------------------------------------------------------
// Type: UErrorCode
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UErrorCode = *opaque{
};
// --------------------------------------------------------
// Type: UTraceLevel
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UTraceLevel = *opaque{
};
// --------------------------------------------------------
// Type: UTraceFunctionNumber
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UTraceFunctionNumber = *opaque{
};
// --------------------------------------------------------
// Type: UTraceEntry
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UTraceEntry = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: UTraceExit
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UTraceExit = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: UTraceData
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UTraceData = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: UStringTrieResult
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UStringTrieResult = *opaque{
};
// --------------------------------------------------------
// Type: UScriptCode
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UScriptCode = *opaque{
};
// --------------------------------------------------------
// Type: UScriptUsage
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UScriptUsage = *opaque{
};
// --------------------------------------------------------
// Type: UReplaceableCallbacks
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const UReplaceableCallbacks = extern struct {
    length: ?*opaque{},
    charAt: ?*opaque{},
    char32At: ?*opaque{},
    replace: ?*opaque{},
    extract: ?*opaque{},
    copy: ?*opaque{},
};
// --------------------------------------------------------
// Type: UFieldPosition
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const UFieldPosition = extern struct {
    field: i32,
    beginIndex: i32,
    endIndex: i32,
};
// --------------------------------------------------------
// Type: UCharIteratorOrigin
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UCharIteratorOrigin = *opaque{
};
// --------------------------------------------------------
// Type: UCharIteratorGetIndex
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UCharIteratorGetIndex = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: UCharIteratorMove
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UCharIteratorMove = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: UCharIteratorHasNext
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UCharIteratorHasNext = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: UCharIteratorHasPrevious
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UCharIteratorHasPrevious = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: UCharIteratorCurrent
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UCharIteratorCurrent = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: UCharIteratorNext
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UCharIteratorNext = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: UCharIteratorPrevious
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UCharIteratorPrevious = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: UCharIteratorReserved
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UCharIteratorReserved = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: UCharIteratorGetState
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UCharIteratorGetState = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: UCharIteratorSetState
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UCharIteratorSetState = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: UCharIterator
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const UCharIterator = extern struct {
    context: ?*opaque{},
    length: i32,
    start: i32,
    index: i32,
    limit: i32,
    reservedField: i32,
    getIndex: ?*UCharIteratorGetIndex,
    move: ?*UCharIteratorMove,
    hasNext: ?*UCharIteratorHasNext,
    hasPrevious: ?*UCharIteratorHasPrevious,
    current: ?*UCharIteratorCurrent,
    next: ?*UCharIteratorNext,
    previous: ?*UCharIteratorPrevious,
    reservedFn: ?*UCharIteratorReserved,
    getState: ?*UCharIteratorGetState,
    setState: ?*UCharIteratorSetState,
};
// --------------------------------------------------------
// Type: UEnumeration
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const UEnumeration = opaque {
};
// --------------------------------------------------------
// Type: ULocDataLocaleType
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const ULocDataLocaleType = *opaque{
};
// --------------------------------------------------------
// Type: ULayoutType
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const ULayoutType = *opaque{
};
// --------------------------------------------------------
// Type: UAcceptResult
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UAcceptResult = *opaque{
};
// --------------------------------------------------------
// Type: UResourceBundle
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const UResourceBundle = opaque {
};
// --------------------------------------------------------
// Type: UResType
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UResType = *opaque{
};
// --------------------------------------------------------
// Type: UDisplayContextType
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UDisplayContextType = *opaque{
};
// --------------------------------------------------------
// Type: UDisplayContext
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UDisplayContext = *opaque{
};
// --------------------------------------------------------
// Type: UDialectHandling
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UDialectHandling = *opaque{
};
// --------------------------------------------------------
// Type: ULocaleDisplayNames
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const ULocaleDisplayNames = opaque {
};
// --------------------------------------------------------
// Type: UCurrencyUsage
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UCurrencyUsage = *opaque{
};
// --------------------------------------------------------
// Type: UCurrNameStyle
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UCurrNameStyle = *opaque{
};
// --------------------------------------------------------
// Type: UCurrCurrencyType
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UCurrCurrencyType = *opaque{
};
// --------------------------------------------------------
// Type: UConverter
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const UConverter = opaque {
};
// --------------------------------------------------------
// Type: UConverterCallbackReason
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UConverterCallbackReason = *opaque{
};
// --------------------------------------------------------
// Type: UConverterFromUnicodeArgs
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const UConverterFromUnicodeArgs = extern struct {
    size: u16,
    flush: i8,
    converter: ?*UConverter,
    source: ?*u16,
    sourceLimit: ?*u16,
    target: ?*i8,
    targetLimit: ?*i8,
    offsets: ?*i32,
};
// --------------------------------------------------------
// Type: UConverterToUnicodeArgs
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const UConverterToUnicodeArgs = extern struct {
    size: u16,
    flush: i8,
    converter: ?*UConverter,
    source: ?*i8,
    sourceLimit: ?*i8,
    target: ?*u16,
    targetLimit: ?*u16,
    offsets: ?*i32,
};
// --------------------------------------------------------
// Type: USet
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const USet = opaque {
};
// --------------------------------------------------------
// Type: UConverterType
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UConverterType = *opaque{
};
// --------------------------------------------------------
// Type: UConverterPlatform
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UConverterPlatform = *opaque{
};
// --------------------------------------------------------
// Type: UConverterToUCallback
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UConverterToUCallback = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: UConverterFromUCallback
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UConverterFromUCallback = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: UConverterUnicodeSet
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UConverterUnicodeSet = *opaque{
};
// --------------------------------------------------------
// Type: UMemAllocFn
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UMemAllocFn = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: UMemReallocFn
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UMemReallocFn = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: UMemFreeFn
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UMemFreeFn = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: UProperty
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UProperty = *opaque{
};
// --------------------------------------------------------
// Type: UCharCategory
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UCharCategory = *opaque{
};
// --------------------------------------------------------
// Type: UCharDirection
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UCharDirection = *opaque{
};
// --------------------------------------------------------
// Type: UBidiPairedBracketType
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UBidiPairedBracketType = *opaque{
};
// --------------------------------------------------------
// Type: UBlockCode
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UBlockCode = *opaque{
};
// --------------------------------------------------------
// Type: UEastAsianWidth
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UEastAsianWidth = *opaque{
};
// --------------------------------------------------------
// Type: UCharNameChoice
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UCharNameChoice = *opaque{
};
// --------------------------------------------------------
// Type: UPropertyNameChoice
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UPropertyNameChoice = *opaque{
};
// --------------------------------------------------------
// Type: UDecompositionType
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UDecompositionType = *opaque{
};
// --------------------------------------------------------
// Type: UJoiningType
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UJoiningType = *opaque{
};
// --------------------------------------------------------
// Type: UJoiningGroup
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UJoiningGroup = *opaque{
};
// --------------------------------------------------------
// Type: UGraphemeClusterBreak
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UGraphemeClusterBreak = *opaque{
};
// --------------------------------------------------------
// Type: UWordBreakValues
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UWordBreakValues = *opaque{
};
// --------------------------------------------------------
// Type: USentenceBreak
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const USentenceBreak = *opaque{
};
// --------------------------------------------------------
// Type: ULineBreak
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const ULineBreak = *opaque{
};
// --------------------------------------------------------
// Type: UNumericType
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UNumericType = *opaque{
};
// --------------------------------------------------------
// Type: UHangulSyllableType
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UHangulSyllableType = *opaque{
};
// --------------------------------------------------------
// Type: UIndicPositionalCategory
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UIndicPositionalCategory = *opaque{
};
// --------------------------------------------------------
// Type: UIndicSyllabicCategory
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UIndicSyllabicCategory = *opaque{
};
// --------------------------------------------------------
// Type: UVerticalOrientation
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UVerticalOrientation = *opaque{
};
// --------------------------------------------------------
// Type: UCharEnumTypeRange
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UCharEnumTypeRange = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: UEnumCharNamesFn
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UEnumCharNamesFn = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: UBiDiDirection
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UBiDiDirection = *opaque{
};
// --------------------------------------------------------
// Type: UBiDi
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const UBiDi = opaque {
};
// --------------------------------------------------------
// Type: UBiDiReorderingMode
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UBiDiReorderingMode = *opaque{
};
// --------------------------------------------------------
// Type: UBiDiReorderingOption
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UBiDiReorderingOption = *opaque{
};
// --------------------------------------------------------
// Type: UBiDiClassCallback
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UBiDiClassCallback = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: UBiDiOrder
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UBiDiOrder = *opaque{
};
// --------------------------------------------------------
// Type: UBiDiMirroring
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UBiDiMirroring = *opaque{
};
// --------------------------------------------------------
// Type: UBiDiTransform
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const UBiDiTransform = opaque {
};
// --------------------------------------------------------
// Type: UTextClone
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UTextClone = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: UTextNativeLength
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UTextNativeLength = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: UTextAccess
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UTextAccess = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: UTextExtract
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UTextExtract = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: UTextReplace
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UTextReplace = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: UTextCopy
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UTextCopy = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: UTextMapOffsetToNative
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UTextMapOffsetToNative = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: UTextMapNativeIndexToUTF16
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UTextMapNativeIndexToUTF16 = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: UTextClose
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UTextClose = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: UTextFuncs
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const UTextFuncs = extern struct {
    tableSize: i32,
    reserved1: i32,
    reserved2: i32,
    reserved3: i32,
    clone: ?*UTextClone,
    nativeLength: ?*UTextNativeLength,
    access: ?*UTextAccess,
    extract: ?*UTextExtract,
    replace: ?*UTextReplace,
    copy: ?*UTextCopy,
    mapOffsetToNative: ?*UTextMapOffsetToNative,
    mapNativeIndexToUTF16: ?*UTextMapNativeIndexToUTF16,
    close: ?*UTextClose,
    spare1: ?*UTextClose,
    spare2: ?*UTextClose,
    spare3: ?*UTextClose,
};
// --------------------------------------------------------
// Type: UText
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const UText = extern struct {
    magic: u32,
    flags: i32,
    providerProperties: i32,
    sizeOfStruct: i32,
    chunkNativeLimit: i64,
    extraSize: i32,
    nativeIndexingLimit: i32,
    chunkNativeStart: i64,
    chunkOffset: i32,
    chunkLength: i32,
    chunkContents: ?*u16,
    pFuncs: ?*UTextFuncs,
    pExtra: ?*opaque{},
    context: ?*opaque{},
    p: ?*opaque{},
    q: ?*opaque{},
    r: ?*opaque{},
    privP: ?*opaque{},
    a: i64,
    b: i32,
    c: i32,
    privA: i64,
    privB: i32,
    privC: i32,
};
// --------------------------------------------------------
// Type: USetSpanCondition
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const USetSpanCondition = *opaque{
};
// --------------------------------------------------------
// Type: USerializedSet
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const USerializedSet = extern struct {
    array: ?*u16,
    bmpLength: i32,
    length: i32,
    staticArray: ?[*]u16,
};
// --------------------------------------------------------
// Type: UNormalization2Mode
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UNormalization2Mode = *opaque{
};
// --------------------------------------------------------
// Type: UNormalizationCheckResult
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UNormalizationCheckResult = *opaque{
};
// --------------------------------------------------------
// Type: UNormalizer2
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const UNormalizer2 = opaque {
};
// --------------------------------------------------------
// Type: UNormalizationMode
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UNormalizationMode = *opaque{
};
// --------------------------------------------------------
// Type: UConverterSelector
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const UConverterSelector = opaque {
};
// --------------------------------------------------------
// Type: UBreakIterator
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const UBreakIterator = opaque {
};
// --------------------------------------------------------
// Type: UNESCAPE_CHAR_AT
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UNESCAPE_CHAR_AT = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: UCaseMap
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const UCaseMap = opaque {
};
// --------------------------------------------------------
// Type: UParseError
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const UParseError = extern struct {
    line: i32,
    offset: i32,
    preContext: ?[*]u16,
    postContext: ?[*]u16,
};
// --------------------------------------------------------
// Type: UStringPrepProfile
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const UStringPrepProfile = opaque {
};
// --------------------------------------------------------
// Type: UStringPrepProfileType
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UStringPrepProfileType = *opaque{
};
// --------------------------------------------------------
// Type: UIDNA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const UIDNA = opaque {
};
// --------------------------------------------------------
// Type: UIDNAInfo
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const UIDNAInfo = extern struct {
    size: i16,
    isTransitionalDifferent: i8,
    reservedB3: i8,
    errors: u32,
    reservedI2: i32,
    reservedI3: i32,
};
// --------------------------------------------------------
// Type: UBreakIteratorType
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UBreakIteratorType = *opaque{
};
// --------------------------------------------------------
// Type: UWordBreak
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UWordBreak = *opaque{
};
// --------------------------------------------------------
// Type: ULineBreakTag
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const ULineBreakTag = *opaque{
};
// --------------------------------------------------------
// Type: USentenceBreakTag
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const USentenceBreakTag = *opaque{
};
// --------------------------------------------------------
// Type: UCalendarType
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UCalendarType = *opaque{
};
// --------------------------------------------------------
// Type: UCalendarDateFields
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UCalendarDateFields = *opaque{
};
// --------------------------------------------------------
// Type: UCalendarDaysOfWeek
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UCalendarDaysOfWeek = *opaque{
};
// --------------------------------------------------------
// Type: UCalendarMonths
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UCalendarMonths = *opaque{
};
// --------------------------------------------------------
// Type: UCalendarAMPMs
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UCalendarAMPMs = *opaque{
};
// --------------------------------------------------------
// Type: USystemTimeZoneType
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const USystemTimeZoneType = *opaque{
};
// --------------------------------------------------------
// Type: UCalendarDisplayNameType
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UCalendarDisplayNameType = *opaque{
};
// --------------------------------------------------------
// Type: UCalendarAttribute
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UCalendarAttribute = *opaque{
};
// --------------------------------------------------------
// Type: UCalendarWallTimeOption
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UCalendarWallTimeOption = *opaque{
};
// --------------------------------------------------------
// Type: UCalendarLimitType
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UCalendarLimitType = *opaque{
};
// --------------------------------------------------------
// Type: UCalendarWeekdayType
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UCalendarWeekdayType = *opaque{
};
// --------------------------------------------------------
// Type: UTimeZoneTransitionType
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UTimeZoneTransitionType = *opaque{
};
// --------------------------------------------------------
// Type: UCollator
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const UCollator = opaque {
};
// --------------------------------------------------------
// Type: UCollationResult
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UCollationResult = *opaque{
};
// --------------------------------------------------------
// Type: UColAttributeValue
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UColAttributeValue = *opaque{
};
// --------------------------------------------------------
// Type: UColReorderCode
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UColReorderCode = *opaque{
};
// --------------------------------------------------------
// Type: UColAttribute
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UColAttribute = *opaque{
};
// --------------------------------------------------------
// Type: UColRuleOption
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UColRuleOption = *opaque{
};
// --------------------------------------------------------
// Type: UColBoundMode
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UColBoundMode = *opaque{
};
// --------------------------------------------------------
// Type: UCollationElements
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const UCollationElements = opaque {
};
// --------------------------------------------------------
// Type: UCharsetDetector
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const UCharsetDetector = opaque {
};
// --------------------------------------------------------
// Type: UCharsetMatch
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const UCharsetMatch = opaque {
};
// --------------------------------------------------------
// Type: UDateTimePatternField
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UDateTimePatternField = *opaque{
};
// --------------------------------------------------------
// Type: UDateTimePGDisplayWidth
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UDateTimePGDisplayWidth = *opaque{
};
// --------------------------------------------------------
// Type: UDateTimePatternMatchOptions
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UDateTimePatternMatchOptions = *opaque{
};
// --------------------------------------------------------
// Type: UDateTimePatternConflict
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UDateTimePatternConflict = *opaque{
};
// --------------------------------------------------------
// Type: UFieldPositionIterator
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const UFieldPositionIterator = opaque {
};
// --------------------------------------------------------
// Type: UFormattableType
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UFormattableType = *opaque{
};
// --------------------------------------------------------
// Type: UDateIntervalFormat
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const UDateIntervalFormat = opaque {
};
// --------------------------------------------------------
// Type: UGender
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UGender = *opaque{
};
// --------------------------------------------------------
// Type: UGenderInfo
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const UGenderInfo = opaque {
};
// --------------------------------------------------------
// Type: UListFormatter
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const UListFormatter = opaque {
};
// --------------------------------------------------------
// Type: ULocaleData
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const ULocaleData = opaque {
};
// --------------------------------------------------------
// Type: ULocaleDataExemplarSetType
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const ULocaleDataExemplarSetType = *opaque{
};
// --------------------------------------------------------
// Type: ULocaleDataDelimiterType
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const ULocaleDataDelimiterType = *opaque{
};
// --------------------------------------------------------
// Type: UMeasurementSystem
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UMeasurementSystem = *opaque{
};
// --------------------------------------------------------
// Type: UNumberFormatStyle
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UNumberFormatStyle = *opaque{
};
// --------------------------------------------------------
// Type: UNumberFormatRoundingMode
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UNumberFormatRoundingMode = *opaque{
};
// --------------------------------------------------------
// Type: UNumberFormatPadPosition
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UNumberFormatPadPosition = *opaque{
};
// --------------------------------------------------------
// Type: UNumberCompactStyle
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UNumberCompactStyle = *opaque{
};
// --------------------------------------------------------
// Type: UCurrencySpacing
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UCurrencySpacing = *opaque{
};
// --------------------------------------------------------
// Type: UNumberFormatFields
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UNumberFormatFields = *opaque{
};
// --------------------------------------------------------
// Type: UNumberFormatAttributeValue
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UNumberFormatAttributeValue = *opaque{
};
// --------------------------------------------------------
// Type: UNumberFormatAttribute
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UNumberFormatAttribute = *opaque{
};
// --------------------------------------------------------
// Type: UNumberFormatTextAttribute
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UNumberFormatTextAttribute = *opaque{
};
// --------------------------------------------------------
// Type: UNumberFormatSymbol
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UNumberFormatSymbol = *opaque{
};
// --------------------------------------------------------
// Type: UDateFormatStyle
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UDateFormatStyle = *opaque{
};
// --------------------------------------------------------
// Type: UDateFormatField
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UDateFormatField = *opaque{
};
// --------------------------------------------------------
// Type: UDateFormatBooleanAttribute
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UDateFormatBooleanAttribute = *opaque{
};
// --------------------------------------------------------
// Type: UDateFormatSymbolType
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UDateFormatSymbolType = *opaque{
};
// --------------------------------------------------------
// Type: UDateFormatSymbols
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const UDateFormatSymbols = opaque {
};
// --------------------------------------------------------
// Type: UNumberFormatter
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const UNumberFormatter = opaque {
};
// --------------------------------------------------------
// Type: UFormattedNumber
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const UFormattedNumber = opaque {
};
// --------------------------------------------------------
// Type: UNumberingSystem
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const UNumberingSystem = opaque {
};
// --------------------------------------------------------
// Type: UPluralType
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UPluralType = *opaque{
};
// --------------------------------------------------------
// Type: UPluralRules
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const UPluralRules = opaque {
};
// --------------------------------------------------------
// Type: URegularExpression
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const URegularExpression = opaque {
};
// --------------------------------------------------------
// Type: URegexpFlag
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const URegexpFlag = *opaque{
};
// --------------------------------------------------------
// Type: URegexMatchCallback
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const URegexMatchCallback = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: URegexFindProgressCallback
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const URegexFindProgressCallback = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: URegionType
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const URegionType = *opaque{
};
// --------------------------------------------------------
// Type: URegion
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const URegion = opaque {
};
// --------------------------------------------------------
// Type: UDateRelativeDateTimeFormatterStyle
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UDateRelativeDateTimeFormatterStyle = *opaque{
};
// --------------------------------------------------------
// Type: URelativeDateTimeUnit
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const URelativeDateTimeUnit = *opaque{
};
// --------------------------------------------------------
// Type: URelativeDateTimeFormatter
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const URelativeDateTimeFormatter = opaque {
};
// --------------------------------------------------------
// Type: UStringSearch
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const UStringSearch = opaque {
};
// --------------------------------------------------------
// Type: USearchAttribute
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const USearchAttribute = *opaque{
};
// --------------------------------------------------------
// Type: USearchAttributeValue
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const USearchAttributeValue = *opaque{
};
// --------------------------------------------------------
// Type: USpoofChecker
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const USpoofChecker = opaque {
};
// --------------------------------------------------------
// Type: USpoofCheckResult
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const USpoofCheckResult = opaque {
};
// --------------------------------------------------------
// Type: USpoofChecks
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const USpoofChecks = *opaque{
};
// --------------------------------------------------------
// Type: URestrictionLevel
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const URestrictionLevel = *opaque{
};
// --------------------------------------------------------
// Type: UDateTimeScale
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UDateTimeScale = *opaque{
};
// --------------------------------------------------------
// Type: UTimeScaleValue
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UTimeScaleValue = *opaque{
};
// --------------------------------------------------------
// Type: UTransDirection
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UTransDirection = *opaque{
};
// --------------------------------------------------------
// Type: UTransPosition
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const UTransPosition = extern struct {
    contextStart: i32,
    contextLimit: i32,
    start: i32,
    limit: i32,
};

//
// functions
//

// set_last_errror=False (can and should we use this?)
pub extern "GDI32" fn GetTextCharset(
    hdc: HDC,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "GDI32" fn GetTextCharsetInfo(
    hdc: HDC,
    lpSig: ?*FONTSIGNATURE,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=True (can and should we use this?)
pub extern "GDI32" fn TranslateCharsetInfo(
    lpSrc: ?*u32,
    lpCs: ?*CHARSETINFO,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn FindStringOrdinal(
    dwFindStringOrdinalFlags: u32,
    lpStringSource: ?*u16,
    cchSource: i32,
    lpStringValue: ?*u16,
    cchValue: i32,
    bIgnoreCase: BOOL,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetDateFormatA(
    Locale: u32,
    dwFlags: u32,
    lpDate: ?*SYSTEMTIME,
    lpFormat: ?*i8,
    lpDateStr: ?*i8,
    cchDate: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetDateFormatW(
    Locale: u32,
    dwFlags: u32,
    lpDate: ?*SYSTEMTIME,
    lpFormat: ?*u16,
    lpDateStr: ?*u16,
    cchDate: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetTimeFormatA(
    Locale: u32,
    dwFlags: u32,
    lpTime: ?*SYSTEMTIME,
    lpFormat: ?*i8,
    lpTimeStr: ?*i8,
    cchTime: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetTimeFormatW(
    Locale: u32,
    dwFlags: u32,
    lpTime: ?*SYSTEMTIME,
    lpFormat: ?*u16,
    lpTimeStr: ?*u16,
    cchTime: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetTimeFormatEx(
    lpLocaleName: ?*u16,
    dwFlags: u32,
    lpTime: ?*SYSTEMTIME,
    lpFormat: ?*u16,
    lpTimeStr: ?*u16,
    cchTime: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetDateFormatEx(
    lpLocaleName: ?*u16,
    dwFlags: u32,
    lpDate: ?*SYSTEMTIME,
    lpFormat: ?*u16,
    lpDateStr: ?*u16,
    cchDate: i32,
    lpCalendar: ?*u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetDurationFormatEx(
    lpLocaleName: ?*u16,
    dwFlags: u32,
    lpDuration: ?*SYSTEMTIME,
    ullDuration: u64,
    lpFormat: ?*u16,
    lpDurationStr: ?*u16,
    cchDuration: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn CompareStringEx(
    lpLocaleName: ?*u16,
    dwCmpFlags: u32,
    lpString1: ?*u16,
    cchCount1: i32,
    lpString2: ?*u16,
    cchCount2: i32,
    lpVersionInformation: ?*NLSVERSIONINFO,
    lpReserved: ?*opaque{},
    lParam: LPARAM,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn CompareStringOrdinal(
    lpString1: ?*u16,
    cchCount1: i32,
    lpString2: ?*u16,
    cchCount2: i32,
    bIgnoreCase: BOOL,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn CompareStringW(
    Locale: u32,
    dwCmpFlags: u32,
    lpString1: ?*u16,
    cchCount1: i32,
    lpString2: ?*u16,
    cchCount2: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn FoldStringW(
    dwMapFlags: u32,
    lpSrcStr: ?*u16,
    cchSrc: i32,
    lpDestStr: ?*u16,
    cchDest: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetStringTypeExW(
    Locale: u32,
    dwInfoType: u32,
    lpSrcStr: ?*u16,
    cchSrc: i32,
    lpCharType: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetStringTypeW(
    dwInfoType: u32,
    lpSrcStr: ?*u16,
    cchSrc: i32,
    lpCharType: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn MultiByteToWideChar(
    CodePage: u32,
    dwFlags: u32,
    lpMultiByteStr: ?*i8,
    cbMultiByte: i32,
    lpWideCharStr: ?*u16,
    cchWideChar: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn WideCharToMultiByte(
    CodePage: u32,
    dwFlags: u32,
    lpWideCharStr: ?*u16,
    cchWideChar: i32,
    lpMultiByteStr: ?*i8,
    cbMultiByte: i32,
    lpDefaultChar: ?*i8,
    lpUsedDefaultChar: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn IsValidCodePage(
    CodePage: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn GetACP(
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn GetOEMCP(
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetCPInfo(
    CodePage: u32,
    lpCPInfo: ?*CPINFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetCPInfoExA(
    CodePage: u32,
    dwFlags: u32,
    lpCPInfoEx: ?*CPINFOEXA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetCPInfoExW(
    CodePage: u32,
    dwFlags: u32,
    lpCPInfoEx: ?*CPINFOEXW,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn CompareStringA(
    Locale: u32,
    dwCmpFlags: u32,
    lpString1: ?*i8,
    cchCount1: i32,
    lpString2: ?*i8,
    cchCount2: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn FindNLSString(
    Locale: u32,
    dwFindNLSStringFlags: u32,
    lpStringSource: ?*u16,
    cchSource: i32,
    lpStringValue: ?*u16,
    cchValue: i32,
    pcchFound: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn LCMapStringW(
    Locale: u32,
    dwMapFlags: u32,
    lpSrcStr: ?*u16,
    cchSrc: i32,
    lpDestStr: ?*u16,
    cchDest: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn LCMapStringA(
    Locale: u32,
    dwMapFlags: u32,
    lpSrcStr: ?*i8,
    cchSrc: i32,
    lpDestStr: ?*i8,
    cchDest: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetLocaleInfoW(
    Locale: u32,
    LCType: u32,
    lpLCData: ?*u16,
    cchData: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetLocaleInfoA(
    Locale: u32,
    LCType: u32,
    lpLCData: ?*i8,
    cchData: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn SetLocaleInfoA(
    Locale: u32,
    LCType: u32,
    lpLCData: ?*i8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn SetLocaleInfoW(
    Locale: u32,
    LCType: u32,
    lpLCData: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetCalendarInfoA(
    Locale: u32,
    Calendar: u32,
    CalType: u32,
    lpCalData: ?*i8,
    cchData: i32,
    lpValue: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetCalendarInfoW(
    Locale: u32,
    Calendar: u32,
    CalType: u32,
    lpCalData: ?*u16,
    cchData: i32,
    lpValue: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn SetCalendarInfoA(
    Locale: u32,
    Calendar: u32,
    CalType: u32,
    lpCalData: ?*i8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn SetCalendarInfoW(
    Locale: u32,
    Calendar: u32,
    CalType: u32,
    lpCalData: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn IsDBCSLeadByte(
    TestChar: u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn IsDBCSLeadByteEx(
    CodePage: u32,
    TestChar: u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn LocaleNameToLCID(
    lpName: ?*u16,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn LCIDToLocaleName(
    Locale: u32,
    lpName: ?*u16,
    cchName: i32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetDurationFormat(
    Locale: u32,
    dwFlags: u32,
    lpDuration: ?*SYSTEMTIME,
    ullDuration: u64,
    lpFormat: ?*u16,
    lpDurationStr: ?*u16,
    cchDuration: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetNumberFormatA(
    Locale: u32,
    dwFlags: u32,
    lpValue: ?*i8,
    lpFormat: ?*NUMBERFMTA,
    lpNumberStr: ?*i8,
    cchNumber: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetNumberFormatW(
    Locale: u32,
    dwFlags: u32,
    lpValue: ?*u16,
    lpFormat: ?*NUMBERFMTW,
    lpNumberStr: ?*u16,
    cchNumber: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetCurrencyFormatA(
    Locale: u32,
    dwFlags: u32,
    lpValue: ?*i8,
    lpFormat: ?*CURRENCYFMTA,
    lpCurrencyStr: ?*i8,
    cchCurrency: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetCurrencyFormatW(
    Locale: u32,
    dwFlags: u32,
    lpValue: ?*u16,
    lpFormat: ?*CURRENCYFMTW,
    lpCurrencyStr: ?*u16,
    cchCurrency: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn EnumCalendarInfoA(
    lpCalInfoEnumProc: CALINFO_ENUMPROCA,
    Locale: u32,
    Calendar: u32,
    CalType: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn EnumCalendarInfoW(
    lpCalInfoEnumProc: CALINFO_ENUMPROCW,
    Locale: u32,
    Calendar: u32,
    CalType: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn EnumCalendarInfoExA(
    lpCalInfoEnumProcEx: CALINFO_ENUMPROCEXA,
    Locale: u32,
    Calendar: u32,
    CalType: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn EnumCalendarInfoExW(
    lpCalInfoEnumProcEx: CALINFO_ENUMPROCEXW,
    Locale: u32,
    Calendar: u32,
    CalType: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn EnumTimeFormatsA(
    lpTimeFmtEnumProc: TIMEFMT_ENUMPROCA,
    Locale: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn EnumTimeFormatsW(
    lpTimeFmtEnumProc: TIMEFMT_ENUMPROCW,
    Locale: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn EnumDateFormatsA(
    lpDateFmtEnumProc: DATEFMT_ENUMPROCA,
    Locale: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn EnumDateFormatsW(
    lpDateFmtEnumProc: DATEFMT_ENUMPROCW,
    Locale: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn EnumDateFormatsExA(
    lpDateFmtEnumProcEx: DATEFMT_ENUMPROCEXA,
    Locale: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn EnumDateFormatsExW(
    lpDateFmtEnumProcEx: DATEFMT_ENUMPROCEXW,
    Locale: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn IsValidLanguageGroup(
    LanguageGroup: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetNLSVersion(
    Function: u32,
    Locale: u32,
    lpVersionInformation: ?*NLSVERSIONINFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn IsValidLocale(
    Locale: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetGeoInfoA(
    Location: i32,
    GeoType: u32,
    lpGeoData: ?*i8,
    cchData: i32,
    LangId: u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetGeoInfoW(
    Location: i32,
    GeoType: u32,
    lpGeoData: ?*u16,
    cchData: i32,
    LangId: u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetGeoInfoEx(
    location: ?*u16,
    geoType: u32,
    geoData: ?*u16,
    geoDataCount: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn EnumSystemGeoID(
    GeoClass: u32,
    ParentGeoId: i32,
    lpGeoEnumProc: GEO_ENUMPROC,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn EnumSystemGeoNames(
    geoClass: u32,
    geoEnumProc: GEO_ENUMNAMEPROC,
    data: LPARAM,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn GetUserGeoID(
    GeoClass: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetUserDefaultGeoName(
    geoName: ?*u16,
    geoNameCount: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn SetUserGeoID(
    GeoId: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn SetUserGeoName(
    geoName: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn ConvertDefaultLocale(
    Locale: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn GetSystemDefaultUILanguage(
) callconv(@import("std").os.windows.WINAPI) u16;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn GetThreadLocale(
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn SetThreadLocale(
    Locale: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn GetUserDefaultUILanguage(
) callconv(@import("std").os.windows.WINAPI) u16;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn GetUserDefaultLangID(
) callconv(@import("std").os.windows.WINAPI) u16;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn GetSystemDefaultLangID(
) callconv(@import("std").os.windows.WINAPI) u16;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn GetSystemDefaultLCID(
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn GetUserDefaultLCID(
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn SetThreadUILanguage(
    LangId: u16,
) callconv(@import("std").os.windows.WINAPI) u16;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn GetThreadUILanguage(
) callconv(@import("std").os.windows.WINAPI) u16;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetProcessPreferredUILanguages(
    dwFlags: u32,
    pulNumLanguages: ?*u32,
    pwszLanguagesBuffer: ?*u16,
    pcchLanguagesBuffer: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn SetProcessPreferredUILanguages(
    dwFlags: u32,
    pwszLanguagesBuffer: ?*u16,
    pulNumLanguages: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetUserPreferredUILanguages(
    dwFlags: u32,
    pulNumLanguages: ?*u32,
    pwszLanguagesBuffer: ?*u16,
    pcchLanguagesBuffer: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetSystemPreferredUILanguages(
    dwFlags: u32,
    pulNumLanguages: ?*u32,
    pwszLanguagesBuffer: ?*u16,
    pcchLanguagesBuffer: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetThreadPreferredUILanguages(
    dwFlags: u32,
    pulNumLanguages: ?*u32,
    pwszLanguagesBuffer: ?*u16,
    pcchLanguagesBuffer: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn SetThreadPreferredUILanguages(
    dwFlags: u32,
    pwszLanguagesBuffer: ?*u16,
    pulNumLanguages: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetFileMUIInfo(
    dwFlags: u32,
    pcwszFilePath: ?*u16,
    pFileMUIInfo: ?*FILEMUIINFO,
    pcbFileMUIInfo: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetFileMUIPath(
    dwFlags: u32,
    pcwszFilePath: ?*u16,
    pwszLanguage: ?*u16,
    pcchLanguage: ?*u32,
    pwszFileMUIPath: ?*u16,
    pcchFileMUIPath: ?*u32,
    pululEnumerator: ?*u64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetUILanguageInfo(
    dwFlags: u32,
    pwmszLanguage: ?*u16,
    pwszFallbackLanguages: ?*u16,
    pcchFallbackLanguages: ?*u32,
    pAttributes: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn SetThreadPreferredUILanguages2(
    flags: u32,
    languages: ?*u16,
    numLanguagesSet: ?*u32,
    snapshot: ?*?*HSAVEDUILANGUAGES__,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn RestoreThreadPreferredUILanguages(
    snapshot: ?*HSAVEDUILANGUAGES__,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn NotifyUILanguageChange(
    dwFlags: u32,
    pcwstrNewLanguage: ?*u16,
    pcwstrPreviousLanguage: ?*u16,
    dwReserved: u32,
    pdwStatusRtrn: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn GetStringTypeExA(
    Locale: u32,
    dwInfoType: u32,
    lpSrcStr: ?*i8,
    cchSrc: i32,
    lpCharType: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetStringTypeA(
    Locale: u32,
    dwInfoType: u32,
    lpSrcStr: ?*i8,
    cchSrc: i32,
    lpCharType: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn FoldStringA(
    dwMapFlags: u32,
    lpSrcStr: ?*i8,
    cchSrc: i32,
    lpDestStr: ?*i8,
    cchDest: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn EnumSystemLocalesA(
    lpLocaleEnumProc: LOCALE_ENUMPROCA,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn EnumSystemLocalesW(
    lpLocaleEnumProc: LOCALE_ENUMPROCW,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn EnumSystemLanguageGroupsA(
    lpLanguageGroupEnumProc: LANGUAGEGROUP_ENUMPROCA,
    dwFlags: u32,
    lParam: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn EnumSystemLanguageGroupsW(
    lpLanguageGroupEnumProc: LANGUAGEGROUP_ENUMPROCW,
    dwFlags: u32,
    lParam: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn EnumLanguageGroupLocalesA(
    lpLangGroupLocaleEnumProc: LANGGROUPLOCALE_ENUMPROCA,
    LanguageGroup: u32,
    dwFlags: u32,
    lParam: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn EnumLanguageGroupLocalesW(
    lpLangGroupLocaleEnumProc: LANGGROUPLOCALE_ENUMPROCW,
    LanguageGroup: u32,
    dwFlags: u32,
    lParam: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn EnumUILanguagesA(
    lpUILanguageEnumProc: UILANGUAGE_ENUMPROCA,
    dwFlags: u32,
    lParam: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn EnumUILanguagesW(
    lpUILanguageEnumProc: UILANGUAGE_ENUMPROCW,
    dwFlags: u32,
    lParam: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn EnumSystemCodePagesA(
    lpCodePageEnumProc: CODEPAGE_ENUMPROCA,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn EnumSystemCodePagesW(
    lpCodePageEnumProc: CODEPAGE_ENUMPROCW,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "NORMALIZ" fn IdnToAscii(
    dwFlags: u32,
    lpUnicodeCharStr: ?*u16,
    cchUnicodeChar: i32,
    lpASCIICharStr: ?*u16,
    cchASCIIChar: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=True (can and should we use this?)
pub extern "NORMALIZ" fn IdnToUnicode(
    dwFlags: u32,
    lpASCIICharStr: ?*u16,
    cchASCIIChar: i32,
    lpUnicodeCharStr: ?*u16,
    cchUnicodeChar: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn IdnToNameprepUnicode(
    dwFlags: u32,
    lpUnicodeCharStr: ?*u16,
    cchUnicodeChar: i32,
    lpNameprepCharStr: ?*u16,
    cchNameprepChar: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn NormalizeString(
    NormForm: NORM_FORM,
    lpSrcString: ?*u16,
    cwSrcLength: i32,
    lpDstString: ?*u16,
    cwDstLength: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn IsNormalizedString(
    NormForm: NORM_FORM,
    lpString: ?*u16,
    cwLength: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn VerifyScripts(
    dwFlags: u32,
    lpLocaleScripts: ?*u16,
    cchLocaleScripts: i32,
    lpTestScripts: ?*u16,
    cchTestScripts: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetStringScripts(
    dwFlags: u32,
    lpString: ?*u16,
    cchString: i32,
    lpScripts: ?*u16,
    cchScripts: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetLocaleInfoEx(
    lpLocaleName: ?*u16,
    LCType: u32,
    lpLCData: ?*u16,
    cchData: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetCalendarInfoEx(
    lpLocaleName: ?*u16,
    Calendar: u32,
    lpReserved: ?*u16,
    CalType: u32,
    lpCalData: ?*u16,
    cchData: i32,
    lpValue: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetNumberFormatEx(
    lpLocaleName: ?*u16,
    dwFlags: u32,
    lpValue: ?*u16,
    lpFormat: ?*NUMBERFMTW,
    lpNumberStr: ?*u16,
    cchNumber: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetCurrencyFormatEx(
    lpLocaleName: ?*u16,
    dwFlags: u32,
    lpValue: ?*u16,
    lpFormat: ?*CURRENCYFMTW,
    lpCurrencyStr: ?*u16,
    cchCurrency: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetUserDefaultLocaleName(
    lpLocaleName: ?*u16,
    cchLocaleName: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetSystemDefaultLocaleName(
    lpLocaleName: ?*u16,
    cchLocaleName: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn IsNLSDefinedString(
    Function: u32,
    dwFlags: u32,
    lpVersionInformation: ?*NLSVERSIONINFO,
    lpString: ?*u16,
    cchStr: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn GetNLSVersionEx(
    function: u32,
    lpLocaleName: ?*u16,
    lpVersionInformation: ?*NLSVERSIONINFOEX,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn IsValidNLSVersion(
    function: u32,
    lpLocaleName: ?*u16,
    lpVersionInformation: ?*NLSVERSIONINFOEX,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn FindNLSStringEx(
    lpLocaleName: ?*u16,
    dwFindNLSStringFlags: u32,
    lpStringSource: ?*u16,
    cchSource: i32,
    lpStringValue: ?*u16,
    cchValue: i32,
    pcchFound: ?*i32,
    lpVersionInformation: ?*NLSVERSIONINFO,
    lpReserved: ?*opaque{},
    sortHandle: LPARAM,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn LCMapStringEx(
    lpLocaleName: ?*u16,
    dwMapFlags: u32,
    lpSrcStr: ?*u16,
    cchSrc: i32,
    lpDestStr: ?*u16,
    cchDest: i32,
    lpVersionInformation: ?*NLSVERSIONINFO,
    lpReserved: ?*opaque{},
    sortHandle: LPARAM,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "KERNEL32" fn IsValidLocaleName(
    lpLocaleName: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn EnumCalendarInfoExEx(
    pCalInfoEnumProcExEx: CALINFO_ENUMPROCEXEX,
    lpLocaleName: ?*u16,
    Calendar: u32,
    lpReserved: ?*u16,
    CalType: u32,
    lParam: LPARAM,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn EnumDateFormatsExEx(
    lpDateFmtEnumProcExEx: DATEFMT_ENUMPROCEXEX,
    lpLocaleName: ?*u16,
    dwFlags: u32,
    lParam: LPARAM,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn EnumTimeFormatsEx(
    lpTimeFmtEnumProcEx: TIMEFMT_ENUMPROCEX,
    lpLocaleName: ?*u16,
    dwFlags: u32,
    lParam: LPARAM,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn EnumSystemLocalesEx(
    lpLocaleEnumProcEx: LOCALE_ENUMPROCEX,
    dwFlags: u32,
    lParam: LPARAM,
    lpReserved: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "KERNEL32" fn ResolveLocaleName(
    lpNameToResolve: ?*u16,
    lpLocaleName: ?*u16,
    cchLocaleName: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "IMM32" fn ImmInstallIMEA(
    lpszIMEFileName: ?*i8,
    lpszLayoutText: ?*i8,
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=False (can and should we use this?)
pub extern "IMM32" fn ImmInstallIMEW(
    lpszIMEFileName: ?*u16,
    lpszLayoutText: ?*u16,
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=False (can and should we use this?)
pub extern "IMM32" fn ImmGetDefaultIMEWnd(
    param0: HWND,
) callconv(@import("std").os.windows.WINAPI) HWND;

// set_last_errror=False (can and should we use this?)
pub extern "IMM32" fn ImmGetDescriptionA(
    param0: ?*opaque{},
    lpszDescription: ?*i8,
    uBufLen: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "IMM32" fn ImmGetDescriptionW(
    param0: ?*opaque{},
    lpszDescription: ?*u16,
    uBufLen: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "IMM32" fn ImmGetIMEFileNameA(
    param0: ?*opaque{},
    lpszFileName: ?*i8,
    uBufLen: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "IMM32" fn ImmGetIMEFileNameW(
    param0: ?*opaque{},
    lpszFileName: ?*u16,
    uBufLen: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "IMM32" fn ImmGetProperty(
    param0: ?*opaque{},
    param1: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "IMM32" fn ImmIsIME(
    param0: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "IMM32" fn ImmSimulateHotKey(
    param0: HWND,
    param1: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "IMM32" fn ImmCreateContext(
) callconv(@import("std").os.windows.WINAPI) ?*HIMC__;

// set_last_errror=False (can and should we use this?)
pub extern "IMM32" fn ImmDestroyContext(
    param0: ?*HIMC__,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "IMM32" fn ImmGetContext(
    param0: HWND,
) callconv(@import("std").os.windows.WINAPI) ?*HIMC__;

// set_last_errror=False (can and should we use this?)
pub extern "IMM32" fn ImmReleaseContext(
    param0: HWND,
    param1: ?*HIMC__,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "IMM32" fn ImmAssociateContext(
    param0: HWND,
    param1: ?*HIMC__,
) callconv(@import("std").os.windows.WINAPI) ?*HIMC__;

// set_last_errror=False (can and should we use this?)
pub extern "IMM32" fn ImmAssociateContextEx(
    param0: HWND,
    param1: ?*HIMC__,
    param2: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "IMM32" fn ImmGetCompositionStringA(
    param0: ?*HIMC__,
    param1: u32,
    lpBuf: ?*opaque{},
    dwBufLen: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "IMM32" fn ImmGetCompositionStringW(
    param0: ?*HIMC__,
    param1: u32,
    lpBuf: ?*opaque{},
    dwBufLen: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "IMM32" fn ImmSetCompositionStringA(
    param0: ?*HIMC__,
    dwIndex: u32,
    lpComp: ?*opaque{},
    dwCompLen: u32,
    lpRead: ?*opaque{},
    dwReadLen: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "IMM32" fn ImmSetCompositionStringW(
    param0: ?*HIMC__,
    dwIndex: u32,
    lpComp: ?*opaque{},
    dwCompLen: u32,
    lpRead: ?*opaque{},
    dwReadLen: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "IMM32" fn ImmGetCandidateListCountA(
    param0: ?*HIMC__,
    lpdwListCount: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "IMM32" fn ImmGetCandidateListCountW(
    param0: ?*HIMC__,
    lpdwListCount: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "IMM32" fn ImmGetCandidateListA(
    param0: ?*HIMC__,
    deIndex: u32,
    lpCandList: ?*CANDIDATELIST,
    dwBufLen: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "IMM32" fn ImmGetCandidateListW(
    param0: ?*HIMC__,
    deIndex: u32,
    lpCandList: ?*CANDIDATELIST,
    dwBufLen: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "IMM32" fn ImmGetGuideLineA(
    param0: ?*HIMC__,
    dwIndex: u32,
    lpBuf: ?*i8,
    dwBufLen: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "IMM32" fn ImmGetGuideLineW(
    param0: ?*HIMC__,
    dwIndex: u32,
    lpBuf: ?*u16,
    dwBufLen: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "IMM32" fn ImmGetConversionStatus(
    param0: ?*HIMC__,
    lpfdwConversion: ?*u32,
    lpfdwSentence: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "IMM32" fn ImmSetConversionStatus(
    param0: ?*HIMC__,
    param1: u32,
    param2: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "IMM32" fn ImmGetOpenStatus(
    param0: ?*HIMC__,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "IMM32" fn ImmSetOpenStatus(
    param0: ?*HIMC__,
    param1: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "IMM32" fn ImmGetCompositionFontA(
    param0: ?*HIMC__,
    lplf: ?*LOGFONTA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "IMM32" fn ImmGetCompositionFontW(
    param0: ?*HIMC__,
    lplf: ?*LOGFONTW,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "IMM32" fn ImmSetCompositionFontA(
    param0: ?*HIMC__,
    lplf: ?*LOGFONTA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "IMM32" fn ImmSetCompositionFontW(
    param0: ?*HIMC__,
    lplf: ?*LOGFONTW,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "IMM32" fn ImmConfigureIMEA(
    param0: ?*opaque{},
    param1: HWND,
    param2: u32,
    param3: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "IMM32" fn ImmConfigureIMEW(
    param0: ?*opaque{},
    param1: HWND,
    param2: u32,
    param3: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "IMM32" fn ImmEscapeA(
    param0: ?*opaque{},
    param1: ?*HIMC__,
    param2: u32,
    param3: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) LRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "IMM32" fn ImmEscapeW(
    param0: ?*opaque{},
    param1: ?*HIMC__,
    param2: u32,
    param3: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) LRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "IMM32" fn ImmGetConversionListA(
    param0: ?*opaque{},
    param1: ?*HIMC__,
    lpSrc: ?*i8,
    lpDst: ?*CANDIDATELIST,
    dwBufLen: u32,
    uFlag: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "IMM32" fn ImmGetConversionListW(
    param0: ?*opaque{},
    param1: ?*HIMC__,
    lpSrc: ?*u16,
    lpDst: ?*CANDIDATELIST,
    dwBufLen: u32,
    uFlag: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "IMM32" fn ImmNotifyIME(
    param0: ?*HIMC__,
    dwAction: u32,
    dwIndex: u32,
    dwValue: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "IMM32" fn ImmGetStatusWindowPos(
    param0: ?*HIMC__,
    lpptPos: ?*POINT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "IMM32" fn ImmSetStatusWindowPos(
    param0: ?*HIMC__,
    lpptPos: ?*POINT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "IMM32" fn ImmGetCompositionWindow(
    param0: ?*HIMC__,
    lpCompForm: ?*COMPOSITIONFORM,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "IMM32" fn ImmSetCompositionWindow(
    param0: ?*HIMC__,
    lpCompForm: ?*COMPOSITIONFORM,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "IMM32" fn ImmGetCandidateWindow(
    param0: ?*HIMC__,
    param1: u32,
    lpCandidate: ?*CANDIDATEFORM,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "IMM32" fn ImmSetCandidateWindow(
    param0: ?*HIMC__,
    lpCandidate: ?*CANDIDATEFORM,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "IMM32" fn ImmIsUIMessageA(
    param0: HWND,
    param1: u32,
    param2: WPARAM,
    param3: LPARAM,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "IMM32" fn ImmIsUIMessageW(
    param0: HWND,
    param1: u32,
    param2: WPARAM,
    param3: LPARAM,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "IMM32" fn ImmGetVirtualKey(
    param0: HWND,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "IMM32" fn ImmRegisterWordA(
    param0: ?*opaque{},
    lpszReading: ?*i8,
    param2: u32,
    lpszRegister: ?*i8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "IMM32" fn ImmRegisterWordW(
    param0: ?*opaque{},
    lpszReading: ?*u16,
    param2: u32,
    lpszRegister: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "IMM32" fn ImmUnregisterWordA(
    param0: ?*opaque{},
    lpszReading: ?*i8,
    param2: u32,
    lpszUnregister: ?*i8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "IMM32" fn ImmUnregisterWordW(
    param0: ?*opaque{},
    lpszReading: ?*u16,
    param2: u32,
    lpszUnregister: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "IMM32" fn ImmGetRegisterWordStyleA(
    param0: ?*opaque{},
    nItem: u32,
    lpStyleBuf: ?*STYLEBUFA,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "IMM32" fn ImmGetRegisterWordStyleW(
    param0: ?*opaque{},
    nItem: u32,
    lpStyleBuf: ?*STYLEBUFW,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "IMM32" fn ImmEnumRegisterWordA(
    param0: ?*opaque{},
    param1: REGISTERWORDENUMPROCA,
    lpszReading: ?*i8,
    param3: u32,
    lpszRegister: ?*i8,
    param5: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "IMM32" fn ImmEnumRegisterWordW(
    param0: ?*opaque{},
    param1: REGISTERWORDENUMPROCW,
    lpszReading: ?*u16,
    param3: u32,
    lpszRegister: ?*u16,
    param5: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "IMM32" fn ImmDisableIME(
    param0: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "IMM32" fn ImmEnumInputContext(
    idThread: u32,
    lpfn: IMCENUMPROC,
    lParam: LPARAM,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "IMM32" fn ImmGetImeMenuItemsA(
    param0: ?*HIMC__,
    param1: u32,
    param2: u32,
    lpImeParentMenu: ?*IMEMENUITEMINFOA,
    lpImeMenu: ?*IMEMENUITEMINFOA,
    dwSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "IMM32" fn ImmGetImeMenuItemsW(
    param0: ?*HIMC__,
    param1: u32,
    param2: u32,
    lpImeParentMenu: ?*IMEMENUITEMINFOW,
    lpImeMenu: ?*IMEMENUITEMINFOW,
    dwSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "IMM32" fn ImmDisableTextFrameService(
    idThread: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "IMM32" fn ImmDisableLegacyIME(
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "elscore" fn MappingGetServices(
    pOptions: ?*MAPPING_ENUM_OPTIONS,
    prgServices: ?*?*MAPPING_SERVICE_INFO,
    pdwServicesCount: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "elscore" fn MappingFreeServices(
    pServiceInfo: ?*MAPPING_SERVICE_INFO,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "elscore" fn MappingRecognizeText(
    pServiceInfo: ?*MAPPING_SERVICE_INFO,
    pszText: ?*u16,
    dwLength: u32,
    dwIndex: u32,
    pOptions: ?*MAPPING_OPTIONS,
    pbag: ?*MAPPING_PROPERTY_BAG,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "elscore" fn MappingDoAction(
    pBag: ?*MAPPING_PROPERTY_BAG,
    dwRangeIndex: u32,
    pszActionId: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "elscore" fn MappingFreePropertyBag(
    pBag: ?*MAPPING_PROPERTY_BAG,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "IMM32" fn ImmGetHotKey(
    param0: u32,
    lpuModifiers: ?*u32,
    lpuVKey: ?*u32,
    phKL: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "IMM32" fn ImmSetHotKey(
    param0: u32,
    param1: u32,
    param2: u32,
    param3: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "IMM32" fn ImmGenerateMessage(
    param0: ?*HIMC__,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "IMM32" fn ImmRequestMessageA(
    param0: ?*HIMC__,
    param1: WPARAM,
    param2: LPARAM,
) callconv(@import("std").os.windows.WINAPI) LRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "IMM32" fn ImmRequestMessageW(
    param0: ?*HIMC__,
    param1: WPARAM,
    param2: LPARAM,
) callconv(@import("std").os.windows.WINAPI) LRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "IMM32" fn ImmCreateSoftKeyboard(
    param0: u32,
    param1: HWND,
    param2: i32,
    param3: i32,
) callconv(@import("std").os.windows.WINAPI) HWND;

// set_last_errror=False (can and should we use this?)
pub extern "IMM32" fn ImmDestroySoftKeyboard(
    param0: HWND,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "IMM32" fn ImmShowSoftKeyboard(
    param0: HWND,
    param1: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "IMM32" fn ImmLockIMC(
    param0: ?*HIMC__,
) callconv(@import("std").os.windows.WINAPI) ?*INPUTCONTEXT;

// set_last_errror=False (can and should we use this?)
pub extern "IMM32" fn ImmUnlockIMC(
    param0: ?*HIMC__,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "IMM32" fn ImmGetIMCLockCount(
    param0: ?*HIMC__,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "IMM32" fn ImmCreateIMCC(
    param0: u32,
) callconv(@import("std").os.windows.WINAPI) ?*HIMCC__;

// set_last_errror=False (can and should we use this?)
pub extern "IMM32" fn ImmDestroyIMCC(
    param0: ?*HIMCC__,
) callconv(@import("std").os.windows.WINAPI) ?*HIMCC__;

// set_last_errror=False (can and should we use this?)
pub extern "IMM32" fn ImmLockIMCC(
    param0: ?*HIMCC__,
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=False (can and should we use this?)
pub extern "IMM32" fn ImmUnlockIMCC(
    param0: ?*HIMCC__,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "IMM32" fn ImmGetIMCCLockCount(
    param0: ?*HIMCC__,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "IMM32" fn ImmReSizeIMCC(
    param0: ?*HIMCC__,
    param1: u32,
) callconv(@import("std").os.windows.WINAPI) ?*HIMCC__;

// set_last_errror=False (can and should we use this?)
pub extern "IMM32" fn ImmGetIMCCSize(
    param0: ?*HIMCC__,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "USP10" fn ScriptFreeCache(
    psc: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "USP10" fn ScriptItemize(
    pwcInChars: ?*u16,
    cInChars: i32,
    cMaxItems: i32,
    psControl: ?*SCRIPT_CONTROL,
    psState: ?*SCRIPT_STATE,
    pItems: ?*SCRIPT_ITEM,
    pcItems: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "USP10" fn ScriptLayout(
    cRuns: i32,
    pbLevel: ?*u8,
    piVisualToLogical: ?*i32,
    piLogicalToVisual: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "USP10" fn ScriptShape(
    hdc: HDC,
    psc: ?*?*opaque{},
    pwcChars: ?*u16,
    cChars: i32,
    cMaxGlyphs: i32,
    psa: ?*SCRIPT_ANALYSIS,
    pwOutGlyphs: ?*u16,
    pwLogClust: ?*u16,
    psva: ?*SCRIPT_VISATTR,
    pcGlyphs: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "USP10" fn ScriptPlace(
    hdc: HDC,
    psc: ?*?*opaque{},
    pwGlyphs: ?*u16,
    cGlyphs: i32,
    psva: ?*SCRIPT_VISATTR,
    psa: ?*SCRIPT_ANALYSIS,
    piAdvance: ?*i32,
    pGoffset: ?*GOFFSET,
    pABC: ?*ABC,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "USP10" fn ScriptTextOut(
    hdc: ?*opaque{},
    psc: ?*?*opaque{},
    x: i32,
    y: i32,
    fuOptions: u32,
    lprc: ?*RECT,
    psa: ?*SCRIPT_ANALYSIS,
    pwcReserved: ?*u16,
    iReserved: i32,
    pwGlyphs: ?*u16,
    cGlyphs: i32,
    piAdvance: ?*i32,
    piJustify: ?*i32,
    pGoffset: ?*GOFFSET,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "USP10" fn ScriptJustify(
    psva: ?*SCRIPT_VISATTR,
    piAdvance: ?*i32,
    cGlyphs: i32,
    iDx: i32,
    iMinKashida: i32,
    piJustify: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "USP10" fn ScriptBreak(
    pwcChars: ?*u16,
    cChars: i32,
    psa: ?*SCRIPT_ANALYSIS,
    psla: ?*SCRIPT_LOGATTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "USP10" fn ScriptCPtoX(
    iCP: i32,
    fTrailing: BOOL,
    cChars: i32,
    cGlyphs: i32,
    pwLogClust: ?*u16,
    psva: ?*SCRIPT_VISATTR,
    piAdvance: ?*i32,
    psa: ?*SCRIPT_ANALYSIS,
    piX: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "USP10" fn ScriptXtoCP(
    iX: i32,
    cChars: i32,
    cGlyphs: i32,
    pwLogClust: ?*u16,
    psva: ?*SCRIPT_VISATTR,
    piAdvance: ?*i32,
    psa: ?*SCRIPT_ANALYSIS,
    piCP: ?*i32,
    piTrailing: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "USP10" fn ScriptGetLogicalWidths(
    psa: ?*SCRIPT_ANALYSIS,
    cChars: i32,
    cGlyphs: i32,
    piGlyphWidth: ?*i32,
    pwLogClust: ?*u16,
    psva: ?*SCRIPT_VISATTR,
    piDx: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "USP10" fn ScriptApplyLogicalWidth(
    piDx: ?*i32,
    cChars: i32,
    cGlyphs: i32,
    pwLogClust: ?*u16,
    psva: ?*SCRIPT_VISATTR,
    piAdvance: ?*i32,
    psa: ?*SCRIPT_ANALYSIS,
    pABC: ?*ABC,
    piJustify: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "USP10" fn ScriptGetCMap(
    hdc: HDC,
    psc: ?*?*opaque{},
    pwcInChars: ?*u16,
    cChars: i32,
    dwFlags: u32,
    pwOutGlyphs: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "USP10" fn ScriptGetGlyphABCWidth(
    hdc: HDC,
    psc: ?*?*opaque{},
    wGlyph: u16,
    pABC: ?*ABC,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "USP10" fn ScriptGetProperties(
    ppSp: ?*?*?*SCRIPT_PROPERTIES,
    piNumScripts: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "USP10" fn ScriptGetFontProperties(
    hdc: HDC,
    psc: ?*?*opaque{},
    sfp: ?*SCRIPT_FONTPROPERTIES,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "USP10" fn ScriptCacheGetHeight(
    hdc: HDC,
    psc: ?*?*opaque{},
    tmHeight: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "USP10" fn ScriptStringAnalyse(
    hdc: HDC,
    pString: ?*opaque{},
    cString: i32,
    cGlyphs: i32,
    iCharset: i32,
    dwFlags: u32,
    iReqWidth: i32,
    psControl: ?*SCRIPT_CONTROL,
    psState: ?*SCRIPT_STATE,
    piDx: ?*i32,
    pTabdef: ?*SCRIPT_TABDEF,
    pbInClass: ?*u8,
    pssa: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "USP10" fn ScriptStringFree(
    pssa: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "USP10" fn ScriptString_pSize(
    ssa: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) ?*SIZE;

// set_last_errror=False (can and should we use this?)
pub extern "USP10" fn ScriptString_pcOutChars(
    ssa: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) ?*i32;

// set_last_errror=False (can and should we use this?)
pub extern "USP10" fn ScriptString_pLogAttr(
    ssa: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) ?*SCRIPT_LOGATTR;

// set_last_errror=False (can and should we use this?)
pub extern "USP10" fn ScriptStringGetOrder(
    ssa: ?*opaque{},
    puOrder: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "USP10" fn ScriptStringCPtoX(
    ssa: ?*opaque{},
    icp: i32,
    fTrailing: BOOL,
    pX: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "USP10" fn ScriptStringXtoCP(
    ssa: ?*opaque{},
    iX: i32,
    piCh: ?*i32,
    piTrailing: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "USP10" fn ScriptStringGetLogicalWidths(
    ssa: ?*opaque{},
    piDx: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "USP10" fn ScriptStringValidate(
    ssa: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "USP10" fn ScriptStringOut(
    ssa: ?*opaque{},
    iX: i32,
    iY: i32,
    uOptions: u32,
    prc: ?*RECT,
    iMinSel: i32,
    iMaxSel: i32,
    fDisabled: BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "USP10" fn ScriptIsComplex(
    pwcInChars: ?*u16,
    cInChars: i32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "USP10" fn ScriptRecordDigitSubstitution(
    Locale: u32,
    psds: ?*SCRIPT_DIGITSUBSTITUTE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "USP10" fn ScriptApplyDigitSubstitution(
    psds: ?*SCRIPT_DIGITSUBSTITUTE,
    psc: ?*SCRIPT_CONTROL,
    pss: ?*SCRIPT_STATE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "USP10" fn ScriptShapeOpenType(
    hdc: HDC,
    psc: ?*?*opaque{},
    psa: ?*SCRIPT_ANALYSIS,
    tagScript: u32,
    tagLangSys: u32,
    rcRangeChars: ?*i32,
    rpRangeProperties: ?*?*textrange_properties,
    cRanges: i32,
    pwcChars: ?*u16,
    cChars: i32,
    cMaxGlyphs: i32,
    pwLogClust: ?*u16,
    pCharProps: ?*script_charprop,
    pwOutGlyphs: ?*u16,
    pOutGlyphProps: ?*script_glyphprop,
    pcGlyphs: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "USP10" fn ScriptPlaceOpenType(
    hdc: HDC,
    psc: ?*?*opaque{},
    psa: ?*SCRIPT_ANALYSIS,
    tagScript: u32,
    tagLangSys: u32,
    rcRangeChars: ?*i32,
    rpRangeProperties: ?*?*textrange_properties,
    cRanges: i32,
    pwcChars: ?*u16,
    pwLogClust: ?*u16,
    pCharProps: ?*script_charprop,
    cChars: i32,
    pwGlyphs: ?*u16,
    pGlyphProps: ?*script_glyphprop,
    cGlyphs: i32,
    piAdvance: ?*i32,
    pGoffset: ?*GOFFSET,
    pABC: ?*ABC,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "USP10" fn ScriptItemizeOpenType(
    pwcInChars: ?*u16,
    cInChars: i32,
    cMaxItems: i32,
    psControl: ?*SCRIPT_CONTROL,
    psState: ?*SCRIPT_STATE,
    pItems: ?*SCRIPT_ITEM,
    pScriptTags: ?*u32,
    pcItems: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "USP10" fn ScriptGetFontScriptTags(
    hdc: HDC,
    psc: ?*?*opaque{},
    psa: ?*SCRIPT_ANALYSIS,
    cMaxTags: i32,
    pScriptTags: ?*u32,
    pcTags: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "USP10" fn ScriptGetFontLanguageTags(
    hdc: HDC,
    psc: ?*?*opaque{},
    psa: ?*SCRIPT_ANALYSIS,
    tagScript: u32,
    cMaxTags: i32,
    pLangsysTags: ?*u32,
    pcTags: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "USP10" fn ScriptGetFontFeatureTags(
    hdc: HDC,
    psc: ?*?*opaque{},
    psa: ?*SCRIPT_ANALYSIS,
    tagScript: u32,
    tagLangSys: u32,
    cMaxTags: i32,
    pFeatureTags: ?*u32,
    pcTags: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "USP10" fn ScriptGetFontAlternateGlyphs(
    hdc: HDC,
    psc: ?*?*opaque{},
    psa: ?*SCRIPT_ANALYSIS,
    tagScript: u32,
    tagLangSys: u32,
    tagFeature: u32,
    wGlyphId: u16,
    cMaxAlternates: i32,
    pAlternateGlyphs: ?*u16,
    pcAlternates: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "USP10" fn ScriptSubstituteSingleGlyph(
    hdc: HDC,
    psc: ?*?*opaque{},
    psa: ?*SCRIPT_ANALYSIS,
    tagScript: u32,
    tagLangSys: u32,
    tagFeature: u32,
    lParameter: i32,
    wGlyphId: u16,
    pwOutGlyphId: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "USP10" fn ScriptPositionSingleGlyph(
    hdc: HDC,
    psc: ?*?*opaque{},
    psa: ?*SCRIPT_ANALYSIS,
    tagScript: u32,
    tagLangSys: u32,
    tagFeature: u32,
    lParameter: i32,
    wGlyphId: u16,
    iAdvance: i32,
    GOffset: GOFFSET,
    piOutAdvance: ?*i32,
    pOutGoffset: ?*GOFFSET,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn utf8_nextCharSafeBody(
    s: ?*u8,
    pi: ?*i32,
    length: i32,
    c: i32,
    strict: i8,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn utf8_appendCharSafeBody(
    s: ?*u8,
    i: i32,
    length: i32,
    c: i32,
    pIsError: ?*i8,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn utf8_prevCharSafeBody(
    s: ?*u8,
    start: i32,
    pi: ?*i32,
    c: i32,
    strict: i8,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn utf8_back1SafeBody(
    s: ?*u8,
    start: i32,
    i: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_versionFromString(
    versionArray: ?*u8,
    versionString: ?*i8,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_versionFromUString(
    versionArray: ?*u8,
    versionString: ?*u16,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_versionToString(
    versionArray: ?*u8,
    versionString: ?*i8,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_getVersion(
    versionArray: ?*u8,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_errorName(
    code: UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn utrace_setLevel(
    traceLevel: i32,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn utrace_getLevel(
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn utrace_setFunctions(
    context: ?*opaque{},
    e: ?*UTraceEntry,
    x: ?*UTraceExit,
    d: ?*UTraceData,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn utrace_getFunctions(
    context: ?*?*opaque{},
    e: ?*?*UTraceEntry,
    x: ?*?*UTraceExit,
    d: ?*?*UTraceData,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn utrace_vformat(
    outBuf: ?*i8,
    capacity: i32,
    indent: i32,
    fmt: ?*i8,
    args: ?*i8,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn utrace_format(
    outBuf: ?*i8,
    capacity: i32,
    indent: i32,
    fmt: ?*i8,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn utrace_functionName(
    fnNumber: i32,
) callconv(@import("std").os.windows.WINAPI) ?*i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_shapeArabic(
    source: ?*u16,
    sourceLength: i32,
    dest: ?*u16,
    destSize: i32,
    options: u32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uscript_getCode(
    nameOrAbbrOrLocale: ?*i8,
    fillIn: ?*UScriptCode,
    capacity: i32,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uscript_getName(
    scriptCode: UScriptCode,
) callconv(@import("std").os.windows.WINAPI) ?*i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uscript_getShortName(
    scriptCode: UScriptCode,
) callconv(@import("std").os.windows.WINAPI) ?*i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uscript_getScript(
    codepoint: i32,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) UScriptCode;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uscript_hasScript(
    c: i32,
    sc: UScriptCode,
) callconv(@import("std").os.windows.WINAPI) i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uscript_getScriptExtensions(
    c: i32,
    scripts: ?*UScriptCode,
    capacity: i32,
    errorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uscript_getSampleString(
    script: UScriptCode,
    dest: ?*u16,
    capacity: i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uscript_getUsage(
    script: UScriptCode,
) callconv(@import("std").os.windows.WINAPI) UScriptUsage;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uscript_isRightToLeft(
    script: UScriptCode,
) callconv(@import("std").os.windows.WINAPI) i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uscript_breaksBetweenLetters(
    script: UScriptCode,
) callconv(@import("std").os.windows.WINAPI) i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uscript_isCased(
    script: UScriptCode,
) callconv(@import("std").os.windows.WINAPI) i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uiter_current32(
    iter: ?*UCharIterator,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uiter_next32(
    iter: ?*UCharIterator,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uiter_previous32(
    iter: ?*UCharIterator,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uiter_getState(
    iter: ?*UCharIterator,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uiter_setState(
    iter: ?*UCharIterator,
    state: u32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uiter_setString(
    iter: ?*UCharIterator,
    s: ?*u16,
    length: i32,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uiter_setUTF16BE(
    iter: ?*UCharIterator,
    s: ?*i8,
    length: i32,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uiter_setUTF8(
    iter: ?*UCharIterator,
    s: ?*i8,
    length: i32,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uenum_close(
    en: ?*UEnumeration,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uenum_count(
    en: ?*UEnumeration,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uenum_unext(
    en: ?*UEnumeration,
    resultLength: ?*i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uenum_next(
    en: ?*UEnumeration,
    resultLength: ?*i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uenum_reset(
    en: ?*UEnumeration,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uenum_openUCharStringsEnumeration(
    strings: ?*?*u16,
    count: i32,
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UEnumeration;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uenum_openCharStringsEnumeration(
    strings: ?*?*i8,
    count: i32,
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UEnumeration;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uloc_getDefault(
) callconv(@import("std").os.windows.WINAPI) ?*i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uloc_setDefault(
    localeID: ?*i8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uloc_getLanguage(
    localeID: ?*i8,
    language: ?*i8,
    languageCapacity: i32,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uloc_getScript(
    localeID: ?*i8,
    script: ?*i8,
    scriptCapacity: i32,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uloc_getCountry(
    localeID: ?*i8,
    country: ?*i8,
    countryCapacity: i32,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uloc_getVariant(
    localeID: ?*i8,
    variant: ?*i8,
    variantCapacity: i32,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uloc_getName(
    localeID: ?*i8,
    name: ?*i8,
    nameCapacity: i32,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uloc_canonicalize(
    localeID: ?*i8,
    name: ?*i8,
    nameCapacity: i32,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uloc_getISO3Language(
    localeID: ?*i8,
) callconv(@import("std").os.windows.WINAPI) ?*i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uloc_getISO3Country(
    localeID: ?*i8,
) callconv(@import("std").os.windows.WINAPI) ?*i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uloc_getLCID(
    localeID: ?*i8,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uloc_getDisplayLanguage(
    locale: ?*i8,
    displayLocale: ?*i8,
    language: ?*u16,
    languageCapacity: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uloc_getDisplayScript(
    locale: ?*i8,
    displayLocale: ?*i8,
    script: ?*u16,
    scriptCapacity: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uloc_getDisplayCountry(
    locale: ?*i8,
    displayLocale: ?*i8,
    country: ?*u16,
    countryCapacity: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uloc_getDisplayVariant(
    locale: ?*i8,
    displayLocale: ?*i8,
    variant: ?*u16,
    variantCapacity: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uloc_getDisplayKeyword(
    keyword: ?*i8,
    displayLocale: ?*i8,
    dest: ?*u16,
    destCapacity: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uloc_getDisplayKeywordValue(
    locale: ?*i8,
    keyword: ?*i8,
    displayLocale: ?*i8,
    dest: ?*u16,
    destCapacity: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uloc_getDisplayName(
    localeID: ?*i8,
    inLocaleID: ?*i8,
    result: ?*u16,
    maxResultSize: i32,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uloc_getAvailable(
    n: i32,
) callconv(@import("std").os.windows.WINAPI) ?*i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uloc_countAvailable(
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uloc_getISOLanguages(
) callconv(@import("std").os.windows.WINAPI) ?*?*i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uloc_getISOCountries(
) callconv(@import("std").os.windows.WINAPI) ?*?*i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uloc_getParent(
    localeID: ?*i8,
    parent: ?*i8,
    parentCapacity: i32,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uloc_getBaseName(
    localeID: ?*i8,
    name: ?*i8,
    nameCapacity: i32,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uloc_openKeywords(
    localeID: ?*i8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UEnumeration;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uloc_getKeywordValue(
    localeID: ?*i8,
    keywordName: ?*i8,
    buffer: ?*i8,
    bufferCapacity: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uloc_setKeywordValue(
    keywordName: ?*i8,
    keywordValue: ?*i8,
    buffer: ?*i8,
    bufferCapacity: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uloc_isRightToLeft(
    locale: ?*i8,
) callconv(@import("std").os.windows.WINAPI) i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uloc_getCharacterOrientation(
    localeId: ?*i8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ULayoutType;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uloc_getLineOrientation(
    localeId: ?*i8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ULayoutType;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uloc_acceptLanguageFromHTTP(
    result: ?*i8,
    resultAvailable: i32,
    outResult: ?*UAcceptResult,
    httpAcceptLanguage: ?*i8,
    availableLocales: ?*UEnumeration,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uloc_acceptLanguage(
    result: ?*i8,
    resultAvailable: i32,
    outResult: ?*UAcceptResult,
    acceptList: ?*?*i8,
    acceptListCount: i32,
    availableLocales: ?*UEnumeration,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uloc_getLocaleForLCID(
    hostID: u32,
    locale: ?*i8,
    localeCapacity: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uloc_addLikelySubtags(
    localeID: ?*i8,
    maximizedLocaleID: ?*i8,
    maximizedLocaleIDCapacity: i32,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uloc_minimizeSubtags(
    localeID: ?*i8,
    minimizedLocaleID: ?*i8,
    minimizedLocaleIDCapacity: i32,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uloc_forLanguageTag(
    langtag: ?*i8,
    localeID: ?*i8,
    localeIDCapacity: i32,
    parsedLength: ?*i32,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uloc_toLanguageTag(
    localeID: ?*i8,
    langtag: ?*i8,
    langtagCapacity: i32,
    strict: i8,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uloc_toUnicodeLocaleKey(
    keyword: ?*i8,
) callconv(@import("std").os.windows.WINAPI) ?*i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uloc_toUnicodeLocaleType(
    keyword: ?*i8,
    value: ?*i8,
) callconv(@import("std").os.windows.WINAPI) ?*i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uloc_toLegacyKey(
    keyword: ?*i8,
) callconv(@import("std").os.windows.WINAPI) ?*i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uloc_toLegacyType(
    keyword: ?*i8,
    value: ?*i8,
) callconv(@import("std").os.windows.WINAPI) ?*i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ures_open(
    packageName: ?*i8,
    locale: ?*i8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UResourceBundle;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ures_openDirect(
    packageName: ?*i8,
    locale: ?*i8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UResourceBundle;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ures_openU(
    packageName: ?*u16,
    locale: ?*i8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UResourceBundle;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ures_close(
    resourceBundle: ?*UResourceBundle,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ures_getVersion(
    resB: ?*UResourceBundle,
    versionInfo: ?*u8,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ures_getLocaleByType(
    resourceBundle: ?*UResourceBundle,
    type: ULocDataLocaleType,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ures_getString(
    resourceBundle: ?*UResourceBundle,
    len: ?*i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ures_getUTF8String(
    resB: ?*UResourceBundle,
    dest: ?*i8,
    length: ?*i32,
    forceCopy: i8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ures_getBinary(
    resourceBundle: ?*UResourceBundle,
    len: ?*i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ures_getIntVector(
    resourceBundle: ?*UResourceBundle,
    len: ?*i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ures_getUInt(
    resourceBundle: ?*UResourceBundle,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ures_getInt(
    resourceBundle: ?*UResourceBundle,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ures_getSize(
    resourceBundle: ?*UResourceBundle,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ures_getType(
    resourceBundle: ?*UResourceBundle,
) callconv(@import("std").os.windows.WINAPI) UResType;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ures_getKey(
    resourceBundle: ?*UResourceBundle,
) callconv(@import("std").os.windows.WINAPI) ?*i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ures_resetIterator(
    resourceBundle: ?*UResourceBundle,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ures_hasNext(
    resourceBundle: ?*UResourceBundle,
) callconv(@import("std").os.windows.WINAPI) i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ures_getNextResource(
    resourceBundle: ?*UResourceBundle,
    fillIn: ?*UResourceBundle,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UResourceBundle;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ures_getNextString(
    resourceBundle: ?*UResourceBundle,
    len: ?*i32,
    key: ?*?*i8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ures_getByIndex(
    resourceBundle: ?*UResourceBundle,
    indexR: i32,
    fillIn: ?*UResourceBundle,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UResourceBundle;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ures_getStringByIndex(
    resourceBundle: ?*UResourceBundle,
    indexS: i32,
    len: ?*i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ures_getUTF8StringByIndex(
    resB: ?*UResourceBundle,
    stringIndex: i32,
    dest: ?*i8,
    pLength: ?*i32,
    forceCopy: i8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ures_getByKey(
    resourceBundle: ?*UResourceBundle,
    key: ?*i8,
    fillIn: ?*UResourceBundle,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UResourceBundle;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ures_getStringByKey(
    resB: ?*UResourceBundle,
    key: ?*i8,
    len: ?*i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ures_getUTF8StringByKey(
    resB: ?*UResourceBundle,
    key: ?*i8,
    dest: ?*i8,
    pLength: ?*i32,
    forceCopy: i8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ures_openAvailableLocales(
    packageName: ?*i8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UEnumeration;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uldn_open(
    locale: ?*i8,
    dialectHandling: UDialectHandling,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*ULocaleDisplayNames;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uldn_close(
    ldn: ?*ULocaleDisplayNames,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uldn_getLocale(
    ldn: ?*ULocaleDisplayNames,
) callconv(@import("std").os.windows.WINAPI) ?*i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uldn_getDialectHandling(
    ldn: ?*ULocaleDisplayNames,
) callconv(@import("std").os.windows.WINAPI) UDialectHandling;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uldn_localeDisplayName(
    ldn: ?*ULocaleDisplayNames,
    locale: ?*i8,
    result: ?*u16,
    maxResultSize: i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uldn_languageDisplayName(
    ldn: ?*ULocaleDisplayNames,
    lang: ?*i8,
    result: ?*u16,
    maxResultSize: i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uldn_scriptDisplayName(
    ldn: ?*ULocaleDisplayNames,
    script: ?*i8,
    result: ?*u16,
    maxResultSize: i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uldn_scriptCodeDisplayName(
    ldn: ?*ULocaleDisplayNames,
    scriptCode: UScriptCode,
    result: ?*u16,
    maxResultSize: i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uldn_regionDisplayName(
    ldn: ?*ULocaleDisplayNames,
    region: ?*i8,
    result: ?*u16,
    maxResultSize: i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uldn_variantDisplayName(
    ldn: ?*ULocaleDisplayNames,
    variant: ?*i8,
    result: ?*u16,
    maxResultSize: i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uldn_keyDisplayName(
    ldn: ?*ULocaleDisplayNames,
    key: ?*i8,
    result: ?*u16,
    maxResultSize: i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uldn_keyValueDisplayName(
    ldn: ?*ULocaleDisplayNames,
    key: ?*i8,
    value: ?*i8,
    result: ?*u16,
    maxResultSize: i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uldn_openForContext(
    locale: ?*i8,
    contexts: ?*UDisplayContext,
    length: i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*ULocaleDisplayNames;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uldn_getContext(
    ldn: ?*ULocaleDisplayNames,
    type: UDisplayContextType,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) UDisplayContext;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucurr_forLocale(
    locale: ?*i8,
    buff: ?*u16,
    buffCapacity: i32,
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucurr_register(
    isoCode: ?*u16,
    locale: ?*i8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucurr_unregister(
    key: ?*opaque{},
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucurr_getName(
    currency: ?*u16,
    locale: ?*i8,
    nameStyle: UCurrNameStyle,
    isChoiceFormat: ?*i8,
    len: ?*i32,
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucurr_getPluralName(
    currency: ?*u16,
    locale: ?*i8,
    isChoiceFormat: ?*i8,
    pluralCount: ?*i8,
    len: ?*i32,
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucurr_getDefaultFractionDigits(
    currency: ?*u16,
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucurr_getDefaultFractionDigitsForUsage(
    currency: ?*u16,
    usage: UCurrencyUsage,
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucurr_getRoundingIncrement(
    currency: ?*u16,
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) f64;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucurr_getRoundingIncrementForUsage(
    currency: ?*u16,
    usage: UCurrencyUsage,
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) f64;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucurr_openISOCurrencies(
    currType: u32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UEnumeration;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucurr_isAvailable(
    isoCode: ?*u16,
    from: f64,
    to: f64,
    errorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucurr_countCurrencies(
    locale: ?*i8,
    date: f64,
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucurr_forLocaleAndDate(
    locale: ?*i8,
    date: f64,
    index: i32,
    buff: ?*u16,
    buffCapacity: i32,
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucurr_getKeywordValuesForLocale(
    key: ?*i8,
    locale: ?*i8,
    commonlyUsed: i8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UEnumeration;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucurr_getNumericCode(
    currency: ?*u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn UCNV_FROM_U_CALLBACK_STOP(
    context: ?*opaque{},
    fromUArgs: ?*UConverterFromUnicodeArgs,
    codeUnits: ?*u16,
    length: i32,
    codePoint: i32,
    reason: UConverterCallbackReason,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn UCNV_TO_U_CALLBACK_STOP(
    context: ?*opaque{},
    toUArgs: ?*UConverterToUnicodeArgs,
    codeUnits: ?*i8,
    length: i32,
    reason: UConverterCallbackReason,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn UCNV_FROM_U_CALLBACK_SKIP(
    context: ?*opaque{},
    fromUArgs: ?*UConverterFromUnicodeArgs,
    codeUnits: ?*u16,
    length: i32,
    codePoint: i32,
    reason: UConverterCallbackReason,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn UCNV_FROM_U_CALLBACK_SUBSTITUTE(
    context: ?*opaque{},
    fromUArgs: ?*UConverterFromUnicodeArgs,
    codeUnits: ?*u16,
    length: i32,
    codePoint: i32,
    reason: UConverterCallbackReason,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn UCNV_FROM_U_CALLBACK_ESCAPE(
    context: ?*opaque{},
    fromUArgs: ?*UConverterFromUnicodeArgs,
    codeUnits: ?*u16,
    length: i32,
    codePoint: i32,
    reason: UConverterCallbackReason,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn UCNV_TO_U_CALLBACK_SKIP(
    context: ?*opaque{},
    toUArgs: ?*UConverterToUnicodeArgs,
    codeUnits: ?*i8,
    length: i32,
    reason: UConverterCallbackReason,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn UCNV_TO_U_CALLBACK_SUBSTITUTE(
    context: ?*opaque{},
    toUArgs: ?*UConverterToUnicodeArgs,
    codeUnits: ?*i8,
    length: i32,
    reason: UConverterCallbackReason,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn UCNV_TO_U_CALLBACK_ESCAPE(
    context: ?*opaque{},
    toUArgs: ?*UConverterToUnicodeArgs,
    codeUnits: ?*i8,
    length: i32,
    reason: UConverterCallbackReason,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucnv_compareNames(
    name1: ?*i8,
    name2: ?*i8,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucnv_open(
    converterName: ?*i8,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UConverter;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucnv_openU(
    name: ?*u16,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UConverter;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucnv_openCCSID(
    codepage: i32,
    platform: UConverterPlatform,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UConverter;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucnv_openPackage(
    packageName: ?*i8,
    converterName: ?*i8,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UConverter;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucnv_safeClone(
    cnv: ?*UConverter,
    stackBuffer: ?*opaque{},
    pBufferSize: ?*i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UConverter;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucnv_close(
    converter: ?*UConverter,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucnv_getSubstChars(
    converter: ?*UConverter,
    subChars: ?*i8,
    len: ?*i8,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucnv_setSubstChars(
    converter: ?*UConverter,
    subChars: ?*i8,
    len: i8,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucnv_setSubstString(
    cnv: ?*UConverter,
    s: ?*u16,
    length: i32,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucnv_getInvalidChars(
    converter: ?*UConverter,
    errBytes: ?*i8,
    len: ?*i8,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucnv_getInvalidUChars(
    converter: ?*UConverter,
    errUChars: ?*u16,
    len: ?*i8,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucnv_reset(
    converter: ?*UConverter,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucnv_resetToUnicode(
    converter: ?*UConverter,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucnv_resetFromUnicode(
    converter: ?*UConverter,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucnv_getMaxCharSize(
    converter: ?*UConverter,
) callconv(@import("std").os.windows.WINAPI) i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucnv_getMinCharSize(
    converter: ?*UConverter,
) callconv(@import("std").os.windows.WINAPI) i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucnv_getDisplayName(
    converter: ?*UConverter,
    displayLocale: ?*i8,
    displayName: ?*u16,
    displayNameCapacity: i32,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucnv_getName(
    converter: ?*UConverter,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucnv_getCCSID(
    converter: ?*UConverter,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucnv_getPlatform(
    converter: ?*UConverter,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) UConverterPlatform;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucnv_getType(
    converter: ?*UConverter,
) callconv(@import("std").os.windows.WINAPI) UConverterType;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucnv_getStarters(
    converter: ?*UConverter,
    starters: ?*i8,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucnv_getUnicodeSet(
    cnv: ?*UConverter,
    setFillIn: ?*USet,
    whichSet: UConverterUnicodeSet,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucnv_getToUCallBack(
    converter: ?*UConverter,
    action: ?*UConverterToUCallback,
    context: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucnv_getFromUCallBack(
    converter: ?*UConverter,
    action: ?*UConverterFromUCallback,
    context: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucnv_setToUCallBack(
    converter: ?*UConverter,
    newAction: UConverterToUCallback,
    newContext: ?*opaque{},
    oldAction: ?*UConverterToUCallback,
    oldContext: ?*?*opaque{},
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucnv_setFromUCallBack(
    converter: ?*UConverter,
    newAction: UConverterFromUCallback,
    newContext: ?*opaque{},
    oldAction: ?*UConverterFromUCallback,
    oldContext: ?*?*opaque{},
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucnv_fromUnicode(
    converter: ?*UConverter,
    target: ?*?*i8,
    targetLimit: ?*i8,
    source: ?*?*u16,
    sourceLimit: ?*u16,
    offsets: ?*i32,
    flush: i8,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucnv_toUnicode(
    converter: ?*UConverter,
    target: ?*?*u16,
    targetLimit: ?*u16,
    source: ?*?*i8,
    sourceLimit: ?*i8,
    offsets: ?*i32,
    flush: i8,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucnv_fromUChars(
    cnv: ?*UConverter,
    dest: ?*i8,
    destCapacity: i32,
    src: ?*u16,
    srcLength: i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucnv_toUChars(
    cnv: ?*UConverter,
    dest: ?*u16,
    destCapacity: i32,
    src: ?*i8,
    srcLength: i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucnv_getNextUChar(
    converter: ?*UConverter,
    source: ?*?*i8,
    sourceLimit: ?*i8,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucnv_convertEx(
    targetCnv: ?*UConverter,
    sourceCnv: ?*UConverter,
    target: ?*?*i8,
    targetLimit: ?*i8,
    source: ?*?*i8,
    sourceLimit: ?*i8,
    pivotStart: ?*u16,
    pivotSource: ?*?*u16,
    pivotTarget: ?*?*u16,
    pivotLimit: ?*u16,
    reset: i8,
    flush: i8,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucnv_convert(
    toConverterName: ?*i8,
    fromConverterName: ?*i8,
    target: ?*i8,
    targetCapacity: i32,
    source: ?*i8,
    sourceLength: i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucnv_toAlgorithmic(
    algorithmicType: UConverterType,
    cnv: ?*UConverter,
    target: ?*i8,
    targetCapacity: i32,
    source: ?*i8,
    sourceLength: i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucnv_fromAlgorithmic(
    cnv: ?*UConverter,
    algorithmicType: UConverterType,
    target: ?*i8,
    targetCapacity: i32,
    source: ?*i8,
    sourceLength: i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucnv_flushCache(
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucnv_countAvailable(
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucnv_getAvailableName(
    n: i32,
) callconv(@import("std").os.windows.WINAPI) ?*i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucnv_openAllNames(
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UEnumeration;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucnv_countAliases(
    alias: ?*i8,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) u16;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucnv_getAlias(
    alias: ?*i8,
    n: u16,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucnv_getAliases(
    alias: ?*i8,
    aliases: ?*?*i8,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucnv_openStandardNames(
    convName: ?*i8,
    standard: ?*i8,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UEnumeration;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucnv_countStandards(
) callconv(@import("std").os.windows.WINAPI) u16;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucnv_getStandard(
    n: u16,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucnv_getStandardName(
    name: ?*i8,
    standard: ?*i8,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucnv_getCanonicalName(
    alias: ?*i8,
    standard: ?*i8,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucnv_getDefaultName(
) callconv(@import("std").os.windows.WINAPI) ?*i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucnv_setDefaultName(
    name: ?*i8,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucnv_fixFileSeparator(
    cnv: ?*UConverter,
    source: ?*u16,
    sourceLen: i32,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucnv_isAmbiguous(
    cnv: ?*UConverter,
) callconv(@import("std").os.windows.WINAPI) i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucnv_setFallback(
    cnv: ?*UConverter,
    usesFallback: i8,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucnv_usesFallback(
    cnv: ?*UConverter,
) callconv(@import("std").os.windows.WINAPI) i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucnv_detectUnicodeSignature(
    source: ?*i8,
    sourceLength: i32,
    signatureLength: ?*i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucnv_fromUCountPending(
    cnv: ?*UConverter,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucnv_toUCountPending(
    cnv: ?*UConverter,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucnv_isFixedWidth(
    cnv: ?*UConverter,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucnv_cbFromUWriteBytes(
    args: ?*UConverterFromUnicodeArgs,
    source: ?*i8,
    length: i32,
    offsetIndex: i32,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucnv_cbFromUWriteSub(
    args: ?*UConverterFromUnicodeArgs,
    offsetIndex: i32,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucnv_cbFromUWriteUChars(
    args: ?*UConverterFromUnicodeArgs,
    source: ?*?*u16,
    sourceLimit: ?*u16,
    offsetIndex: i32,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucnv_cbToUWriteUChars(
    args: ?*UConverterToUnicodeArgs,
    source: ?*u16,
    length: i32,
    offsetIndex: i32,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucnv_cbToUWriteSub(
    args: ?*UConverterToUnicodeArgs,
    offsetIndex: i32,
    err: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_init(
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_cleanup(
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_setMemoryFunctions(
    context: ?*opaque{},
    a: ?*UMemAllocFn,
    r: ?*UMemReallocFn,
    f: ?*UMemFreeFn,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_catopen(
    name: ?*i8,
    locale: ?*i8,
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UResourceBundle;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_catclose(
    catd: ?*UResourceBundle,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_catgets(
    catd: ?*UResourceBundle,
    set_num: i32,
    msg_num: i32,
    s: ?*u16,
    len: ?*i32,
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_hasBinaryProperty(
    c: i32,
    which: UProperty,
) callconv(@import("std").os.windows.WINAPI) i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_isUAlphabetic(
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_isULowercase(
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_isUUppercase(
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_isUWhiteSpace(
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_getIntPropertyValue(
    c: i32,
    which: UProperty,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_getIntPropertyMinValue(
    which: UProperty,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_getIntPropertyMaxValue(
    which: UProperty,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_getNumericValue(
    c: i32,
) callconv(@import("std").os.windows.WINAPI) f64;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_islower(
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_isupper(
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_istitle(
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_isdigit(
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_isalpha(
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_isalnum(
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_isxdigit(
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_ispunct(
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_isgraph(
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_isblank(
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_isdefined(
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_isspace(
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_isJavaSpaceChar(
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_isWhitespace(
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_iscntrl(
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_isISOControl(
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_isprint(
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_isbase(
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_charDirection(
    c: i32,
) callconv(@import("std").os.windows.WINAPI) UCharDirection;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_isMirrored(
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_charMirror(
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_getBidiPairedBracket(
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_charType(
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_enumCharTypes(
    enumRange: ?*UCharEnumTypeRange,
    context: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_getCombiningClass(
    c: i32,
) callconv(@import("std").os.windows.WINAPI) u8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_charDigitValue(
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ublock_getCode(
    c: i32,
) callconv(@import("std").os.windows.WINAPI) UBlockCode;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_charName(
    code: i32,
    nameChoice: UCharNameChoice,
    buffer: ?*i8,
    bufferLength: i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_charFromName(
    nameChoice: UCharNameChoice,
    name: ?*i8,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_enumCharNames(
    start: i32,
    limit: i32,
    @"fn": ?*UEnumCharNamesFn,
    context: ?*opaque{},
    nameChoice: UCharNameChoice,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_getPropertyName(
    property: UProperty,
    nameChoice: UPropertyNameChoice,
) callconv(@import("std").os.windows.WINAPI) ?*i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_getPropertyEnum(
    alias: ?*i8,
) callconv(@import("std").os.windows.WINAPI) UProperty;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_getPropertyValueName(
    property: UProperty,
    value: i32,
    nameChoice: UPropertyNameChoice,
) callconv(@import("std").os.windows.WINAPI) ?*i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_getPropertyValueEnum(
    property: UProperty,
    alias: ?*i8,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_isIDStart(
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_isIDPart(
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_isIDIgnorable(
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_isJavaIDStart(
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_isJavaIDPart(
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_tolower(
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_toupper(
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_totitle(
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_foldCase(
    c: i32,
    options: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_digit(
    ch: i32,
    radix: i8,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_forDigit(
    digit: i32,
    radix: i8,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_charAge(
    c: i32,
    versionArray: ?*u8,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_getUnicodeVersion(
    versionArray: ?*u8,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_getFC_NFKC_Closure(
    c: i32,
    dest: ?*u16,
    destCapacity: i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ubidi_open(
) callconv(@import("std").os.windows.WINAPI) ?*UBiDi;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ubidi_openSized(
    maxLength: i32,
    maxRunCount: i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UBiDi;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ubidi_close(
    pBiDi: ?*UBiDi,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ubidi_setInverse(
    pBiDi: ?*UBiDi,
    isInverse: i8,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ubidi_isInverse(
    pBiDi: ?*UBiDi,
) callconv(@import("std").os.windows.WINAPI) i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ubidi_orderParagraphsLTR(
    pBiDi: ?*UBiDi,
    orderParagraphsLTR: i8,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ubidi_isOrderParagraphsLTR(
    pBiDi: ?*UBiDi,
) callconv(@import("std").os.windows.WINAPI) i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ubidi_setReorderingMode(
    pBiDi: ?*UBiDi,
    reorderingMode: UBiDiReorderingMode,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ubidi_getReorderingMode(
    pBiDi: ?*UBiDi,
) callconv(@import("std").os.windows.WINAPI) UBiDiReorderingMode;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ubidi_setReorderingOptions(
    pBiDi: ?*UBiDi,
    reorderingOptions: u32,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ubidi_getReorderingOptions(
    pBiDi: ?*UBiDi,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ubidi_setContext(
    pBiDi: ?*UBiDi,
    prologue: ?*u16,
    proLength: i32,
    epilogue: ?*u16,
    epiLength: i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ubidi_setPara(
    pBiDi: ?*UBiDi,
    text: ?*u16,
    length: i32,
    paraLevel: u8,
    embeddingLevels: ?*u8,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ubidi_setLine(
    pParaBiDi: ?*UBiDi,
    start: i32,
    limit: i32,
    pLineBiDi: ?*UBiDi,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ubidi_getDirection(
    pBiDi: ?*UBiDi,
) callconv(@import("std").os.windows.WINAPI) UBiDiDirection;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ubidi_getBaseDirection(
    text: ?*u16,
    length: i32,
) callconv(@import("std").os.windows.WINAPI) UBiDiDirection;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ubidi_getText(
    pBiDi: ?*UBiDi,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ubidi_getLength(
    pBiDi: ?*UBiDi,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ubidi_getParaLevel(
    pBiDi: ?*UBiDi,
) callconv(@import("std").os.windows.WINAPI) u8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ubidi_countParagraphs(
    pBiDi: ?*UBiDi,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ubidi_getParagraph(
    pBiDi: ?*UBiDi,
    charIndex: i32,
    pParaStart: ?*i32,
    pParaLimit: ?*i32,
    pParaLevel: ?*u8,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ubidi_getParagraphByIndex(
    pBiDi: ?*UBiDi,
    paraIndex: i32,
    pParaStart: ?*i32,
    pParaLimit: ?*i32,
    pParaLevel: ?*u8,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ubidi_getLevelAt(
    pBiDi: ?*UBiDi,
    charIndex: i32,
) callconv(@import("std").os.windows.WINAPI) u8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ubidi_getLevels(
    pBiDi: ?*UBiDi,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ubidi_getLogicalRun(
    pBiDi: ?*UBiDi,
    logicalPosition: i32,
    pLogicalLimit: ?*i32,
    pLevel: ?*u8,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ubidi_countRuns(
    pBiDi: ?*UBiDi,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ubidi_getVisualRun(
    pBiDi: ?*UBiDi,
    runIndex: i32,
    pLogicalStart: ?*i32,
    pLength: ?*i32,
) callconv(@import("std").os.windows.WINAPI) UBiDiDirection;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ubidi_getVisualIndex(
    pBiDi: ?*UBiDi,
    logicalIndex: i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ubidi_getLogicalIndex(
    pBiDi: ?*UBiDi,
    visualIndex: i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ubidi_getLogicalMap(
    pBiDi: ?*UBiDi,
    indexMap: ?*i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ubidi_getVisualMap(
    pBiDi: ?*UBiDi,
    indexMap: ?*i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ubidi_reorderLogical(
    levels: ?*u8,
    length: i32,
    indexMap: ?*i32,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ubidi_reorderVisual(
    levels: ?*u8,
    length: i32,
    indexMap: ?*i32,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ubidi_invertMap(
    srcMap: ?*i32,
    destMap: ?*i32,
    length: i32,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ubidi_getProcessedLength(
    pBiDi: ?*UBiDi,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ubidi_getResultLength(
    pBiDi: ?*UBiDi,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ubidi_getCustomizedClass(
    pBiDi: ?*UBiDi,
    c: i32,
) callconv(@import("std").os.windows.WINAPI) UCharDirection;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ubidi_setClassCallback(
    pBiDi: ?*UBiDi,
    newFn: ?*UBiDiClassCallback,
    newContext: ?*opaque{},
    oldFn: ?*?*UBiDiClassCallback,
    oldContext: ?*?*opaque{},
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ubidi_getClassCallback(
    pBiDi: ?*UBiDi,
    @"fn": ?*?*UBiDiClassCallback,
    context: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ubidi_writeReordered(
    pBiDi: ?*UBiDi,
    dest: ?*u16,
    destSize: i32,
    options: u16,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ubidi_writeReverse(
    src: ?*u16,
    srcLength: i32,
    dest: ?*u16,
    destSize: i32,
    options: u16,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ubiditransform_transform(
    pBiDiTransform: ?*UBiDiTransform,
    src: ?*u16,
    srcLength: i32,
    dest: ?*u16,
    destSize: i32,
    inParaLevel: u8,
    inOrder: UBiDiOrder,
    outParaLevel: u8,
    outOrder: UBiDiOrder,
    doMirroring: UBiDiMirroring,
    shapingOptions: u32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ubiditransform_open(
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UBiDiTransform;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ubiditransform_close(
    pBidiTransform: ?*UBiDiTransform,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn utext_close(
    ut: ?*UText,
) callconv(@import("std").os.windows.WINAPI) ?*UText;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn utext_openUTF8(
    ut: ?*UText,
    s: ?*i8,
    length: i64,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UText;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn utext_openUChars(
    ut: ?*UText,
    s: ?*u16,
    length: i64,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UText;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn utext_clone(
    dest: ?*UText,
    src: ?*UText,
    deep: i8,
    readOnly: i8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UText;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn utext_equals(
    a: ?*UText,
    b: ?*UText,
) callconv(@import("std").os.windows.WINAPI) i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn utext_nativeLength(
    ut: ?*UText,
) callconv(@import("std").os.windows.WINAPI) i64;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn utext_isLengthExpensive(
    ut: ?*UText,
) callconv(@import("std").os.windows.WINAPI) i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn utext_char32At(
    ut: ?*UText,
    nativeIndex: i64,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn utext_current32(
    ut: ?*UText,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn utext_next32(
    ut: ?*UText,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn utext_previous32(
    ut: ?*UText,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn utext_next32From(
    ut: ?*UText,
    nativeIndex: i64,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn utext_previous32From(
    ut: ?*UText,
    nativeIndex: i64,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn utext_getNativeIndex(
    ut: ?*UText,
) callconv(@import("std").os.windows.WINAPI) i64;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn utext_setNativeIndex(
    ut: ?*UText,
    nativeIndex: i64,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn utext_moveIndex32(
    ut: ?*UText,
    delta: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn utext_getPreviousNativeIndex(
    ut: ?*UText,
) callconv(@import("std").os.windows.WINAPI) i64;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn utext_extract(
    ut: ?*UText,
    nativeStart: i64,
    nativeLimit: i64,
    dest: ?*u16,
    destCapacity: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn utext_isWritable(
    ut: ?*UText,
) callconv(@import("std").os.windows.WINAPI) i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn utext_hasMetaData(
    ut: ?*UText,
) callconv(@import("std").os.windows.WINAPI) i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn utext_replace(
    ut: ?*UText,
    nativeStart: i64,
    nativeLimit: i64,
    replacementText: ?*u16,
    replacementLength: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn utext_copy(
    ut: ?*UText,
    nativeStart: i64,
    nativeLimit: i64,
    destIndex: i64,
    move: i8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn utext_freeze(
    ut: ?*UText,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn utext_setup(
    ut: ?*UText,
    extraSpace: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UText;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uset_openEmpty(
) callconv(@import("std").os.windows.WINAPI) ?*USet;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uset_open(
    start: i32,
    end: i32,
) callconv(@import("std").os.windows.WINAPI) ?*USet;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uset_openPattern(
    pattern: ?*u16,
    patternLength: i32,
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*USet;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uset_openPatternOptions(
    pattern: ?*u16,
    patternLength: i32,
    options: u32,
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*USet;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uset_close(
    set: ?*USet,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uset_clone(
    set: ?*USet,
) callconv(@import("std").os.windows.WINAPI) ?*USet;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uset_isFrozen(
    set: ?*USet,
) callconv(@import("std").os.windows.WINAPI) i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uset_freeze(
    set: ?*USet,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uset_cloneAsThawed(
    set: ?*USet,
) callconv(@import("std").os.windows.WINAPI) ?*USet;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uset_set(
    set: ?*USet,
    start: i32,
    end: i32,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uset_applyPattern(
    set: ?*USet,
    pattern: ?*u16,
    patternLength: i32,
    options: u32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uset_applyIntPropertyValue(
    set: ?*USet,
    prop: UProperty,
    value: i32,
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uset_applyPropertyAlias(
    set: ?*USet,
    prop: ?*u16,
    propLength: i32,
    value: ?*u16,
    valueLength: i32,
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uset_resemblesPattern(
    pattern: ?*u16,
    patternLength: i32,
    pos: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uset_toPattern(
    set: ?*USet,
    result: ?*u16,
    resultCapacity: i32,
    escapeUnprintable: i8,
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uset_add(
    set: ?*USet,
    c: i32,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uset_addAll(
    set: ?*USet,
    additionalSet: ?*USet,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uset_addRange(
    set: ?*USet,
    start: i32,
    end: i32,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uset_addString(
    set: ?*USet,
    str: ?*u16,
    strLen: i32,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uset_addAllCodePoints(
    set: ?*USet,
    str: ?*u16,
    strLen: i32,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uset_remove(
    set: ?*USet,
    c: i32,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uset_removeRange(
    set: ?*USet,
    start: i32,
    end: i32,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uset_removeString(
    set: ?*USet,
    str: ?*u16,
    strLen: i32,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uset_removeAll(
    set: ?*USet,
    removeSet: ?*USet,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uset_retain(
    set: ?*USet,
    start: i32,
    end: i32,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uset_retainAll(
    set: ?*USet,
    retain: ?*USet,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uset_compact(
    set: ?*USet,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uset_complement(
    set: ?*USet,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uset_complementAll(
    set: ?*USet,
    complement: ?*USet,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uset_clear(
    set: ?*USet,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uset_closeOver(
    set: ?*USet,
    attributes: i32,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uset_removeAllStrings(
    set: ?*USet,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uset_isEmpty(
    set: ?*USet,
) callconv(@import("std").os.windows.WINAPI) i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uset_contains(
    set: ?*USet,
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uset_containsRange(
    set: ?*USet,
    start: i32,
    end: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uset_containsString(
    set: ?*USet,
    str: ?*u16,
    strLen: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uset_indexOf(
    set: ?*USet,
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uset_charAt(
    set: ?*USet,
    charIndex: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uset_size(
    set: ?*USet,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uset_getItemCount(
    set: ?*USet,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uset_getItem(
    set: ?*USet,
    itemIndex: i32,
    start: ?*i32,
    end: ?*i32,
    str: ?*u16,
    strCapacity: i32,
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uset_containsAll(
    set1: ?*USet,
    set2: ?*USet,
) callconv(@import("std").os.windows.WINAPI) i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uset_containsAllCodePoints(
    set: ?*USet,
    str: ?*u16,
    strLen: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uset_containsNone(
    set1: ?*USet,
    set2: ?*USet,
) callconv(@import("std").os.windows.WINAPI) i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uset_containsSome(
    set1: ?*USet,
    set2: ?*USet,
) callconv(@import("std").os.windows.WINAPI) i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uset_span(
    set: ?*USet,
    s: ?*u16,
    length: i32,
    spanCondition: USetSpanCondition,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uset_spanBack(
    set: ?*USet,
    s: ?*u16,
    length: i32,
    spanCondition: USetSpanCondition,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uset_spanUTF8(
    set: ?*USet,
    s: ?*i8,
    length: i32,
    spanCondition: USetSpanCondition,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uset_spanBackUTF8(
    set: ?*USet,
    s: ?*i8,
    length: i32,
    spanCondition: USetSpanCondition,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uset_equals(
    set1: ?*USet,
    set2: ?*USet,
) callconv(@import("std").os.windows.WINAPI) i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uset_serialize(
    set: ?*USet,
    dest: ?*u16,
    destCapacity: i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uset_getSerializedSet(
    fillSet: ?*USerializedSet,
    src: ?*u16,
    srcLength: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uset_setSerializedToOne(
    fillSet: ?*USerializedSet,
    c: i32,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uset_serializedContains(
    set: ?*USerializedSet,
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uset_getSerializedRangeCount(
    set: ?*USerializedSet,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uset_getSerializedRange(
    set: ?*USerializedSet,
    rangeIndex: i32,
    pStart: ?*i32,
    pEnd: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn unorm2_getNFCInstance(
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UNormalizer2;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn unorm2_getNFDInstance(
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UNormalizer2;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn unorm2_getNFKCInstance(
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UNormalizer2;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn unorm2_getNFKDInstance(
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UNormalizer2;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn unorm2_getNFKCCasefoldInstance(
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UNormalizer2;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn unorm2_getInstance(
    packageName: ?*i8,
    name: ?*i8,
    mode: UNormalization2Mode,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UNormalizer2;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn unorm2_openFiltered(
    norm2: ?*UNormalizer2,
    filterSet: ?*USet,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UNormalizer2;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn unorm2_close(
    norm2: ?*UNormalizer2,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn unorm2_normalize(
    norm2: ?*UNormalizer2,
    src: ?*u16,
    length: i32,
    dest: ?*u16,
    capacity: i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn unorm2_normalizeSecondAndAppend(
    norm2: ?*UNormalizer2,
    first: ?*u16,
    firstLength: i32,
    firstCapacity: i32,
    second: ?*u16,
    secondLength: i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn unorm2_append(
    norm2: ?*UNormalizer2,
    first: ?*u16,
    firstLength: i32,
    firstCapacity: i32,
    second: ?*u16,
    secondLength: i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn unorm2_getDecomposition(
    norm2: ?*UNormalizer2,
    c: i32,
    decomposition: ?*u16,
    capacity: i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn unorm2_getRawDecomposition(
    norm2: ?*UNormalizer2,
    c: i32,
    decomposition: ?*u16,
    capacity: i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn unorm2_composePair(
    norm2: ?*UNormalizer2,
    a: i32,
    b: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn unorm2_getCombiningClass(
    norm2: ?*UNormalizer2,
    c: i32,
) callconv(@import("std").os.windows.WINAPI) u8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn unorm2_isNormalized(
    norm2: ?*UNormalizer2,
    s: ?*u16,
    length: i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn unorm2_quickCheck(
    norm2: ?*UNormalizer2,
    s: ?*u16,
    length: i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) UNormalizationCheckResult;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn unorm2_spanQuickCheckYes(
    norm2: ?*UNormalizer2,
    s: ?*u16,
    length: i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn unorm2_hasBoundaryBefore(
    norm2: ?*UNormalizer2,
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn unorm2_hasBoundaryAfter(
    norm2: ?*UNormalizer2,
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn unorm2_isInert(
    norm2: ?*UNormalizer2,
    c: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn unorm_compare(
    s1: ?*u16,
    length1: i32,
    s2: ?*u16,
    length2: i32,
    options: u32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucnvsel_open(
    converterList: ?*?*i8,
    converterListSize: i32,
    excludedCodePoints: ?*USet,
    whichSet: UConverterUnicodeSet,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UConverterSelector;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucnvsel_close(
    sel: ?*UConverterSelector,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucnvsel_openFromSerialized(
    buffer: ?*opaque{},
    length: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UConverterSelector;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucnvsel_serialize(
    sel: ?*UConverterSelector,
    buffer: ?*opaque{},
    bufferCapacity: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucnvsel_selectForString(
    sel: ?*UConverterSelector,
    s: ?*u16,
    length: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UEnumeration;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucnvsel_selectForUTF8(
    sel: ?*UConverterSelector,
    s: ?*i8,
    length: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UEnumeration;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_charsToUChars(
    cs: ?*i8,
    us: ?*u16,
    length: i32,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_UCharsToChars(
    us: ?*u16,
    cs: ?*i8,
    length: i32,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_strlen(
    s: ?*u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_countChar32(
    s: ?*u16,
    length: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_strHasMoreChar32Than(
    s: ?*u16,
    length: i32,
    number: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_strcat(
    dst: ?*u16,
    src: ?*u16,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_strncat(
    dst: ?*u16,
    src: ?*u16,
    n: i32,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_strstr(
    s: ?*u16,
    substring: ?*u16,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_strFindFirst(
    s: ?*u16,
    length: i32,
    substring: ?*u16,
    subLength: i32,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_strchr(
    s: ?*u16,
    c: u16,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_strchr32(
    s: ?*u16,
    c: i32,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_strrstr(
    s: ?*u16,
    substring: ?*u16,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_strFindLast(
    s: ?*u16,
    length: i32,
    substring: ?*u16,
    subLength: i32,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_strrchr(
    s: ?*u16,
    c: u16,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_strrchr32(
    s: ?*u16,
    c: i32,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_strpbrk(
    string: ?*u16,
    matchSet: ?*u16,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_strcspn(
    string: ?*u16,
    matchSet: ?*u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_strspn(
    string: ?*u16,
    matchSet: ?*u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_strtok_r(
    src: ?*u16,
    delim: ?*u16,
    saveState: ?*?*u16,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_strcmp(
    s1: ?*u16,
    s2: ?*u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_strcmpCodePointOrder(
    s1: ?*u16,
    s2: ?*u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_strCompare(
    s1: ?*u16,
    length1: i32,
    s2: ?*u16,
    length2: i32,
    codePointOrder: i8,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_strCompareIter(
    iter1: ?*UCharIterator,
    iter2: ?*UCharIterator,
    codePointOrder: i8,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_strCaseCompare(
    s1: ?*u16,
    length1: i32,
    s2: ?*u16,
    length2: i32,
    options: u32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_strncmp(
    ucs1: ?*u16,
    ucs2: ?*u16,
    n: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_strncmpCodePointOrder(
    s1: ?*u16,
    s2: ?*u16,
    n: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_strcasecmp(
    s1: ?*u16,
    s2: ?*u16,
    options: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_strncasecmp(
    s1: ?*u16,
    s2: ?*u16,
    n: i32,
    options: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_memcasecmp(
    s1: ?*u16,
    s2: ?*u16,
    length: i32,
    options: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_strcpy(
    dst: ?*u16,
    src: ?*u16,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_strncpy(
    dst: ?*u16,
    src: ?*u16,
    n: i32,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_uastrcpy(
    dst: ?*u16,
    src: ?*i8,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_uastrncpy(
    dst: ?*u16,
    src: ?*i8,
    n: i32,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_austrcpy(
    dst: ?*i8,
    src: ?*u16,
) callconv(@import("std").os.windows.WINAPI) ?*i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_austrncpy(
    dst: ?*i8,
    src: ?*u16,
    n: i32,
) callconv(@import("std").os.windows.WINAPI) ?*i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_memcpy(
    dest: ?*u16,
    src: ?*u16,
    count: i32,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_memmove(
    dest: ?*u16,
    src: ?*u16,
    count: i32,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_memset(
    dest: ?*u16,
    c: u16,
    count: i32,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_memcmp(
    buf1: ?*u16,
    buf2: ?*u16,
    count: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_memcmpCodePointOrder(
    s1: ?*u16,
    s2: ?*u16,
    count: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_memchr(
    s: ?*u16,
    c: u16,
    count: i32,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_memchr32(
    s: ?*u16,
    c: i32,
    count: i32,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_memrchr(
    s: ?*u16,
    c: u16,
    count: i32,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_memrchr32(
    s: ?*u16,
    c: i32,
    count: i32,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_unescape(
    src: ?*i8,
    dest: ?*u16,
    destCapacity: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_unescapeAt(
    charAt: UNESCAPE_CHAR_AT,
    offset: ?*i32,
    length: i32,
    context: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_strToUpper(
    dest: ?*u16,
    destCapacity: i32,
    src: ?*u16,
    srcLength: i32,
    locale: ?*i8,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_strToLower(
    dest: ?*u16,
    destCapacity: i32,
    src: ?*u16,
    srcLength: i32,
    locale: ?*i8,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_strToTitle(
    dest: ?*u16,
    destCapacity: i32,
    src: ?*u16,
    srcLength: i32,
    titleIter: ?*UBreakIterator,
    locale: ?*i8,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_strFoldCase(
    dest: ?*u16,
    destCapacity: i32,
    src: ?*u16,
    srcLength: i32,
    options: u32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_strToWCS(
    dest: ?*u16,
    destCapacity: i32,
    pDestLength: ?*i32,
    src: ?*u16,
    srcLength: i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_strFromWCS(
    dest: ?*u16,
    destCapacity: i32,
    pDestLength: ?*i32,
    src: ?*u16,
    srcLength: i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_strToUTF8(
    dest: ?*i8,
    destCapacity: i32,
    pDestLength: ?*i32,
    src: ?*u16,
    srcLength: i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_strFromUTF8(
    dest: ?*u16,
    destCapacity: i32,
    pDestLength: ?*i32,
    src: ?*i8,
    srcLength: i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_strToUTF8WithSub(
    dest: ?*i8,
    destCapacity: i32,
    pDestLength: ?*i32,
    src: ?*u16,
    srcLength: i32,
    subchar: i32,
    pNumSubstitutions: ?*i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_strFromUTF8WithSub(
    dest: ?*u16,
    destCapacity: i32,
    pDestLength: ?*i32,
    src: ?*i8,
    srcLength: i32,
    subchar: i32,
    pNumSubstitutions: ?*i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_strFromUTF8Lenient(
    dest: ?*u16,
    destCapacity: i32,
    pDestLength: ?*i32,
    src: ?*i8,
    srcLength: i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_strToUTF32(
    dest: ?*i32,
    destCapacity: i32,
    pDestLength: ?*i32,
    src: ?*u16,
    srcLength: i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_strFromUTF32(
    dest: ?*u16,
    destCapacity: i32,
    pDestLength: ?*i32,
    src: ?*i32,
    srcLength: i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_strToUTF32WithSub(
    dest: ?*i32,
    destCapacity: i32,
    pDestLength: ?*i32,
    src: ?*u16,
    srcLength: i32,
    subchar: i32,
    pNumSubstitutions: ?*i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_strFromUTF32WithSub(
    dest: ?*u16,
    destCapacity: i32,
    pDestLength: ?*i32,
    src: ?*i32,
    srcLength: i32,
    subchar: i32,
    pNumSubstitutions: ?*i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_strToJavaModifiedUTF8(
    dest: ?*i8,
    destCapacity: i32,
    pDestLength: ?*i32,
    src: ?*u16,
    srcLength: i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_strFromJavaModifiedUTF8WithSub(
    dest: ?*u16,
    destCapacity: i32,
    pDestLength: ?*i32,
    src: ?*i8,
    srcLength: i32,
    subchar: i32,
    pNumSubstitutions: ?*i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucasemap_open(
    locale: ?*i8,
    options: u32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UCaseMap;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucasemap_close(
    csm: ?*UCaseMap,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucasemap_getLocale(
    csm: ?*UCaseMap,
) callconv(@import("std").os.windows.WINAPI) ?*i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucasemap_getOptions(
    csm: ?*UCaseMap,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucasemap_setLocale(
    csm: ?*UCaseMap,
    locale: ?*i8,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucasemap_setOptions(
    csm: ?*UCaseMap,
    options: u32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucasemap_getBreakIterator(
    csm: ?*UCaseMap,
) callconv(@import("std").os.windows.WINAPI) ?*UBreakIterator;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucasemap_setBreakIterator(
    csm: ?*UCaseMap,
    iterToAdopt: ?*UBreakIterator,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucasemap_toTitle(
    csm: ?*UCaseMap,
    dest: ?*u16,
    destCapacity: i32,
    src: ?*u16,
    srcLength: i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucasemap_utf8ToLower(
    csm: ?*UCaseMap,
    dest: ?*i8,
    destCapacity: i32,
    src: ?*i8,
    srcLength: i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucasemap_utf8ToUpper(
    csm: ?*UCaseMap,
    dest: ?*i8,
    destCapacity: i32,
    src: ?*i8,
    srcLength: i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucasemap_utf8ToTitle(
    csm: ?*UCaseMap,
    dest: ?*i8,
    destCapacity: i32,
    src: ?*i8,
    srcLength: i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucasemap_utf8FoldCase(
    csm: ?*UCaseMap,
    dest: ?*i8,
    destCapacity: i32,
    src: ?*i8,
    srcLength: i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn usprep_open(
    path: ?*i8,
    fileName: ?*i8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UStringPrepProfile;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn usprep_openByType(
    type: UStringPrepProfileType,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UStringPrepProfile;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn usprep_close(
    profile: ?*UStringPrepProfile,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn usprep_prepare(
    prep: ?*UStringPrepProfile,
    src: ?*u16,
    srcLength: i32,
    dest: ?*u16,
    destCapacity: i32,
    options: i32,
    parseError: ?*UParseError,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uidna_openUTS46(
    options: u32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UIDNA;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uidna_close(
    idna: ?*UIDNA,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uidna_labelToASCII(
    idna: ?*UIDNA,
    label: ?*u16,
    length: i32,
    dest: ?*u16,
    capacity: i32,
    pInfo: ?*UIDNAInfo,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uidna_labelToUnicode(
    idna: ?*UIDNA,
    label: ?*u16,
    length: i32,
    dest: ?*u16,
    capacity: i32,
    pInfo: ?*UIDNAInfo,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uidna_nameToASCII(
    idna: ?*UIDNA,
    name: ?*u16,
    length: i32,
    dest: ?*u16,
    capacity: i32,
    pInfo: ?*UIDNAInfo,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uidna_nameToUnicode(
    idna: ?*UIDNA,
    name: ?*u16,
    length: i32,
    dest: ?*u16,
    capacity: i32,
    pInfo: ?*UIDNAInfo,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uidna_labelToASCII_UTF8(
    idna: ?*UIDNA,
    label: ?*i8,
    length: i32,
    dest: ?*i8,
    capacity: i32,
    pInfo: ?*UIDNAInfo,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uidna_labelToUnicodeUTF8(
    idna: ?*UIDNA,
    label: ?*i8,
    length: i32,
    dest: ?*i8,
    capacity: i32,
    pInfo: ?*UIDNAInfo,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uidna_nameToASCII_UTF8(
    idna: ?*UIDNA,
    name: ?*i8,
    length: i32,
    dest: ?*i8,
    capacity: i32,
    pInfo: ?*UIDNAInfo,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uidna_nameToUnicodeUTF8(
    idna: ?*UIDNA,
    name: ?*i8,
    length: i32,
    dest: ?*i8,
    capacity: i32,
    pInfo: ?*UIDNAInfo,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ubrk_open(
    type: UBreakIteratorType,
    locale: ?*i8,
    text: ?*u16,
    textLength: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UBreakIterator;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ubrk_openRules(
    rules: ?*u16,
    rulesLength: i32,
    text: ?*u16,
    textLength: i32,
    parseErr: ?*UParseError,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UBreakIterator;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ubrk_openBinaryRules(
    binaryRules: ?*u8,
    rulesLength: i32,
    text: ?*u16,
    textLength: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UBreakIterator;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ubrk_safeClone(
    bi: ?*UBreakIterator,
    stackBuffer: ?*opaque{},
    pBufferSize: ?*i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UBreakIterator;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ubrk_close(
    bi: ?*UBreakIterator,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ubrk_setText(
    bi: ?*UBreakIterator,
    text: ?*u16,
    textLength: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ubrk_setUText(
    bi: ?*UBreakIterator,
    text: ?*UText,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ubrk_current(
    bi: ?*UBreakIterator,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ubrk_next(
    bi: ?*UBreakIterator,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ubrk_previous(
    bi: ?*UBreakIterator,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ubrk_first(
    bi: ?*UBreakIterator,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ubrk_last(
    bi: ?*UBreakIterator,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ubrk_preceding(
    bi: ?*UBreakIterator,
    offset: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ubrk_following(
    bi: ?*UBreakIterator,
    offset: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ubrk_getAvailable(
    index: i32,
) callconv(@import("std").os.windows.WINAPI) ?*i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ubrk_countAvailable(
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ubrk_isBoundary(
    bi: ?*UBreakIterator,
    offset: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ubrk_getRuleStatus(
    bi: ?*UBreakIterator,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ubrk_getRuleStatusVec(
    bi: ?*UBreakIterator,
    fillInVec: ?*i32,
    capacity: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ubrk_getLocaleByType(
    bi: ?*UBreakIterator,
    type: ULocDataLocaleType,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ubrk_refreshUText(
    bi: ?*UBreakIterator,
    text: ?*UText,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ubrk_getBinaryRules(
    bi: ?*UBreakIterator,
    binaryRules: ?*u8,
    rulesCapacity: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_getDataVersion(
    dataVersionFillin: ?*u8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucal_openTimeZoneIDEnumeration(
    zoneType: USystemTimeZoneType,
    region: ?*i8,
    rawOffset: ?*i32,
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UEnumeration;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucal_openTimeZones(
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UEnumeration;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucal_openCountryTimeZones(
    country: ?*i8,
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UEnumeration;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucal_getDefaultTimeZone(
    result: ?*u16,
    resultCapacity: i32,
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucal_setDefaultTimeZone(
    zoneID: ?*u16,
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucal_getDSTSavings(
    zoneID: ?*u16,
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucal_getNow(
) callconv(@import("std").os.windows.WINAPI) f64;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucal_open(
    zoneID: ?*u16,
    len: i32,
    locale: ?*i8,
    type: UCalendarType,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*?*opaque{};

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucal_close(
    cal: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucal_clone(
    cal: ?*?*opaque{},
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*?*opaque{};

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucal_setTimeZone(
    cal: ?*?*opaque{},
    zoneID: ?*u16,
    len: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucal_getTimeZoneID(
    cal: ?*?*opaque{},
    result: ?*u16,
    resultLength: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucal_getTimeZoneDisplayName(
    cal: ?*?*opaque{},
    type: UCalendarDisplayNameType,
    locale: ?*i8,
    result: ?*u16,
    resultLength: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucal_inDaylightTime(
    cal: ?*?*opaque{},
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucal_setGregorianChange(
    cal: ?*?*opaque{},
    date: f64,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucal_getGregorianChange(
    cal: ?*?*opaque{},
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) f64;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucal_getAttribute(
    cal: ?*?*opaque{},
    attr: UCalendarAttribute,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucal_setAttribute(
    cal: ?*?*opaque{},
    attr: UCalendarAttribute,
    newValue: i32,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucal_getAvailable(
    localeIndex: i32,
) callconv(@import("std").os.windows.WINAPI) ?*i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucal_countAvailable(
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucal_getMillis(
    cal: ?*?*opaque{},
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) f64;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucal_setMillis(
    cal: ?*?*opaque{},
    dateTime: f64,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucal_setDate(
    cal: ?*?*opaque{},
    year: i32,
    month: i32,
    date: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucal_setDateTime(
    cal: ?*?*opaque{},
    year: i32,
    month: i32,
    date: i32,
    hour: i32,
    minute: i32,
    second: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucal_equivalentTo(
    cal1: ?*?*opaque{},
    cal2: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucal_add(
    cal: ?*?*opaque{},
    field: UCalendarDateFields,
    amount: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucal_roll(
    cal: ?*?*opaque{},
    field: UCalendarDateFields,
    amount: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucal_get(
    cal: ?*?*opaque{},
    field: UCalendarDateFields,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucal_set(
    cal: ?*?*opaque{},
    field: UCalendarDateFields,
    value: i32,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucal_isSet(
    cal: ?*?*opaque{},
    field: UCalendarDateFields,
) callconv(@import("std").os.windows.WINAPI) i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucal_clearField(
    cal: ?*?*opaque{},
    field: UCalendarDateFields,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucal_clear(
    calendar: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucal_getLimit(
    cal: ?*?*opaque{},
    field: UCalendarDateFields,
    type: UCalendarLimitType,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucal_getLocaleByType(
    cal: ?*?*opaque{},
    type: ULocDataLocaleType,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucal_getTZDataVersion(
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucal_getCanonicalTimeZoneID(
    id: ?*u16,
    len: i32,
    result: ?*u16,
    resultCapacity: i32,
    isSystemID: ?*i8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucal_getType(
    cal: ?*?*opaque{},
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucal_getKeywordValuesForLocale(
    key: ?*i8,
    locale: ?*i8,
    commonlyUsed: i8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UEnumeration;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucal_getDayOfWeekType(
    cal: ?*?*opaque{},
    dayOfWeek: UCalendarDaysOfWeek,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) UCalendarWeekdayType;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucal_getWeekendTransition(
    cal: ?*?*opaque{},
    dayOfWeek: UCalendarDaysOfWeek,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucal_isWeekend(
    cal: ?*?*opaque{},
    date: f64,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucal_getFieldDifference(
    cal: ?*?*opaque{},
    target: f64,
    field: UCalendarDateFields,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucal_getTimeZoneTransitionDate(
    cal: ?*?*opaque{},
    type: UTimeZoneTransitionType,
    transition: ?*f64,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucal_getWindowsTimeZoneID(
    id: ?*u16,
    len: i32,
    winid: ?*u16,
    winidCapacity: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucal_getTimeZoneIDForWindowsID(
    winid: ?*u16,
    len: i32,
    region: ?*i8,
    id: ?*u16,
    idCapacity: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucol_open(
    loc: ?*i8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UCollator;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucol_openRules(
    rules: ?*u16,
    rulesLength: i32,
    normalizationMode: UColAttributeValue,
    strength: UColAttributeValue,
    parseError: ?*UParseError,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UCollator;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucol_getContractionsAndExpansions(
    coll: ?*UCollator,
    contractions: ?*USet,
    expansions: ?*USet,
    addPrefixes: i8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucol_close(
    coll: ?*UCollator,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucol_strcoll(
    coll: ?*UCollator,
    source: ?*u16,
    sourceLength: i32,
    target: ?*u16,
    targetLength: i32,
) callconv(@import("std").os.windows.WINAPI) UCollationResult;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucol_strcollUTF8(
    coll: ?*UCollator,
    source: ?*i8,
    sourceLength: i32,
    target: ?*i8,
    targetLength: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) UCollationResult;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucol_greater(
    coll: ?*UCollator,
    source: ?*u16,
    sourceLength: i32,
    target: ?*u16,
    targetLength: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucol_greaterOrEqual(
    coll: ?*UCollator,
    source: ?*u16,
    sourceLength: i32,
    target: ?*u16,
    targetLength: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucol_equal(
    coll: ?*UCollator,
    source: ?*u16,
    sourceLength: i32,
    target: ?*u16,
    targetLength: i32,
) callconv(@import("std").os.windows.WINAPI) i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucol_strcollIter(
    coll: ?*UCollator,
    sIter: ?*UCharIterator,
    tIter: ?*UCharIterator,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) UCollationResult;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucol_getStrength(
    coll: ?*UCollator,
) callconv(@import("std").os.windows.WINAPI) UColAttributeValue;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucol_setStrength(
    coll: ?*UCollator,
    strength: UColAttributeValue,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucol_getReorderCodes(
    coll: ?*UCollator,
    dest: ?*i32,
    destCapacity: i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucol_setReorderCodes(
    coll: ?*UCollator,
    reorderCodes: ?*i32,
    reorderCodesLength: i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucol_getEquivalentReorderCodes(
    reorderCode: i32,
    dest: ?*i32,
    destCapacity: i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucol_getDisplayName(
    objLoc: ?*i8,
    dispLoc: ?*i8,
    result: ?*u16,
    resultLength: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucol_getAvailable(
    localeIndex: i32,
) callconv(@import("std").os.windows.WINAPI) ?*i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucol_countAvailable(
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucol_openAvailableLocales(
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UEnumeration;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucol_getKeywords(
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UEnumeration;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucol_getKeywordValues(
    keyword: ?*i8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UEnumeration;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucol_getKeywordValuesForLocale(
    key: ?*i8,
    locale: ?*i8,
    commonlyUsed: i8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UEnumeration;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucol_getFunctionalEquivalent(
    result: ?*i8,
    resultCapacity: i32,
    keyword: ?*i8,
    locale: ?*i8,
    isAvailable: ?*i8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucol_getRules(
    coll: ?*UCollator,
    length: ?*i32,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucol_getSortKey(
    coll: ?*UCollator,
    source: ?*u16,
    sourceLength: i32,
    result: ?*u8,
    resultLength: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucol_nextSortKeyPart(
    coll: ?*UCollator,
    iter: ?*UCharIterator,
    state: ?*u32,
    dest: ?*u8,
    count: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucol_getBound(
    source: ?*u8,
    sourceLength: i32,
    boundType: UColBoundMode,
    noOfLevels: u32,
    result: ?*u8,
    resultLength: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucol_getVersion(
    coll: ?*UCollator,
    info: ?*u8,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucol_getUCAVersion(
    coll: ?*UCollator,
    info: ?*u8,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucol_mergeSortkeys(
    src1: ?*u8,
    src1Length: i32,
    src2: ?*u8,
    src2Length: i32,
    dest: ?*u8,
    destCapacity: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucol_setAttribute(
    coll: ?*UCollator,
    attr: UColAttribute,
    value: UColAttributeValue,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucol_getAttribute(
    coll: ?*UCollator,
    attr: UColAttribute,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) UColAttributeValue;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucol_setMaxVariable(
    coll: ?*UCollator,
    group: UColReorderCode,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucol_getMaxVariable(
    coll: ?*UCollator,
) callconv(@import("std").os.windows.WINAPI) UColReorderCode;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucol_getVariableTop(
    coll: ?*UCollator,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucol_safeClone(
    coll: ?*UCollator,
    stackBuffer: ?*opaque{},
    pBufferSize: ?*i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UCollator;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucol_getRulesEx(
    coll: ?*UCollator,
    delta: UColRuleOption,
    buffer: ?*u16,
    bufferLen: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucol_getLocaleByType(
    coll: ?*UCollator,
    type: ULocDataLocaleType,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucol_getTailoredSet(
    coll: ?*UCollator,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*USet;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucol_cloneBinary(
    coll: ?*UCollator,
    buffer: ?*u8,
    capacity: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucol_openBinary(
    bin: ?*u8,
    length: i32,
    base: ?*UCollator,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UCollator;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucol_openElements(
    coll: ?*UCollator,
    text: ?*u16,
    textLength: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UCollationElements;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucol_keyHashCode(
    key: ?*u8,
    length: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucol_closeElements(
    elems: ?*UCollationElements,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucol_reset(
    elems: ?*UCollationElements,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucol_next(
    elems: ?*UCollationElements,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucol_previous(
    elems: ?*UCollationElements,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucol_getMaxExpansion(
    elems: ?*UCollationElements,
    order: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucol_setText(
    elems: ?*UCollationElements,
    text: ?*u16,
    textLength: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucol_getOffset(
    elems: ?*UCollationElements,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucol_setOffset(
    elems: ?*UCollationElements,
    offset: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucol_primaryOrder(
    order: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucol_secondaryOrder(
    order: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucol_tertiaryOrder(
    order: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucsdet_open(
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UCharsetDetector;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucsdet_close(
    ucsd: ?*UCharsetDetector,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucsdet_setText(
    ucsd: ?*UCharsetDetector,
    textIn: ?*i8,
    len: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucsdet_setDeclaredEncoding(
    ucsd: ?*UCharsetDetector,
    encoding: ?*i8,
    length: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucsdet_detect(
    ucsd: ?*UCharsetDetector,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UCharsetMatch;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucsdet_detectAll(
    ucsd: ?*UCharsetDetector,
    matchesFound: ?*i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*?*UCharsetMatch;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucsdet_getName(
    ucsm: ?*UCharsetMatch,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucsdet_getConfidence(
    ucsm: ?*UCharsetMatch,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucsdet_getLanguage(
    ucsm: ?*UCharsetMatch,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucsdet_getUChars(
    ucsm: ?*UCharsetMatch,
    buf: ?*u16,
    cap: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucsdet_getAllDetectableCharsets(
    ucsd: ?*UCharsetDetector,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UEnumeration;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucsdet_isInputFilterEnabled(
    ucsd: ?*UCharsetDetector,
) callconv(@import("std").os.windows.WINAPI) i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ucsdet_enableInputFilter(
    ucsd: ?*UCharsetDetector,
    filter: i8,
) callconv(@import("std").os.windows.WINAPI) i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn udatpg_open(
    locale: ?*i8,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*?*opaque{};

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn udatpg_openEmpty(
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*?*opaque{};

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn udatpg_close(
    dtpg: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn udatpg_clone(
    dtpg: ?*?*opaque{},
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*?*opaque{};

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn udatpg_getBestPattern(
    dtpg: ?*?*opaque{},
    skeleton: ?*u16,
    length: i32,
    bestPattern: ?*u16,
    capacity: i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn udatpg_getBestPatternWithOptions(
    dtpg: ?*?*opaque{},
    skeleton: ?*u16,
    length: i32,
    options: UDateTimePatternMatchOptions,
    bestPattern: ?*u16,
    capacity: i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn udatpg_getSkeleton(
    unusedDtpg: ?*?*opaque{},
    pattern: ?*u16,
    length: i32,
    skeleton: ?*u16,
    capacity: i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn udatpg_getBaseSkeleton(
    unusedDtpg: ?*?*opaque{},
    pattern: ?*u16,
    length: i32,
    baseSkeleton: ?*u16,
    capacity: i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn udatpg_addPattern(
    dtpg: ?*?*opaque{},
    pattern: ?*u16,
    patternLength: i32,
    override: i8,
    conflictingPattern: ?*u16,
    capacity: i32,
    pLength: ?*i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) UDateTimePatternConflict;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn udatpg_setAppendItemFormat(
    dtpg: ?*?*opaque{},
    field: UDateTimePatternField,
    value: ?*u16,
    length: i32,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn udatpg_getAppendItemFormat(
    dtpg: ?*?*opaque{},
    field: UDateTimePatternField,
    pLength: ?*i32,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn udatpg_setAppendItemName(
    dtpg: ?*?*opaque{},
    field: UDateTimePatternField,
    value: ?*u16,
    length: i32,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn udatpg_getAppendItemName(
    dtpg: ?*?*opaque{},
    field: UDateTimePatternField,
    pLength: ?*i32,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn udatpg_getFieldDisplayName(
    dtpg: ?*?*opaque{},
    field: UDateTimePatternField,
    width: UDateTimePGDisplayWidth,
    fieldName: ?*u16,
    capacity: i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn udatpg_setDateTimeFormat(
    dtpg: ?*?*opaque{},
    dtFormat: ?*u16,
    length: i32,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn udatpg_getDateTimeFormat(
    dtpg: ?*?*opaque{},
    pLength: ?*i32,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn udatpg_setDecimal(
    dtpg: ?*?*opaque{},
    decimal: ?*u16,
    length: i32,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn udatpg_getDecimal(
    dtpg: ?*?*opaque{},
    pLength: ?*i32,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn udatpg_replaceFieldTypes(
    dtpg: ?*?*opaque{},
    pattern: ?*u16,
    patternLength: i32,
    skeleton: ?*u16,
    skeletonLength: i32,
    dest: ?*u16,
    destCapacity: i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn udatpg_replaceFieldTypesWithOptions(
    dtpg: ?*?*opaque{},
    pattern: ?*u16,
    patternLength: i32,
    skeleton: ?*u16,
    skeletonLength: i32,
    options: UDateTimePatternMatchOptions,
    dest: ?*u16,
    destCapacity: i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn udatpg_openSkeletons(
    dtpg: ?*?*opaque{},
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UEnumeration;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn udatpg_openBaseSkeletons(
    dtpg: ?*?*opaque{},
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UEnumeration;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn udatpg_getPatternForSkeleton(
    dtpg: ?*?*opaque{},
    skeleton: ?*u16,
    skeletonLength: i32,
    pLength: ?*i32,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ufieldpositer_open(
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UFieldPositionIterator;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ufieldpositer_close(
    fpositer: ?*UFieldPositionIterator,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ufieldpositer_next(
    fpositer: ?*UFieldPositionIterator,
    beginIndex: ?*i32,
    endIndex: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ufmt_open(
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*?*opaque{};

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ufmt_close(
    fmt: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ufmt_getType(
    fmt: ?*?*opaque{},
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) UFormattableType;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ufmt_isNumeric(
    fmt: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ufmt_getDate(
    fmt: ?*?*opaque{},
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) f64;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ufmt_getDouble(
    fmt: ?*?*opaque{},
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) f64;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ufmt_getLong(
    fmt: ?*?*opaque{},
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ufmt_getInt64(
    fmt: ?*?*opaque{},
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i64;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ufmt_getObject(
    fmt: ?*?*opaque{},
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ufmt_getUChars(
    fmt: ?*?*opaque{},
    len: ?*i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ufmt_getArrayLength(
    fmt: ?*?*opaque{},
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ufmt_getArrayItemByIndex(
    fmt: ?*?*opaque{},
    n: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*?*opaque{};

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ufmt_getDecNumChars(
    fmt: ?*?*opaque{},
    len: ?*i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn udtitvfmt_open(
    locale: ?*i8,
    skeleton: ?*u16,
    skeletonLength: i32,
    tzID: ?*u16,
    tzIDLength: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UDateIntervalFormat;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn udtitvfmt_close(
    formatter: ?*UDateIntervalFormat,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn udtitvfmt_format(
    formatter: ?*UDateIntervalFormat,
    fromDate: f64,
    toDate: f64,
    result: ?*u16,
    resultCapacity: i32,
    position: ?*UFieldPosition,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ugender_getInstance(
    locale: ?*i8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UGenderInfo;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ugender_getListGender(
    genderInfo: ?*UGenderInfo,
    genders: ?*UGender,
    size: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) UGender;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ulistfmt_open(
    locale: ?*i8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UListFormatter;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ulistfmt_close(
    listfmt: ?*UListFormatter,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ulistfmt_format(
    listfmt: ?*UListFormatter,
    strings: ?*?*u16,
    stringLengths: ?*i32,
    stringCount: i32,
    result: ?*u16,
    resultCapacity: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ulocdata_open(
    localeID: ?*i8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*ULocaleData;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ulocdata_close(
    uld: ?*ULocaleData,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ulocdata_setNoSubstitute(
    uld: ?*ULocaleData,
    setting: i8,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ulocdata_getNoSubstitute(
    uld: ?*ULocaleData,
) callconv(@import("std").os.windows.WINAPI) i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ulocdata_getExemplarSet(
    uld: ?*ULocaleData,
    fillIn: ?*USet,
    options: u32,
    extype: ULocaleDataExemplarSetType,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*USet;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ulocdata_getDelimiter(
    uld: ?*ULocaleData,
    type: ULocaleDataDelimiterType,
    result: ?*u16,
    resultLength: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ulocdata_getMeasurementSystem(
    localeID: ?*i8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) UMeasurementSystem;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ulocdata_getPaperSize(
    localeID: ?*i8,
    height: ?*i32,
    width: ?*i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ulocdata_getCLDRVersion(
    versionArray: ?*u8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ulocdata_getLocaleDisplayPattern(
    uld: ?*ULocaleData,
    pattern: ?*u16,
    patternCapacity: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ulocdata_getLocaleSeparator(
    uld: ?*ULocaleData,
    separator: ?*u16,
    separatorCapacity: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_formatMessage(
    locale: ?*i8,
    pattern: ?*u16,
    patternLength: i32,
    result: ?*u16,
    resultLength: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_vformatMessage(
    locale: ?*i8,
    pattern: ?*u16,
    patternLength: i32,
    result: ?*u16,
    resultLength: i32,
    ap: ?*i8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_parseMessage(
    locale: ?*i8,
    pattern: ?*u16,
    patternLength: i32,
    source: ?*u16,
    sourceLength: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_vparseMessage(
    locale: ?*i8,
    pattern: ?*u16,
    patternLength: i32,
    source: ?*u16,
    sourceLength: i32,
    ap: ?*i8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_formatMessageWithError(
    locale: ?*i8,
    pattern: ?*u16,
    patternLength: i32,
    result: ?*u16,
    resultLength: i32,
    parseError: ?*UParseError,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_vformatMessageWithError(
    locale: ?*i8,
    pattern: ?*u16,
    patternLength: i32,
    result: ?*u16,
    resultLength: i32,
    parseError: ?*UParseError,
    ap: ?*i8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_parseMessageWithError(
    locale: ?*i8,
    pattern: ?*u16,
    patternLength: i32,
    source: ?*u16,
    sourceLength: i32,
    parseError: ?*UParseError,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn u_vparseMessageWithError(
    locale: ?*i8,
    pattern: ?*u16,
    patternLength: i32,
    source: ?*u16,
    sourceLength: i32,
    ap: ?*i8,
    parseError: ?*UParseError,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn umsg_open(
    pattern: ?*u16,
    patternLength: i32,
    locale: ?*i8,
    parseError: ?*UParseError,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*?*opaque{};

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn umsg_close(
    format: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn umsg_clone(
    fmt: ?*?*opaque{},
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn umsg_setLocale(
    fmt: ?*?*opaque{},
    locale: ?*i8,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn umsg_getLocale(
    fmt: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) ?*i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn umsg_applyPattern(
    fmt: ?*?*opaque{},
    pattern: ?*u16,
    patternLength: i32,
    parseError: ?*UParseError,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn umsg_toPattern(
    fmt: ?*?*opaque{},
    result: ?*u16,
    resultLength: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn umsg_format(
    fmt: ?*?*opaque{},
    result: ?*u16,
    resultLength: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn umsg_vformat(
    fmt: ?*?*opaque{},
    result: ?*u16,
    resultLength: i32,
    ap: ?*i8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn umsg_parse(
    fmt: ?*?*opaque{},
    source: ?*u16,
    sourceLength: i32,
    count: ?*i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn umsg_vparse(
    fmt: ?*?*opaque{},
    source: ?*u16,
    sourceLength: i32,
    count: ?*i32,
    ap: ?*i8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn umsg_autoQuoteApostrophe(
    pattern: ?*u16,
    patternLength: i32,
    dest: ?*u16,
    destCapacity: i32,
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn unum_open(
    style: UNumberFormatStyle,
    pattern: ?*u16,
    patternLength: i32,
    locale: ?*i8,
    parseErr: ?*UParseError,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*?*opaque{};

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn unum_close(
    fmt: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn unum_clone(
    fmt: ?*?*opaque{},
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*?*opaque{};

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn unum_format(
    fmt: ?*?*opaque{},
    number: i32,
    result: ?*u16,
    resultLength: i32,
    pos: ?*UFieldPosition,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn unum_formatInt64(
    fmt: ?*?*opaque{},
    number: i64,
    result: ?*u16,
    resultLength: i32,
    pos: ?*UFieldPosition,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn unum_formatDouble(
    fmt: ?*?*opaque{},
    number: f64,
    result: ?*u16,
    resultLength: i32,
    pos: ?*UFieldPosition,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn unum_formatDoubleForFields(
    format: ?*?*opaque{},
    number: f64,
    result: ?*u16,
    resultLength: i32,
    fpositer: ?*UFieldPositionIterator,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn unum_formatDecimal(
    fmt: ?*?*opaque{},
    number: ?*i8,
    length: i32,
    result: ?*u16,
    resultLength: i32,
    pos: ?*UFieldPosition,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn unum_formatDoubleCurrency(
    fmt: ?*?*opaque{},
    number: f64,
    currency: ?*u16,
    result: ?*u16,
    resultLength: i32,
    pos: ?*UFieldPosition,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn unum_formatUFormattable(
    fmt: ?*?*opaque{},
    number: ?*?*opaque{},
    result: ?*u16,
    resultLength: i32,
    pos: ?*UFieldPosition,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn unum_parse(
    fmt: ?*?*opaque{},
    text: ?*u16,
    textLength: i32,
    parsePos: ?*i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn unum_parseInt64(
    fmt: ?*?*opaque{},
    text: ?*u16,
    textLength: i32,
    parsePos: ?*i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i64;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn unum_parseDouble(
    fmt: ?*?*opaque{},
    text: ?*u16,
    textLength: i32,
    parsePos: ?*i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) f64;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn unum_parseDecimal(
    fmt: ?*?*opaque{},
    text: ?*u16,
    textLength: i32,
    parsePos: ?*i32,
    outBuf: ?*i8,
    outBufLength: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn unum_parseDoubleCurrency(
    fmt: ?*?*opaque{},
    text: ?*u16,
    textLength: i32,
    parsePos: ?*i32,
    currency: ?*u16,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) f64;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn unum_parseToUFormattable(
    fmt: ?*?*opaque{},
    result: ?*?*opaque{},
    text: ?*u16,
    textLength: i32,
    parsePos: ?*i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*?*opaque{};

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn unum_applyPattern(
    format: ?*?*opaque{},
    localized: i8,
    pattern: ?*u16,
    patternLength: i32,
    parseError: ?*UParseError,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn unum_getAvailable(
    localeIndex: i32,
) callconv(@import("std").os.windows.WINAPI) ?*i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn unum_countAvailable(
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn unum_getAttribute(
    fmt: ?*?*opaque{},
    attr: UNumberFormatAttribute,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn unum_setAttribute(
    fmt: ?*?*opaque{},
    attr: UNumberFormatAttribute,
    newValue: i32,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn unum_getDoubleAttribute(
    fmt: ?*?*opaque{},
    attr: UNumberFormatAttribute,
) callconv(@import("std").os.windows.WINAPI) f64;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn unum_setDoubleAttribute(
    fmt: ?*?*opaque{},
    attr: UNumberFormatAttribute,
    newValue: f64,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn unum_getTextAttribute(
    fmt: ?*?*opaque{},
    tag: UNumberFormatTextAttribute,
    result: ?*u16,
    resultLength: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn unum_setTextAttribute(
    fmt: ?*?*opaque{},
    tag: UNumberFormatTextAttribute,
    newValue: ?*u16,
    newValueLength: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn unum_toPattern(
    fmt: ?*?*opaque{},
    isPatternLocalized: i8,
    result: ?*u16,
    resultLength: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn unum_getSymbol(
    fmt: ?*?*opaque{},
    symbol: UNumberFormatSymbol,
    buffer: ?*u16,
    size: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn unum_setSymbol(
    fmt: ?*?*opaque{},
    symbol: UNumberFormatSymbol,
    value: ?*u16,
    length: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn unum_getLocaleByType(
    fmt: ?*?*opaque{},
    type: ULocDataLocaleType,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn unum_setContext(
    fmt: ?*?*opaque{},
    value: UDisplayContext,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn unum_getContext(
    fmt: ?*?*opaque{},
    type: UDisplayContextType,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) UDisplayContext;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn udat_toCalendarDateField(
    field: UDateFormatField,
) callconv(@import("std").os.windows.WINAPI) UCalendarDateFields;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn udat_open(
    timeStyle: UDateFormatStyle,
    dateStyle: UDateFormatStyle,
    locale: ?*i8,
    tzID: ?*u16,
    tzIDLength: i32,
    pattern: ?*u16,
    patternLength: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*?*opaque{};

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn udat_close(
    format: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn udat_getBooleanAttribute(
    fmt: ?*?*opaque{},
    attr: UDateFormatBooleanAttribute,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn udat_setBooleanAttribute(
    fmt: ?*?*opaque{},
    attr: UDateFormatBooleanAttribute,
    newValue: i8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn udat_clone(
    fmt: ?*?*opaque{},
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*?*opaque{};

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn udat_format(
    format: ?*?*opaque{},
    dateToFormat: f64,
    result: ?*u16,
    resultLength: i32,
    position: ?*UFieldPosition,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn udat_formatCalendar(
    format: ?*?*opaque{},
    calendar: ?*?*opaque{},
    result: ?*u16,
    capacity: i32,
    position: ?*UFieldPosition,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn udat_formatForFields(
    format: ?*?*opaque{},
    dateToFormat: f64,
    result: ?*u16,
    resultLength: i32,
    fpositer: ?*UFieldPositionIterator,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn udat_formatCalendarForFields(
    format: ?*?*opaque{},
    calendar: ?*?*opaque{},
    result: ?*u16,
    capacity: i32,
    fpositer: ?*UFieldPositionIterator,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn udat_parse(
    format: ?*?*opaque{},
    text: ?*u16,
    textLength: i32,
    parsePos: ?*i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) f64;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn udat_parseCalendar(
    format: ?*?*opaque{},
    calendar: ?*?*opaque{},
    text: ?*u16,
    textLength: i32,
    parsePos: ?*i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn udat_isLenient(
    fmt: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn udat_setLenient(
    fmt: ?*?*opaque{},
    isLenient: i8,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn udat_getCalendar(
    fmt: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) ?*?*opaque{};

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn udat_setCalendar(
    fmt: ?*?*opaque{},
    calendarToSet: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn udat_getNumberFormat(
    fmt: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) ?*?*opaque{};

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn udat_getNumberFormatForField(
    fmt: ?*?*opaque{},
    field: u16,
) callconv(@import("std").os.windows.WINAPI) ?*?*opaque{};

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn udat_adoptNumberFormatForFields(
    fmt: ?*?*opaque{},
    fields: ?*u16,
    numberFormatToSet: ?*?*opaque{},
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn udat_setNumberFormat(
    fmt: ?*?*opaque{},
    numberFormatToSet: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn udat_adoptNumberFormat(
    fmt: ?*?*opaque{},
    numberFormatToAdopt: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn udat_getAvailable(
    localeIndex: i32,
) callconv(@import("std").os.windows.WINAPI) ?*i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn udat_countAvailable(
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn udat_get2DigitYearStart(
    fmt: ?*?*opaque{},
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) f64;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn udat_set2DigitYearStart(
    fmt: ?*?*opaque{},
    d: f64,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn udat_toPattern(
    fmt: ?*?*opaque{},
    localized: i8,
    result: ?*u16,
    resultLength: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn udat_applyPattern(
    format: ?*?*opaque{},
    localized: i8,
    pattern: ?*u16,
    patternLength: i32,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn udat_getSymbols(
    fmt: ?*?*opaque{},
    type: UDateFormatSymbolType,
    symbolIndex: i32,
    result: ?*u16,
    resultLength: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn udat_countSymbols(
    fmt: ?*?*opaque{},
    type: UDateFormatSymbolType,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn udat_setSymbols(
    format: ?*?*opaque{},
    type: UDateFormatSymbolType,
    symbolIndex: i32,
    value: ?*u16,
    valueLength: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn udat_getLocaleByType(
    fmt: ?*?*opaque{},
    type: ULocDataLocaleType,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn udat_setContext(
    fmt: ?*?*opaque{},
    value: UDisplayContext,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn udat_getContext(
    fmt: ?*?*opaque{},
    type: UDisplayContextType,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) UDisplayContext;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn unumf_openForSkeletonAndLocale(
    skeleton: ?*u16,
    skeletonLen: i32,
    locale: ?*i8,
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UNumberFormatter;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn unumf_openResult(
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UFormattedNumber;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn unumf_formatInt(
    uformatter: ?*UNumberFormatter,
    value: i64,
    uresult: ?*UFormattedNumber,
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn unumf_formatDouble(
    uformatter: ?*UNumberFormatter,
    value: f64,
    uresult: ?*UFormattedNumber,
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn unumf_formatDecimal(
    uformatter: ?*UNumberFormatter,
    value: ?*i8,
    valueLen: i32,
    uresult: ?*UFormattedNumber,
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn unumf_resultToString(
    uresult: ?*UFormattedNumber,
    buffer: ?*u16,
    bufferCapacity: i32,
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn unumf_resultNextFieldPosition(
    uresult: ?*UFormattedNumber,
    ufpos: ?*UFieldPosition,
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn unumf_resultGetAllFieldPositions(
    uresult: ?*UFormattedNumber,
    ufpositer: ?*UFieldPositionIterator,
    ec: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn unumf_close(
    uformatter: ?*UNumberFormatter,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn unumf_closeResult(
    uresult: ?*UFormattedNumber,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn unumsys_open(
    locale: ?*i8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UNumberingSystem;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn unumsys_openByName(
    name: ?*i8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UNumberingSystem;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn unumsys_close(
    unumsys: ?*UNumberingSystem,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn unumsys_openAvailableNames(
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UEnumeration;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn unumsys_getName(
    unumsys: ?*UNumberingSystem,
) callconv(@import("std").os.windows.WINAPI) ?*i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn unumsys_isAlgorithmic(
    unumsys: ?*UNumberingSystem,
) callconv(@import("std").os.windows.WINAPI) i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn unumsys_getRadix(
    unumsys: ?*UNumberingSystem,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn unumsys_getDescription(
    unumsys: ?*UNumberingSystem,
    result: ?*u16,
    resultLength: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uplrules_open(
    locale: ?*i8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UPluralRules;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uplrules_openForType(
    locale: ?*i8,
    type: UPluralType,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UPluralRules;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uplrules_close(
    uplrules: ?*UPluralRules,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uplrules_select(
    uplrules: ?*UPluralRules,
    number: f64,
    keyword: ?*u16,
    capacity: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uplrules_getKeywords(
    uplrules: ?*UPluralRules,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UEnumeration;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uregex_open(
    pattern: ?*u16,
    patternLength: i32,
    flags: u32,
    pe: ?*UParseError,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*URegularExpression;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uregex_openUText(
    pattern: ?*UText,
    flags: u32,
    pe: ?*UParseError,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*URegularExpression;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uregex_openC(
    pattern: ?*i8,
    flags: u32,
    pe: ?*UParseError,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*URegularExpression;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uregex_close(
    regexp: ?*URegularExpression,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uregex_clone(
    regexp: ?*URegularExpression,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*URegularExpression;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uregex_pattern(
    regexp: ?*URegularExpression,
    patLength: ?*i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uregex_patternUText(
    regexp: ?*URegularExpression,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UText;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uregex_flags(
    regexp: ?*URegularExpression,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uregex_setText(
    regexp: ?*URegularExpression,
    text: ?*u16,
    textLength: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uregex_setUText(
    regexp: ?*URegularExpression,
    text: ?*UText,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uregex_getText(
    regexp: ?*URegularExpression,
    textLength: ?*i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uregex_getUText(
    regexp: ?*URegularExpression,
    dest: ?*UText,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UText;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uregex_refreshUText(
    regexp: ?*URegularExpression,
    text: ?*UText,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uregex_matches(
    regexp: ?*URegularExpression,
    startIndex: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uregex_matches64(
    regexp: ?*URegularExpression,
    startIndex: i64,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uregex_lookingAt(
    regexp: ?*URegularExpression,
    startIndex: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uregex_lookingAt64(
    regexp: ?*URegularExpression,
    startIndex: i64,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uregex_find(
    regexp: ?*URegularExpression,
    startIndex: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uregex_find64(
    regexp: ?*URegularExpression,
    startIndex: i64,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uregex_findNext(
    regexp: ?*URegularExpression,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uregex_groupCount(
    regexp: ?*URegularExpression,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uregex_groupNumberFromName(
    regexp: ?*URegularExpression,
    groupName: ?*u16,
    nameLength: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uregex_groupNumberFromCName(
    regexp: ?*URegularExpression,
    groupName: ?*i8,
    nameLength: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uregex_group(
    regexp: ?*URegularExpression,
    groupNum: i32,
    dest: ?*u16,
    destCapacity: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uregex_groupUText(
    regexp: ?*URegularExpression,
    groupNum: i32,
    dest: ?*UText,
    groupLength: ?*i64,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UText;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uregex_start(
    regexp: ?*URegularExpression,
    groupNum: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uregex_start64(
    regexp: ?*URegularExpression,
    groupNum: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i64;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uregex_end(
    regexp: ?*URegularExpression,
    groupNum: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uregex_end64(
    regexp: ?*URegularExpression,
    groupNum: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i64;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uregex_reset(
    regexp: ?*URegularExpression,
    index: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uregex_reset64(
    regexp: ?*URegularExpression,
    index: i64,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uregex_setRegion(
    regexp: ?*URegularExpression,
    regionStart: i32,
    regionLimit: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uregex_setRegion64(
    regexp: ?*URegularExpression,
    regionStart: i64,
    regionLimit: i64,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uregex_setRegionAndStart(
    regexp: ?*URegularExpression,
    regionStart: i64,
    regionLimit: i64,
    startIndex: i64,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uregex_regionStart(
    regexp: ?*URegularExpression,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uregex_regionStart64(
    regexp: ?*URegularExpression,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i64;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uregex_regionEnd(
    regexp: ?*URegularExpression,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uregex_regionEnd64(
    regexp: ?*URegularExpression,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i64;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uregex_hasTransparentBounds(
    regexp: ?*URegularExpression,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uregex_useTransparentBounds(
    regexp: ?*URegularExpression,
    b: i8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uregex_hasAnchoringBounds(
    regexp: ?*URegularExpression,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uregex_useAnchoringBounds(
    regexp: ?*URegularExpression,
    b: i8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uregex_hitEnd(
    regexp: ?*URegularExpression,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uregex_requireEnd(
    regexp: ?*URegularExpression,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uregex_replaceAll(
    regexp: ?*URegularExpression,
    replacementText: ?*u16,
    replacementLength: i32,
    destBuf: ?*u16,
    destCapacity: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uregex_replaceAllUText(
    regexp: ?*URegularExpression,
    replacement: ?*UText,
    dest: ?*UText,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UText;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uregex_replaceFirst(
    regexp: ?*URegularExpression,
    replacementText: ?*u16,
    replacementLength: i32,
    destBuf: ?*u16,
    destCapacity: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uregex_replaceFirstUText(
    regexp: ?*URegularExpression,
    replacement: ?*UText,
    dest: ?*UText,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UText;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uregex_appendReplacement(
    regexp: ?*URegularExpression,
    replacementText: ?*u16,
    replacementLength: i32,
    destBuf: ?*?*u16,
    destCapacity: ?*i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uregex_appendReplacementUText(
    regexp: ?*URegularExpression,
    replacementText: ?*UText,
    dest: ?*UText,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uregex_appendTail(
    regexp: ?*URegularExpression,
    destBuf: ?*?*u16,
    destCapacity: ?*i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uregex_appendTailUText(
    regexp: ?*URegularExpression,
    dest: ?*UText,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UText;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uregex_split(
    regexp: ?*URegularExpression,
    destBuf: ?*u16,
    destCapacity: i32,
    requiredCapacity: ?*i32,
    destFields: ?*?*u16,
    destFieldsCapacity: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uregex_splitUText(
    regexp: ?*URegularExpression,
    destFields: ?*?*UText,
    destFieldsCapacity: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uregex_setTimeLimit(
    regexp: ?*URegularExpression,
    limit: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uregex_getTimeLimit(
    regexp: ?*URegularExpression,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uregex_setStackLimit(
    regexp: ?*URegularExpression,
    limit: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uregex_getStackLimit(
    regexp: ?*URegularExpression,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uregex_setMatchCallback(
    regexp: ?*URegularExpression,
    callback: ?*URegexMatchCallback,
    context: ?*opaque{},
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uregex_getMatchCallback(
    regexp: ?*URegularExpression,
    callback: ?*?*URegexMatchCallback,
    context: ?*?*opaque{},
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uregex_setFindProgressCallback(
    regexp: ?*URegularExpression,
    callback: ?*URegexFindProgressCallback,
    context: ?*opaque{},
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uregex_getFindProgressCallback(
    regexp: ?*URegularExpression,
    callback: ?*?*URegexFindProgressCallback,
    context: ?*?*opaque{},
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uregion_getRegionFromCode(
    regionCode: ?*i8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*URegion;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uregion_getRegionFromNumericCode(
    code: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*URegion;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uregion_getAvailable(
    type: URegionType,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UEnumeration;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uregion_areEqual(
    uregion: ?*URegion,
    otherRegion: ?*URegion,
) callconv(@import("std").os.windows.WINAPI) i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uregion_getContainingRegion(
    uregion: ?*URegion,
) callconv(@import("std").os.windows.WINAPI) ?*URegion;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uregion_getContainingRegionOfType(
    uregion: ?*URegion,
    type: URegionType,
) callconv(@import("std").os.windows.WINAPI) ?*URegion;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uregion_getContainedRegions(
    uregion: ?*URegion,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UEnumeration;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uregion_getContainedRegionsOfType(
    uregion: ?*URegion,
    type: URegionType,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UEnumeration;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uregion_contains(
    uregion: ?*URegion,
    otherRegion: ?*URegion,
) callconv(@import("std").os.windows.WINAPI) i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uregion_getPreferredValues(
    uregion: ?*URegion,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UEnumeration;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uregion_getRegionCode(
    uregion: ?*URegion,
) callconv(@import("std").os.windows.WINAPI) ?*i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uregion_getNumericCode(
    uregion: ?*URegion,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uregion_getType(
    uregion: ?*URegion,
) callconv(@import("std").os.windows.WINAPI) URegionType;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ureldatefmt_open(
    locale: ?*i8,
    nfToAdopt: ?*?*opaque{},
    width: UDateRelativeDateTimeFormatterStyle,
    capitalizationContext: UDisplayContext,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*URelativeDateTimeFormatter;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ureldatefmt_close(
    reldatefmt: ?*URelativeDateTimeFormatter,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ureldatefmt_formatNumeric(
    reldatefmt: ?*URelativeDateTimeFormatter,
    offset: f64,
    unit: URelativeDateTimeUnit,
    result: ?*u16,
    resultCapacity: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ureldatefmt_format(
    reldatefmt: ?*URelativeDateTimeFormatter,
    offset: f64,
    unit: URelativeDateTimeUnit,
    result: ?*u16,
    resultCapacity: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn ureldatefmt_combineDateAndTime(
    reldatefmt: ?*URelativeDateTimeFormatter,
    relativeDateString: ?*u16,
    relativeDateStringLen: i32,
    timeString: ?*u16,
    timeStringLen: i32,
    result: ?*u16,
    resultCapacity: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn usearch_open(
    pattern: ?*u16,
    patternlength: i32,
    text: ?*u16,
    textlength: i32,
    locale: ?*i8,
    breakiter: ?*UBreakIterator,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UStringSearch;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn usearch_openFromCollator(
    pattern: ?*u16,
    patternlength: i32,
    text: ?*u16,
    textlength: i32,
    collator: ?*UCollator,
    breakiter: ?*UBreakIterator,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UStringSearch;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn usearch_close(
    searchiter: ?*UStringSearch,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn usearch_setOffset(
    strsrch: ?*UStringSearch,
    position: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn usearch_getOffset(
    strsrch: ?*UStringSearch,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn usearch_setAttribute(
    strsrch: ?*UStringSearch,
    attribute: USearchAttribute,
    value: USearchAttributeValue,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn usearch_getAttribute(
    strsrch: ?*UStringSearch,
    attribute: USearchAttribute,
) callconv(@import("std").os.windows.WINAPI) USearchAttributeValue;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn usearch_getMatchedStart(
    strsrch: ?*UStringSearch,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn usearch_getMatchedLength(
    strsrch: ?*UStringSearch,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn usearch_getMatchedText(
    strsrch: ?*UStringSearch,
    result: ?*u16,
    resultCapacity: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn usearch_setBreakIterator(
    strsrch: ?*UStringSearch,
    breakiter: ?*UBreakIterator,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn usearch_getBreakIterator(
    strsrch: ?*UStringSearch,
) callconv(@import("std").os.windows.WINAPI) ?*UBreakIterator;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn usearch_setText(
    strsrch: ?*UStringSearch,
    text: ?*u16,
    textlength: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn usearch_getText(
    strsrch: ?*UStringSearch,
    length: ?*i32,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn usearch_getCollator(
    strsrch: ?*UStringSearch,
) callconv(@import("std").os.windows.WINAPI) ?*UCollator;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn usearch_setCollator(
    strsrch: ?*UStringSearch,
    collator: ?*UCollator,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn usearch_setPattern(
    strsrch: ?*UStringSearch,
    pattern: ?*u16,
    patternlength: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn usearch_getPattern(
    strsrch: ?*UStringSearch,
    length: ?*i32,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn usearch_first(
    strsrch: ?*UStringSearch,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn usearch_following(
    strsrch: ?*UStringSearch,
    position: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn usearch_last(
    strsrch: ?*UStringSearch,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn usearch_preceding(
    strsrch: ?*UStringSearch,
    position: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn usearch_next(
    strsrch: ?*UStringSearch,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn usearch_previous(
    strsrch: ?*UStringSearch,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn usearch_reset(
    strsrch: ?*UStringSearch,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uspoof_open(
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*USpoofChecker;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uspoof_openFromSerialized(
    data: ?*opaque{},
    length: i32,
    pActualLength: ?*i32,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*USpoofChecker;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uspoof_openFromSource(
    confusables: ?*i8,
    confusablesLen: i32,
    confusablesWholeScript: ?*i8,
    confusablesWholeScriptLen: i32,
    errType: ?*i32,
    pe: ?*UParseError,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*USpoofChecker;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uspoof_close(
    sc: ?*USpoofChecker,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uspoof_clone(
    sc: ?*USpoofChecker,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*USpoofChecker;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uspoof_setChecks(
    sc: ?*USpoofChecker,
    checks: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uspoof_getChecks(
    sc: ?*USpoofChecker,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uspoof_setRestrictionLevel(
    sc: ?*USpoofChecker,
    restrictionLevel: URestrictionLevel,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uspoof_getRestrictionLevel(
    sc: ?*USpoofChecker,
) callconv(@import("std").os.windows.WINAPI) URestrictionLevel;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uspoof_setAllowedLocales(
    sc: ?*USpoofChecker,
    localesList: ?*i8,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uspoof_getAllowedLocales(
    sc: ?*USpoofChecker,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*i8;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uspoof_setAllowedChars(
    sc: ?*USpoofChecker,
    chars: ?*USet,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uspoof_getAllowedChars(
    sc: ?*USpoofChecker,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*USet;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uspoof_check(
    sc: ?*USpoofChecker,
    id: ?*u16,
    length: i32,
    position: ?*i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uspoof_checkUTF8(
    sc: ?*USpoofChecker,
    id: ?*i8,
    length: i32,
    position: ?*i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uspoof_check2(
    sc: ?*USpoofChecker,
    id: ?*u16,
    length: i32,
    checkResult: ?*USpoofCheckResult,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uspoof_check2UTF8(
    sc: ?*USpoofChecker,
    id: ?*i8,
    length: i32,
    checkResult: ?*USpoofCheckResult,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uspoof_openCheckResult(
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*USpoofCheckResult;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uspoof_closeCheckResult(
    checkResult: ?*USpoofCheckResult,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uspoof_getCheckResultChecks(
    checkResult: ?*USpoofCheckResult,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uspoof_getCheckResultRestrictionLevel(
    checkResult: ?*USpoofCheckResult,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) URestrictionLevel;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uspoof_getCheckResultNumerics(
    checkResult: ?*USpoofCheckResult,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*USet;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uspoof_areConfusable(
    sc: ?*USpoofChecker,
    id1: ?*u16,
    length1: i32,
    id2: ?*u16,
    length2: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uspoof_areConfusableUTF8(
    sc: ?*USpoofChecker,
    id1: ?*i8,
    length1: i32,
    id2: ?*i8,
    length2: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uspoof_getSkeleton(
    sc: ?*USpoofChecker,
    type: u32,
    id: ?*u16,
    length: i32,
    dest: ?*u16,
    destCapacity: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uspoof_getSkeletonUTF8(
    sc: ?*USpoofChecker,
    type: u32,
    id: ?*i8,
    length: i32,
    dest: ?*i8,
    destCapacity: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uspoof_getInclusionSet(
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*USet;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uspoof_getRecommendedSet(
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*USet;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn uspoof_serialize(
    sc: ?*USpoofChecker,
    data: ?*opaque{},
    capacity: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn utmscale_getTimeScaleValue(
    timeScale: UDateTimeScale,
    value: UTimeScaleValue,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i64;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn utmscale_fromInt64(
    otherTime: i64,
    timeScale: UDateTimeScale,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i64;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn utmscale_toInt64(
    universalTime: i64,
    timeScale: UDateTimeScale,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i64;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn utrans_openU(
    id: ?*u16,
    idLength: i32,
    dir: UTransDirection,
    rules: ?*u16,
    rulesLength: i32,
    parseError: ?*UParseError,
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*?*opaque{};

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn utrans_openInverse(
    trans: ?*?*opaque{},
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*?*opaque{};

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn utrans_clone(
    trans: ?*?*opaque{},
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*?*opaque{};

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn utrans_close(
    trans: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn utrans_getUnicodeID(
    trans: ?*?*opaque{},
    resultLength: ?*i32,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn utrans_register(
    adoptedTrans: ?*?*opaque{},
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn utrans_unregisterID(
    id: ?*u16,
    idLength: i32,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn utrans_setFilter(
    trans: ?*?*opaque{},
    filterPattern: ?*u16,
    filterPatternLen: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn utrans_countAvailableIDs(
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn utrans_openIDs(
    pErrorCode: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*UEnumeration;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn utrans_trans(
    trans: ?*?*opaque{},
    rep: ?*?*opaque{},
    repFunc: ?*UReplaceableCallbacks,
    start: i32,
    limit: ?*i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn utrans_transIncremental(
    trans: ?*?*opaque{},
    rep: ?*?*opaque{},
    repFunc: ?*UReplaceableCallbacks,
    pos: ?*UTransPosition,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn utrans_transUChars(
    trans: ?*?*opaque{},
    text: ?*u16,
    textLength: ?*i32,
    textCapacity: i32,
    start: i32,
    limit: ?*i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn utrans_transIncrementalUChars(
    trans: ?*?*opaque{},
    text: ?*u16,
    textLength: ?*i32,
    textCapacity: i32,
    pos: ?*UTransPosition,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn utrans_toRules(
    trans: ?*?*opaque{},
    escapeUnprintable: i8,
    result: ?*u16,
    resultLength: i32,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "icu" fn utrans_getSourceSet(
    trans: ?*?*opaque{},
    ignoreFilter: i8,
    fillIn: ?*USet,
    status: ?*UErrorCode,
) callconv(@import("std").os.windows.WINAPI) ?*USet;

// set_last_errror=False (can and should we use this?)
pub extern "ADVAPI32" fn IsTextUnicode(
    lpv: ?*opaque{},
    iSize: i32,
    lpiResult: ?*i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

//
// Unicode Symbol Aliases
//
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {
        pub const CPINFOEX = CPINFOEXA;
        pub const NUMBERFMT = NUMBERFMTA;
        pub const CURRENCYFMT = CURRENCYFMTA;
        pub const LOCALE_ENUMPROC = LOCALE_ENUMPROCA;
        pub const LANGUAGEGROUP_ENUMPROC = LANGUAGEGROUP_ENUMPROCA;
        pub const LANGGROUPLOCALE_ENUMPROC = LANGGROUPLOCALE_ENUMPROCA;
        pub const UILANGUAGE_ENUMPROC = UILANGUAGE_ENUMPROCA;
        pub const CODEPAGE_ENUMPROC = CODEPAGE_ENUMPROCA;
        pub const DATEFMT_ENUMPROC = DATEFMT_ENUMPROCA;
        pub const DATEFMT_ENUMPROCEX = DATEFMT_ENUMPROCEXA;
        pub const TIMEFMT_ENUMPROC = TIMEFMT_ENUMPROCA;
        pub const CALINFO_ENUMPROC = CALINFO_ENUMPROCA;
        pub const CALINFO_ENUMPROCEX = CALINFO_ENUMPROCEXA;
        pub const REGISTERWORD = REGISTERWORDA;
        pub const STYLEBUF = STYLEBUFA;
        pub const IMEMENUITEMINFO = IMEMENUITEMINFOA;
        pub const REGISTERWORDENUMPROC = REGISTERWORDENUMPROCA;
        pub const GetDateFormat = GetDateFormatA;
        pub const GetTimeFormat = GetTimeFormatA;
        pub const CompareString = CompareStringA;
        pub const FoldString = FoldStringA;
        pub const GetStringTypeEx = GetStringTypeExA;
        pub const GetStringType = GetStringTypeA;
        pub const GetCPInfoEx = GetCPInfoExA;
        pub const LCMapString = LCMapStringA;
        pub const GetLocaleInfo = GetLocaleInfoA;
        pub const SetLocaleInfo = SetLocaleInfoA;
        pub const GetCalendarInfo = GetCalendarInfoA;
        pub const SetCalendarInfo = SetCalendarInfoA;
        pub const GetNumberFormat = GetNumberFormatA;
        pub const GetCurrencyFormat = GetCurrencyFormatA;
        pub const EnumCalendarInfo = EnumCalendarInfoA;
        pub const EnumCalendarInfoEx = EnumCalendarInfoExA;
        pub const EnumTimeFormats = EnumTimeFormatsA;
        pub const EnumDateFormats = EnumDateFormatsA;
        pub const EnumDateFormatsEx = EnumDateFormatsExA;
        pub const GetGeoInfo = GetGeoInfoA;
        pub const EnumSystemLocales = EnumSystemLocalesA;
        pub const EnumSystemLanguageGroups = EnumSystemLanguageGroupsA;
        pub const EnumLanguageGroupLocales = EnumLanguageGroupLocalesA;
        pub const EnumUILanguages = EnumUILanguagesA;
        pub const EnumSystemCodePages = EnumSystemCodePagesA;
        pub const ImmInstallIME = ImmInstallIMEA;
        pub const ImmGetDescription = ImmGetDescriptionA;
        pub const ImmGetIMEFileName = ImmGetIMEFileNameA;
        pub const ImmGetCompositionString = ImmGetCompositionStringA;
        pub const ImmSetCompositionString = ImmSetCompositionStringA;
        pub const ImmGetCandidateListCount = ImmGetCandidateListCountA;
        pub const ImmGetCandidateList = ImmGetCandidateListA;
        pub const ImmGetGuideLine = ImmGetGuideLineA;
        pub const ImmGetCompositionFont = ImmGetCompositionFontA;
        pub const ImmSetCompositionFont = ImmSetCompositionFontA;
        pub const ImmConfigureIME = ImmConfigureIMEA;
        pub const ImmEscape = ImmEscapeA;
        pub const ImmGetConversionList = ImmGetConversionListA;
        pub const ImmIsUIMessage = ImmIsUIMessageA;
        pub const ImmRegisterWord = ImmRegisterWordA;
        pub const ImmUnregisterWord = ImmUnregisterWordA;
        pub const ImmGetRegisterWordStyle = ImmGetRegisterWordStyleA;
        pub const ImmEnumRegisterWord = ImmEnumRegisterWordA;
        pub const ImmGetImeMenuItems = ImmGetImeMenuItemsA;
        pub const ImmRequestMessage = ImmRequestMessageA;
    },
    .wide => struct {
        pub const CPINFOEX = CPINFOEXW;
        pub const NUMBERFMT = NUMBERFMTW;
        pub const CURRENCYFMT = CURRENCYFMTW;
        pub const LOCALE_ENUMPROC = LOCALE_ENUMPROCW;
        pub const LANGUAGEGROUP_ENUMPROC = LANGUAGEGROUP_ENUMPROCW;
        pub const LANGGROUPLOCALE_ENUMPROC = LANGGROUPLOCALE_ENUMPROCW;
        pub const UILANGUAGE_ENUMPROC = UILANGUAGE_ENUMPROCW;
        pub const CODEPAGE_ENUMPROC = CODEPAGE_ENUMPROCW;
        pub const DATEFMT_ENUMPROC = DATEFMT_ENUMPROCW;
        pub const DATEFMT_ENUMPROCEX = DATEFMT_ENUMPROCEXW;
        pub const TIMEFMT_ENUMPROC = TIMEFMT_ENUMPROCW;
        pub const CALINFO_ENUMPROC = CALINFO_ENUMPROCW;
        pub const CALINFO_ENUMPROCEX = CALINFO_ENUMPROCEXW;
        pub const REGISTERWORD = REGISTERWORDW;
        pub const STYLEBUF = STYLEBUFW;
        pub const IMEMENUITEMINFO = IMEMENUITEMINFOW;
        pub const REGISTERWORDENUMPROC = REGISTERWORDENUMPROCW;
        pub const GetDateFormat = GetDateFormatW;
        pub const GetTimeFormat = GetTimeFormatW;
        pub const CompareString = CompareStringW;
        pub const FoldString = FoldStringW;
        pub const GetStringTypeEx = GetStringTypeExW;
        pub const GetStringType = GetStringTypeW;
        pub const GetCPInfoEx = GetCPInfoExW;
        pub const LCMapString = LCMapStringW;
        pub const GetLocaleInfo = GetLocaleInfoW;
        pub const SetLocaleInfo = SetLocaleInfoW;
        pub const GetCalendarInfo = GetCalendarInfoW;
        pub const SetCalendarInfo = SetCalendarInfoW;
        pub const GetNumberFormat = GetNumberFormatW;
        pub const GetCurrencyFormat = GetCurrencyFormatW;
        pub const EnumCalendarInfo = EnumCalendarInfoW;
        pub const EnumCalendarInfoEx = EnumCalendarInfoExW;
        pub const EnumTimeFormats = EnumTimeFormatsW;
        pub const EnumDateFormats = EnumDateFormatsW;
        pub const EnumDateFormatsEx = EnumDateFormatsExW;
        pub const GetGeoInfo = GetGeoInfoW;
        pub const EnumSystemLocales = EnumSystemLocalesW;
        pub const EnumSystemLanguageGroups = EnumSystemLanguageGroupsW;
        pub const EnumLanguageGroupLocales = EnumLanguageGroupLocalesW;
        pub const EnumUILanguages = EnumUILanguagesW;
        pub const EnumSystemCodePages = EnumSystemCodePagesW;
        pub const ImmInstallIME = ImmInstallIMEW;
        pub const ImmGetDescription = ImmGetDescriptionW;
        pub const ImmGetIMEFileName = ImmGetIMEFileNameW;
        pub const ImmGetCompositionString = ImmGetCompositionStringW;
        pub const ImmSetCompositionString = ImmSetCompositionStringW;
        pub const ImmGetCandidateListCount = ImmGetCandidateListCountW;
        pub const ImmGetCandidateList = ImmGetCandidateListW;
        pub const ImmGetGuideLine = ImmGetGuideLineW;
        pub const ImmGetCompositionFont = ImmGetCompositionFontW;
        pub const ImmSetCompositionFont = ImmSetCompositionFontW;
        pub const ImmConfigureIME = ImmConfigureIMEW;
        pub const ImmEscape = ImmEscapeW;
        pub const ImmGetConversionList = ImmGetConversionListW;
        pub const ImmIsUIMessage = ImmIsUIMessageW;
        pub const ImmRegisterWord = ImmRegisterWordW;
        pub const ImmUnregisterWord = ImmUnregisterWordW;
        pub const ImmGetRegisterWordStyle = ImmGetRegisterWordStyleW;
        pub const ImmEnumRegisterWord = ImmEnumRegisterWordW;
        pub const ImmGetImeMenuItems = ImmGetImeMenuItemsW;
        pub const ImmRequestMessage = ImmRequestMessageW;
    },
    else => if (@import("builtin").is_test) struct {
        pub const CPINFOEX = *opaque{};
        pub const NUMBERFMT = *opaque{};
        pub const CURRENCYFMT = *opaque{};
        pub const LOCALE_ENUMPROC = *opaque{};
        pub const LANGUAGEGROUP_ENUMPROC = *opaque{};
        pub const LANGGROUPLOCALE_ENUMPROC = *opaque{};
        pub const UILANGUAGE_ENUMPROC = *opaque{};
        pub const CODEPAGE_ENUMPROC = *opaque{};
        pub const DATEFMT_ENUMPROC = *opaque{};
        pub const DATEFMT_ENUMPROCEX = *opaque{};
        pub const TIMEFMT_ENUMPROC = *opaque{};
        pub const CALINFO_ENUMPROC = *opaque{};
        pub const CALINFO_ENUMPROCEX = *opaque{};
        pub const REGISTERWORD = *opaque{};
        pub const STYLEBUF = *opaque{};
        pub const IMEMENUITEMINFO = *opaque{};
        pub const REGISTERWORDENUMPROC = *opaque{};
        pub const GetDateFormat = *opaque{};
        pub const GetTimeFormat = *opaque{};
        pub const CompareString = *opaque{};
        pub const FoldString = *opaque{};
        pub const GetStringTypeEx = *opaque{};
        pub const GetStringType = *opaque{};
        pub const GetCPInfoEx = *opaque{};
        pub const LCMapString = *opaque{};
        pub const GetLocaleInfo = *opaque{};
        pub const SetLocaleInfo = *opaque{};
        pub const GetCalendarInfo = *opaque{};
        pub const SetCalendarInfo = *opaque{};
        pub const GetNumberFormat = *opaque{};
        pub const GetCurrencyFormat = *opaque{};
        pub const EnumCalendarInfo = *opaque{};
        pub const EnumCalendarInfoEx = *opaque{};
        pub const EnumTimeFormats = *opaque{};
        pub const EnumDateFormats = *opaque{};
        pub const EnumDateFormatsEx = *opaque{};
        pub const GetGeoInfo = *opaque{};
        pub const EnumSystemLocales = *opaque{};
        pub const EnumSystemLanguageGroups = *opaque{};
        pub const EnumLanguageGroupLocales = *opaque{};
        pub const EnumUILanguages = *opaque{};
        pub const EnumSystemCodePages = *opaque{};
        pub const ImmInstallIME = *opaque{};
        pub const ImmGetDescription = *opaque{};
        pub const ImmGetIMEFileName = *opaque{};
        pub const ImmGetCompositionString = *opaque{};
        pub const ImmSetCompositionString = *opaque{};
        pub const ImmGetCandidateListCount = *opaque{};
        pub const ImmGetCandidateList = *opaque{};
        pub const ImmGetGuideLine = *opaque{};
        pub const ImmGetCompositionFont = *opaque{};
        pub const ImmSetCompositionFont = *opaque{};
        pub const ImmConfigureIME = *opaque{};
        pub const ImmEscape = *opaque{};
        pub const ImmGetConversionList = *opaque{};
        pub const ImmIsUIMessage = *opaque{};
        pub const ImmRegisterWord = *opaque{};
        pub const ImmUnregisterWord = *opaque{};
        pub const ImmGetRegisterWordStyle = *opaque{};
        pub const ImmEnumRegisterWord = *opaque{};
        pub const ImmGetImeMenuItems = *opaque{};
        pub const ImmRequestMessage = *opaque{};
    } else struct {
        pub const CPINFOEX = @compileError("'CPINFOEX' requires that UNICODE be set to true or false in the root module");
        pub const NUMBERFMT = @compileError("'NUMBERFMT' requires that UNICODE be set to true or false in the root module");
        pub const CURRENCYFMT = @compileError("'CURRENCYFMT' requires that UNICODE be set to true or false in the root module");
        pub const LOCALE_ENUMPROC = @compileError("'LOCALE_ENUMPROC' requires that UNICODE be set to true or false in the root module");
        pub const LANGUAGEGROUP_ENUMPROC = @compileError("'LANGUAGEGROUP_ENUMPROC' requires that UNICODE be set to true or false in the root module");
        pub const LANGGROUPLOCALE_ENUMPROC = @compileError("'LANGGROUPLOCALE_ENUMPROC' requires that UNICODE be set to true or false in the root module");
        pub const UILANGUAGE_ENUMPROC = @compileError("'UILANGUAGE_ENUMPROC' requires that UNICODE be set to true or false in the root module");
        pub const CODEPAGE_ENUMPROC = @compileError("'CODEPAGE_ENUMPROC' requires that UNICODE be set to true or false in the root module");
        pub const DATEFMT_ENUMPROC = @compileError("'DATEFMT_ENUMPROC' requires that UNICODE be set to true or false in the root module");
        pub const DATEFMT_ENUMPROCEX = @compileError("'DATEFMT_ENUMPROCEX' requires that UNICODE be set to true or false in the root module");
        pub const TIMEFMT_ENUMPROC = @compileError("'TIMEFMT_ENUMPROC' requires that UNICODE be set to true or false in the root module");
        pub const CALINFO_ENUMPROC = @compileError("'CALINFO_ENUMPROC' requires that UNICODE be set to true or false in the root module");
        pub const CALINFO_ENUMPROCEX = @compileError("'CALINFO_ENUMPROCEX' requires that UNICODE be set to true or false in the root module");
        pub const REGISTERWORD = @compileError("'REGISTERWORD' requires that UNICODE be set to true or false in the root module");
        pub const STYLEBUF = @compileError("'STYLEBUF' requires that UNICODE be set to true or false in the root module");
        pub const IMEMENUITEMINFO = @compileError("'IMEMENUITEMINFO' requires that UNICODE be set to true or false in the root module");
        pub const REGISTERWORDENUMPROC = @compileError("'REGISTERWORDENUMPROC' requires that UNICODE be set to true or false in the root module");
        pub const GetDateFormat = @compileError("'GetDateFormat' requires that UNICODE be set to true or false in the root module");
        pub const GetTimeFormat = @compileError("'GetTimeFormat' requires that UNICODE be set to true or false in the root module");
        pub const CompareString = @compileError("'CompareString' requires that UNICODE be set to true or false in the root module");
        pub const FoldString = @compileError("'FoldString' requires that UNICODE be set to true or false in the root module");
        pub const GetStringTypeEx = @compileError("'GetStringTypeEx' requires that UNICODE be set to true or false in the root module");
        pub const GetStringType = @compileError("'GetStringType' requires that UNICODE be set to true or false in the root module");
        pub const GetCPInfoEx = @compileError("'GetCPInfoEx' requires that UNICODE be set to true or false in the root module");
        pub const LCMapString = @compileError("'LCMapString' requires that UNICODE be set to true or false in the root module");
        pub const GetLocaleInfo = @compileError("'GetLocaleInfo' requires that UNICODE be set to true or false in the root module");
        pub const SetLocaleInfo = @compileError("'SetLocaleInfo' requires that UNICODE be set to true or false in the root module");
        pub const GetCalendarInfo = @compileError("'GetCalendarInfo' requires that UNICODE be set to true or false in the root module");
        pub const SetCalendarInfo = @compileError("'SetCalendarInfo' requires that UNICODE be set to true or false in the root module");
        pub const GetNumberFormat = @compileError("'GetNumberFormat' requires that UNICODE be set to true or false in the root module");
        pub const GetCurrencyFormat = @compileError("'GetCurrencyFormat' requires that UNICODE be set to true or false in the root module");
        pub const EnumCalendarInfo = @compileError("'EnumCalendarInfo' requires that UNICODE be set to true or false in the root module");
        pub const EnumCalendarInfoEx = @compileError("'EnumCalendarInfoEx' requires that UNICODE be set to true or false in the root module");
        pub const EnumTimeFormats = @compileError("'EnumTimeFormats' requires that UNICODE be set to true or false in the root module");
        pub const EnumDateFormats = @compileError("'EnumDateFormats' requires that UNICODE be set to true or false in the root module");
        pub const EnumDateFormatsEx = @compileError("'EnumDateFormatsEx' requires that UNICODE be set to true or false in the root module");
        pub const GetGeoInfo = @compileError("'GetGeoInfo' requires that UNICODE be set to true or false in the root module");
        pub const EnumSystemLocales = @compileError("'EnumSystemLocales' requires that UNICODE be set to true or false in the root module");
        pub const EnumSystemLanguageGroups = @compileError("'EnumSystemLanguageGroups' requires that UNICODE be set to true or false in the root module");
        pub const EnumLanguageGroupLocales = @compileError("'EnumLanguageGroupLocales' requires that UNICODE be set to true or false in the root module");
        pub const EnumUILanguages = @compileError("'EnumUILanguages' requires that UNICODE be set to true or false in the root module");
        pub const EnumSystemCodePages = @compileError("'EnumSystemCodePages' requires that UNICODE be set to true or false in the root module");
        pub const ImmInstallIME = @compileError("'ImmInstallIME' requires that UNICODE be set to true or false in the root module");
        pub const ImmGetDescription = @compileError("'ImmGetDescription' requires that UNICODE be set to true or false in the root module");
        pub const ImmGetIMEFileName = @compileError("'ImmGetIMEFileName' requires that UNICODE be set to true or false in the root module");
        pub const ImmGetCompositionString = @compileError("'ImmGetCompositionString' requires that UNICODE be set to true or false in the root module");
        pub const ImmSetCompositionString = @compileError("'ImmSetCompositionString' requires that UNICODE be set to true or false in the root module");
        pub const ImmGetCandidateListCount = @compileError("'ImmGetCandidateListCount' requires that UNICODE be set to true or false in the root module");
        pub const ImmGetCandidateList = @compileError("'ImmGetCandidateList' requires that UNICODE be set to true or false in the root module");
        pub const ImmGetGuideLine = @compileError("'ImmGetGuideLine' requires that UNICODE be set to true or false in the root module");
        pub const ImmGetCompositionFont = @compileError("'ImmGetCompositionFont' requires that UNICODE be set to true or false in the root module");
        pub const ImmSetCompositionFont = @compileError("'ImmSetCompositionFont' requires that UNICODE be set to true or false in the root module");
        pub const ImmConfigureIME = @compileError("'ImmConfigureIME' requires that UNICODE be set to true or false in the root module");
        pub const ImmEscape = @compileError("'ImmEscape' requires that UNICODE be set to true or false in the root module");
        pub const ImmGetConversionList = @compileError("'ImmGetConversionList' requires that UNICODE be set to true or false in the root module");
        pub const ImmIsUIMessage = @compileError("'ImmIsUIMessage' requires that UNICODE be set to true or false in the root module");
        pub const ImmRegisterWord = @compileError("'ImmRegisterWord' requires that UNICODE be set to true or false in the root module");
        pub const ImmUnregisterWord = @compileError("'ImmUnregisterWord' requires that UNICODE be set to true or false in the root module");
        pub const ImmGetRegisterWordStyle = @compileError("'ImmGetRegisterWordStyle' requires that UNICODE be set to true or false in the root module");
        pub const ImmEnumRegisterWord = @compileError("'ImmEnumRegisterWord' requires that UNICODE be set to true or false in the root module");
        pub const ImmGetImeMenuItems = @compileError("'ImmGetImeMenuItems' requires that UNICODE be set to true or false in the root module");
        pub const ImmRequestMessage = @compileError("'ImmRequestMessage' requires that UNICODE be set to true or false in the root module");
    },
};

//
// type imports
//
const Guid = @import("../zig.zig").Guid;
const POINT = @import("displaydevices.zig").POINT;
const RECT = @import("displaydevices.zig").RECT;
const HBITMAP = @import("gdi.zig").HBITMAP;
const WPARAM = @import("windowsandmessaging.zig").WPARAM;
const LPARAM = @import("windowsandmessaging.zig").LPARAM;
const HWND = @import("windowsandmessaging.zig").HWND;
const BOOL = @import("systemservices.zig").BOOL;
const HICON = @import("gdi.zig").HICON;
const HDC = @import("gdi.zig").HDC;
const SYSTEMTIME = @import("windowsprogramming.zig").SYSTEMTIME;
const LOGFONTA = @import("shell.zig").LOGFONTA;
const LOGFONTW = @import("shell.zig").LOGFONTW;
const LRESULT = @import("systemservices.zig").LRESULT;
const HRESULT = @import("com.zig").HRESULT;
const ABC = @import("gdi.zig").ABC;
const SIZE = @import("displaydevices.zig").SIZE;

test "" {
    const constant_export_count = 34;
    const type_export_count = 331;
    const func_count = 1225;
    const unicode_alias_count = 62;
    const type_import_count = 17;
    @setEvalBranchQuota(0
        + constant_export_count
        + type_export_count
        + func_count
        + unicode_alias_count
        + type_import_count
        + 2 // TODO: why do I need these extra 2?
    );
    @import("std").testing.refAllDecls(@This());
}
