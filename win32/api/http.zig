//! NOTE: this source file is autogenerated, DO NOT MODIFY

//
// constants
//

//
// types
//
// --------------------------------------------------------
// Type: HTTP_SERVER_PROPERTY
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const HTTP_SERVER_PROPERTY = *opaque{
};
// --------------------------------------------------------
// Type: HTTP_PROPERTY_FLAGS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HTTP_PROPERTY_FLAGS = extern struct {
    _bitfield: u32,
};
// --------------------------------------------------------
// Type: HTTP_ENABLED_STATE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const HTTP_ENABLED_STATE = *opaque{
};
// --------------------------------------------------------
// Type: HTTP_STATE_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HTTP_STATE_INFO = extern struct {
    Flags: HTTP_PROPERTY_FLAGS,
    State: HTTP_ENABLED_STATE,
};
// --------------------------------------------------------
// Type: HTTP_503_RESPONSE_VERBOSITY
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const HTTP_503_RESPONSE_VERBOSITY = *opaque{
};
// --------------------------------------------------------
// Type: HTTP_QOS_SETTING_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const HTTP_QOS_SETTING_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: HTTP_QOS_SETTING_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HTTP_QOS_SETTING_INFO = extern struct {
    QosType: HTTP_QOS_SETTING_TYPE,
    QosSetting: ?*opaque{},
};
// --------------------------------------------------------
// Type: HTTP_CONNECTION_LIMIT_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HTTP_CONNECTION_LIMIT_INFO = extern struct {
    Flags: HTTP_PROPERTY_FLAGS,
    MaxConnections: u32,
};
// --------------------------------------------------------
// Type: HTTP_BANDWIDTH_LIMIT_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HTTP_BANDWIDTH_LIMIT_INFO = extern struct {
    Flags: HTTP_PROPERTY_FLAGS,
    MaxBandwidth: u32,
};
// --------------------------------------------------------
// Type: HTTP_FLOWRATE_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HTTP_FLOWRATE_INFO = extern struct {
    Flags: HTTP_PROPERTY_FLAGS,
    MaxBandwidth: u32,
    MaxPeakBandwidth: u32,
    BurstSize: u32,
};
// --------------------------------------------------------
// Type: HTTP_SERVICE_CONFIG_TIMEOUT_KEY
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const HTTP_SERVICE_CONFIG_TIMEOUT_KEY = *opaque{
};
// --------------------------------------------------------
// Type: HTTP_SERVICE_CONFIG_TIMEOUT_SET
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HTTP_SERVICE_CONFIG_TIMEOUT_SET = extern struct {
    KeyDesc: HTTP_SERVICE_CONFIG_TIMEOUT_KEY,
    ParamDesc: u16,
};
// --------------------------------------------------------
// Type: HTTP_TIMEOUT_LIMIT_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HTTP_TIMEOUT_LIMIT_INFO = extern struct {
    Flags: HTTP_PROPERTY_FLAGS,
    EntityBody: u16,
    DrainEntityBody: u16,
    RequestQueue: u16,
    IdleConnection: u16,
    HeaderWait: u16,
    MinSendRate: u32,
};
// --------------------------------------------------------
// Type: HTTP_SERVICE_CONFIG_SETTING_KEY
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const HTTP_SERVICE_CONFIG_SETTING_KEY = *opaque{
};
// --------------------------------------------------------
// Type: HTTP_SERVICE_CONFIG_SETTING_SET
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HTTP_SERVICE_CONFIG_SETTING_SET = extern struct {
    KeyDesc: HTTP_SERVICE_CONFIG_SETTING_KEY,
    ParamDesc: u32,
};
// --------------------------------------------------------
// Type: HTTP_LISTEN_ENDPOINT_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HTTP_LISTEN_ENDPOINT_INFO = extern struct {
    Flags: HTTP_PROPERTY_FLAGS,
    EnableSharing: u8,
};
// --------------------------------------------------------
// Type: HTTP_SERVER_AUTHENTICATION_DIGEST_PARAMS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HTTP_SERVER_AUTHENTICATION_DIGEST_PARAMS = extern struct {
    DomainNameLength: u16,
    DomainName: ?*u16,
    RealmLength: u16,
    Realm: ?*u16,
};
// --------------------------------------------------------
// Type: HTTP_SERVER_AUTHENTICATION_BASIC_PARAMS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HTTP_SERVER_AUTHENTICATION_BASIC_PARAMS = extern struct {
    RealmLength: u16,
    Realm: ?*u16,
};
// --------------------------------------------------------
// Type: HTTP_SERVER_AUTHENTICATION_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HTTP_SERVER_AUTHENTICATION_INFO = extern struct {
    Flags: HTTP_PROPERTY_FLAGS,
    AuthSchemes: u32,
    ReceiveMutualAuth: u8,
    ReceiveContextHandle: u8,
    DisableNTLMCredentialCaching: u8,
    ExFlags: u8,
    DigestParams: HTTP_SERVER_AUTHENTICATION_DIGEST_PARAMS,
    BasicParams: HTTP_SERVER_AUTHENTICATION_BASIC_PARAMS,
};
// --------------------------------------------------------
// Type: HTTP_SERVICE_BINDING_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const HTTP_SERVICE_BINDING_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: HTTP_SERVICE_BINDING_BASE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HTTP_SERVICE_BINDING_BASE = extern struct {
    Type: HTTP_SERVICE_BINDING_TYPE,
};
// --------------------------------------------------------
// Type: HTTP_SERVICE_BINDING_A
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HTTP_SERVICE_BINDING_A = extern struct {
    Base: HTTP_SERVICE_BINDING_BASE,
    Buffer: ?*i8,
    BufferSize: u32,
};
// --------------------------------------------------------
// Type: HTTP_SERVICE_BINDING_W
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HTTP_SERVICE_BINDING_W = extern struct {
    Base: HTTP_SERVICE_BINDING_BASE,
    Buffer: ?*u16,
    BufferSize: u32,
};
// --------------------------------------------------------
// Type: HTTP_AUTHENTICATION_HARDENING_LEVELS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const HTTP_AUTHENTICATION_HARDENING_LEVELS = *opaque{
};
// --------------------------------------------------------
// Type: HTTP_CHANNEL_BIND_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HTTP_CHANNEL_BIND_INFO = extern struct {
    Hardening: HTTP_AUTHENTICATION_HARDENING_LEVELS,
    Flags: u32,
    ServiceNames: ?*?*HTTP_SERVICE_BINDING_BASE,
    NumberOfServiceNames: u32,
};
// --------------------------------------------------------
// Type: HTTP_REQUEST_CHANNEL_BIND_STATUS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HTTP_REQUEST_CHANNEL_BIND_STATUS = extern struct {
    ServiceName: ?*HTTP_SERVICE_BINDING_BASE,
    ChannelToken: ?*u8,
    ChannelTokenSize: u32,
    Flags: u32,
};
// --------------------------------------------------------
// Type: HTTP_REQUEST_TOKEN_BINDING_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HTTP_REQUEST_TOKEN_BINDING_INFO = extern struct {
    TokenBinding: ?*u8,
    TokenBindingSize: u32,
    EKM: ?*u8,
    EKMSize: u32,
    KeyType: u8,
};
// --------------------------------------------------------
// Type: HTTP_LOGGING_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const HTTP_LOGGING_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: HTTP_LOGGING_ROLLOVER_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const HTTP_LOGGING_ROLLOVER_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: HTTP_LOGGING_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HTTP_LOGGING_INFO = extern struct {
    Flags: HTTP_PROPERTY_FLAGS,
    LoggingFlags: u32,
    SoftwareName: ?*u16,
    SoftwareNameLength: u16,
    DirectoryNameLength: u16,
    DirectoryName: ?*u16,
    Format: HTTP_LOGGING_TYPE,
    Fields: u32,
    pExtFields: ?*opaque{},
    NumOfExtFields: u16,
    MaxRecordSize: u16,
    RolloverType: HTTP_LOGGING_ROLLOVER_TYPE,
    RolloverSize: u32,
    pSecurityDescriptor: ?*opaque{},
};
// --------------------------------------------------------
// Type: HTTP_BINDING_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HTTP_BINDING_INFO = extern struct {
    Flags: HTTP_PROPERTY_FLAGS,
    RequestQueueHandle: HANDLE,
};
// --------------------------------------------------------
// Type: HTTP_PROTECTION_LEVEL_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const HTTP_PROTECTION_LEVEL_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: HTTP_PROTECTION_LEVEL_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HTTP_PROTECTION_LEVEL_INFO = extern struct {
    Flags: HTTP_PROPERTY_FLAGS,
    Level: HTTP_PROTECTION_LEVEL_TYPE,
};
// --------------------------------------------------------
// Type: HTTP_BYTE_RANGE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HTTP_BYTE_RANGE = extern struct {
    StartingOffset: ULARGE_INTEGER,
    Length: ULARGE_INTEGER,
};
// --------------------------------------------------------
// Type: HTTP_VERSION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HTTP_VERSION = extern struct {
    MajorVersion: u16,
    MinorVersion: u16,
};
// --------------------------------------------------------
// Type: _HTTP_URI_SCHEME
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const _HTTP_URI_SCHEME = *opaque{
};
// --------------------------------------------------------
// Type: HTTP_VERB
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const HTTP_VERB = *opaque{
};
// --------------------------------------------------------
// Type: HTTP_HEADER_ID
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const HTTP_HEADER_ID = *opaque{
};
// --------------------------------------------------------
// Type: HTTP_KNOWN_HEADER
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HTTP_KNOWN_HEADER = extern struct {
    RawValueLength: u16,
    pRawValue: ?*i8,
};
// --------------------------------------------------------
// Type: HTTP_UNKNOWN_HEADER
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HTTP_UNKNOWN_HEADER = extern struct {
    NameLength: u16,
    RawValueLength: u16,
    pName: ?*i8,
    pRawValue: ?*i8,
};
// --------------------------------------------------------
// Type: HTTP_LOG_DATA_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const HTTP_LOG_DATA_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: HTTP_LOG_DATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HTTP_LOG_DATA = extern struct {
    Type: HTTP_LOG_DATA_TYPE,
};
// --------------------------------------------------------
// Type: HTTP_LOG_FIELDS_DATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HTTP_LOG_FIELDS_DATA = extern struct {
    Base: HTTP_LOG_DATA,
    UserNameLength: u16,
    UriStemLength: u16,
    ClientIpLength: u16,
    ServerNameLength: u16,
    ServiceNameLength: u16,
    ServerIpLength: u16,
    MethodLength: u16,
    UriQueryLength: u16,
    HostLength: u16,
    UserAgentLength: u16,
    CookieLength: u16,
    ReferrerLength: u16,
    UserName: ?*u16,
    UriStem: ?*u16,
    ClientIp: ?*i8,
    ServerName: ?*i8,
    ServiceName: ?*i8,
    ServerIp: ?*i8,
    Method: ?*i8,
    UriQuery: ?*i8,
    Host: ?*i8,
    UserAgent: ?*i8,
    Cookie: ?*i8,
    Referrer: ?*i8,
    ServerPort: u16,
    ProtocolStatus: u16,
    Win32Status: u32,
    MethodNum: HTTP_VERB,
    SubStatus: u16,
};
// --------------------------------------------------------
// Type: HTTP_DATA_CHUNK_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const HTTP_DATA_CHUNK_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: HTTP_DATA_CHUNK
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HTTP_DATA_CHUNK = extern struct {
    DataChunkType: HTTP_DATA_CHUNK_TYPE,
    Anonymous: _Anonymous_e__Union,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
        // --------------------------------------------------------
        // Type: _FromFragmentCacheEx_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _FromFragmentCacheEx_e__Struct = extern struct {
            ByteRange: HTTP_BYTE_RANGE,
            pFragmentName: ?*u16,
        };
        // --------------------------------------------------------
        // Type: _FromFileHandle_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _FromFileHandle_e__Struct = extern struct {
            ByteRange: HTTP_BYTE_RANGE,
            FileHandle: HANDLE,
        };
        // --------------------------------------------------------
        // Type: _FromFragmentCache_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _FromFragmentCache_e__Struct = extern struct {
            FragmentNameLength: u16,
            pFragmentName: ?*u16,
        };
        // --------------------------------------------------------
        // Type: _FromMemory_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _FromMemory_e__Struct = extern struct {
            pBuffer: ?*opaque{},
            BufferLength: u32,
        };
    };
};
// --------------------------------------------------------
// Type: HTTP_REQUEST_HEADERS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HTTP_REQUEST_HEADERS = extern struct {
    UnknownHeaderCount: u16,
    pUnknownHeaders: ?*HTTP_UNKNOWN_HEADER,
    TrailerCount: u16,
    pTrailers: ?*HTTP_UNKNOWN_HEADER,
    KnownHeaders: ?[*]HTTP_KNOWN_HEADER,
};
// --------------------------------------------------------
// Type: HTTP_RESPONSE_HEADERS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HTTP_RESPONSE_HEADERS = extern struct {
    UnknownHeaderCount: u16,
    pUnknownHeaders: ?*HTTP_UNKNOWN_HEADER,
    TrailerCount: u16,
    pTrailers: ?*HTTP_UNKNOWN_HEADER,
    KnownHeaders: ?[*]HTTP_KNOWN_HEADER,
};
// --------------------------------------------------------
// Type: HTTP_DELEGATE_REQUEST_PROPERTY_ID
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const HTTP_DELEGATE_REQUEST_PROPERTY_ID = *opaque{
};
// --------------------------------------------------------
// Type: HTTP_DELEGATE_REQUEST_PROPERTY_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HTTP_DELEGATE_REQUEST_PROPERTY_INFO = extern struct {
    ProperyId: HTTP_DELEGATE_REQUEST_PROPERTY_ID,
    PropertyInfoLength: u32,
    PropertyInfo: ?*opaque{},
};
// --------------------------------------------------------
// Type: HTTP_TRANSPORT_ADDRESS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HTTP_TRANSPORT_ADDRESS = extern struct {
    pRemoteAddress: ?*SOCKADDR,
    pLocalAddress: ?*SOCKADDR,
};
// --------------------------------------------------------
// Type: HTTP_COOKED_URL
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HTTP_COOKED_URL = extern struct {
    FullUrlLength: u16,
    HostLength: u16,
    AbsPathLength: u16,
    QueryStringLength: u16,
    pFullUrl: ?*u16,
    pHost: ?*u16,
    pAbsPath: ?*u16,
    pQueryString: ?*u16,
};
// --------------------------------------------------------
// Type: HTTP_AUTH_STATUS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const HTTP_AUTH_STATUS = *opaque{
};
// --------------------------------------------------------
// Type: HTTP_REQUEST_AUTH_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const HTTP_REQUEST_AUTH_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: HTTP_SSL_CLIENT_CERT_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HTTP_SSL_CLIENT_CERT_INFO = extern struct {
    CertFlags: u32,
    CertEncodedSize: u32,
    pCertEncoded: ?*u8,
    Token: HANDLE,
    CertDeniedByMapper: u8,
};
// --------------------------------------------------------
// Type: HTTP_SSL_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HTTP_SSL_INFO = extern struct {
    ServerCertKeySize: u16,
    ConnectionKeySize: u16,
    ServerCertIssuerSize: u32,
    ServerCertSubjectSize: u32,
    pServerCertIssuer: ?*i8,
    pServerCertSubject: ?*i8,
    pClientCertInfo: ?*HTTP_SSL_CLIENT_CERT_INFO,
    SslClientCertNegotiated: u32,
};
// --------------------------------------------------------
// Type: HTTP_SSL_PROTOCOL_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HTTP_SSL_PROTOCOL_INFO = extern struct {
    Protocol: u32,
    CipherType: u32,
    CipherStrength: u32,
    HashType: u32,
    HashStrength: u32,
    KeyExchangeType: u32,
    KeyExchangeStrength: u32,
};
// --------------------------------------------------------
// Type: HTTP_REQUEST_SIZING_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const HTTP_REQUEST_SIZING_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: HTTP_REQUEST_SIZING_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HTTP_REQUEST_SIZING_INFO = extern struct {
    Flags: u64,
    RequestIndex: u32,
    RequestSizingCount: u32,
    RequestSizing: ?[*]u64,
};
// --------------------------------------------------------
// Type: HTTP_REQUEST_TIMING_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const HTTP_REQUEST_TIMING_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: HTTP_REQUEST_TIMING_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HTTP_REQUEST_TIMING_INFO = extern struct {
    RequestTimingCount: u32,
    RequestTiming: ?[*]u64,
};
// --------------------------------------------------------
// Type: HTTP_REQUEST_INFO_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const HTTP_REQUEST_INFO_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: HTTP_REQUEST_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HTTP_REQUEST_INFO = extern struct {
    InfoType: HTTP_REQUEST_INFO_TYPE,
    InfoLength: u32,
    pInfo: ?*opaque{},
};
// --------------------------------------------------------
// Type: HTTP_REQUEST_AUTH_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HTTP_REQUEST_AUTH_INFO = extern struct {
    AuthStatus: HTTP_AUTH_STATUS,
    SecStatus: i32,
    Flags: u32,
    AuthType: HTTP_REQUEST_AUTH_TYPE,
    AccessToken: HANDLE,
    ContextAttributes: u32,
    PackedContextLength: u32,
    PackedContextType: u32,
    PackedContext: ?*opaque{},
    MutualAuthDataLength: u32,
    pMutualAuthData: ?*i8,
    PackageNameLength: u16,
    pPackageName: ?*u16,
};
// --------------------------------------------------------
// Type: HTTP_REQUEST_V1
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HTTP_REQUEST_V1 = extern struct {
    Flags: u32,
    ConnectionId: u64,
    RequestId: u64,
    UrlContext: u64,
    Version: HTTP_VERSION,
    Verb: HTTP_VERB,
    UnknownVerbLength: u16,
    RawUrlLength: u16,
    pUnknownVerb: ?*i8,
    pRawUrl: ?*i8,
    CookedUrl: HTTP_COOKED_URL,
    Address: HTTP_TRANSPORT_ADDRESS,
    Headers: HTTP_REQUEST_HEADERS,
    BytesReceived: u64,
    EntityChunkCount: u16,
    pEntityChunks: ?*HTTP_DATA_CHUNK,
    RawConnectionId: u64,
    pSslInfo: ?*HTTP_SSL_INFO,
};
// --------------------------------------------------------
// Type: HTTP_REQUEST_V2
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HTTP_REQUEST_V2 = extern struct {
    __AnonymousBase_http_L1816_C35: HTTP_REQUEST_V1,
    RequestInfoCount: u16,
    pRequestInfo: ?*HTTP_REQUEST_INFO,
};
// --------------------------------------------------------
// Type: HTTP_RESPONSE_V1
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HTTP_RESPONSE_V1 = extern struct {
    Flags: u32,
    Version: HTTP_VERSION,
    StatusCode: u16,
    ReasonLength: u16,
    pReason: ?*i8,
    Headers: HTTP_RESPONSE_HEADERS,
    EntityChunkCount: u16,
    pEntityChunks: ?*HTTP_DATA_CHUNK,
};
// --------------------------------------------------------
// Type: HTTP_RESPONSE_INFO_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const HTTP_RESPONSE_INFO_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: HTTP_RESPONSE_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HTTP_RESPONSE_INFO = extern struct {
    Type: HTTP_RESPONSE_INFO_TYPE,
    Length: u32,
    pInfo: ?*opaque{},
};
// --------------------------------------------------------
// Type: HTTP_MULTIPLE_KNOWN_HEADERS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HTTP_MULTIPLE_KNOWN_HEADERS = extern struct {
    HeaderId: HTTP_HEADER_ID,
    Flags: u32,
    KnownHeaderCount: u16,
    KnownHeaders: ?*HTTP_KNOWN_HEADER,
};
// --------------------------------------------------------
// Type: HTTP_RESPONSE_V2
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HTTP_RESPONSE_V2 = extern struct {
    __AnonymousBase_http_L2003_C36: HTTP_RESPONSE_V1,
    ResponseInfoCount: u16,
    pResponseInfo: ?*HTTP_RESPONSE_INFO,
};
// --------------------------------------------------------
// Type: HTTPAPI_VERSION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HTTPAPI_VERSION = extern struct {
    HttpApiMajorVersion: u16,
    HttpApiMinorVersion: u16,
};
// --------------------------------------------------------
// Type: HTTP_CACHE_POLICY_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const HTTP_CACHE_POLICY_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: HTTP_CACHE_POLICY
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HTTP_CACHE_POLICY = extern struct {
    Policy: HTTP_CACHE_POLICY_TYPE,
    SecondsToLive: u32,
};
// --------------------------------------------------------
// Type: HTTP_SERVICE_CONFIG_ID
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const HTTP_SERVICE_CONFIG_ID = *opaque{
};
// --------------------------------------------------------
// Type: HTTP_SERVICE_CONFIG_QUERY_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const HTTP_SERVICE_CONFIG_QUERY_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: HTTP_SERVICE_CONFIG_SSL_KEY
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HTTP_SERVICE_CONFIG_SSL_KEY = extern struct {
    pIpPort: ?*SOCKADDR,
};
// --------------------------------------------------------
// Type: HTTP_SERVICE_CONFIG_SSL_KEY_EX
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HTTP_SERVICE_CONFIG_SSL_KEY_EX = extern struct {
    IpPort: SOCKADDR_STORAGE_LH,
};
// --------------------------------------------------------
// Type: HTTP_SERVICE_CONFIG_SSL_SNI_KEY
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HTTP_SERVICE_CONFIG_SSL_SNI_KEY = extern struct {
    IpPort: SOCKADDR_STORAGE_LH,
    Host: ?*u16,
};
// --------------------------------------------------------
// Type: HTTP_SERVICE_CONFIG_SSL_CCS_KEY
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HTTP_SERVICE_CONFIG_SSL_CCS_KEY = extern struct {
    LocalAddress: SOCKADDR_STORAGE_LH,
};
// --------------------------------------------------------
// Type: HTTP_SERVICE_CONFIG_SSL_PARAM
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HTTP_SERVICE_CONFIG_SSL_PARAM = extern struct {
    SslHashLength: u32,
    pSslHash: ?*opaque{},
    AppId: Guid,
    pSslCertStoreName: ?*u16,
    DefaultCertCheckMode: u32,
    DefaultRevocationFreshnessTime: u32,
    DefaultRevocationUrlRetrievalTimeout: u32,
    pDefaultSslCtlIdentifier: ?*u16,
    pDefaultSslCtlStoreName: ?*u16,
    DefaultFlags: u32,
};
// --------------------------------------------------------
// Type: HTTP_SSL_SERVICE_CONFIG_EX_PARAM_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const HTTP_SSL_SERVICE_CONFIG_EX_PARAM_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: HTTP2_WINDOW_SIZE_PARAM
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HTTP2_WINDOW_SIZE_PARAM = extern struct {
    Http2ReceiveWindowSize: u32,
};
// --------------------------------------------------------
// Type: HTTP2_SETTINGS_LIMITS_PARAM
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HTTP2_SETTINGS_LIMITS_PARAM = extern struct {
    Http2MaxSettingsPerFrame: u32,
    Http2MaxSettingsPerMinute: u32,
};
// --------------------------------------------------------
// Type: HTTP_PERFORMANCE_PARAM
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HTTP_PERFORMANCE_PARAM = extern struct {
    SendBufferingFlags: u64,
    EnableAggressiveICW: u8,
    MaxBufferedSendBytes: u32,
    MaxConcurrentClientStreams: u32,
};
// --------------------------------------------------------
// Type: HTTP_SERVICE_CONFIG_SSL_PARAM_EX
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HTTP_SERVICE_CONFIG_SSL_PARAM_EX = extern struct {
    ParamType: HTTP_SSL_SERVICE_CONFIG_EX_PARAM_TYPE,
    Flags: u64,
    Anonymous: _Anonymous_e__Union,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: HTTP_SERVICE_CONFIG_SSL_SET
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HTTP_SERVICE_CONFIG_SSL_SET = extern struct {
    KeyDesc: HTTP_SERVICE_CONFIG_SSL_KEY,
    ParamDesc: HTTP_SERVICE_CONFIG_SSL_PARAM,
};
// --------------------------------------------------------
// Type: HTTP_SERVICE_CONFIG_SSL_SNI_SET
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HTTP_SERVICE_CONFIG_SSL_SNI_SET = extern struct {
    KeyDesc: HTTP_SERVICE_CONFIG_SSL_SNI_KEY,
    ParamDesc: HTTP_SERVICE_CONFIG_SSL_PARAM,
};
// --------------------------------------------------------
// Type: HTTP_SERVICE_CONFIG_SSL_CCS_SET
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HTTP_SERVICE_CONFIG_SSL_CCS_SET = extern struct {
    KeyDesc: HTTP_SERVICE_CONFIG_SSL_CCS_KEY,
    ParamDesc: HTTP_SERVICE_CONFIG_SSL_PARAM,
};
// --------------------------------------------------------
// Type: HTTP_SERVICE_CONFIG_SSL_SET_EX
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HTTP_SERVICE_CONFIG_SSL_SET_EX = extern struct {
    KeyDesc: HTTP_SERVICE_CONFIG_SSL_KEY_EX,
    ParamDesc: HTTP_SERVICE_CONFIG_SSL_PARAM_EX,
};
// --------------------------------------------------------
// Type: HTTP_SERVICE_CONFIG_SSL_SNI_SET_EX
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HTTP_SERVICE_CONFIG_SSL_SNI_SET_EX = extern struct {
    KeyDesc: HTTP_SERVICE_CONFIG_SSL_SNI_KEY,
    ParamDesc: HTTP_SERVICE_CONFIG_SSL_PARAM_EX,
};
// --------------------------------------------------------
// Type: HTTP_SERVICE_CONFIG_SSL_CCS_SET_EX
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HTTP_SERVICE_CONFIG_SSL_CCS_SET_EX = extern struct {
    KeyDesc: HTTP_SERVICE_CONFIG_SSL_CCS_KEY,
    ParamDesc: HTTP_SERVICE_CONFIG_SSL_PARAM_EX,
};
// --------------------------------------------------------
// Type: HTTP_SERVICE_CONFIG_SSL_QUERY
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HTTP_SERVICE_CONFIG_SSL_QUERY = extern struct {
    QueryDesc: HTTP_SERVICE_CONFIG_QUERY_TYPE,
    KeyDesc: HTTP_SERVICE_CONFIG_SSL_KEY,
    dwToken: u32,
};
// --------------------------------------------------------
// Type: HTTP_SERVICE_CONFIG_SSL_SNI_QUERY
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HTTP_SERVICE_CONFIG_SSL_SNI_QUERY = extern struct {
    QueryDesc: HTTP_SERVICE_CONFIG_QUERY_TYPE,
    KeyDesc: HTTP_SERVICE_CONFIG_SSL_SNI_KEY,
    dwToken: u32,
};
// --------------------------------------------------------
// Type: HTTP_SERVICE_CONFIG_SSL_CCS_QUERY
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HTTP_SERVICE_CONFIG_SSL_CCS_QUERY = extern struct {
    QueryDesc: HTTP_SERVICE_CONFIG_QUERY_TYPE,
    KeyDesc: HTTP_SERVICE_CONFIG_SSL_CCS_KEY,
    dwToken: u32,
};
// --------------------------------------------------------
// Type: HTTP_SERVICE_CONFIG_SSL_QUERY_EX
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HTTP_SERVICE_CONFIG_SSL_QUERY_EX = extern struct {
    QueryDesc: HTTP_SERVICE_CONFIG_QUERY_TYPE,
    KeyDesc: HTTP_SERVICE_CONFIG_SSL_KEY_EX,
    dwToken: u32,
    ParamType: HTTP_SSL_SERVICE_CONFIG_EX_PARAM_TYPE,
};
// --------------------------------------------------------
// Type: HTTP_SERVICE_CONFIG_SSL_SNI_QUERY_EX
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HTTP_SERVICE_CONFIG_SSL_SNI_QUERY_EX = extern struct {
    QueryDesc: HTTP_SERVICE_CONFIG_QUERY_TYPE,
    KeyDesc: HTTP_SERVICE_CONFIG_SSL_SNI_KEY,
    dwToken: u32,
    ParamType: HTTP_SSL_SERVICE_CONFIG_EX_PARAM_TYPE,
};
// --------------------------------------------------------
// Type: HTTP_SERVICE_CONFIG_SSL_CCS_QUERY_EX
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HTTP_SERVICE_CONFIG_SSL_CCS_QUERY_EX = extern struct {
    QueryDesc: HTTP_SERVICE_CONFIG_QUERY_TYPE,
    KeyDesc: HTTP_SERVICE_CONFIG_SSL_CCS_KEY,
    dwToken: u32,
    ParamType: HTTP_SSL_SERVICE_CONFIG_EX_PARAM_TYPE,
};
// --------------------------------------------------------
// Type: HTTP_SERVICE_CONFIG_IP_LISTEN_PARAM
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HTTP_SERVICE_CONFIG_IP_LISTEN_PARAM = extern struct {
    AddrLength: u16,
    pAddress: ?*SOCKADDR,
};
// --------------------------------------------------------
// Type: HTTP_SERVICE_CONFIG_IP_LISTEN_QUERY
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HTTP_SERVICE_CONFIG_IP_LISTEN_QUERY = extern struct {
    AddrCount: u32,
    AddrList: ?[*]SOCKADDR_STORAGE_LH,
};
// --------------------------------------------------------
// Type: HTTP_SERVICE_CONFIG_URLACL_KEY
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HTTP_SERVICE_CONFIG_URLACL_KEY = extern struct {
    pUrlPrefix: ?*u16,
};
// --------------------------------------------------------
// Type: HTTP_SERVICE_CONFIG_URLACL_PARAM
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HTTP_SERVICE_CONFIG_URLACL_PARAM = extern struct {
    pStringSecurityDescriptor: ?*u16,
};
// --------------------------------------------------------
// Type: HTTP_SERVICE_CONFIG_URLACL_SET
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HTTP_SERVICE_CONFIG_URLACL_SET = extern struct {
    KeyDesc: HTTP_SERVICE_CONFIG_URLACL_KEY,
    ParamDesc: HTTP_SERVICE_CONFIG_URLACL_PARAM,
};
// --------------------------------------------------------
// Type: HTTP_SERVICE_CONFIG_URLACL_QUERY
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HTTP_SERVICE_CONFIG_URLACL_QUERY = extern struct {
    QueryDesc: HTTP_SERVICE_CONFIG_QUERY_TYPE,
    KeyDesc: HTTP_SERVICE_CONFIG_URLACL_KEY,
    dwToken: u32,
};
// --------------------------------------------------------
// Type: HTTP_SERVICE_CONFIG_CACHE_KEY
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const HTTP_SERVICE_CONFIG_CACHE_KEY = *opaque{
};
// --------------------------------------------------------
// Type: HTTP_SERVICE_CONFIG_CACHE_SET
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HTTP_SERVICE_CONFIG_CACHE_SET = extern struct {
    KeyDesc: HTTP_SERVICE_CONFIG_CACHE_KEY,
    ParamDesc: u32,
};
// --------------------------------------------------------
// Type: HTTP_REQUEST_PROPERTY
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const HTTP_REQUEST_PROPERTY = *opaque{
};
// --------------------------------------------------------
// Type: HTTP_QUERY_REQUEST_QUALIFIER_TCP
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HTTP_QUERY_REQUEST_QUALIFIER_TCP = extern struct {
    Freshness: u64,
};
// --------------------------------------------------------
// Type: HTTP_QUERY_REQUEST_QUALIFIER_QUIC
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HTTP_QUERY_REQUEST_QUALIFIER_QUIC = extern struct {
    Freshness: u64,
};
// --------------------------------------------------------
// Type: HTTP_REQUEST_PROPERTY_SNI
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HTTP_REQUEST_PROPERTY_SNI = extern struct {
    Hostname: ?[*]u16,
    Flags: u32,
};
// --------------------------------------------------------
// Type: WINHTTP_ASYNC_RESULT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const WINHTTP_ASYNC_RESULT = extern struct {
    dwResult: ?*opaque{},
    dwError: u32,
};
// --------------------------------------------------------
// Type: URL_COMPONENTS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const URL_COMPONENTS = extern struct {
    dwStructSize: u32,
    lpszScheme: ?*u16,
    dwSchemeLength: u32,
    nScheme: INTERNET_SCHEME,
    lpszHostName: ?*u16,
    dwHostNameLength: u32,
    nPort: u16,
    lpszUserName: ?*u16,
    dwUserNameLength: u32,
    lpszPassword: ?*u16,
    dwPasswordLength: u32,
    lpszUrlPath: ?*u16,
    dwUrlPathLength: u32,
    lpszExtraInfo: ?*u16,
    dwExtraInfoLength: u32,
};
// --------------------------------------------------------
// Type: WINHTTP_PROXY_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const WINHTTP_PROXY_INFO = extern struct {
    dwAccessType: u32,
    lpszProxy: ?*u16,
    lpszProxyBypass: ?*u16,
};
// --------------------------------------------------------
// Type: WINHTTP_AUTOPROXY_OPTIONS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const WINHTTP_AUTOPROXY_OPTIONS = extern struct {
    dwFlags: u32,
    dwAutoDetectFlags: u32,
    lpszAutoConfigUrl: ?*u16,
    lpvReserved: ?*opaque{},
    dwReserved: u32,
    fAutoLogonIfChallenged: BOOL,
};
// --------------------------------------------------------
// Type: WINHTTP_PROXY_RESULT_ENTRY
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const WINHTTP_PROXY_RESULT_ENTRY = extern struct {
    fProxy: BOOL,
    fBypass: BOOL,
    ProxyScheme: INTERNET_SCHEME,
    pwszProxy: ?*u16,
    ProxyPort: u16,
};
// --------------------------------------------------------
// Type: WINHTTP_PROXY_RESULT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const WINHTTP_PROXY_RESULT = extern struct {
    cEntries: u32,
    pEntries: ?*WINHTTP_PROXY_RESULT_ENTRY,
};
// --------------------------------------------------------
// Type: WINHTTP_PROXY_RESULT_EX
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const WINHTTP_PROXY_RESULT_EX = extern struct {
    cEntries: u32,
    pEntries: ?*WINHTTP_PROXY_RESULT_ENTRY,
    hProxyDetectionHandle: HANDLE,
    dwProxyInterfaceAffinity: u32,
};
// --------------------------------------------------------
// Type: _WinHttpProxyNetworkKey
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const _WinHttpProxyNetworkKey = extern struct {
    pbBuffer: ?[*]u8,
};
// --------------------------------------------------------
// Type: WINHTTP_PROXY_SETTINGS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const WINHTTP_PROXY_SETTINGS = extern struct {
    dwStructSize: u32,
    dwFlags: u32,
    dwCurrentSettingsVersion: u32,
    pwszConnectionName: ?*u16,
    pwszProxy: ?*u16,
    pwszProxyBypass: ?*u16,
    pwszAutoconfigUrl: ?*u16,
    pwszAutoconfigSecondaryUrl: ?*u16,
    dwAutoDiscoveryFlags: u32,
    pwszLastKnownGoodAutoConfigUrl: ?*u16,
    dwAutoconfigReloadDelayMins: u32,
    ftLastKnownDetectTime: FILETIME,
    dwDetectedInterfaceIpCount: u32,
    pdwDetectedInterfaceIp: ?*u32,
    cNetworkKeys: u32,
    pNetworkKeys: ?*_WinHttpProxyNetworkKey,
};
// --------------------------------------------------------
// Type: WINHTTP_CERTIFICATE_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const WINHTTP_CERTIFICATE_INFO = extern struct {
    ftExpiry: FILETIME,
    ftStart: FILETIME,
    lpszSubjectInfo: ?*u16,
    lpszIssuerInfo: ?*u16,
    lpszProtocolName: ?*u16,
    lpszSignatureAlgName: ?*u16,
    lpszEncryptionAlgName: ?*u16,
    dwKeySize: u32,
};
// --------------------------------------------------------
// Type: WINHTTP_CONNECTION_INFO
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=4 Size=0
pub const WINHTTP_CONNECTION_INFO = *opaque{
};
// --------------------------------------------------------
// Type: WINHTTP_REQUEST_TIME_ENTRY
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const WINHTTP_REQUEST_TIME_ENTRY = *opaque{
};
// --------------------------------------------------------
// Type: WINHTTP_REQUEST_TIMES
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=4 Size=0
pub const WINHTTP_REQUEST_TIMES = *opaque{
};
// --------------------------------------------------------
// Type: WINHTTP_REQUEST_STAT_ENTRY
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const WINHTTP_REQUEST_STAT_ENTRY = *opaque{
};
// --------------------------------------------------------
// Type: WINHTTP_REQUEST_STATS
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=4 Size=0
pub const WINHTTP_REQUEST_STATS = *opaque{
};
// --------------------------------------------------------
// Type: WINHTTP_EXTENDED_HEADER
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const WINHTTP_EXTENDED_HEADER = extern struct {
    Anonymous1: _Anonymous1_e__Union,
    Anonymous2: _Anonymous2_e__Union,
    // --------------------------------------------------------
    // Type: _Anonymous1_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous1_e__Union = *opaque{
    };
    // --------------------------------------------------------
    // Type: _Anonymous2_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous2_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: WINHTTP_CREDS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const WINHTTP_CREDS = extern struct {
    lpszUserName: ?*i8,
    lpszPassword: ?*i8,
    lpszRealm: ?*i8,
    dwAuthScheme: u32,
    lpszHostName: ?*i8,
    dwPort: u32,
};
// --------------------------------------------------------
// Type: WINHTTP_CREDS_EX
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const WINHTTP_CREDS_EX = extern struct {
    lpszUserName: ?*i8,
    lpszPassword: ?*i8,
    lpszRealm: ?*i8,
    dwAuthScheme: u32,
    lpszHostName: ?*i8,
    dwPort: u32,
    lpszUrl: ?*i8,
};
// --------------------------------------------------------
// Type: WINHTTP_STATUS_CALLBACK
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const WINHTTP_STATUS_CALLBACK = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: LPWINHTTP_STATUS_CALLBACK
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const LPWINHTTP_STATUS_CALLBACK = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: WINHTTP_CURRENT_USER_IE_PROXY_CONFIG
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const WINHTTP_CURRENT_USER_IE_PROXY_CONFIG = extern struct {
    fAutoDetect: BOOL,
    lpszAutoConfigUrl: ?*u16,
    lpszProxy: ?*u16,
    lpszProxyBypass: ?*u16,
};
// --------------------------------------------------------
// Type: WINHTTP_WEB_SOCKET_OPERATION
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const WINHTTP_WEB_SOCKET_OPERATION = *opaque{
};
// --------------------------------------------------------
// Type: WINHTTP_WEB_SOCKET_BUFFER_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const WINHTTP_WEB_SOCKET_BUFFER_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: WINHTTP_WEB_SOCKET_CLOSE_STATUS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const WINHTTP_WEB_SOCKET_CLOSE_STATUS = *opaque{
};
// --------------------------------------------------------
// Type: WINHTTP_WEB_SOCKET_ASYNC_RESULT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const WINHTTP_WEB_SOCKET_ASYNC_RESULT = extern struct {
    AsyncResult: WINHTTP_ASYNC_RESULT,
    Operation: WINHTTP_WEB_SOCKET_OPERATION,
};
// --------------------------------------------------------
// Type: WINHTTP_WEB_SOCKET_STATUS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const WINHTTP_WEB_SOCKET_STATUS = extern struct {
    dwBytesTransferred: u32,
    eBufferType: WINHTTP_WEB_SOCKET_BUFFER_TYPE,
};

//
// functions
//

// set_last_errror=False (can and should we use this?)
pub extern "HTTPAPI" fn HttpInitialize(
    Version: HTTPAPI_VERSION,
    Flags: u32,
    pReserved: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "HTTPAPI" fn HttpTerminate(
    Flags: u32,
    pReserved: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "HTTPAPI" fn HttpCreateHttpHandle(
    RequestQueueHandle: ?*?*opaque{},
    Reserved: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "HTTPAPI" fn HttpCreateRequestQueue(
    Version: HTTPAPI_VERSION,
    Name: ?*u16,
    SecurityAttributes: ?*SECURITY_ATTRIBUTES,
    Flags: u32,
    RequestQueueHandle: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "HTTPAPI" fn HttpCloseRequestQueue(
    RequestQueueHandle: HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "HTTPAPI" fn HttpSetRequestQueueProperty(
    RequestQueueHandle: HANDLE,
    Property: HTTP_SERVER_PROPERTY,
    PropertyInformation: ?*opaque{},
    PropertyInformationLength: u32,
    Reserved1: u32,
    Reserved2: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "HTTPAPI" fn HttpQueryRequestQueueProperty(
    RequestQueueHandle: HANDLE,
    Property: HTTP_SERVER_PROPERTY,
    PropertyInformation: ?*opaque{},
    PropertyInformationLength: u32,
    Reserved1: u32,
    ReturnLength: ?*u32,
    Reserved2: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "HTTPAPI" fn HttpShutdownRequestQueue(
    RequestQueueHandle: HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "HTTPAPI" fn HttpReceiveClientCertificate(
    RequestQueueHandle: HANDLE,
    ConnectionId: u64,
    Flags: u32,
    SslClientCertInfo: ?*HTTP_SSL_CLIENT_CERT_INFO,
    SslClientCertInfoSize: u32,
    BytesReceived: ?*u32,
    Overlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "HTTPAPI" fn HttpCreateServerSession(
    Version: HTTPAPI_VERSION,
    ServerSessionId: ?*u64,
    Reserved: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "HTTPAPI" fn HttpCloseServerSession(
    ServerSessionId: u64,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "HTTPAPI" fn HttpQueryServerSessionProperty(
    ServerSessionId: u64,
    Property: HTTP_SERVER_PROPERTY,
    PropertyInformation: ?*opaque{},
    PropertyInformationLength: u32,
    ReturnLength: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "HTTPAPI" fn HttpSetServerSessionProperty(
    ServerSessionId: u64,
    Property: HTTP_SERVER_PROPERTY,
    PropertyInformation: ?*opaque{},
    PropertyInformationLength: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "HTTPAPI" fn HttpAddUrl(
    RequestQueueHandle: HANDLE,
    FullyQualifiedUrl: ?*u16,
    Reserved: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "HTTPAPI" fn HttpRemoveUrl(
    RequestQueueHandle: HANDLE,
    FullyQualifiedUrl: ?*u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "HTTPAPI" fn HttpCreateUrlGroup(
    ServerSessionId: u64,
    pUrlGroupId: ?*u64,
    Reserved: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "HTTPAPI" fn HttpCloseUrlGroup(
    UrlGroupId: u64,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "HTTPAPI" fn HttpAddUrlToUrlGroup(
    UrlGroupId: u64,
    pFullyQualifiedUrl: ?*u16,
    UrlContext: u64,
    Reserved: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "HTTPAPI" fn HttpRemoveUrlFromUrlGroup(
    UrlGroupId: u64,
    pFullyQualifiedUrl: ?*u16,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "HTTPAPI" fn HttpSetUrlGroupProperty(
    UrlGroupId: u64,
    Property: HTTP_SERVER_PROPERTY,
    PropertyInformation: ?*opaque{},
    PropertyInformationLength: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "HTTPAPI" fn HttpQueryUrlGroupProperty(
    UrlGroupId: u64,
    Property: HTTP_SERVER_PROPERTY,
    PropertyInformation: ?*opaque{},
    PropertyInformationLength: u32,
    ReturnLength: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "HTTPAPI" fn HttpPrepareUrl(
    Reserved: ?*opaque{},
    Flags: u32,
    Url: ?*u16,
    PreparedUrl: ?*?*u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "HTTPAPI" fn HttpReceiveHttpRequest(
    RequestQueueHandle: HANDLE,
    RequestId: u64,
    Flags: u32,
    RequestBuffer: ?*HTTP_REQUEST_V2,
    RequestBufferLength: u32,
    BytesReturned: ?*u32,
    Overlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "HTTPAPI" fn HttpReceiveRequestEntityBody(
    RequestQueueHandle: HANDLE,
    RequestId: u64,
    Flags: u32,
    EntityBuffer: ?*opaque{},
    EntityBufferLength: u32,
    BytesReturned: ?*u32,
    Overlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "HTTPAPI" fn HttpSendHttpResponse(
    RequestQueueHandle: HANDLE,
    RequestId: u64,
    Flags: u32,
    HttpResponse: ?*HTTP_RESPONSE_V2,
    CachePolicy: ?*HTTP_CACHE_POLICY,
    BytesSent: ?*u32,
    Reserved1: ?*opaque{},
    Reserved2: u32,
    Overlapped: ?*OVERLAPPED,
    LogData: ?*HTTP_LOG_DATA,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "HTTPAPI" fn HttpSendResponseEntityBody(
    RequestQueueHandle: HANDLE,
    RequestId: u64,
    Flags: u32,
    EntityChunkCount: u16,
    EntityChunks: ?*HTTP_DATA_CHUNK,
    BytesSent: ?*u32,
    Reserved1: ?*opaque{},
    Reserved2: u32,
    Overlapped: ?*OVERLAPPED,
    LogData: ?*HTTP_LOG_DATA,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "HTTPAPI" fn HttpDeclarePush(
    RequestQueueHandle: HANDLE,
    RequestId: u64,
    Verb: HTTP_VERB,
    Path: ?*u16,
    Query: ?*i8,
    Headers: ?*HTTP_REQUEST_HEADERS,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "HTTPAPI" fn HttpWaitForDisconnect(
    RequestQueueHandle: HANDLE,
    ConnectionId: u64,
    Overlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "HTTPAPI" fn HttpWaitForDisconnectEx(
    RequestQueueHandle: HANDLE,
    ConnectionId: u64,
    Reserved: u32,
    Overlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "HTTPAPI" fn HttpCancelHttpRequest(
    RequestQueueHandle: HANDLE,
    RequestId: u64,
    Overlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "HTTPAPI" fn HttpWaitForDemandStart(
    RequestQueueHandle: HANDLE,
    Overlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "HTTPAPI" fn HttpFlushResponseCache(
    RequestQueueHandle: HANDLE,
    UrlPrefix: ?*u16,
    Flags: u32,
    Overlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "HTTPAPI" fn HttpAddFragmentToCache(
    RequestQueueHandle: HANDLE,
    UrlPrefix: ?*u16,
    DataChunk: ?*HTTP_DATA_CHUNK,
    CachePolicy: ?*HTTP_CACHE_POLICY,
    Overlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "HTTPAPI" fn HttpReadFragmentFromCache(
    RequestQueueHandle: HANDLE,
    UrlPrefix: ?*u16,
    ByteRange: ?*HTTP_BYTE_RANGE,
    Buffer: ?*opaque{},
    BufferLength: u32,
    BytesRead: ?*u32,
    Overlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "HTTPAPI" fn HttpSetServiceConfiguration(
    ServiceHandle: HANDLE,
    ConfigId: HTTP_SERVICE_CONFIG_ID,
    pConfigInformation: ?*opaque{},
    ConfigInformationLength: u32,
    pOverlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "HTTPAPI" fn HttpUpdateServiceConfiguration(
    Handle: HANDLE,
    ConfigId: HTTP_SERVICE_CONFIG_ID,
    ConfigInfo: ?*opaque{},
    ConfigInfoLength: u32,
    Overlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "HTTPAPI" fn HttpDeleteServiceConfiguration(
    ServiceHandle: HANDLE,
    ConfigId: HTTP_SERVICE_CONFIG_ID,
    pConfigInformation: ?*opaque{},
    ConfigInformationLength: u32,
    pOverlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "HTTPAPI" fn HttpQueryServiceConfiguration(
    ServiceHandle: HANDLE,
    ConfigId: HTTP_SERVICE_CONFIG_ID,
    pInput: ?*opaque{},
    InputLength: u32,
    pOutput: ?*opaque{},
    OutputLength: u32,
    pReturnLength: ?*u32,
    pOverlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "HTTPAPI" fn HttpGetExtension(
    Version: HTTPAPI_VERSION,
    Extension: u32,
    Buffer: ?*opaque{},
    BufferSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "WINHTTP" fn WinHttpSetStatusCallback(
    hInternet: ?*opaque{},
    lpfnInternetCallback: WINHTTP_STATUS_CALLBACK,
    dwNotificationFlags: u32,
    dwReserved: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) WINHTTP_STATUS_CALLBACK;

// set_last_errror=True (can and should we use this?)
pub extern "WINHTTP" fn WinHttpTimeFromSystemTime(
    pst: ?*SYSTEMTIME,
    pwszTime: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "WINHTTP" fn WinHttpTimeToSystemTime(
    pwszTime: ?*u16,
    pst: ?*SYSTEMTIME,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "WINHTTP" fn WinHttpCrackUrl(
    pwszUrl: ?*u16,
    dwUrlLength: u32,
    dwFlags: u32,
    lpUrlComponents: ?*URL_COMPONENTS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "WINHTTP" fn WinHttpCreateUrl(
    lpUrlComponents: ?*URL_COMPONENTS,
    dwFlags: u32,
    pwszUrl: ?*u16,
    pdwUrlLength: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "WINHTTP" fn WinHttpCheckPlatform(
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "WINHTTP" fn WinHttpGetDefaultProxyConfiguration(
    pProxyInfo: ?*WINHTTP_PROXY_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "WINHTTP" fn WinHttpSetDefaultProxyConfiguration(
    pProxyInfo: ?*WINHTTP_PROXY_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "WINHTTP" fn WinHttpOpen(
    pszAgentW: ?*u16,
    dwAccessType: u32,
    pszProxyW: ?*u16,
    pszProxyBypassW: ?*u16,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=True (can and should we use this?)
pub extern "WINHTTP" fn WinHttpCloseHandle(
    hInternet: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "WINHTTP" fn WinHttpConnect(
    hSession: ?*opaque{},
    pswzServerName: ?*u16,
    nServerPort: u16,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=True (can and should we use this?)
pub extern "WINHTTP" fn WinHttpReadData(
    hRequest: ?*opaque{},
    lpBuffer: ?*opaque{},
    dwNumberOfBytesToRead: u32,
    lpdwNumberOfBytesRead: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "WINHTTP" fn WinHttpWriteData(
    hRequest: ?*opaque{},
    lpBuffer: ?*opaque{},
    dwNumberOfBytesToWrite: u32,
    lpdwNumberOfBytesWritten: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "WINHTTP" fn WinHttpQueryDataAvailable(
    hRequest: ?*opaque{},
    lpdwNumberOfBytesAvailable: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "WINHTTP" fn WinHttpQueryOption(
    hInternet: ?*opaque{},
    dwOption: u32,
    lpBuffer: ?*opaque{},
    lpdwBufferLength: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "WINHTTP" fn WinHttpSetOption(
    hInternet: ?*opaque{},
    dwOption: u32,
    lpBuffer: ?*opaque{},
    dwBufferLength: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "WINHTTP" fn WinHttpSetTimeouts(
    hInternet: ?*opaque{},
    nResolveTimeout: i32,
    nConnectTimeout: i32,
    nSendTimeout: i32,
    nReceiveTimeout: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "WINHTTP" fn WinHttpOpenRequest(
    hConnect: ?*opaque{},
    pwszVerb: ?*u16,
    pwszObjectName: ?*u16,
    pwszVersion: ?*u16,
    pwszReferrer: ?*u16,
    ppwszAcceptTypes: ?*?*u16,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=True (can and should we use this?)
pub extern "WINHTTP" fn WinHttpAddRequestHeaders(
    hRequest: ?*opaque{},
    lpszHeaders: ?*u16,
    dwHeadersLength: u32,
    dwModifiers: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "WINHTTP" fn WinHttpAddRequestHeadersEx(
    hRequest: ?*opaque{},
    dwModifiers: u32,
    ullFlags: u64,
    ullExtra: u64,
    cHeaders: u32,
    pHeaders: ?*WINHTTP_EXTENDED_HEADER,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "WINHTTP" fn WinHttpSendRequest(
    hRequest: ?*opaque{},
    lpszHeaders: ?*u16,
    dwHeadersLength: u32,
    lpOptional: ?*opaque{},
    dwOptionalLength: u32,
    dwTotalLength: u32,
    dwContext: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "WINHTTP" fn WinHttpSetCredentials(
    hRequest: ?*opaque{},
    AuthTargets: u32,
    AuthScheme: u32,
    pwszUserName: ?*u16,
    pwszPassword: ?*u16,
    pAuthParams: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "WINHTTP" fn WinHttpQueryAuthSchemes(
    hRequest: ?*opaque{},
    lpdwSupportedSchemes: ?*u32,
    lpdwFirstScheme: ?*u32,
    pdwAuthTarget: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "WINHTTP" fn WinHttpReceiveResponse(
    hRequest: ?*opaque{},
    lpReserved: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "WINHTTP" fn WinHttpQueryHeaders(
    hRequest: ?*opaque{},
    dwInfoLevel: u32,
    pwszName: ?*u16,
    lpBuffer: ?*opaque{},
    lpdwBufferLength: ?*u32,
    lpdwIndex: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "WINHTTP" fn WinHttpDetectAutoProxyConfigUrl(
    dwAutoDetectFlags: u32,
    ppwstrAutoConfigUrl: ?*?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "WINHTTP" fn WinHttpGetProxyForUrl(
    hSession: ?*opaque{},
    lpcwszUrl: ?*u16,
    pAutoProxyOptions: ?*WINHTTP_AUTOPROXY_OPTIONS,
    pProxyInfo: ?*WINHTTP_PROXY_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "WINHTTP" fn WinHttpCreateProxyResolver(
    hSession: ?*opaque{},
    phResolver: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINHTTP" fn WinHttpGetProxyForUrlEx(
    hResolver: ?*opaque{},
    pcwszUrl: ?*u16,
    pAutoProxyOptions: ?*WINHTTP_AUTOPROXY_OPTIONS,
    pContext: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINHTTP" fn WinHttpGetProxyForUrlEx2(
    hResolver: ?*opaque{},
    pcwszUrl: ?*u16,
    pAutoProxyOptions: ?*WINHTTP_AUTOPROXY_OPTIONS,
    cbInterfaceSelectionContext: u32,
    pInterfaceSelectionContext: ?*u8,
    pContext: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINHTTP" fn WinHttpGetProxyResult(
    hResolver: ?*opaque{},
    pProxyResult: ?*WINHTTP_PROXY_RESULT,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINHTTP" fn WinHttpGetProxyResultEx(
    hResolver: ?*opaque{},
    pProxyResultEx: ?*WINHTTP_PROXY_RESULT_EX,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINHTTP" fn WinHttpFreeProxyResult(
    pProxyResult: ?*WINHTTP_PROXY_RESULT,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "WINHTTP" fn WinHttpFreeProxyResultEx(
    pProxyResultEx: ?*WINHTTP_PROXY_RESULT_EX,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "WINHTTP" fn WinHttpResetAutoProxy(
    hSession: ?*opaque{},
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "WINHTTP" fn WinHttpGetIEProxyConfigForCurrentUser(
    pProxyConfig: ?*WINHTTP_CURRENT_USER_IE_PROXY_CONFIG,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "WINHTTP" fn WinHttpWriteProxySettings(
    hSession: ?*opaque{},
    fForceUpdate: BOOL,
    pWinHttpProxySettings: ?*WINHTTP_PROXY_SETTINGS,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINHTTP" fn WinHttpReadProxySettings(
    hSession: ?*opaque{},
    pcwszConnectionName: ?*u16,
    fFallBackToDefaultSettings: BOOL,
    fSetAutoDiscoverForDefaultSettings: BOOL,
    pdwSettingsVersion: ?*u32,
    pfDefaultSettingsAreReturned: ?*i32,
    pWinHttpProxySettings: ?*WINHTTP_PROXY_SETTINGS,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINHTTP" fn WinHttpFreeProxySettings(
    pWinHttpProxySettings: ?*WINHTTP_PROXY_SETTINGS,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "WINHTTP" fn WinHttpGetProxySettingsVersion(
    hSession: ?*opaque{},
    pdwProxySettingsVersion: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINHTTP" fn WinHttpSetProxySettingsPerUser(
    fProxySettingsPerUser: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "WINHTTP" fn WinHttpWebSocketCompleteUpgrade(
    hRequest: ?*opaque{},
    pContext: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=False (can and should we use this?)
pub extern "WINHTTP" fn WinHttpWebSocketSend(
    hWebSocket: ?*opaque{},
    eBufferType: WINHTTP_WEB_SOCKET_BUFFER_TYPE,
    pvBuffer: ?*opaque{},
    dwBufferLength: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINHTTP" fn WinHttpWebSocketReceive(
    hWebSocket: ?*opaque{},
    pvBuffer: ?*opaque{},
    dwBufferLength: u32,
    pdwBytesRead: ?*u32,
    peBufferType: ?*WINHTTP_WEB_SOCKET_BUFFER_TYPE,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINHTTP" fn WinHttpWebSocketShutdown(
    hWebSocket: ?*opaque{},
    usStatus: u16,
    pvReason: ?*opaque{},
    dwReasonLength: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINHTTP" fn WinHttpWebSocketClose(
    hWebSocket: ?*opaque{},
    usStatus: u16,
    pvReason: ?*opaque{},
    dwReasonLength: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINHTTP" fn WinHttpWebSocketQueryCloseStatus(
    hWebSocket: ?*opaque{},
    pusStatus: ?*u16,
    pvReason: ?*opaque{},
    dwReasonLength: u32,
    pdwReasonLengthConsumed: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

//
// Unicode Symbol Aliases
//
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {
        pub const HTTP_SERVICE_BINDING_ = HTTP_SERVICE_BINDING_A;
    },
    .wide => struct {
        pub const HTTP_SERVICE_BINDING_ = HTTP_SERVICE_BINDING_W;
    },
    else => if (@import("builtin").is_test) struct {
        pub const HTTP_SERVICE_BINDING_ = *opaque{};
    } else struct {
        pub const HTTP_SERVICE_BINDING_ = @compileError("'HTTP_SERVICE_BINDING_' requires that UNICODE be set to true or false in the root module");
    },
};

//
// type imports
//
const Guid = @import("../zig.zig").Guid;
const HANDLE = @import("systemservices.zig").HANDLE;
const ULARGE_INTEGER = @import("systemservices.zig").ULARGE_INTEGER;
const SOCKADDR = @import("winsock.zig").SOCKADDR;
const SOCKADDR_STORAGE_LH = @import("networkdrivers.zig").SOCKADDR_STORAGE_LH;
const INTERNET_SCHEME = @import("wininet.zig").INTERNET_SCHEME;
const BOOL = @import("systemservices.zig").BOOL;
const FILETIME = @import("windowsprogramming.zig").FILETIME;
const SECURITY_ATTRIBUTES = @import("systemservices.zig").SECURITY_ATTRIBUTES;
const OVERLAPPED = @import("systemservices.zig").OVERLAPPED;
const SYSTEMTIME = @import("windowsprogramming.zig").SYSTEMTIME;

test "" {
    const constant_export_count = 0;
    const type_export_count = 135;
    const func_count = 86;
    const unicode_alias_count = 1;
    const type_import_count = 11;
    @setEvalBranchQuota(0
        + constant_export_count
        + type_export_count
        + func_count
        + unicode_alias_count
        + type_import_count
        + 2 // TODO: why do I need these extra 2?
    );
    @import("std").testing.refAllDecls(@This());
}
