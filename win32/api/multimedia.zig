//! NOTE: this source file is autogenerated, DO NOT MODIFY

//
// constants
//

//
// types
//
// --------------------------------------------------------
// Type: MMTIME
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const MMTIME = *opaque{
    // --------------------------------------------------------
    // Type: _u_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _u_e__Union = *opaque{
        // --------------------------------------------------------
        // Type: _smpte_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _smpte_e__Struct = extern struct {
            hour: u8,
            min: u8,
            sec: u8,
            frame: u8,
            fps: u8,
            dummy: u8,
            pad: ?[*]u8,
        };
        // --------------------------------------------------------
        // Type: _midi_e__Struct
        // TypeLayoutAttr: sequential
        // not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
        pub const _midi_e__Struct = *opaque{
        };
    };
};
// --------------------------------------------------------
// Type: HDRVR__
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const HDRVR__ = *opaque{
};
// --------------------------------------------------------
// Type: DRVCALLBACK
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const DRVCALLBACK = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: LPDRVCALLBACK
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const LPDRVCALLBACK = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PDRVCALLBACK
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PDRVCALLBACK = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: DRVCONFIGINFOEX
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const DRVCONFIGINFOEX = *opaque{
};
// --------------------------------------------------------
// Type: DRVCONFIGINFO
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const DRVCONFIGINFO = *opaque{
};
// --------------------------------------------------------
// Type: DRIVERPROC
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const DRIVERPROC = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: DRIVERMSGPROC
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const DRIVERMSGPROC = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: HMMIO__
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const HMMIO__ = *opaque{
};
// --------------------------------------------------------
// Type: MMIOPROC
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const MMIOPROC = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: LPMMIOPROC
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const LPMMIOPROC = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: MMIOINFO
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const MMIOINFO = *opaque{
};
// --------------------------------------------------------
// Type: MMCKINFO
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const MMCKINFO = *opaque{
};
// --------------------------------------------------------
// Type: HWAVE__
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const HWAVE__ = *opaque{
};
// --------------------------------------------------------
// Type: HWAVEIN__
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const HWAVEIN__ = *opaque{
};
// --------------------------------------------------------
// Type: HWAVEOUT__
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const HWAVEOUT__ = *opaque{
};
// --------------------------------------------------------
// Type: WAVECALLBACK
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const WAVECALLBACK = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: LPWAVECALLBACK
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const LPWAVECALLBACK = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: WAVEHDR
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const WAVEHDR = *opaque{
};
// --------------------------------------------------------
// Type: WAVEOUTCAPSA
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const WAVEOUTCAPSA = *opaque{
};
// --------------------------------------------------------
// Type: WAVEOUTCAPSW
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const WAVEOUTCAPSW = *opaque{
};
// --------------------------------------------------------
// Type: WAVEOUTCAPS2A
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const WAVEOUTCAPS2A = *opaque{
};
// --------------------------------------------------------
// Type: WAVEOUTCAPS2W
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const WAVEOUTCAPS2W = *opaque{
};
// --------------------------------------------------------
// Type: WAVEINCAPSA
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const WAVEINCAPSA = *opaque{
};
// --------------------------------------------------------
// Type: WAVEINCAPSW
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const WAVEINCAPSW = *opaque{
};
// --------------------------------------------------------
// Type: WAVEINCAPS2A
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const WAVEINCAPS2A = *opaque{
};
// --------------------------------------------------------
// Type: WAVEINCAPS2W
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const WAVEINCAPS2W = *opaque{
};
// --------------------------------------------------------
// Type: WAVEFORMAT
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const WAVEFORMAT = *opaque{
};
// --------------------------------------------------------
// Type: PCMWAVEFORMAT
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const PCMWAVEFORMAT = *opaque{
};
// --------------------------------------------------------
// Type: WAVEFORMATEX
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const WAVEFORMATEX = *opaque{
};
// --------------------------------------------------------
// Type: HMIDI__
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const HMIDI__ = *opaque{
};
// --------------------------------------------------------
// Type: HMIDIIN__
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const HMIDIIN__ = *opaque{
};
// --------------------------------------------------------
// Type: HMIDIOUT__
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const HMIDIOUT__ = *opaque{
};
// --------------------------------------------------------
// Type: HMIDISTRM__
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const HMIDISTRM__ = *opaque{
};
// --------------------------------------------------------
// Type: MIDICALLBACK
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const MIDICALLBACK = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: LPMIDICALLBACK
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const LPMIDICALLBACK = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: MIDIOUTCAPSA
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const MIDIOUTCAPSA = *opaque{
};
// --------------------------------------------------------
// Type: MIDIOUTCAPSW
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const MIDIOUTCAPSW = *opaque{
};
// --------------------------------------------------------
// Type: MIDIOUTCAPS2A
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const MIDIOUTCAPS2A = *opaque{
};
// --------------------------------------------------------
// Type: MIDIOUTCAPS2W
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const MIDIOUTCAPS2W = *opaque{
};
// --------------------------------------------------------
// Type: MIDIINCAPSA
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const MIDIINCAPSA = *opaque{
};
// --------------------------------------------------------
// Type: MIDIINCAPSW
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const MIDIINCAPSW = *opaque{
};
// --------------------------------------------------------
// Type: MIDIINCAPS2A
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const MIDIINCAPS2A = *opaque{
};
// --------------------------------------------------------
// Type: MIDIINCAPS2W
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const MIDIINCAPS2W = *opaque{
};
// --------------------------------------------------------
// Type: MIDIHDR
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const MIDIHDR = *opaque{
};
// --------------------------------------------------------
// Type: MIDIEVENT
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const MIDIEVENT = *opaque{
};
// --------------------------------------------------------
// Type: MIDISTRMBUFFVER
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const MIDISTRMBUFFVER = *opaque{
};
// --------------------------------------------------------
// Type: MIDIPROPTIMEDIV
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const MIDIPROPTIMEDIV = *opaque{
};
// --------------------------------------------------------
// Type: MIDIPROPTEMPO
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const MIDIPROPTEMPO = *opaque{
};
// --------------------------------------------------------
// Type: AUXCAPSA
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const AUXCAPSA = *opaque{
};
// --------------------------------------------------------
// Type: AUXCAPSW
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const AUXCAPSW = *opaque{
};
// --------------------------------------------------------
// Type: AUXCAPS2A
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const AUXCAPS2A = *opaque{
};
// --------------------------------------------------------
// Type: AUXCAPS2W
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const AUXCAPS2W = *opaque{
};
// --------------------------------------------------------
// Type: HMIXEROBJ__
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const HMIXEROBJ__ = *opaque{
};
// --------------------------------------------------------
// Type: HMIXER__
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const HMIXER__ = *opaque{
};
// --------------------------------------------------------
// Type: MIXERCAPSA
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const MIXERCAPSA = *opaque{
};
// --------------------------------------------------------
// Type: MIXERCAPSW
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const MIXERCAPSW = *opaque{
};
// --------------------------------------------------------
// Type: MIXERCAPS2A
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const MIXERCAPS2A = *opaque{
};
// --------------------------------------------------------
// Type: MIXERCAPS2W
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const MIXERCAPS2W = *opaque{
};
// --------------------------------------------------------
// Type: MIXERLINEA
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const MIXERLINEA = *opaque{
    // --------------------------------------------------------
    // Type: _Target_e__Struct
    // TypeLayoutAttr: sequential
    // not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
    pub const _Target_e__Struct = *opaque{
    };
};
// --------------------------------------------------------
// Type: MIXERLINEW
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const MIXERLINEW = *opaque{
    // --------------------------------------------------------
    // Type: _Target_e__Struct
    // TypeLayoutAttr: sequential
    // not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
    pub const _Target_e__Struct = *opaque{
    };
};
// --------------------------------------------------------
// Type: MIXERCONTROLA
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const MIXERCONTROLA = *opaque{
    // --------------------------------------------------------
    // Type: _Bounds_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Bounds_e__Union = *opaque{
        // --------------------------------------------------------
        // Type: _Anonymous2_e__Struct
        // TypeLayoutAttr: sequential
        // not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
        pub const _Anonymous2_e__Struct = *opaque{
        };
        // --------------------------------------------------------
        // Type: _Anonymous1_e__Struct
        // TypeLayoutAttr: sequential
        // not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
        pub const _Anonymous1_e__Struct = *opaque{
        };
    };
    // --------------------------------------------------------
    // Type: _Metrics_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Metrics_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: MIXERCONTROLW
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const MIXERCONTROLW = *opaque{
    // --------------------------------------------------------
    // Type: _Metrics_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Metrics_e__Union = *opaque{
    };
    // --------------------------------------------------------
    // Type: _Bounds_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Bounds_e__Union = *opaque{
        // --------------------------------------------------------
        // Type: _Anonymous1_e__Struct
        // TypeLayoutAttr: sequential
        // not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
        pub const _Anonymous1_e__Struct = *opaque{
        };
        // --------------------------------------------------------
        // Type: _Anonymous2_e__Struct
        // TypeLayoutAttr: sequential
        // not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
        pub const _Anonymous2_e__Struct = *opaque{
        };
    };
};
// --------------------------------------------------------
// Type: MIXERLINECONTROLSA
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const MIXERLINECONTROLSA = *opaque{
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: MIXERLINECONTROLSW
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const MIXERLINECONTROLSW = *opaque{
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: MIXERCONTROLDETAILS
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const MIXERCONTROLDETAILS = *opaque{
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: MIXERCONTROLDETAILS_LISTTEXTA
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const MIXERCONTROLDETAILS_LISTTEXTA = *opaque{
};
// --------------------------------------------------------
// Type: MIXERCONTROLDETAILS_LISTTEXTW
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const MIXERCONTROLDETAILS_LISTTEXTW = *opaque{
};
// --------------------------------------------------------
// Type: MIXERCONTROLDETAILS_BOOLEAN
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const MIXERCONTROLDETAILS_BOOLEAN = *opaque{
};
// --------------------------------------------------------
// Type: MIXERCONTROLDETAILS_SIGNED
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const MIXERCONTROLDETAILS_SIGNED = *opaque{
};
// --------------------------------------------------------
// Type: MIXERCONTROLDETAILS_UNSIGNED
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const MIXERCONTROLDETAILS_UNSIGNED = *opaque{
};
// --------------------------------------------------------
// Type: TIMECAPS
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const TIMECAPS = *opaque{
};
// --------------------------------------------------------
// Type: JOYCAPSA
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const JOYCAPSA = *opaque{
};
// --------------------------------------------------------
// Type: JOYCAPSW
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const JOYCAPSW = *opaque{
};
// --------------------------------------------------------
// Type: JOYCAPS2A
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const JOYCAPS2A = *opaque{
};
// --------------------------------------------------------
// Type: JOYCAPS2W
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const JOYCAPS2W = *opaque{
};
// --------------------------------------------------------
// Type: JOYINFO
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const JOYINFO = *opaque{
};
// --------------------------------------------------------
// Type: JOYINFOEX
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const JOYINFOEX = *opaque{
};
// --------------------------------------------------------
// Type: KSDATAFORMAT_SUBTYPE_PCM
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const KSDATAFORMAT_SUBTYPE_PCM = opaque {
};
// --------------------------------------------------------
// Type: KSDATAFORMAT_SUBTYPE_IEEE_FLOAT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const KSDATAFORMAT_SUBTYPE_IEEE_FLOAT = opaque {
};
// --------------------------------------------------------
// Type: KSDATAFORMAT_SUBTYPE_WAVEFORMATEX
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const KSDATAFORMAT_SUBTYPE_WAVEFORMATEX = opaque {
};
// --------------------------------------------------------
// Type: WAVEFORMATEXTENSIBLE
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const WAVEFORMATEXTENSIBLE = *opaque{
    // --------------------------------------------------------
    // Type: _Samples_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Samples_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: ADPCMCOEFSET
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const ADPCMCOEFSET = *opaque{
};
// --------------------------------------------------------
// Type: ADPCMWAVEFORMAT
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const ADPCMWAVEFORMAT = *opaque{
};
// --------------------------------------------------------
// Type: DRMWAVEFORMAT
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const DRMWAVEFORMAT = *opaque{
};
// --------------------------------------------------------
// Type: DVIADPCMWAVEFORMAT
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const DVIADPCMWAVEFORMAT = *opaque{
};
// --------------------------------------------------------
// Type: IMAADPCMWAVEFORMAT
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const IMAADPCMWAVEFORMAT = *opaque{
};
// --------------------------------------------------------
// Type: MEDIASPACEADPCMWAVEFORMAT
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const MEDIASPACEADPCMWAVEFORMAT = *opaque{
};
// --------------------------------------------------------
// Type: SIERRAADPCMWAVEFORMAT
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const SIERRAADPCMWAVEFORMAT = *opaque{
};
// --------------------------------------------------------
// Type: G723_ADPCMWAVEFORMAT
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const G723_ADPCMWAVEFORMAT = *opaque{
};
// --------------------------------------------------------
// Type: DIGISTDWAVEFORMAT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DIGISTDWAVEFORMAT = extern struct {
    wfx: WAVEFORMATEX,
};
// --------------------------------------------------------
// Type: DIGIFIXWAVEFORMAT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DIGIFIXWAVEFORMAT = extern struct {
    wfx: WAVEFORMATEX,
};
// --------------------------------------------------------
// Type: DIALOGICOKIADPCMWAVEFORMAT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DIALOGICOKIADPCMWAVEFORMAT = extern struct {
    ewf: WAVEFORMATEX,
};
// --------------------------------------------------------
// Type: YAMAHA_ADPCMWAVEFORMAT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const YAMAHA_ADPCMWAVEFORMAT = extern struct {
    wfx: WAVEFORMATEX,
};
// --------------------------------------------------------
// Type: SONARCWAVEFORMAT
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const SONARCWAVEFORMAT = *opaque{
};
// --------------------------------------------------------
// Type: TRUESPEECHWAVEFORMAT
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const TRUESPEECHWAVEFORMAT = *opaque{
};
// --------------------------------------------------------
// Type: ECHOSC1WAVEFORMAT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const ECHOSC1WAVEFORMAT = extern struct {
    wfx: WAVEFORMATEX,
};
// --------------------------------------------------------
// Type: AUDIOFILE_AF36WAVEFORMAT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const AUDIOFILE_AF36WAVEFORMAT = extern struct {
    wfx: WAVEFORMATEX,
};
// --------------------------------------------------------
// Type: APTXWAVEFORMAT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const APTXWAVEFORMAT = extern struct {
    wfx: WAVEFORMATEX,
};
// --------------------------------------------------------
// Type: AUDIOFILE_AF10WAVEFORMAT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const AUDIOFILE_AF10WAVEFORMAT = extern struct {
    wfx: WAVEFORMATEX,
};
// --------------------------------------------------------
// Type: DOLBYAC2WAVEFORMAT
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const DOLBYAC2WAVEFORMAT = *opaque{
};
// --------------------------------------------------------
// Type: GSM610WAVEFORMAT
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const GSM610WAVEFORMAT = *opaque{
};
// --------------------------------------------------------
// Type: ADPCMEWAVEFORMAT
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const ADPCMEWAVEFORMAT = *opaque{
};
// --------------------------------------------------------
// Type: CONTRESVQLPCWAVEFORMAT
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const CONTRESVQLPCWAVEFORMAT = *opaque{
};
// --------------------------------------------------------
// Type: DIGIREALWAVEFORMAT
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const DIGIREALWAVEFORMAT = *opaque{
};
// --------------------------------------------------------
// Type: DIGIADPCMWAVEFORMAT
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const DIGIADPCMWAVEFORMAT = *opaque{
};
// --------------------------------------------------------
// Type: CONTRESCR10WAVEFORMAT
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const CONTRESCR10WAVEFORMAT = *opaque{
};
// --------------------------------------------------------
// Type: NMS_VBXADPCMWAVEFORMAT
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const NMS_VBXADPCMWAVEFORMAT = *opaque{
};
// --------------------------------------------------------
// Type: G721_ADPCMWAVEFORMAT
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const G721_ADPCMWAVEFORMAT = *opaque{
};
// --------------------------------------------------------
// Type: MSAUDIO1WAVEFORMAT
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const MSAUDIO1WAVEFORMAT = *opaque{
};
// --------------------------------------------------------
// Type: WMAUDIO2WAVEFORMAT
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const WMAUDIO2WAVEFORMAT = *opaque{
};
// --------------------------------------------------------
// Type: WMAUDIO3WAVEFORMAT
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const WMAUDIO3WAVEFORMAT = *opaque{
};
// --------------------------------------------------------
// Type: CREATIVEADPCMWAVEFORMAT
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const CREATIVEADPCMWAVEFORMAT = *opaque{
};
// --------------------------------------------------------
// Type: CREATIVEFASTSPEECH8WAVEFORMAT
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const CREATIVEFASTSPEECH8WAVEFORMAT = *opaque{
};
// --------------------------------------------------------
// Type: CREATIVEFASTSPEECH10WAVEFORMAT
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const CREATIVEFASTSPEECH10WAVEFORMAT = *opaque{
};
// --------------------------------------------------------
// Type: FMTOWNS_SND_WAVEFORMAT
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const FMTOWNS_SND_WAVEFORMAT = *opaque{
};
// --------------------------------------------------------
// Type: OLIGSMWAVEFORMAT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const OLIGSMWAVEFORMAT = extern struct {
    wfx: WAVEFORMATEX,
};
// --------------------------------------------------------
// Type: OLIADPCMWAVEFORMAT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const OLIADPCMWAVEFORMAT = extern struct {
    wfx: WAVEFORMATEX,
};
// --------------------------------------------------------
// Type: OLICELPWAVEFORMAT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const OLICELPWAVEFORMAT = extern struct {
    wfx: WAVEFORMATEX,
};
// --------------------------------------------------------
// Type: OLISBCWAVEFORMAT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const OLISBCWAVEFORMAT = extern struct {
    wfx: WAVEFORMATEX,
};
// --------------------------------------------------------
// Type: OLIOPRWAVEFORMAT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const OLIOPRWAVEFORMAT = extern struct {
    wfx: WAVEFORMATEX,
};
// --------------------------------------------------------
// Type: CSIMAADPCMWAVEFORMAT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CSIMAADPCMWAVEFORMAT = extern struct {
    wfx: WAVEFORMATEX,
};
// --------------------------------------------------------
// Type: WAVEFILTER
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const WAVEFILTER = *opaque{
};
// --------------------------------------------------------
// Type: VOLUMEWAVEFILTER
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const VOLUMEWAVEFILTER = *opaque{
};
// --------------------------------------------------------
// Type: ECHOWAVEFILTER
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const ECHOWAVEFILTER = *opaque{
};
// --------------------------------------------------------
// Type: s_RIFFWAVE_inst
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const s_RIFFWAVE_inst = extern struct {
    bUnshiftedNote: u8,
    chFineTune: i8,
    chGain: i8,
    bLowNote: u8,
    bHighNote: u8,
    bLowVelocity: u8,
    bHighVelocity: u8,
};
// --------------------------------------------------------
// Type: tag_s_RIFFWAVE_INST
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const tag_s_RIFFWAVE_INST = opaque {
};
// --------------------------------------------------------
// Type: EXBMINFOHEADER
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const EXBMINFOHEADER = *opaque{
};
// --------------------------------------------------------
// Type: JPEGINFOHEADER
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const JPEGINFOHEADER = *opaque{
};
// --------------------------------------------------------
// Type: MCI_DGV_RECT_PARMS
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const MCI_DGV_RECT_PARMS = *opaque{
};
// --------------------------------------------------------
// Type: MCI_DGV_CAPTURE_PARMSA
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const MCI_DGV_CAPTURE_PARMSA = *opaque{
};
// --------------------------------------------------------
// Type: MCI_DGV_CAPTURE_PARMSW
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const MCI_DGV_CAPTURE_PARMSW = *opaque{
};
// --------------------------------------------------------
// Type: MCI_DGV_COPY_PARMS
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const MCI_DGV_COPY_PARMS = *opaque{
};
// --------------------------------------------------------
// Type: MCI_DGV_CUE_PARMS
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const MCI_DGV_CUE_PARMS = *opaque{
};
// --------------------------------------------------------
// Type: MCI_DGV_CUT_PARMS
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const MCI_DGV_CUT_PARMS = *opaque{
};
// --------------------------------------------------------
// Type: MCI_DGV_DELETE_PARMS
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const MCI_DGV_DELETE_PARMS = *opaque{
};
// --------------------------------------------------------
// Type: MCI_DGV_INFO_PARMSA
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const MCI_DGV_INFO_PARMSA = *opaque{
};
// --------------------------------------------------------
// Type: MCI_DGV_INFO_PARMSW
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const MCI_DGV_INFO_PARMSW = *opaque{
};
// --------------------------------------------------------
// Type: MCI_DGV_LIST_PARMSA
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const MCI_DGV_LIST_PARMSA = *opaque{
};
// --------------------------------------------------------
// Type: MCI_DGV_LIST_PARMSW
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const MCI_DGV_LIST_PARMSW = *opaque{
};
// --------------------------------------------------------
// Type: MCI_DGV_MONITOR_PARMS
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const MCI_DGV_MONITOR_PARMS = *opaque{
};
// --------------------------------------------------------
// Type: MCI_DGV_OPEN_PARMSA
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const MCI_DGV_OPEN_PARMSA = *opaque{
};
// --------------------------------------------------------
// Type: MCI_DGV_OPEN_PARMSW
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const MCI_DGV_OPEN_PARMSW = *opaque{
};
// --------------------------------------------------------
// Type: MCI_DGV_PASTE_PARMS
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const MCI_DGV_PASTE_PARMS = *opaque{
};
// --------------------------------------------------------
// Type: MCI_DGV_QUALITY_PARMSA
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const MCI_DGV_QUALITY_PARMSA = *opaque{
};
// --------------------------------------------------------
// Type: MCI_DGV_QUALITY_PARMSW
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const MCI_DGV_QUALITY_PARMSW = *opaque{
};
// --------------------------------------------------------
// Type: MCI_DGV_RECORD_PARMS
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const MCI_DGV_RECORD_PARMS = *opaque{
};
// --------------------------------------------------------
// Type: MCI_DGV_RESERVE_PARMSA
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const MCI_DGV_RESERVE_PARMSA = *opaque{
};
// --------------------------------------------------------
// Type: MCI_DGV_RESERVE_PARMSW
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const MCI_DGV_RESERVE_PARMSW = *opaque{
};
// --------------------------------------------------------
// Type: MCI_DGV_RESTORE_PARMSA
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const MCI_DGV_RESTORE_PARMSA = *opaque{
};
// --------------------------------------------------------
// Type: MCI_DGV_RESTORE_PARMSW
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const MCI_DGV_RESTORE_PARMSW = *opaque{
};
// --------------------------------------------------------
// Type: MCI_DGV_SAVE_PARMSA
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const MCI_DGV_SAVE_PARMSA = *opaque{
};
// --------------------------------------------------------
// Type: MCI_DGV_SAVE_PARMSW
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const MCI_DGV_SAVE_PARMSW = *opaque{
};
// --------------------------------------------------------
// Type: MCI_DGV_SET_PARMS
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const MCI_DGV_SET_PARMS = *opaque{
};
// --------------------------------------------------------
// Type: MCI_DGV_SETAUDIO_PARMSA
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const MCI_DGV_SETAUDIO_PARMSA = *opaque{
};
// --------------------------------------------------------
// Type: MCI_DGV_SETAUDIO_PARMSW
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const MCI_DGV_SETAUDIO_PARMSW = *opaque{
};
// --------------------------------------------------------
// Type: MCI_DGV_SIGNAL_PARMS
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const MCI_DGV_SIGNAL_PARMS = *opaque{
};
// --------------------------------------------------------
// Type: MCI_DGV_SETVIDEO_PARMSA
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const MCI_DGV_SETVIDEO_PARMSA = *opaque{
};
// --------------------------------------------------------
// Type: MCI_DGV_SETVIDEO_PARMSW
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const MCI_DGV_SETVIDEO_PARMSW = *opaque{
};
// --------------------------------------------------------
// Type: MCI_DGV_STATUS_PARMSA
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const MCI_DGV_STATUS_PARMSA = *opaque{
};
// --------------------------------------------------------
// Type: MCI_DGV_STATUS_PARMSW
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const MCI_DGV_STATUS_PARMSW = *opaque{
};
// --------------------------------------------------------
// Type: MCI_DGV_STEP_PARMS
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const MCI_DGV_STEP_PARMS = *opaque{
};
// --------------------------------------------------------
// Type: MCI_DGV_UPDATE_PARMS
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const MCI_DGV_UPDATE_PARMS = *opaque{
};
// --------------------------------------------------------
// Type: MCI_DGV_WINDOW_PARMSA
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const MCI_DGV_WINDOW_PARMSA = *opaque{
};
// --------------------------------------------------------
// Type: MCI_DGV_WINDOW_PARMSW
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const MCI_DGV_WINDOW_PARMSW = *opaque{
};
// --------------------------------------------------------
// Type: HACMDRIVERID__
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const HACMDRIVERID__ = *opaque{
};
// --------------------------------------------------------
// Type: HACMDRIVER__
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const HACMDRIVER__ = *opaque{
};
// --------------------------------------------------------
// Type: HACMSTREAM__
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const HACMSTREAM__ = *opaque{
};
// --------------------------------------------------------
// Type: HACMOBJ__
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const HACMOBJ__ = *opaque{
};
// --------------------------------------------------------
// Type: ACMDRIVERENUMCB
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const ACMDRIVERENUMCB = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: ACMDRIVERPROC
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const ACMDRIVERPROC = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: LPACMDRIVERPROC
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const LPACMDRIVERPROC = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: tACMDRIVERDETAILSA
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const tACMDRIVERDETAILSA = *opaque{
};
// --------------------------------------------------------
// Type: tACMDRIVERDETAILSW
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const tACMDRIVERDETAILSW = *opaque{
};
// --------------------------------------------------------
// Type: tACMFORMATTAGDETAILSA
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const tACMFORMATTAGDETAILSA = *opaque{
};
// --------------------------------------------------------
// Type: tACMFORMATTAGDETAILSW
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const tACMFORMATTAGDETAILSW = *opaque{
};
// --------------------------------------------------------
// Type: ACMFORMATTAGENUMCBA
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const ACMFORMATTAGENUMCBA = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: ACMFORMATTAGENUMCBW
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const ACMFORMATTAGENUMCBW = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: tACMFORMATDETAILSA
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const tACMFORMATDETAILSA = *opaque{
};
// --------------------------------------------------------
// Type: tACMFORMATDETAILSW
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const tACMFORMATDETAILSW = *opaque{
};
// --------------------------------------------------------
// Type: ACMFORMATENUMCBA
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const ACMFORMATENUMCBA = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: ACMFORMATENUMCBW
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const ACMFORMATENUMCBW = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: ACMFORMATCHOOSEHOOKPROCA
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const ACMFORMATCHOOSEHOOKPROCA = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: ACMFORMATCHOOSEHOOKPROCW
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const ACMFORMATCHOOSEHOOKPROCW = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: tACMFORMATCHOOSEA
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const tACMFORMATCHOOSEA = *opaque{
};
// --------------------------------------------------------
// Type: tACMFORMATCHOOSEW
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const tACMFORMATCHOOSEW = *opaque{
};
// --------------------------------------------------------
// Type: tACMFILTERTAGDETAILSA
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const tACMFILTERTAGDETAILSA = *opaque{
};
// --------------------------------------------------------
// Type: tACMFILTERTAGDETAILSW
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const tACMFILTERTAGDETAILSW = *opaque{
};
// --------------------------------------------------------
// Type: ACMFILTERTAGENUMCBA
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const ACMFILTERTAGENUMCBA = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: ACMFILTERTAGENUMCBW
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const ACMFILTERTAGENUMCBW = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: tACMFILTERDETAILSA
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const tACMFILTERDETAILSA = *opaque{
};
// --------------------------------------------------------
// Type: tACMFILTERDETAILSW
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const tACMFILTERDETAILSW = *opaque{
};
// --------------------------------------------------------
// Type: ACMFILTERENUMCBA
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const ACMFILTERENUMCBA = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: ACMFILTERENUMCBW
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const ACMFILTERENUMCBW = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: ACMFILTERCHOOSEHOOKPROCA
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const ACMFILTERCHOOSEHOOKPROCA = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: ACMFILTERCHOOSEHOOKPROCW
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const ACMFILTERCHOOSEHOOKPROCW = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: tACMFILTERCHOOSEA
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const tACMFILTERCHOOSEA = *opaque{
};
// --------------------------------------------------------
// Type: tACMFILTERCHOOSEW
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const tACMFILTERCHOOSEW = *opaque{
};
// --------------------------------------------------------
// Type: ACMSTREAMHEADER
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const ACMSTREAMHEADER = *opaque{
};
// --------------------------------------------------------
// Type: HIC__
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HIC__ = extern struct {
    unused: i32,
};
// --------------------------------------------------------
// Type: ICOPEN
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const ICOPEN = extern struct {
    dwSize: u32,
    fccType: u32,
    fccHandler: u32,
    dwVersion: u32,
    dwFlags: u32,
    dwError: LRESULT,
    pV1Reserved: ?*opaque{},
    pV2Reserved: ?*opaque{},
    dnDevNode: u32,
};
// --------------------------------------------------------
// Type: ICINFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const ICINFO = extern struct {
    dwSize: u32,
    fccType: u32,
    fccHandler: u32,
    dwFlags: u32,
    dwVersion: u32,
    dwVersionICM: u32,
    szName: ?[*]u16,
    szDescription: ?[*]u16,
    szDriver: ?[*]u16,
};
// --------------------------------------------------------
// Type: ICCOMPRESS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const ICCOMPRESS = extern struct {
    dwFlags: u32,
    lpbiOutput: ?*BITMAPINFOHEADER,
    lpOutput: ?*opaque{},
    lpbiInput: ?*BITMAPINFOHEADER,
    lpInput: ?*opaque{},
    lpckid: ?*u32,
    lpdwFlags: ?*u32,
    lFrameNum: i32,
    dwFrameSize: u32,
    dwQuality: u32,
    lpbiPrev: ?*BITMAPINFOHEADER,
    lpPrev: ?*opaque{},
};
// --------------------------------------------------------
// Type: ICCOMPRESSFRAMES
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const ICCOMPRESSFRAMES = extern struct {
    dwFlags: u32,
    lpbiOutput: ?*BITMAPINFOHEADER,
    lOutput: LPARAM,
    lpbiInput: ?*BITMAPINFOHEADER,
    lInput: LPARAM,
    lStartFrame: i32,
    lFrameCount: i32,
    lQuality: i32,
    lDataRate: i32,
    lKeyRate: i32,
    dwRate: u32,
    dwScale: u32,
    dwOverheadPerFrame: u32,
    dwReserved2: u32,
    GetData: ?*opaque{},
    PutData: ?*opaque{},
};
// --------------------------------------------------------
// Type: ICSETSTATUSPROC
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const ICSETSTATUSPROC = extern struct {
    dwFlags: u32,
    lParam: LPARAM,
    Status: ?*opaque{},
};
// --------------------------------------------------------
// Type: ICDECOMPRESS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const ICDECOMPRESS = extern struct {
    dwFlags: u32,
    lpbiInput: ?*BITMAPINFOHEADER,
    lpInput: ?*opaque{},
    lpbiOutput: ?*BITMAPINFOHEADER,
    lpOutput: ?*opaque{},
    ckid: u32,
};
// --------------------------------------------------------
// Type: ICDECOMPRESSEX
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const ICDECOMPRESSEX = extern struct {
    dwFlags: u32,
    lpbiSrc: ?*BITMAPINFOHEADER,
    lpSrc: ?*opaque{},
    lpbiDst: ?*BITMAPINFOHEADER,
    lpDst: ?*opaque{},
    xDst: i32,
    yDst: i32,
    dxDst: i32,
    dyDst: i32,
    xSrc: i32,
    ySrc: i32,
    dxSrc: i32,
    dySrc: i32,
};
// --------------------------------------------------------
// Type: ICDRAWBEGIN
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const ICDRAWBEGIN = extern struct {
    dwFlags: u32,
    hpal: HPALETTE,
    hwnd: HWND,
    hdc: HDC,
    xDst: i32,
    yDst: i32,
    dxDst: i32,
    dyDst: i32,
    lpbi: ?*BITMAPINFOHEADER,
    xSrc: i32,
    ySrc: i32,
    dxSrc: i32,
    dySrc: i32,
    dwRate: u32,
    dwScale: u32,
};
// --------------------------------------------------------
// Type: ICDRAW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const ICDRAW = extern struct {
    dwFlags: u32,
    lpFormat: ?*opaque{},
    lpData: ?*opaque{},
    cbData: u32,
    lTime: i32,
};
// --------------------------------------------------------
// Type: ICDRAWSUGGEST
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const ICDRAWSUGGEST = extern struct {
    lpbiIn: ?*BITMAPINFOHEADER,
    lpbiSuggest: ?*BITMAPINFOHEADER,
    dxSrc: i32,
    dySrc: i32,
    dxDst: i32,
    dyDst: i32,
    hicDecompressor: ?*HIC__,
};
// --------------------------------------------------------
// Type: ICPALETTE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const ICPALETTE = extern struct {
    dwFlags: u32,
    iStart: i32,
    iLen: i32,
    lppe: ?*PALETTEENTRY,
};
// --------------------------------------------------------
// Type: COMPVARS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const COMPVARS = extern struct {
    cbSize: i32,
    dwFlags: u32,
    hic: ?*HIC__,
    fccType: u32,
    fccHandler: u32,
    lpbiIn: ?*BITMAPINFO,
    lpbiOut: ?*BITMAPINFO,
    lpBitsOut: ?*opaque{},
    lpBitsPrev: ?*opaque{},
    lFrame: i32,
    lKey: i32,
    lDataRate: i32,
    lQ: i32,
    lKeyCount: i32,
    lpState: ?*opaque{},
    cbState: i32,
};
// --------------------------------------------------------
// Type: DRAWDIBTIME
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DRAWDIBTIME = extern struct {
    timeCount: i32,
    timeDraw: i32,
    timeDecompress: i32,
    timeDither: i32,
    timeStretch: i32,
    timeBlt: i32,
    timeSetDIBits: i32,
};
// --------------------------------------------------------
// Type: AVISTREAMINFOW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const AVISTREAMINFOW = extern struct {
    fccType: u32,
    fccHandler: u32,
    dwFlags: u32,
    dwCaps: u32,
    wPriority: u16,
    wLanguage: u16,
    dwScale: u32,
    dwRate: u32,
    dwStart: u32,
    dwLength: u32,
    dwInitialFrames: u32,
    dwSuggestedBufferSize: u32,
    dwQuality: u32,
    dwSampleSize: u32,
    rcFrame: RECT,
    dwEditCount: u32,
    dwFormatChangeCount: u32,
    szName: ?[*]u16,
};
// --------------------------------------------------------
// Type: AVISTREAMINFOA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const AVISTREAMINFOA = extern struct {
    fccType: u32,
    fccHandler: u32,
    dwFlags: u32,
    dwCaps: u32,
    wPriority: u16,
    wLanguage: u16,
    dwScale: u32,
    dwRate: u32,
    dwStart: u32,
    dwLength: u32,
    dwInitialFrames: u32,
    dwSuggestedBufferSize: u32,
    dwQuality: u32,
    dwSampleSize: u32,
    rcFrame: RECT,
    dwEditCount: u32,
    dwFormatChangeCount: u32,
    szName: ?[*]i8,
};
// --------------------------------------------------------
// Type: AVIFILEINFOW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const AVIFILEINFOW = extern struct {
    dwMaxBytesPerSec: u32,
    dwFlags: u32,
    dwCaps: u32,
    dwStreams: u32,
    dwSuggestedBufferSize: u32,
    dwWidth: u32,
    dwHeight: u32,
    dwScale: u32,
    dwRate: u32,
    dwLength: u32,
    dwEditCount: u32,
    szFileType: ?[*]u16,
};
// --------------------------------------------------------
// Type: AVIFILEINFOA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const AVIFILEINFOA = extern struct {
    dwMaxBytesPerSec: u32,
    dwFlags: u32,
    dwCaps: u32,
    dwStreams: u32,
    dwSuggestedBufferSize: u32,
    dwWidth: u32,
    dwHeight: u32,
    dwScale: u32,
    dwRate: u32,
    dwLength: u32,
    dwEditCount: u32,
    szFileType: ?[*]i8,
};
// --------------------------------------------------------
// Type: AVISAVECALLBACK
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const AVISAVECALLBACK = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: AVICOMPRESSOPTIONS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const AVICOMPRESSOPTIONS = extern struct {
    fccType: u32,
    fccHandler: u32,
    dwKeyFrameEvery: u32,
    dwQuality: u32,
    dwBytesPerSecond: u32,
    dwFlags: u32,
    lpFormat: ?*opaque{},
    cbFormat: u32,
    lpParms: ?*opaque{},
    cbParms: u32,
    dwInterleaveEvery: u32,
};
// --------------------------------------------------------
// Type: IAVIStream
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IAVIStream = *opaque{
    // TODO: Method 'Create'
    // TODO: Method 'Info'
    // TODO: Method 'FindSample'
    // TODO: Method 'ReadFormat'
    // TODO: Method 'SetFormat'
    // TODO: Method 'Read'
    // TODO: Method 'Write'
    // TODO: Method 'Delete'
    // TODO: Method 'ReadData'
    // TODO: Method 'WriteData'
    // TODO: Method 'SetInfo'
};
// --------------------------------------------------------
// Type: IAVIStreaming
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IAVIStreaming = *opaque{
    // TODO: Method 'Begin'
    // TODO: Method 'End'
};
// --------------------------------------------------------
// Type: IAVIEditStream
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IAVIEditStream = *opaque{
    // TODO: Method 'Cut'
    // TODO: Method 'Copy'
    // TODO: Method 'Paste'
    // TODO: Method 'Clone'
    // TODO: Method 'SetInfo'
};
// --------------------------------------------------------
// Type: IAVIPersistFile
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IAVIPersistFile = *opaque{
    // TODO: Method 'Reserved1'
};
// --------------------------------------------------------
// Type: IAVIFile
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IAVIFile = *opaque{
    // TODO: Method 'Info'
    // TODO: Method 'GetStream'
    // TODO: Method 'CreateStream'
    // TODO: Method 'WriteData'
    // TODO: Method 'ReadData'
    // TODO: Method 'EndRecord'
    // TODO: Method 'DeleteStream'
};
// --------------------------------------------------------
// Type: IGetFrame
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IGetFrame = *opaque{
    // TODO: Method 'GetFrame'
    // TODO: Method 'Begin'
    // TODO: Method 'End'
    // TODO: Method 'SetFormat'
};
// --------------------------------------------------------
// Type: HVIDEO__
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HVIDEO__ = extern struct {
    unused: i32,
};
// --------------------------------------------------------
// Type: VIDEOHDR
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VIDEOHDR = extern struct {
    lpData: ?*u8,
    dwBufferLength: u32,
    dwBytesUsed: u32,
    dwTimeCaptured: u32,
    dwUser: ?*opaque{},
    dwFlags: u32,
    dwReserved: ?[*]?*opaque{},
};
// --------------------------------------------------------
// Type: channel_caps_tag
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const channel_caps_tag = extern struct {
    dwFlags: u32,
    dwSrcRectXMod: u32,
    dwSrcRectYMod: u32,
    dwSrcRectWidthMod: u32,
    dwSrcRectHeightMod: u32,
    dwDstRectXMod: u32,
    dwDstRectYMod: u32,
    dwDstRectWidthMod: u32,
    dwDstRectHeightMod: u32,
};
// --------------------------------------------------------
// Type: CAPDRIVERCAPS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CAPDRIVERCAPS = extern struct {
    wDeviceIndex: u32,
    fHasOverlay: BOOL,
    fHasDlgVideoSource: BOOL,
    fHasDlgVideoFormat: BOOL,
    fHasDlgVideoDisplay: BOOL,
    fCaptureInitialized: BOOL,
    fDriverSuppliesPalettes: BOOL,
    hVideoIn: HANDLE,
    hVideoOut: HANDLE,
    hVideoExtIn: HANDLE,
    hVideoExtOut: HANDLE,
};
// --------------------------------------------------------
// Type: CAPSTATUS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CAPSTATUS = extern struct {
    uiImageWidth: u32,
    uiImageHeight: u32,
    fLiveWindow: BOOL,
    fOverlayWindow: BOOL,
    fScale: BOOL,
    ptScroll: POINT,
    fUsingDefaultPalette: BOOL,
    fAudioHardware: BOOL,
    fCapFileExists: BOOL,
    dwCurrentVideoFrame: u32,
    dwCurrentVideoFramesDropped: u32,
    dwCurrentWaveSamples: u32,
    dwCurrentTimeElapsedMS: u32,
    hPalCurrent: HPALETTE,
    fCapturingNow: BOOL,
    dwReturn: u32,
    wNumVideoAllocated: u32,
    wNumAudioAllocated: u32,
};
// --------------------------------------------------------
// Type: CAPTUREPARMS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CAPTUREPARMS = extern struct {
    dwRequestMicroSecPerFrame: u32,
    fMakeUserHitOKToCapture: BOOL,
    wPercentDropForError: u32,
    fYield: BOOL,
    dwIndexSize: u32,
    wChunkGranularity: u32,
    fUsingDOSMemory: BOOL,
    wNumVideoRequested: u32,
    fCaptureAudio: BOOL,
    wNumAudioRequested: u32,
    vKeyAbort: u32,
    fAbortLeftMouse: BOOL,
    fAbortRightMouse: BOOL,
    fLimitEnabled: BOOL,
    wTimeLimit: u32,
    fMCIControl: BOOL,
    fStepMCIDevice: BOOL,
    dwMCIStartTime: u32,
    dwMCIStopTime: u32,
    fStepCaptureAt2x: BOOL,
    wStepCaptureAverageFrames: u32,
    dwAudioBufferSize: u32,
    fDisableWriteCache: BOOL,
    AVStreamMaster: u32,
};
// --------------------------------------------------------
// Type: CAPINFOCHUNK
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CAPINFOCHUNK = extern struct {
    fccInfoID: u32,
    lpData: ?*opaque{},
    cbData: i32,
};
// --------------------------------------------------------
// Type: CAPYIELDCALLBACK
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const CAPYIELDCALLBACK = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: CAPSTATUSCALLBACKW
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const CAPSTATUSCALLBACKW = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: CAPERRORCALLBACKW
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const CAPERRORCALLBACKW = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: CAPSTATUSCALLBACKA
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const CAPSTATUSCALLBACKA = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: CAPERRORCALLBACKA
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const CAPERRORCALLBACKA = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: CAPVIDEOCALLBACK
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const CAPVIDEOCALLBACK = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: CAPWAVECALLBACK
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const CAPWAVECALLBACK = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: CAPCONTROLCALLBACK
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const CAPCONTROLCALLBACK = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: DRVM_IOCTL_DATA
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const DRVM_IOCTL_DATA = *opaque{
};
// --------------------------------------------------------
// Type: waveopendesc_tag
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const waveopendesc_tag = *opaque{
};
// --------------------------------------------------------
// Type: midiopenstrmid_tag
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const midiopenstrmid_tag = *opaque{
};
// --------------------------------------------------------
// Type: tMIXEROPENDESC
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const tMIXEROPENDESC = *opaque{
};
// --------------------------------------------------------
// Type: timerevent_tag
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const timerevent_tag = *opaque{
};
// --------------------------------------------------------
// Type: joypos_tag
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const joypos_tag = *opaque{
};
// --------------------------------------------------------
// Type: joyrange_tag
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const joyrange_tag = extern struct {
    jpMin: joypos_tag,
    jpMax: joypos_tag,
    jpCenter: joypos_tag,
};
// --------------------------------------------------------
// Type: joyreguservalues_tag
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const joyreguservalues_tag = *opaque{
};
// --------------------------------------------------------
// Type: joyreghwsettings_tag
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const joyreghwsettings_tag = *opaque{
};
// --------------------------------------------------------
// Type: joyreghwconfig_tag
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const joyreghwconfig_tag = *opaque{
};
// --------------------------------------------------------
// Type: joycalibrate_tag
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const joycalibrate_tag = *opaque{
};
// --------------------------------------------------------
// Type: JOYDEVMSGPROC
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const JOYDEVMSGPROC = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: LPJOYDEVMSGPROC
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const LPJOYDEVMSGPROC = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: MCI_OPEN_DRIVER_PARMS
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const MCI_OPEN_DRIVER_PARMS = *opaque{
};
// --------------------------------------------------------
// Type: TASKCALLBACK
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const TASKCALLBACK = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: LPTASKCALLBACK
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const LPTASKCALLBACK = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};

//
// functions
//

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn joyConfigChanged(
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-mm-misc-l1-1-0" fn CloseDriver(
    hDriver: ?*opaque{},
    lParam1: LPARAM,
    lParam2: LPARAM,
) callconv(@import("std").os.windows.WINAPI) LRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-mm-misc-l1-1-0" fn OpenDriver(
    szDriverName: ?*u16,
    szSectionName: ?*u16,
    lParam2: LPARAM,
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-mm-misc-l1-1-0" fn SendDriverMessage(
    hDriver: ?*opaque{},
    message: u32,
    lParam1: LPARAM,
    lParam2: LPARAM,
) callconv(@import("std").os.windows.WINAPI) LRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-mm-misc-l1-1-0" fn DrvGetModuleHandle(
    hDriver: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-mm-misc-l1-1-0" fn GetDriverModuleHandle(
    hDriver: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-mm-misc-l1-1-0" fn DefDriverProc(
    dwDriverIdentifier: ?*opaque{},
    hdrvr: ?*opaque{},
    uMsg: u32,
    lParam1: LPARAM,
    lParam2: LPARAM,
) callconv(@import("std").os.windows.WINAPI) LRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-mm-misc-l1-1-0" fn DriverCallback(
    dwCallback: ?*opaque{},
    dwFlags: u32,
    hDevice: ?*opaque{},
    dwMsg: u32,
    dwUser: ?*opaque{},
    dwParam1: ?*opaque{},
    dwParam2: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-mm-misc-l1-1-1" fn sndOpenSound(
    EventName: ?*u16,
    AppName: ?*u16,
    Flags: i32,
    FileHandle: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-mm-misc-l1-1-0" fn mmDrvInstall(
    hDriver: ?*opaque{},
    wszDrvEntry: ?*u16,
    drvMessage: DRIVERMSGPROC,
    wFlags: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-mm-misc-l1-1-0" fn mmioStringToFOURCCA(
    sz: ?*i8,
    uFlags: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-mm-misc-l1-1-0" fn mmioStringToFOURCCW(
    sz: ?*u16,
    uFlags: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-mm-misc-l1-1-0" fn mmioInstallIOProcA(
    fccIOProc: u32,
    pIOProc: LPMMIOPROC,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) LPMMIOPROC;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-mm-misc-l1-1-0" fn mmioInstallIOProcW(
    fccIOProc: u32,
    pIOProc: LPMMIOPROC,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) LPMMIOPROC;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-mm-misc-l1-1-0" fn mmioOpenA(
    pszFileName: ?*i8,
    pmmioinfo: ?*MMIOINFO,
    fdwOpen: u32,
) callconv(@import("std").os.windows.WINAPI) ?*HMMIO__;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-mm-misc-l1-1-0" fn mmioOpenW(
    pszFileName: ?*u16,
    pmmioinfo: ?*MMIOINFO,
    fdwOpen: u32,
) callconv(@import("std").os.windows.WINAPI) ?*HMMIO__;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-mm-misc-l1-1-0" fn mmioRenameA(
    pszFileName: ?*i8,
    pszNewFileName: ?*i8,
    pmmioinfo: ?*MMIOINFO,
    fdwRename: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-mm-misc-l1-1-0" fn mmioRenameW(
    pszFileName: ?*u16,
    pszNewFileName: ?*u16,
    pmmioinfo: ?*MMIOINFO,
    fdwRename: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-mm-misc-l1-1-0" fn mmioClose(
    hmmio: ?*HMMIO__,
    fuClose: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-mm-misc-l1-1-0" fn mmioRead(
    hmmio: ?*HMMIO__,
    pch: ?*i8,
    cch: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-mm-misc-l1-1-0" fn mmioWrite(
    hmmio: ?*HMMIO__,
    pch: ?*i8,
    cch: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-mm-misc-l1-1-0" fn mmioSeek(
    hmmio: ?*HMMIO__,
    lOffset: i32,
    iOrigin: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-mm-misc-l1-1-0" fn mmioGetInfo(
    hmmio: ?*HMMIO__,
    pmmioinfo: ?*MMIOINFO,
    fuInfo: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-mm-misc-l1-1-0" fn mmioSetInfo(
    hmmio: ?*HMMIO__,
    pmmioinfo: ?*MMIOINFO,
    fuInfo: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-mm-misc-l1-1-0" fn mmioSetBuffer(
    hmmio: ?*HMMIO__,
    pchBuffer: ?*i8,
    cchBuffer: i32,
    fuBuffer: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-mm-misc-l1-1-0" fn mmioFlush(
    hmmio: ?*HMMIO__,
    fuFlush: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-mm-misc-l1-1-0" fn mmioAdvance(
    hmmio: ?*HMMIO__,
    pmmioinfo: ?*MMIOINFO,
    fuAdvance: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-mm-misc-l1-1-0" fn mmioSendMessage(
    hmmio: ?*HMMIO__,
    uMsg: u32,
    lParam1: LPARAM,
    lParam2: LPARAM,
) callconv(@import("std").os.windows.WINAPI) LRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-mm-misc-l1-1-0" fn mmioDescend(
    hmmio: ?*HMMIO__,
    pmmcki: ?*MMCKINFO,
    pmmckiParent: ?*MMCKINFO,
    fuDescend: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-mm-misc-l1-1-0" fn mmioAscend(
    hmmio: ?*HMMIO__,
    pmmcki: ?*MMCKINFO,
    fuAscend: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "api-ms-win-mm-misc-l1-1-0" fn mmioCreateChunk(
    hmmio: ?*HMMIO__,
    pmmcki: ?*MMCKINFO,
    fuCreate: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn sndPlaySoundA(
    pszSound: ?*i8,
    fuSound: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn sndPlaySoundW(
    pszSound: ?*u16,
    fuSound: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn PlaySoundA(
    pszSound: ?*i8,
    hmod: ?*opaque{},
    fdwSound: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn PlaySoundW(
    pszSound: ?*u16,
    hmod: ?*opaque{},
    fdwSound: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn waveOutGetNumDevs(
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn waveOutGetDevCapsA(
    uDeviceID: ?*opaque{},
    pwoc: ?*WAVEOUTCAPSA,
    cbwoc: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn waveOutGetDevCapsW(
    uDeviceID: ?*opaque{},
    pwoc: ?*WAVEOUTCAPSW,
    cbwoc: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn waveOutGetVolume(
    hwo: ?*opaque{},
    pdwVolume: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn waveOutSetVolume(
    hwo: ?*opaque{},
    dwVolume: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn waveOutGetErrorTextA(
    mmrError: u32,
    pszText: ?*i8,
    cchText: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn waveOutGetErrorTextW(
    mmrError: u32,
    pszText: ?*u16,
    cchText: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn waveOutOpen(
    phwo: ?*?*opaque{},
    uDeviceID: u32,
    pwfx: ?*WAVEFORMATEX,
    dwCallback: ?*opaque{},
    dwInstance: ?*opaque{},
    fdwOpen: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn waveOutClose(
    hwo: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn waveOutPrepareHeader(
    hwo: ?*opaque{},
    pwh: ?*WAVEHDR,
    cbwh: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn waveOutUnprepareHeader(
    hwo: ?*opaque{},
    pwh: ?*WAVEHDR,
    cbwh: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn waveOutWrite(
    hwo: ?*opaque{},
    pwh: ?*WAVEHDR,
    cbwh: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn waveOutPause(
    hwo: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn waveOutRestart(
    hwo: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn waveOutReset(
    hwo: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn waveOutBreakLoop(
    hwo: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn waveOutGetPosition(
    hwo: ?*opaque{},
    pmmt: ?*MMTIME,
    cbmmt: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn waveOutGetPitch(
    hwo: ?*opaque{},
    pdwPitch: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn waveOutSetPitch(
    hwo: ?*opaque{},
    dwPitch: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn waveOutGetPlaybackRate(
    hwo: ?*opaque{},
    pdwRate: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn waveOutSetPlaybackRate(
    hwo: ?*opaque{},
    dwRate: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn waveOutGetID(
    hwo: ?*opaque{},
    puDeviceID: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn waveOutMessage(
    hwo: ?*opaque{},
    uMsg: u32,
    dw1: ?*opaque{},
    dw2: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn waveInGetNumDevs(
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn waveInGetDevCapsA(
    uDeviceID: ?*opaque{},
    pwic: ?*WAVEINCAPSA,
    cbwic: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn waveInGetDevCapsW(
    uDeviceID: ?*opaque{},
    pwic: ?*WAVEINCAPSW,
    cbwic: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn waveInGetErrorTextA(
    mmrError: u32,
    pszText: ?*i8,
    cchText: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn waveInGetErrorTextW(
    mmrError: u32,
    pszText: ?*u16,
    cchText: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn waveInOpen(
    phwi: ?*?*opaque{},
    uDeviceID: u32,
    pwfx: ?*WAVEFORMATEX,
    dwCallback: ?*opaque{},
    dwInstance: ?*opaque{},
    fdwOpen: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn waveInClose(
    hwi: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn waveInPrepareHeader(
    hwi: ?*opaque{},
    pwh: ?*WAVEHDR,
    cbwh: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn waveInUnprepareHeader(
    hwi: ?*opaque{},
    pwh: ?*WAVEHDR,
    cbwh: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn waveInAddBuffer(
    hwi: ?*opaque{},
    pwh: ?*WAVEHDR,
    cbwh: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn waveInStart(
    hwi: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn waveInStop(
    hwi: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn waveInReset(
    hwi: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn waveInGetPosition(
    hwi: ?*opaque{},
    pmmt: ?*MMTIME,
    cbmmt: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn waveInGetID(
    hwi: ?*opaque{},
    puDeviceID: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn waveInMessage(
    hwi: ?*opaque{},
    uMsg: u32,
    dw1: ?*opaque{},
    dw2: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn midiOutGetNumDevs(
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn midiStreamOpen(
    phms: ?*?*opaque{},
    puDeviceID: ?*u32,
    cMidi: u32,
    dwCallback: ?*opaque{},
    dwInstance: ?*opaque{},
    fdwOpen: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn midiStreamClose(
    hms: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn midiStreamProperty(
    hms: ?*opaque{},
    lppropdata: ?*u8,
    dwProperty: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn midiStreamPosition(
    hms: ?*opaque{},
    lpmmt: ?*MMTIME,
    cbmmt: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn midiStreamOut(
    hms: ?*opaque{},
    pmh: ?*MIDIHDR,
    cbmh: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn midiStreamPause(
    hms: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn midiStreamRestart(
    hms: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn midiStreamStop(
    hms: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn midiConnect(
    hmi: ?*opaque{},
    hmo: ?*opaque{},
    pReserved: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn midiDisconnect(
    hmi: ?*opaque{},
    hmo: ?*opaque{},
    pReserved: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn midiOutGetDevCapsA(
    uDeviceID: ?*opaque{},
    pmoc: ?*MIDIOUTCAPSA,
    cbmoc: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn midiOutGetDevCapsW(
    uDeviceID: ?*opaque{},
    pmoc: ?*MIDIOUTCAPSW,
    cbmoc: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn midiOutGetVolume(
    hmo: ?*opaque{},
    pdwVolume: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn midiOutSetVolume(
    hmo: ?*opaque{},
    dwVolume: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn midiOutGetErrorTextA(
    mmrError: u32,
    pszText: ?*i8,
    cchText: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn midiOutGetErrorTextW(
    mmrError: u32,
    pszText: ?*u16,
    cchText: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn midiOutOpen(
    phmo: ?*?*opaque{},
    uDeviceID: u32,
    dwCallback: ?*opaque{},
    dwInstance: ?*opaque{},
    fdwOpen: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn midiOutClose(
    hmo: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn midiOutPrepareHeader(
    hmo: ?*opaque{},
    pmh: ?*MIDIHDR,
    cbmh: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn midiOutUnprepareHeader(
    hmo: ?*opaque{},
    pmh: ?*MIDIHDR,
    cbmh: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn midiOutShortMsg(
    hmo: ?*opaque{},
    dwMsg: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn midiOutLongMsg(
    hmo: ?*opaque{},
    pmh: ?*MIDIHDR,
    cbmh: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn midiOutReset(
    hmo: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn midiOutCachePatches(
    hmo: ?*opaque{},
    uBank: u32,
    pwpa: ?*u16,
    fuCache: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn midiOutCacheDrumPatches(
    hmo: ?*opaque{},
    uPatch: u32,
    pwkya: ?*u16,
    fuCache: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn midiOutGetID(
    hmo: ?*opaque{},
    puDeviceID: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn midiOutMessage(
    hmo: ?*opaque{},
    uMsg: u32,
    dw1: ?*opaque{},
    dw2: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn midiInGetNumDevs(
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn midiInGetDevCapsA(
    uDeviceID: ?*opaque{},
    pmic: ?*MIDIINCAPSA,
    cbmic: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn midiInGetDevCapsW(
    uDeviceID: ?*opaque{},
    pmic: ?*MIDIINCAPSW,
    cbmic: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn midiInGetErrorTextA(
    mmrError: u32,
    pszText: ?*i8,
    cchText: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn midiInGetErrorTextW(
    mmrError: u32,
    pszText: ?*u16,
    cchText: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn midiInOpen(
    phmi: ?*?*opaque{},
    uDeviceID: u32,
    dwCallback: ?*opaque{},
    dwInstance: ?*opaque{},
    fdwOpen: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn midiInClose(
    hmi: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn midiInPrepareHeader(
    hmi: ?*opaque{},
    pmh: ?*MIDIHDR,
    cbmh: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn midiInUnprepareHeader(
    hmi: ?*opaque{},
    pmh: ?*MIDIHDR,
    cbmh: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn midiInAddBuffer(
    hmi: ?*opaque{},
    pmh: ?*MIDIHDR,
    cbmh: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn midiInStart(
    hmi: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn midiInStop(
    hmi: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn midiInReset(
    hmi: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn midiInGetID(
    hmi: ?*opaque{},
    puDeviceID: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn midiInMessage(
    hmi: ?*opaque{},
    uMsg: u32,
    dw1: ?*opaque{},
    dw2: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn auxGetNumDevs(
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn auxGetDevCapsA(
    uDeviceID: ?*opaque{},
    pac: ?*AUXCAPSA,
    cbac: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn auxGetDevCapsW(
    uDeviceID: ?*opaque{},
    pac: ?*AUXCAPSW,
    cbac: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn auxSetVolume(
    uDeviceID: u32,
    dwVolume: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn auxGetVolume(
    uDeviceID: u32,
    pdwVolume: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn auxOutMessage(
    uDeviceID: u32,
    uMsg: u32,
    dw1: ?*opaque{},
    dw2: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn mixerGetNumDevs(
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn mixerGetDevCapsA(
    uMxId: ?*opaque{},
    pmxcaps: ?*MIXERCAPSA,
    cbmxcaps: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn mixerGetDevCapsW(
    uMxId: ?*opaque{},
    pmxcaps: ?*MIXERCAPSW,
    cbmxcaps: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn mixerOpen(
    phmx: ?*?*opaque{},
    uMxId: u32,
    dwCallback: ?*opaque{},
    dwInstance: ?*opaque{},
    fdwOpen: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn mixerClose(
    hmx: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn mixerMessage(
    hmx: ?*opaque{},
    uMsg: u32,
    dwParam1: ?*opaque{},
    dwParam2: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn mixerGetLineInfoA(
    hmxobj: ?*opaque{},
    pmxl: ?*MIXERLINEA,
    fdwInfo: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn mixerGetLineInfoW(
    hmxobj: ?*opaque{},
    pmxl: ?*MIXERLINEW,
    fdwInfo: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn mixerGetID(
    hmxobj: ?*opaque{},
    puMxId: ?*u32,
    fdwId: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn mixerGetLineControlsA(
    hmxobj: ?*opaque{},
    pmxlc: ?*MIXERLINECONTROLSA,
    fdwControls: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn mixerGetLineControlsW(
    hmxobj: ?*opaque{},
    pmxlc: ?*MIXERLINECONTROLSW,
    fdwControls: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn mixerGetControlDetailsA(
    hmxobj: ?*opaque{},
    pmxcd: ?*MIXERCONTROLDETAILS,
    fdwDetails: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn mixerGetControlDetailsW(
    hmxobj: ?*opaque{},
    pmxcd: ?*MIXERCONTROLDETAILS,
    fdwDetails: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn mixerSetControlDetails(
    hmxobj: ?*opaque{},
    pmxcd: ?*MIXERCONTROLDETAILS,
    fdwDetails: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn timeGetSystemTime(
    pmmt: ?*MMTIME,
    cbmmt: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn timeGetTime(
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn timeGetDevCaps(
    ptc: ?*TIMECAPS,
    cbtc: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn timeBeginPeriod(
    uPeriod: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn timeEndPeriod(
    uPeriod: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn joyGetPosEx(
    uJoyID: u32,
    pji: ?*JOYINFOEX,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn joyGetNumDevs(
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn joyGetDevCapsA(
    uJoyID: ?*opaque{},
    pjc: ?*JOYCAPSA,
    cbjc: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn joyGetDevCapsW(
    uJoyID: ?*opaque{},
    pjc: ?*JOYCAPSW,
    cbjc: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn joyGetPos(
    uJoyID: u32,
    pji: ?*JOYINFO,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn joyGetThreshold(
    uJoyID: u32,
    puThreshold: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn joyReleaseCapture(
    uJoyID: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn joySetCapture(
    hwnd: HWND,
    uJoyID: u32,
    uPeriod: u32,
    fChanged: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn joySetThreshold(
    uJoyID: u32,
    uThreshold: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MSACM32" fn acmGetVersion(
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MSACM32" fn acmMetrics(
    hao: ?*HACMOBJ__,
    uMetric: u32,
    pMetric: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MSACM32" fn acmDriverEnum(
    fnCallback: ACMDRIVERENUMCB,
    dwInstance: ?*opaque{},
    fdwEnum: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MSACM32" fn acmDriverID(
    hao: ?*HACMOBJ__,
    phadid: ?*?*HACMDRIVERID__,
    fdwDriverID: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MSACM32" fn acmDriverAddA(
    phadid: ?*?*HACMDRIVERID__,
    hinstModule: HINSTANCE,
    lParam: LPARAM,
    dwPriority: u32,
    fdwAdd: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MSACM32" fn acmDriverAddW(
    phadid: ?*?*HACMDRIVERID__,
    hinstModule: HINSTANCE,
    lParam: LPARAM,
    dwPriority: u32,
    fdwAdd: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MSACM32" fn acmDriverRemove(
    hadid: ?*HACMDRIVERID__,
    fdwRemove: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MSACM32" fn acmDriverOpen(
    phad: ?*?*HACMDRIVER__,
    hadid: ?*HACMDRIVERID__,
    fdwOpen: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MSACM32" fn acmDriverClose(
    had: ?*HACMDRIVER__,
    fdwClose: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MSACM32" fn acmDriverMessage(
    had: ?*HACMDRIVER__,
    uMsg: u32,
    lParam1: LPARAM,
    lParam2: LPARAM,
) callconv(@import("std").os.windows.WINAPI) LRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "MSACM32" fn acmDriverPriority(
    hadid: ?*HACMDRIVERID__,
    dwPriority: u32,
    fdwPriority: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MSACM32" fn acmDriverDetailsA(
    hadid: ?*HACMDRIVERID__,
    padd: ?*tACMDRIVERDETAILSA,
    fdwDetails: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MSACM32" fn acmDriverDetailsW(
    hadid: ?*HACMDRIVERID__,
    padd: ?*tACMDRIVERDETAILSW,
    fdwDetails: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MSACM32" fn acmFormatTagDetailsA(
    had: ?*HACMDRIVER__,
    paftd: ?*tACMFORMATTAGDETAILSA,
    fdwDetails: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MSACM32" fn acmFormatTagDetailsW(
    had: ?*HACMDRIVER__,
    paftd: ?*tACMFORMATTAGDETAILSW,
    fdwDetails: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MSACM32" fn acmFormatTagEnumA(
    had: ?*HACMDRIVER__,
    paftd: ?*tACMFORMATTAGDETAILSA,
    fnCallback: ACMFORMATTAGENUMCBA,
    dwInstance: ?*opaque{},
    fdwEnum: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MSACM32" fn acmFormatTagEnumW(
    had: ?*HACMDRIVER__,
    paftd: ?*tACMFORMATTAGDETAILSW,
    fnCallback: ACMFORMATTAGENUMCBW,
    dwInstance: ?*opaque{},
    fdwEnum: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MSACM32" fn acmFormatDetailsA(
    had: ?*HACMDRIVER__,
    pafd: ?*tACMFORMATDETAILSA,
    fdwDetails: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MSACM32" fn acmFormatDetailsW(
    had: ?*HACMDRIVER__,
    pafd: ?*tACMFORMATDETAILSW,
    fdwDetails: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MSACM32" fn acmFormatEnumA(
    had: ?*HACMDRIVER__,
    pafd: ?*tACMFORMATDETAILSA,
    fnCallback: ACMFORMATENUMCBA,
    dwInstance: ?*opaque{},
    fdwEnum: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MSACM32" fn acmFormatEnumW(
    had: ?*HACMDRIVER__,
    pafd: ?*tACMFORMATDETAILSW,
    fnCallback: ACMFORMATENUMCBW,
    dwInstance: ?*opaque{},
    fdwEnum: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MSACM32" fn acmFormatSuggest(
    had: ?*HACMDRIVER__,
    pwfxSrc: ?*WAVEFORMATEX,
    pwfxDst: ?*WAVEFORMATEX,
    cbwfxDst: u32,
    fdwSuggest: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MSACM32" fn acmFormatChooseA(
    pafmtc: ?*tACMFORMATCHOOSEA,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MSACM32" fn acmFormatChooseW(
    pafmtc: ?*tACMFORMATCHOOSEW,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MSACM32" fn acmFilterTagDetailsA(
    had: ?*HACMDRIVER__,
    paftd: ?*tACMFILTERTAGDETAILSA,
    fdwDetails: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MSACM32" fn acmFilterTagDetailsW(
    had: ?*HACMDRIVER__,
    paftd: ?*tACMFILTERTAGDETAILSW,
    fdwDetails: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MSACM32" fn acmFilterTagEnumA(
    had: ?*HACMDRIVER__,
    paftd: ?*tACMFILTERTAGDETAILSA,
    fnCallback: ACMFILTERTAGENUMCBA,
    dwInstance: ?*opaque{},
    fdwEnum: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MSACM32" fn acmFilterTagEnumW(
    had: ?*HACMDRIVER__,
    paftd: ?*tACMFILTERTAGDETAILSW,
    fnCallback: ACMFILTERTAGENUMCBW,
    dwInstance: ?*opaque{},
    fdwEnum: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MSACM32" fn acmFilterDetailsA(
    had: ?*HACMDRIVER__,
    pafd: ?*tACMFILTERDETAILSA,
    fdwDetails: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MSACM32" fn acmFilterDetailsW(
    had: ?*HACMDRIVER__,
    pafd: ?*tACMFILTERDETAILSW,
    fdwDetails: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MSACM32" fn acmFilterEnumA(
    had: ?*HACMDRIVER__,
    pafd: ?*tACMFILTERDETAILSA,
    fnCallback: ACMFILTERENUMCBA,
    dwInstance: ?*opaque{},
    fdwEnum: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MSACM32" fn acmFilterEnumW(
    had: ?*HACMDRIVER__,
    pafd: ?*tACMFILTERDETAILSW,
    fnCallback: ACMFILTERENUMCBW,
    dwInstance: ?*opaque{},
    fdwEnum: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MSACM32" fn acmFilterChooseA(
    pafltrc: ?*tACMFILTERCHOOSEA,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MSACM32" fn acmFilterChooseW(
    pafltrc: ?*tACMFILTERCHOOSEW,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MSACM32" fn acmStreamOpen(
    phas: ?*?*HACMSTREAM__,
    had: ?*HACMDRIVER__,
    pwfxSrc: ?*WAVEFORMATEX,
    pwfxDst: ?*WAVEFORMATEX,
    pwfltr: ?*WAVEFILTER,
    dwCallback: ?*opaque{},
    dwInstance: ?*opaque{},
    fdwOpen: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MSACM32" fn acmStreamClose(
    has: ?*HACMSTREAM__,
    fdwClose: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MSACM32" fn acmStreamSize(
    has: ?*HACMSTREAM__,
    cbInput: u32,
    pdwOutputBytes: ?*u32,
    fdwSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MSACM32" fn acmStreamReset(
    has: ?*HACMSTREAM__,
    fdwReset: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MSACM32" fn acmStreamMessage(
    has: ?*HACMSTREAM__,
    uMsg: u32,
    lParam1: LPARAM,
    lParam2: LPARAM,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MSACM32" fn acmStreamConvert(
    has: ?*HACMSTREAM__,
    pash: ?*ACMSTREAMHEADER,
    fdwConvert: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MSACM32" fn acmStreamPrepareHeader(
    has: ?*HACMSTREAM__,
    pash: ?*ACMSTREAMHEADER,
    fdwPrepare: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MSACM32" fn acmStreamUnprepareHeader(
    has: ?*HACMSTREAM__,
    pash: ?*ACMSTREAMHEADER,
    fdwUnprepare: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MSVFW32" fn VideoForWindowsVersion(
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MSVFW32" fn ICInfo(
    fccType: u32,
    fccHandler: u32,
    lpicinfo: ?*ICINFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "MSVFW32" fn ICInstall(
    fccType: u32,
    fccHandler: u32,
    lParam: LPARAM,
    szDesc: ?*i8,
    wFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "MSVFW32" fn ICRemove(
    fccType: u32,
    fccHandler: u32,
    wFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "MSVFW32" fn ICGetInfo(
    hic: ?*HIC__,
    picinfo: ?*ICINFO,
    cb: u32,
) callconv(@import("std").os.windows.WINAPI) LRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "MSVFW32" fn ICOpen(
    fccType: u32,
    fccHandler: u32,
    wMode: u32,
) callconv(@import("std").os.windows.WINAPI) ?*HIC__;

// set_last_errror=False (can and should we use this?)
pub extern "MSVFW32" fn ICOpenFunction(
    fccType: u32,
    fccHandler: u32,
    wMode: u32,
    lpfnHandler: FARPROC,
) callconv(@import("std").os.windows.WINAPI) ?*HIC__;

// set_last_errror=False (can and should we use this?)
pub extern "MSVFW32" fn ICClose(
    hic: ?*HIC__,
) callconv(@import("std").os.windows.WINAPI) LRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "MSVFW32" fn ICSendMessage(
    hic: ?*HIC__,
    msg: u32,
    dw1: ?*opaque{},
    dw2: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) LRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "MSVFW32" fn ICCompress(
    hic: ?*HIC__,
    dwFlags: u32,
    lpbiOutput: ?*BITMAPINFOHEADER,
    lpData: ?*opaque{},
    lpbiInput: ?*BITMAPINFOHEADER,
    lpBits: ?*opaque{},
    lpckid: ?*u32,
    lpdwFlags: ?*u32,
    lFrameNum: i32,
    dwFrameSize: u32,
    dwQuality: u32,
    lpbiPrev: ?*BITMAPINFOHEADER,
    lpPrev: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MSVFW32" fn ICDecompress(
    hic: ?*HIC__,
    dwFlags: u32,
    lpbiFormat: ?*BITMAPINFOHEADER,
    lpData: ?*opaque{},
    lpbi: ?*BITMAPINFOHEADER,
    lpBits: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MSVFW32" fn ICDrawBegin(
    hic: ?*HIC__,
    dwFlags: u32,
    hpal: HPALETTE,
    hwnd: HWND,
    hdc: HDC,
    xDst: i32,
    yDst: i32,
    dxDst: i32,
    dyDst: i32,
    lpbi: ?*BITMAPINFOHEADER,
    xSrc: i32,
    ySrc: i32,
    dxSrc: i32,
    dySrc: i32,
    dwRate: u32,
    dwScale: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MSVFW32" fn ICDraw(
    hic: ?*HIC__,
    dwFlags: u32,
    lpFormat: ?*opaque{},
    lpData: ?*opaque{},
    cbData: u32,
    lTime: i32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MSVFW32" fn ICLocate(
    fccType: u32,
    fccHandler: u32,
    lpbiIn: ?*BITMAPINFOHEADER,
    lpbiOut: ?*BITMAPINFOHEADER,
    wFlags: u16,
) callconv(@import("std").os.windows.WINAPI) ?*HIC__;

// set_last_errror=False (can and should we use this?)
pub extern "MSVFW32" fn ICGetDisplayFormat(
    hic: ?*HIC__,
    lpbiIn: ?*BITMAPINFOHEADER,
    lpbiOut: ?*BITMAPINFOHEADER,
    BitDepth: i32,
    dx: i32,
    dy: i32,
) callconv(@import("std").os.windows.WINAPI) ?*HIC__;

// set_last_errror=False (can and should we use this?)
pub extern "MSVFW32" fn ICImageCompress(
    hic: ?*HIC__,
    uiFlags: u32,
    lpbiIn: ?*BITMAPINFO,
    lpBits: ?*opaque{},
    lpbiOut: ?*BITMAPINFO,
    lQuality: i32,
    plSize: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// set_last_errror=False (can and should we use this?)
pub extern "MSVFW32" fn ICImageDecompress(
    hic: ?*HIC__,
    uiFlags: u32,
    lpbiIn: ?*BITMAPINFO,
    lpBits: ?*opaque{},
    lpbiOut: ?*BITMAPINFO,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// set_last_errror=False (can and should we use this?)
pub extern "MSVFW32" fn ICCompressorChoose(
    hwnd: HWND,
    uiFlags: u32,
    pvIn: ?*opaque{},
    lpData: ?*opaque{},
    pc: ?*COMPVARS,
    lpszTitle: ?*i8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "MSVFW32" fn ICSeqCompressFrameStart(
    pc: ?*COMPVARS,
    lpbiIn: ?*BITMAPINFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "MSVFW32" fn ICSeqCompressFrameEnd(
    pc: ?*COMPVARS,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "MSVFW32" fn ICSeqCompressFrame(
    pc: ?*COMPVARS,
    uiFlags: u32,
    lpBits: ?*opaque{},
    pfKey: ?*i32,
    plSize: ?*i32,
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=False (can and should we use this?)
pub extern "MSVFW32" fn ICCompressorFree(
    pc: ?*COMPVARS,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "MSVFW32" fn DrawDibOpen(
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=False (can and should we use this?)
pub extern "MSVFW32" fn DrawDibClose(
    hdd: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "MSVFW32" fn DrawDibGetBuffer(
    hdd: ?*opaque{},
    lpbi: ?*BITMAPINFOHEADER,
    dwSize: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=False (can and should we use this?)
pub extern "MSVFW32" fn DrawDibGetPalette(
    hdd: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HPALETTE;

// set_last_errror=False (can and should we use this?)
pub extern "MSVFW32" fn DrawDibSetPalette(
    hdd: ?*opaque{},
    hpal: HPALETTE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "MSVFW32" fn DrawDibChangePalette(
    hdd: ?*opaque{},
    iStart: i32,
    iLen: i32,
    lppe: ?*PALETTEENTRY,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "MSVFW32" fn DrawDibRealize(
    hdd: ?*opaque{},
    hdc: HDC,
    fBackground: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "MSVFW32" fn DrawDibStart(
    hdd: ?*opaque{},
    rate: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "MSVFW32" fn DrawDibStop(
    hdd: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "MSVFW32" fn DrawDibBegin(
    hdd: ?*opaque{},
    hdc: HDC,
    dxDst: i32,
    dyDst: i32,
    lpbi: ?*BITMAPINFOHEADER,
    dxSrc: i32,
    dySrc: i32,
    wFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "MSVFW32" fn DrawDibDraw(
    hdd: ?*opaque{},
    hdc: HDC,
    xDst: i32,
    yDst: i32,
    dxDst: i32,
    dyDst: i32,
    lpbi: ?*BITMAPINFOHEADER,
    lpBits: ?*opaque{},
    xSrc: i32,
    ySrc: i32,
    dxSrc: i32,
    dySrc: i32,
    wFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "MSVFW32" fn DrawDibEnd(
    hdd: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "MSVFW32" fn DrawDibTime(
    hdd: ?*opaque{},
    lpddtime: ?*DRAWDIBTIME,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "MSVFW32" fn DrawDibProfileDisplay(
    lpbi: ?*BITMAPINFOHEADER,
) callconv(@import("std").os.windows.WINAPI) LRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "AVIFIL32" fn AVIFileInit(
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "AVIFIL32" fn AVIFileExit(
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "AVIFIL32" fn AVIFileAddRef(
    pfile: IAVIFile,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "AVIFIL32" fn AVIFileRelease(
    pfile: IAVIFile,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "AVIFIL32" fn AVIFileOpenA(
    ppfile: ?*IAVIFile,
    szFile: ?*i8,
    uMode: u32,
    lpHandler: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "AVIFIL32" fn AVIFileOpenW(
    ppfile: ?*IAVIFile,
    szFile: ?*u16,
    uMode: u32,
    lpHandler: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "AVIFIL32" fn AVIFileInfoW(
    pfile: IAVIFile,
    pfi: ?*AVIFILEINFOW,
    lSize: i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "AVIFIL32" fn AVIFileInfoA(
    pfile: IAVIFile,
    pfi: ?*AVIFILEINFOA,
    lSize: i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "AVIFIL32" fn AVIFileGetStream(
    pfile: IAVIFile,
    ppavi: ?*IAVIStream,
    fccType: u32,
    lParam: i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "AVIFIL32" fn AVIFileCreateStreamW(
    pfile: IAVIFile,
    ppavi: ?*IAVIStream,
    psi: ?*AVISTREAMINFOW,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "AVIFIL32" fn AVIFileCreateStreamA(
    pfile: IAVIFile,
    ppavi: ?*IAVIStream,
    psi: ?*AVISTREAMINFOA,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "AVIFIL32" fn AVIFileWriteData(
    pfile: IAVIFile,
    ckid: u32,
    lpData: ?*opaque{},
    cbData: i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "AVIFIL32" fn AVIFileReadData(
    pfile: IAVIFile,
    ckid: u32,
    lpData: ?*opaque{},
    lpcbData: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "AVIFIL32" fn AVIFileEndRecord(
    pfile: IAVIFile,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "AVIFIL32" fn AVIStreamAddRef(
    pavi: IAVIStream,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "AVIFIL32" fn AVIStreamRelease(
    pavi: IAVIStream,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "AVIFIL32" fn AVIStreamInfoW(
    pavi: IAVIStream,
    psi: ?*AVISTREAMINFOW,
    lSize: i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "AVIFIL32" fn AVIStreamInfoA(
    pavi: IAVIStream,
    psi: ?*AVISTREAMINFOA,
    lSize: i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "AVIFIL32" fn AVIStreamFindSample(
    pavi: IAVIStream,
    lPos: i32,
    lFlags: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "AVIFIL32" fn AVIStreamReadFormat(
    pavi: IAVIStream,
    lPos: i32,
    lpFormat: ?*opaque{},
    lpcbFormat: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "AVIFIL32" fn AVIStreamSetFormat(
    pavi: IAVIStream,
    lPos: i32,
    lpFormat: ?*opaque{},
    cbFormat: i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "AVIFIL32" fn AVIStreamReadData(
    pavi: IAVIStream,
    fcc: u32,
    lp: ?*opaque{},
    lpcb: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "AVIFIL32" fn AVIStreamWriteData(
    pavi: IAVIStream,
    fcc: u32,
    lp: ?*opaque{},
    cb: i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "AVIFIL32" fn AVIStreamRead(
    pavi: IAVIStream,
    lStart: i32,
    lSamples: i32,
    lpBuffer: ?*opaque{},
    cbBuffer: i32,
    plBytes: ?*i32,
    plSamples: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "AVIFIL32" fn AVIStreamWrite(
    pavi: IAVIStream,
    lStart: i32,
    lSamples: i32,
    lpBuffer: ?*opaque{},
    cbBuffer: i32,
    dwFlags: u32,
    plSampWritten: ?*i32,
    plBytesWritten: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "AVIFIL32" fn AVIStreamStart(
    pavi: IAVIStream,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "AVIFIL32" fn AVIStreamLength(
    pavi: IAVIStream,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "AVIFIL32" fn AVIStreamTimeToSample(
    pavi: IAVIStream,
    lTime: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "AVIFIL32" fn AVIStreamSampleToTime(
    pavi: IAVIStream,
    lSample: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "AVIFIL32" fn AVIStreamBeginStreaming(
    pavi: IAVIStream,
    lStart: i32,
    lEnd: i32,
    lRate: i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "AVIFIL32" fn AVIStreamEndStreaming(
    pavi: IAVIStream,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "AVIFIL32" fn AVIStreamGetFrameOpen(
    pavi: IAVIStream,
    lpbiWanted: ?*BITMAPINFOHEADER,
) callconv(@import("std").os.windows.WINAPI) IGetFrame;

// set_last_errror=False (can and should we use this?)
pub extern "AVIFIL32" fn AVIStreamGetFrame(
    pg: IGetFrame,
    lPos: i32,
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=False (can and should we use this?)
pub extern "AVIFIL32" fn AVIStreamGetFrameClose(
    pg: IGetFrame,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "AVIFIL32" fn AVIStreamOpenFromFileA(
    ppavi: ?*IAVIStream,
    szFile: ?*i8,
    fccType: u32,
    lParam: i32,
    mode: u32,
    pclsidHandler: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "AVIFIL32" fn AVIStreamOpenFromFileW(
    ppavi: ?*IAVIStream,
    szFile: ?*u16,
    fccType: u32,
    lParam: i32,
    mode: u32,
    pclsidHandler: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "AVIFIL32" fn AVIStreamCreate(
    ppavi: ?*IAVIStream,
    lParam1: i32,
    lParam2: i32,
    pclsidHandler: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "AVIFIL32" fn AVIMakeCompressedStream(
    ppsCompressed: ?*IAVIStream,
    ppsSource: IAVIStream,
    lpOptions: ?*AVICOMPRESSOPTIONS,
    pclsidHandler: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "AVIFIL32" fn AVISaveA(
    szFile: ?*i8,
    pclsidHandler: ?*Guid,
    lpfnCallback: AVISAVECALLBACK,
    nStreams: i32,
    pfile: IAVIStream,
    lpOptions: ?*AVICOMPRESSOPTIONS,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "AVIFIL32" fn AVISaveVA(
    szFile: ?*i8,
    pclsidHandler: ?*Guid,
    lpfnCallback: AVISAVECALLBACK,
    nStreams: i32,
    ppavi: ?*IAVIStream,
    plpOptions: ?*?*AVICOMPRESSOPTIONS,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "AVIFIL32" fn AVISaveW(
    szFile: ?*u16,
    pclsidHandler: ?*Guid,
    lpfnCallback: AVISAVECALLBACK,
    nStreams: i32,
    pfile: IAVIStream,
    lpOptions: ?*AVICOMPRESSOPTIONS,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "AVIFIL32" fn AVISaveVW(
    szFile: ?*u16,
    pclsidHandler: ?*Guid,
    lpfnCallback: AVISAVECALLBACK,
    nStreams: i32,
    ppavi: ?*IAVIStream,
    plpOptions: ?*?*AVICOMPRESSOPTIONS,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "AVIFIL32" fn AVISaveOptions(
    hwnd: HWND,
    uiFlags: u32,
    nStreams: i32,
    ppavi: ?*IAVIStream,
    plpOptions: ?*?*AVICOMPRESSOPTIONS,
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=False (can and should we use this?)
pub extern "AVIFIL32" fn AVISaveOptionsFree(
    nStreams: i32,
    plpOptions: ?*?*AVICOMPRESSOPTIONS,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "AVIFIL32" fn AVIBuildFilterW(
    lpszFilter: ?*u16,
    cbFilter: i32,
    fSaving: BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "AVIFIL32" fn AVIBuildFilterA(
    lpszFilter: ?*i8,
    cbFilter: i32,
    fSaving: BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "AVIFIL32" fn AVIMakeFileFromStreams(
    ppfile: ?*IAVIFile,
    nStreams: i32,
    papStreams: ?*IAVIStream,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "AVIFIL32" fn AVIMakeStreamFromClipboard(
    cfFormat: u32,
    hGlobal: HANDLE,
    ppstream: ?*IAVIStream,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "AVIFIL32" fn AVIPutFileOnClipboard(
    pf: IAVIFile,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "AVIFIL32" fn AVIGetFromClipboard(
    lppf: ?*IAVIFile,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "AVIFIL32" fn AVIClearClipboard(
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "AVIFIL32" fn CreateEditableStream(
    ppsEditable: ?*IAVIStream,
    psSource: IAVIStream,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "AVIFIL32" fn EditStreamCut(
    pavi: IAVIStream,
    plStart: ?*i32,
    plLength: ?*i32,
    ppResult: ?*IAVIStream,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "AVIFIL32" fn EditStreamCopy(
    pavi: IAVIStream,
    plStart: ?*i32,
    plLength: ?*i32,
    ppResult: ?*IAVIStream,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "AVIFIL32" fn EditStreamPaste(
    pavi: IAVIStream,
    plPos: ?*i32,
    plLength: ?*i32,
    pstream: IAVIStream,
    lStart: i32,
    lEnd: i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "AVIFIL32" fn EditStreamClone(
    pavi: IAVIStream,
    ppResult: ?*IAVIStream,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "AVIFIL32" fn EditStreamSetNameA(
    pavi: IAVIStream,
    lpszName: ?*i8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "AVIFIL32" fn EditStreamSetNameW(
    pavi: IAVIStream,
    lpszName: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "AVIFIL32" fn EditStreamSetInfoW(
    pavi: IAVIStream,
    lpInfo: ?*AVISTREAMINFOW,
    cbInfo: i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "AVIFIL32" fn EditStreamSetInfoA(
    pavi: IAVIStream,
    lpInfo: ?*AVISTREAMINFOA,
    cbInfo: i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "MSVFW32" fn MCIWndCreateA(
    hwndParent: HWND,
    hInstance: HINSTANCE,
    dwStyle: u32,
    szFile: ?*i8,
) callconv(@import("std").os.windows.WINAPI) HWND;

// set_last_errror=False (can and should we use this?)
pub extern "MSVFW32" fn MCIWndCreateW(
    hwndParent: HWND,
    hInstance: HINSTANCE,
    dwStyle: u32,
    szFile: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HWND;

// set_last_errror=False (can and should we use this?)
pub extern "MSVFW32" fn MCIWndRegisterClass(
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "AVICAP32" fn capCreateCaptureWindowA(
    lpszWindowName: ?*i8,
    dwStyle: u32,
    x: i32,
    y: i32,
    nWidth: i32,
    nHeight: i32,
    hwndParent: HWND,
    nID: i32,
) callconv(@import("std").os.windows.WINAPI) HWND;

// set_last_errror=False (can and should we use this?)
pub extern "AVICAP32" fn capGetDriverDescriptionA(
    wDriverIndex: u32,
    lpszName: ?*i8,
    cbName: i32,
    lpszVer: ?*i8,
    cbVer: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "AVICAP32" fn capCreateCaptureWindowW(
    lpszWindowName: ?*u16,
    dwStyle: u32,
    x: i32,
    y: i32,
    nWidth: i32,
    nHeight: i32,
    hwndParent: HWND,
    nID: i32,
) callconv(@import("std").os.windows.WINAPI) HWND;

// set_last_errror=False (can and should we use this?)
pub extern "AVICAP32" fn capGetDriverDescriptionW(
    wDriverIndex: u32,
    lpszName: ?*u16,
    cbName: i32,
    lpszVer: ?*u16,
    cbVer: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "MSVFW32" fn GetOpenFileNamePreviewA(
    lpofn: ?*OPENFILENAMEA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "MSVFW32" fn GetSaveFileNamePreviewA(
    lpofn: ?*OPENFILENAMEA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "MSVFW32" fn GetOpenFileNamePreviewW(
    lpofn: ?*OPENFILENAMEW,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "MSVFW32" fn GetSaveFileNamePreviewW(
    lpofn: ?*OPENFILENAMEW,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn mmTaskCreate(
    lpfn: LPTASKCALLBACK,
    lph: ?*HANDLE,
    dwInst: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn mmTaskBlock(
    h: u32,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn mmTaskSignal(
    h: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn mmTaskYield(
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "WINMM" fn mmGetCurrentTask(
) callconv(@import("std").os.windows.WINAPI) u32;

//
// Unicode Symbol Aliases
//
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {
        pub const WAVEOUTCAPS = WAVEOUTCAPSA;
        pub const WAVEOUTCAPS2 = WAVEOUTCAPS2A;
        pub const WAVEINCAPS = WAVEINCAPSA;
        pub const WAVEINCAPS2 = WAVEINCAPS2A;
        pub const MIDIOUTCAPS = MIDIOUTCAPSA;
        pub const MIDIOUTCAPS2 = MIDIOUTCAPS2A;
        pub const MIDIINCAPS = MIDIINCAPSA;
        pub const MIDIINCAPS2 = MIDIINCAPS2A;
        pub const AUXCAPS = AUXCAPSA;
        pub const AUXCAPS2 = AUXCAPS2A;
        pub const MIXERCAPS = MIXERCAPSA;
        pub const MIXERCAPS2 = MIXERCAPS2A;
        pub const MIXERLINE = MIXERLINEA;
        pub const MIXERCONTROL = MIXERCONTROLA;
        pub const MIXERLINECONTROLS = MIXERLINECONTROLSA;
        pub const MIXERCONTROLDETAILS_LISTTEXT = MIXERCONTROLDETAILS_LISTTEXTA;
        pub const JOYCAPS = JOYCAPSA;
        pub const JOYCAPS2 = JOYCAPS2A;
        pub const MCI_DGV_CAPTURE_PARMS = MCI_DGV_CAPTURE_PARMSA;
        pub const MCI_DGV_INFO_PARMS = MCI_DGV_INFO_PARMSA;
        pub const MCI_DGV_LIST_PARMS = MCI_DGV_LIST_PARMSA;
        pub const MCI_DGV_OPEN_PARMS = MCI_DGV_OPEN_PARMSA;
        pub const MCI_DGV_QUALITY_PARMS = MCI_DGV_QUALITY_PARMSA;
        pub const MCI_DGV_RESERVE_PARMS = MCI_DGV_RESERVE_PARMSA;
        pub const MCI_DGV_RESTORE_PARMS = MCI_DGV_RESTORE_PARMSA;
        pub const MCI_DGV_SAVE_PARMS = MCI_DGV_SAVE_PARMSA;
        pub const MCI_DGV_SETAUDIO_PARMS = MCI_DGV_SETAUDIO_PARMSA;
        pub const MCI_DGV_SETVIDEO_PARMS = MCI_DGV_SETVIDEO_PARMSA;
        pub const MCI_DGV_STATUS_PARMS = MCI_DGV_STATUS_PARMSA;
        pub const MCI_DGV_WINDOW_PARMS = MCI_DGV_WINDOW_PARMSA;
        pub const tACMDRIVERDETAILS = tACMDRIVERDETAILSA;
        pub const tACMFORMATTAGDETAILS = tACMFORMATTAGDETAILSA;
        pub const ACMFORMATTAGENUMCB = ACMFORMATTAGENUMCBA;
        pub const tACMFORMATDETAILS = tACMFORMATDETAILSA;
        pub const ACMFORMATENUMCB = ACMFORMATENUMCBA;
        pub const ACMFORMATCHOOSEHOOKPROC = ACMFORMATCHOOSEHOOKPROCA;
        pub const tACMFORMATCHOOSE = tACMFORMATCHOOSEA;
        pub const tACMFILTERTAGDETAILS = tACMFILTERTAGDETAILSA;
        pub const ACMFILTERTAGENUMCB = ACMFILTERTAGENUMCBA;
        pub const tACMFILTERDETAILS = tACMFILTERDETAILSA;
        pub const ACMFILTERENUMCB = ACMFILTERENUMCBA;
        pub const ACMFILTERCHOOSEHOOKPROC = ACMFILTERCHOOSEHOOKPROCA;
        pub const tACMFILTERCHOOSE = tACMFILTERCHOOSEA;
        pub const AVISTREAMINFO = AVISTREAMINFOA;
        pub const AVIFILEINFO = AVIFILEINFOA;
        pub const CAPSTATUSCALLBACK = CAPSTATUSCALLBACKA;
        pub const CAPERRORCALLBACK = CAPERRORCALLBACKA;
        pub const mmioStringToFOURCC = mmioStringToFOURCCA;
        pub const mmioInstallIOProc = mmioInstallIOProcA;
        pub const mmioOpen = mmioOpenA;
        pub const mmioRename = mmioRenameA;
        pub const sndPlaySound = sndPlaySoundA;
        pub const PlaySound = PlaySoundA;
        pub const waveOutGetDevCaps = waveOutGetDevCapsA;
        pub const waveOutGetErrorText = waveOutGetErrorTextA;
        pub const waveInGetDevCaps = waveInGetDevCapsA;
        pub const waveInGetErrorText = waveInGetErrorTextA;
        pub const midiOutGetDevCaps = midiOutGetDevCapsA;
        pub const midiOutGetErrorText = midiOutGetErrorTextA;
        pub const midiInGetDevCaps = midiInGetDevCapsA;
        pub const midiInGetErrorText = midiInGetErrorTextA;
        pub const auxGetDevCaps = auxGetDevCapsA;
        pub const mixerGetDevCaps = mixerGetDevCapsA;
        pub const mixerGetLineInfo = mixerGetLineInfoA;
        pub const mixerGetLineControls = mixerGetLineControlsA;
        pub const mixerGetControlDetails = mixerGetControlDetailsA;
        pub const joyGetDevCaps = joyGetDevCapsA;
        pub const acmDriverAdd = acmDriverAddA;
        pub const acmDriverDetails = acmDriverDetailsA;
        pub const acmFormatTagDetails = acmFormatTagDetailsA;
        pub const acmFormatTagEnum = acmFormatTagEnumA;
        pub const acmFormatDetails = acmFormatDetailsA;
        pub const acmFormatEnum = acmFormatEnumA;
        pub const acmFormatChoose = acmFormatChooseA;
        pub const acmFilterTagDetails = acmFilterTagDetailsA;
        pub const acmFilterTagEnum = acmFilterTagEnumA;
        pub const acmFilterDetails = acmFilterDetailsA;
        pub const acmFilterEnum = acmFilterEnumA;
        pub const acmFilterChoose = acmFilterChooseA;
        pub const AVIFileOpen = AVIFileOpenA;
        pub const AVIFileInfo = AVIFileInfoA;
        pub const AVIFileCreateStream = AVIFileCreateStreamA;
        pub const AVIStreamInfo = AVIStreamInfoA;
        pub const AVIStreamOpenFromFile = AVIStreamOpenFromFileA;
        pub const AVISave = AVISaveA;
        pub const AVISaveV = AVISaveVA;
        pub const AVIBuildFilter = AVIBuildFilterA;
        pub const EditStreamSetName = EditStreamSetNameA;
        pub const EditStreamSetInfo = EditStreamSetInfoA;
        pub const MCIWndCreate = MCIWndCreateA;
        pub const capCreateCaptureWindow = capCreateCaptureWindowA;
        pub const capGetDriverDescription = capGetDriverDescriptionA;
        pub const GetOpenFileNamePreview = GetOpenFileNamePreviewA;
        pub const GetSaveFileNamePreview = GetSaveFileNamePreviewA;
    },
    .wide => struct {
        pub const WAVEOUTCAPS = WAVEOUTCAPSW;
        pub const WAVEOUTCAPS2 = WAVEOUTCAPS2W;
        pub const WAVEINCAPS = WAVEINCAPSW;
        pub const WAVEINCAPS2 = WAVEINCAPS2W;
        pub const MIDIOUTCAPS = MIDIOUTCAPSW;
        pub const MIDIOUTCAPS2 = MIDIOUTCAPS2W;
        pub const MIDIINCAPS = MIDIINCAPSW;
        pub const MIDIINCAPS2 = MIDIINCAPS2W;
        pub const AUXCAPS = AUXCAPSW;
        pub const AUXCAPS2 = AUXCAPS2W;
        pub const MIXERCAPS = MIXERCAPSW;
        pub const MIXERCAPS2 = MIXERCAPS2W;
        pub const MIXERLINE = MIXERLINEW;
        pub const MIXERCONTROL = MIXERCONTROLW;
        pub const MIXERLINECONTROLS = MIXERLINECONTROLSW;
        pub const MIXERCONTROLDETAILS_LISTTEXT = MIXERCONTROLDETAILS_LISTTEXTW;
        pub const JOYCAPS = JOYCAPSW;
        pub const JOYCAPS2 = JOYCAPS2W;
        pub const MCI_DGV_CAPTURE_PARMS = MCI_DGV_CAPTURE_PARMSW;
        pub const MCI_DGV_INFO_PARMS = MCI_DGV_INFO_PARMSW;
        pub const MCI_DGV_LIST_PARMS = MCI_DGV_LIST_PARMSW;
        pub const MCI_DGV_OPEN_PARMS = MCI_DGV_OPEN_PARMSW;
        pub const MCI_DGV_QUALITY_PARMS = MCI_DGV_QUALITY_PARMSW;
        pub const MCI_DGV_RESERVE_PARMS = MCI_DGV_RESERVE_PARMSW;
        pub const MCI_DGV_RESTORE_PARMS = MCI_DGV_RESTORE_PARMSW;
        pub const MCI_DGV_SAVE_PARMS = MCI_DGV_SAVE_PARMSW;
        pub const MCI_DGV_SETAUDIO_PARMS = MCI_DGV_SETAUDIO_PARMSW;
        pub const MCI_DGV_SETVIDEO_PARMS = MCI_DGV_SETVIDEO_PARMSW;
        pub const MCI_DGV_STATUS_PARMS = MCI_DGV_STATUS_PARMSW;
        pub const MCI_DGV_WINDOW_PARMS = MCI_DGV_WINDOW_PARMSW;
        pub const tACMDRIVERDETAILS = tACMDRIVERDETAILSW;
        pub const tACMFORMATTAGDETAILS = tACMFORMATTAGDETAILSW;
        pub const ACMFORMATTAGENUMCB = ACMFORMATTAGENUMCBW;
        pub const tACMFORMATDETAILS = tACMFORMATDETAILSW;
        pub const ACMFORMATENUMCB = ACMFORMATENUMCBW;
        pub const ACMFORMATCHOOSEHOOKPROC = ACMFORMATCHOOSEHOOKPROCW;
        pub const tACMFORMATCHOOSE = tACMFORMATCHOOSEW;
        pub const tACMFILTERTAGDETAILS = tACMFILTERTAGDETAILSW;
        pub const ACMFILTERTAGENUMCB = ACMFILTERTAGENUMCBW;
        pub const tACMFILTERDETAILS = tACMFILTERDETAILSW;
        pub const ACMFILTERENUMCB = ACMFILTERENUMCBW;
        pub const ACMFILTERCHOOSEHOOKPROC = ACMFILTERCHOOSEHOOKPROCW;
        pub const tACMFILTERCHOOSE = tACMFILTERCHOOSEW;
        pub const AVISTREAMINFO = AVISTREAMINFOW;
        pub const AVIFILEINFO = AVIFILEINFOW;
        pub const CAPSTATUSCALLBACK = CAPSTATUSCALLBACKW;
        pub const CAPERRORCALLBACK = CAPERRORCALLBACKW;
        pub const mmioStringToFOURCC = mmioStringToFOURCCW;
        pub const mmioInstallIOProc = mmioInstallIOProcW;
        pub const mmioOpen = mmioOpenW;
        pub const mmioRename = mmioRenameW;
        pub const sndPlaySound = sndPlaySoundW;
        pub const PlaySound = PlaySoundW;
        pub const waveOutGetDevCaps = waveOutGetDevCapsW;
        pub const waveOutGetErrorText = waveOutGetErrorTextW;
        pub const waveInGetDevCaps = waveInGetDevCapsW;
        pub const waveInGetErrorText = waveInGetErrorTextW;
        pub const midiOutGetDevCaps = midiOutGetDevCapsW;
        pub const midiOutGetErrorText = midiOutGetErrorTextW;
        pub const midiInGetDevCaps = midiInGetDevCapsW;
        pub const midiInGetErrorText = midiInGetErrorTextW;
        pub const auxGetDevCaps = auxGetDevCapsW;
        pub const mixerGetDevCaps = mixerGetDevCapsW;
        pub const mixerGetLineInfo = mixerGetLineInfoW;
        pub const mixerGetLineControls = mixerGetLineControlsW;
        pub const mixerGetControlDetails = mixerGetControlDetailsW;
        pub const joyGetDevCaps = joyGetDevCapsW;
        pub const acmDriverAdd = acmDriverAddW;
        pub const acmDriverDetails = acmDriverDetailsW;
        pub const acmFormatTagDetails = acmFormatTagDetailsW;
        pub const acmFormatTagEnum = acmFormatTagEnumW;
        pub const acmFormatDetails = acmFormatDetailsW;
        pub const acmFormatEnum = acmFormatEnumW;
        pub const acmFormatChoose = acmFormatChooseW;
        pub const acmFilterTagDetails = acmFilterTagDetailsW;
        pub const acmFilterTagEnum = acmFilterTagEnumW;
        pub const acmFilterDetails = acmFilterDetailsW;
        pub const acmFilterEnum = acmFilterEnumW;
        pub const acmFilterChoose = acmFilterChooseW;
        pub const AVIFileOpen = AVIFileOpenW;
        pub const AVIFileInfo = AVIFileInfoW;
        pub const AVIFileCreateStream = AVIFileCreateStreamW;
        pub const AVIStreamInfo = AVIStreamInfoW;
        pub const AVIStreamOpenFromFile = AVIStreamOpenFromFileW;
        pub const AVISave = AVISaveW;
        pub const AVISaveV = AVISaveVW;
        pub const AVIBuildFilter = AVIBuildFilterW;
        pub const EditStreamSetName = EditStreamSetNameW;
        pub const EditStreamSetInfo = EditStreamSetInfoW;
        pub const MCIWndCreate = MCIWndCreateW;
        pub const capCreateCaptureWindow = capCreateCaptureWindowW;
        pub const capGetDriverDescription = capGetDriverDescriptionW;
        pub const GetOpenFileNamePreview = GetOpenFileNamePreviewW;
        pub const GetSaveFileNamePreview = GetSaveFileNamePreviewW;
    },
    else => if (@import("builtin").is_test) struct {
        pub const WAVEOUTCAPS = *opaque{};
        pub const WAVEOUTCAPS2 = *opaque{};
        pub const WAVEINCAPS = *opaque{};
        pub const WAVEINCAPS2 = *opaque{};
        pub const MIDIOUTCAPS = *opaque{};
        pub const MIDIOUTCAPS2 = *opaque{};
        pub const MIDIINCAPS = *opaque{};
        pub const MIDIINCAPS2 = *opaque{};
        pub const AUXCAPS = *opaque{};
        pub const AUXCAPS2 = *opaque{};
        pub const MIXERCAPS = *opaque{};
        pub const MIXERCAPS2 = *opaque{};
        pub const MIXERLINE = *opaque{};
        pub const MIXERCONTROL = *opaque{};
        pub const MIXERLINECONTROLS = *opaque{};
        pub const MIXERCONTROLDETAILS_LISTTEXT = *opaque{};
        pub const JOYCAPS = *opaque{};
        pub const JOYCAPS2 = *opaque{};
        pub const MCI_DGV_CAPTURE_PARMS = *opaque{};
        pub const MCI_DGV_INFO_PARMS = *opaque{};
        pub const MCI_DGV_LIST_PARMS = *opaque{};
        pub const MCI_DGV_OPEN_PARMS = *opaque{};
        pub const MCI_DGV_QUALITY_PARMS = *opaque{};
        pub const MCI_DGV_RESERVE_PARMS = *opaque{};
        pub const MCI_DGV_RESTORE_PARMS = *opaque{};
        pub const MCI_DGV_SAVE_PARMS = *opaque{};
        pub const MCI_DGV_SETAUDIO_PARMS = *opaque{};
        pub const MCI_DGV_SETVIDEO_PARMS = *opaque{};
        pub const MCI_DGV_STATUS_PARMS = *opaque{};
        pub const MCI_DGV_WINDOW_PARMS = *opaque{};
        pub const tACMDRIVERDETAILS = *opaque{};
        pub const tACMFORMATTAGDETAILS = *opaque{};
        pub const ACMFORMATTAGENUMCB = *opaque{};
        pub const tACMFORMATDETAILS = *opaque{};
        pub const ACMFORMATENUMCB = *opaque{};
        pub const ACMFORMATCHOOSEHOOKPROC = *opaque{};
        pub const tACMFORMATCHOOSE = *opaque{};
        pub const tACMFILTERTAGDETAILS = *opaque{};
        pub const ACMFILTERTAGENUMCB = *opaque{};
        pub const tACMFILTERDETAILS = *opaque{};
        pub const ACMFILTERENUMCB = *opaque{};
        pub const ACMFILTERCHOOSEHOOKPROC = *opaque{};
        pub const tACMFILTERCHOOSE = *opaque{};
        pub const AVISTREAMINFO = *opaque{};
        pub const AVIFILEINFO = *opaque{};
        pub const CAPSTATUSCALLBACK = *opaque{};
        pub const CAPERRORCALLBACK = *opaque{};
        pub const mmioStringToFOURCC = *opaque{};
        pub const mmioInstallIOProc = *opaque{};
        pub const mmioOpen = *opaque{};
        pub const mmioRename = *opaque{};
        pub const sndPlaySound = *opaque{};
        pub const PlaySound = *opaque{};
        pub const waveOutGetDevCaps = *opaque{};
        pub const waveOutGetErrorText = *opaque{};
        pub const waveInGetDevCaps = *opaque{};
        pub const waveInGetErrorText = *opaque{};
        pub const midiOutGetDevCaps = *opaque{};
        pub const midiOutGetErrorText = *opaque{};
        pub const midiInGetDevCaps = *opaque{};
        pub const midiInGetErrorText = *opaque{};
        pub const auxGetDevCaps = *opaque{};
        pub const mixerGetDevCaps = *opaque{};
        pub const mixerGetLineInfo = *opaque{};
        pub const mixerGetLineControls = *opaque{};
        pub const mixerGetControlDetails = *opaque{};
        pub const joyGetDevCaps = *opaque{};
        pub const acmDriverAdd = *opaque{};
        pub const acmDriverDetails = *opaque{};
        pub const acmFormatTagDetails = *opaque{};
        pub const acmFormatTagEnum = *opaque{};
        pub const acmFormatDetails = *opaque{};
        pub const acmFormatEnum = *opaque{};
        pub const acmFormatChoose = *opaque{};
        pub const acmFilterTagDetails = *opaque{};
        pub const acmFilterTagEnum = *opaque{};
        pub const acmFilterDetails = *opaque{};
        pub const acmFilterEnum = *opaque{};
        pub const acmFilterChoose = *opaque{};
        pub const AVIFileOpen = *opaque{};
        pub const AVIFileInfo = *opaque{};
        pub const AVIFileCreateStream = *opaque{};
        pub const AVIStreamInfo = *opaque{};
        pub const AVIStreamOpenFromFile = *opaque{};
        pub const AVISave = *opaque{};
        pub const AVISaveV = *opaque{};
        pub const AVIBuildFilter = *opaque{};
        pub const EditStreamSetName = *opaque{};
        pub const EditStreamSetInfo = *opaque{};
        pub const MCIWndCreate = *opaque{};
        pub const capCreateCaptureWindow = *opaque{};
        pub const capGetDriverDescription = *opaque{};
        pub const GetOpenFileNamePreview = *opaque{};
        pub const GetSaveFileNamePreview = *opaque{};
    } else struct {
        pub const WAVEOUTCAPS = @compileError("'WAVEOUTCAPS' requires that UNICODE be set to true or false in the root module");
        pub const WAVEOUTCAPS2 = @compileError("'WAVEOUTCAPS2' requires that UNICODE be set to true or false in the root module");
        pub const WAVEINCAPS = @compileError("'WAVEINCAPS' requires that UNICODE be set to true or false in the root module");
        pub const WAVEINCAPS2 = @compileError("'WAVEINCAPS2' requires that UNICODE be set to true or false in the root module");
        pub const MIDIOUTCAPS = @compileError("'MIDIOUTCAPS' requires that UNICODE be set to true or false in the root module");
        pub const MIDIOUTCAPS2 = @compileError("'MIDIOUTCAPS2' requires that UNICODE be set to true or false in the root module");
        pub const MIDIINCAPS = @compileError("'MIDIINCAPS' requires that UNICODE be set to true or false in the root module");
        pub const MIDIINCAPS2 = @compileError("'MIDIINCAPS2' requires that UNICODE be set to true or false in the root module");
        pub const AUXCAPS = @compileError("'AUXCAPS' requires that UNICODE be set to true or false in the root module");
        pub const AUXCAPS2 = @compileError("'AUXCAPS2' requires that UNICODE be set to true or false in the root module");
        pub const MIXERCAPS = @compileError("'MIXERCAPS' requires that UNICODE be set to true or false in the root module");
        pub const MIXERCAPS2 = @compileError("'MIXERCAPS2' requires that UNICODE be set to true or false in the root module");
        pub const MIXERLINE = @compileError("'MIXERLINE' requires that UNICODE be set to true or false in the root module");
        pub const MIXERCONTROL = @compileError("'MIXERCONTROL' requires that UNICODE be set to true or false in the root module");
        pub const MIXERLINECONTROLS = @compileError("'MIXERLINECONTROLS' requires that UNICODE be set to true or false in the root module");
        pub const MIXERCONTROLDETAILS_LISTTEXT = @compileError("'MIXERCONTROLDETAILS_LISTTEXT' requires that UNICODE be set to true or false in the root module");
        pub const JOYCAPS = @compileError("'JOYCAPS' requires that UNICODE be set to true or false in the root module");
        pub const JOYCAPS2 = @compileError("'JOYCAPS2' requires that UNICODE be set to true or false in the root module");
        pub const MCI_DGV_CAPTURE_PARMS = @compileError("'MCI_DGV_CAPTURE_PARMS' requires that UNICODE be set to true or false in the root module");
        pub const MCI_DGV_INFO_PARMS = @compileError("'MCI_DGV_INFO_PARMS' requires that UNICODE be set to true or false in the root module");
        pub const MCI_DGV_LIST_PARMS = @compileError("'MCI_DGV_LIST_PARMS' requires that UNICODE be set to true or false in the root module");
        pub const MCI_DGV_OPEN_PARMS = @compileError("'MCI_DGV_OPEN_PARMS' requires that UNICODE be set to true or false in the root module");
        pub const MCI_DGV_QUALITY_PARMS = @compileError("'MCI_DGV_QUALITY_PARMS' requires that UNICODE be set to true or false in the root module");
        pub const MCI_DGV_RESERVE_PARMS = @compileError("'MCI_DGV_RESERVE_PARMS' requires that UNICODE be set to true or false in the root module");
        pub const MCI_DGV_RESTORE_PARMS = @compileError("'MCI_DGV_RESTORE_PARMS' requires that UNICODE be set to true or false in the root module");
        pub const MCI_DGV_SAVE_PARMS = @compileError("'MCI_DGV_SAVE_PARMS' requires that UNICODE be set to true or false in the root module");
        pub const MCI_DGV_SETAUDIO_PARMS = @compileError("'MCI_DGV_SETAUDIO_PARMS' requires that UNICODE be set to true or false in the root module");
        pub const MCI_DGV_SETVIDEO_PARMS = @compileError("'MCI_DGV_SETVIDEO_PARMS' requires that UNICODE be set to true or false in the root module");
        pub const MCI_DGV_STATUS_PARMS = @compileError("'MCI_DGV_STATUS_PARMS' requires that UNICODE be set to true or false in the root module");
        pub const MCI_DGV_WINDOW_PARMS = @compileError("'MCI_DGV_WINDOW_PARMS' requires that UNICODE be set to true or false in the root module");
        pub const tACMDRIVERDETAILS = @compileError("'tACMDRIVERDETAILS' requires that UNICODE be set to true or false in the root module");
        pub const tACMFORMATTAGDETAILS = @compileError("'tACMFORMATTAGDETAILS' requires that UNICODE be set to true or false in the root module");
        pub const ACMFORMATTAGENUMCB = @compileError("'ACMFORMATTAGENUMCB' requires that UNICODE be set to true or false in the root module");
        pub const tACMFORMATDETAILS = @compileError("'tACMFORMATDETAILS' requires that UNICODE be set to true or false in the root module");
        pub const ACMFORMATENUMCB = @compileError("'ACMFORMATENUMCB' requires that UNICODE be set to true or false in the root module");
        pub const ACMFORMATCHOOSEHOOKPROC = @compileError("'ACMFORMATCHOOSEHOOKPROC' requires that UNICODE be set to true or false in the root module");
        pub const tACMFORMATCHOOSE = @compileError("'tACMFORMATCHOOSE' requires that UNICODE be set to true or false in the root module");
        pub const tACMFILTERTAGDETAILS = @compileError("'tACMFILTERTAGDETAILS' requires that UNICODE be set to true or false in the root module");
        pub const ACMFILTERTAGENUMCB = @compileError("'ACMFILTERTAGENUMCB' requires that UNICODE be set to true or false in the root module");
        pub const tACMFILTERDETAILS = @compileError("'tACMFILTERDETAILS' requires that UNICODE be set to true or false in the root module");
        pub const ACMFILTERENUMCB = @compileError("'ACMFILTERENUMCB' requires that UNICODE be set to true or false in the root module");
        pub const ACMFILTERCHOOSEHOOKPROC = @compileError("'ACMFILTERCHOOSEHOOKPROC' requires that UNICODE be set to true or false in the root module");
        pub const tACMFILTERCHOOSE = @compileError("'tACMFILTERCHOOSE' requires that UNICODE be set to true or false in the root module");
        pub const AVISTREAMINFO = @compileError("'AVISTREAMINFO' requires that UNICODE be set to true or false in the root module");
        pub const AVIFILEINFO = @compileError("'AVIFILEINFO' requires that UNICODE be set to true or false in the root module");
        pub const CAPSTATUSCALLBACK = @compileError("'CAPSTATUSCALLBACK' requires that UNICODE be set to true or false in the root module");
        pub const CAPERRORCALLBACK = @compileError("'CAPERRORCALLBACK' requires that UNICODE be set to true or false in the root module");
        pub const mmioStringToFOURCC = @compileError("'mmioStringToFOURCC' requires that UNICODE be set to true or false in the root module");
        pub const mmioInstallIOProc = @compileError("'mmioInstallIOProc' requires that UNICODE be set to true or false in the root module");
        pub const mmioOpen = @compileError("'mmioOpen' requires that UNICODE be set to true or false in the root module");
        pub const mmioRename = @compileError("'mmioRename' requires that UNICODE be set to true or false in the root module");
        pub const sndPlaySound = @compileError("'sndPlaySound' requires that UNICODE be set to true or false in the root module");
        pub const PlaySound = @compileError("'PlaySound' requires that UNICODE be set to true or false in the root module");
        pub const waveOutGetDevCaps = @compileError("'waveOutGetDevCaps' requires that UNICODE be set to true or false in the root module");
        pub const waveOutGetErrorText = @compileError("'waveOutGetErrorText' requires that UNICODE be set to true or false in the root module");
        pub const waveInGetDevCaps = @compileError("'waveInGetDevCaps' requires that UNICODE be set to true or false in the root module");
        pub const waveInGetErrorText = @compileError("'waveInGetErrorText' requires that UNICODE be set to true or false in the root module");
        pub const midiOutGetDevCaps = @compileError("'midiOutGetDevCaps' requires that UNICODE be set to true or false in the root module");
        pub const midiOutGetErrorText = @compileError("'midiOutGetErrorText' requires that UNICODE be set to true or false in the root module");
        pub const midiInGetDevCaps = @compileError("'midiInGetDevCaps' requires that UNICODE be set to true or false in the root module");
        pub const midiInGetErrorText = @compileError("'midiInGetErrorText' requires that UNICODE be set to true or false in the root module");
        pub const auxGetDevCaps = @compileError("'auxGetDevCaps' requires that UNICODE be set to true or false in the root module");
        pub const mixerGetDevCaps = @compileError("'mixerGetDevCaps' requires that UNICODE be set to true or false in the root module");
        pub const mixerGetLineInfo = @compileError("'mixerGetLineInfo' requires that UNICODE be set to true or false in the root module");
        pub const mixerGetLineControls = @compileError("'mixerGetLineControls' requires that UNICODE be set to true or false in the root module");
        pub const mixerGetControlDetails = @compileError("'mixerGetControlDetails' requires that UNICODE be set to true or false in the root module");
        pub const joyGetDevCaps = @compileError("'joyGetDevCaps' requires that UNICODE be set to true or false in the root module");
        pub const acmDriverAdd = @compileError("'acmDriverAdd' requires that UNICODE be set to true or false in the root module");
        pub const acmDriverDetails = @compileError("'acmDriverDetails' requires that UNICODE be set to true or false in the root module");
        pub const acmFormatTagDetails = @compileError("'acmFormatTagDetails' requires that UNICODE be set to true or false in the root module");
        pub const acmFormatTagEnum = @compileError("'acmFormatTagEnum' requires that UNICODE be set to true or false in the root module");
        pub const acmFormatDetails = @compileError("'acmFormatDetails' requires that UNICODE be set to true or false in the root module");
        pub const acmFormatEnum = @compileError("'acmFormatEnum' requires that UNICODE be set to true or false in the root module");
        pub const acmFormatChoose = @compileError("'acmFormatChoose' requires that UNICODE be set to true or false in the root module");
        pub const acmFilterTagDetails = @compileError("'acmFilterTagDetails' requires that UNICODE be set to true or false in the root module");
        pub const acmFilterTagEnum = @compileError("'acmFilterTagEnum' requires that UNICODE be set to true or false in the root module");
        pub const acmFilterDetails = @compileError("'acmFilterDetails' requires that UNICODE be set to true or false in the root module");
        pub const acmFilterEnum = @compileError("'acmFilterEnum' requires that UNICODE be set to true or false in the root module");
        pub const acmFilterChoose = @compileError("'acmFilterChoose' requires that UNICODE be set to true or false in the root module");
        pub const AVIFileOpen = @compileError("'AVIFileOpen' requires that UNICODE be set to true or false in the root module");
        pub const AVIFileInfo = @compileError("'AVIFileInfo' requires that UNICODE be set to true or false in the root module");
        pub const AVIFileCreateStream = @compileError("'AVIFileCreateStream' requires that UNICODE be set to true or false in the root module");
        pub const AVIStreamInfo = @compileError("'AVIStreamInfo' requires that UNICODE be set to true or false in the root module");
        pub const AVIStreamOpenFromFile = @compileError("'AVIStreamOpenFromFile' requires that UNICODE be set to true or false in the root module");
        pub const AVISave = @compileError("'AVISave' requires that UNICODE be set to true or false in the root module");
        pub const AVISaveV = @compileError("'AVISaveV' requires that UNICODE be set to true or false in the root module");
        pub const AVIBuildFilter = @compileError("'AVIBuildFilter' requires that UNICODE be set to true or false in the root module");
        pub const EditStreamSetName = @compileError("'EditStreamSetName' requires that UNICODE be set to true or false in the root module");
        pub const EditStreamSetInfo = @compileError("'EditStreamSetInfo' requires that UNICODE be set to true or false in the root module");
        pub const MCIWndCreate = @compileError("'MCIWndCreate' requires that UNICODE be set to true or false in the root module");
        pub const capCreateCaptureWindow = @compileError("'capCreateCaptureWindow' requires that UNICODE be set to true or false in the root module");
        pub const capGetDriverDescription = @compileError("'capGetDriverDescription' requires that UNICODE be set to true or false in the root module");
        pub const GetOpenFileNamePreview = @compileError("'GetOpenFileNamePreview' requires that UNICODE be set to true or false in the root module");
        pub const GetSaveFileNamePreview = @compileError("'GetSaveFileNamePreview' requires that UNICODE be set to true or false in the root module");
    },
};

//
// type imports
//
const Guid = @import("../zig.zig").Guid;
const LRESULT = @import("systemservices.zig").LRESULT;
const BITMAPINFOHEADER = @import("directshow.zig").BITMAPINFOHEADER;
const LPARAM = @import("windowsandmessaging.zig").LPARAM;
const HPALETTE = @import("gdi.zig").HPALETTE;
const HWND = @import("windowsandmessaging.zig").HWND;
const HDC = @import("gdi.zig").HDC;
const PALETTEENTRY = @import("direct2d.zig").PALETTEENTRY;
const BITMAPINFO = @import("gdi.zig").BITMAPINFO;
const RECT = @import("displaydevices.zig").RECT;
const BOOL = @import("systemservices.zig").BOOL;
const HANDLE = @import("systemservices.zig").HANDLE;
const POINT = @import("displaydevices.zig").POINT;
const HINSTANCE = @import("systemservices.zig").HINSTANCE;
const FARPROC = @import("systemservices.zig").FARPROC;
const HRESULT = @import("com.zig").HRESULT;
const OPENFILENAMEA = @import("windowsandmessaging.zig").OPENFILENAMEA;
const OPENFILENAMEW = @import("windowsandmessaging.zig").OPENFILENAMEW;

test "" {
    const constant_export_count = 0;
    const type_export_count = 257;
    const func_count = 305;
    const unicode_alias_count = 94;
    const type_import_count = 18;
    @setEvalBranchQuota(0
        + constant_export_count
        + type_export_count
        + func_count
        + unicode_alias_count
        + type_import_count
        + 2 // TODO: why do I need these extra 2?
    );
    @import("std").testing.refAllDecls(@This());
}
