//! NOTE: this source file is autogenerated, DO NOT MODIFY

//
// constants
//

//
// types
//
// --------------------------------------------------------
// Type: ISequentialStream
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ISequentialStream = *opaque{
    // TODO: Method 'Read'
    // TODO: Method 'Write'
};
// --------------------------------------------------------
// Type: STATSTG
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const STATSTG = extern struct {
    pwcsName: ?*u16,
    type: u32,
    cbSize: ULARGE_INTEGER,
    mtime: FILETIME,
    ctime: FILETIME,
    atime: FILETIME,
    grfMode: u32,
    grfLocksSupported: u32,
    clsid: Guid,
    grfStateBits: u32,
    reserved: u32,
};
// --------------------------------------------------------
// Type: STGTY
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const STGTY = *opaque{
};
// --------------------------------------------------------
// Type: STREAM_SEEK
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const STREAM_SEEK = *opaque{
};
// --------------------------------------------------------
// Type: LOCKTYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const LOCKTYPE = *opaque{
};
// --------------------------------------------------------
// Type: IStream
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IStream = *opaque{
    // TODO: Method 'Seek'
    // TODO: Method 'SetSize'
    // TODO: Method 'CopyTo'
    // TODO: Method 'Commit'
    // TODO: Method 'Revert'
    // TODO: Method 'LockRegion'
    // TODO: Method 'UnlockRegion'
    // TODO: Method 'Stat'
    // TODO: Method 'Clone'
};
// --------------------------------------------------------
// Type: IEnumSTATSTG
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IEnumSTATSTG = *opaque{
    // TODO: Method 'Next'
    // TODO: Method 'Skip'
    // TODO: Method 'Reset'
    // TODO: Method 'Clone'
};
// --------------------------------------------------------
// Type: RemSNB
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const RemSNB = extern struct {
    ulCntStr: u32,
    ulCntChar: u32,
    rgString: ?[*]u16,
};
// --------------------------------------------------------
// Type: IStorage
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IStorage = *opaque{
    // TODO: Method 'CreateStream'
    // TODO: Method 'OpenStream'
    // TODO: Method 'CreateStorage'
    // TODO: Method 'OpenStorage'
    // TODO: Method 'CopyTo'
    // TODO: Method 'MoveElementTo'
    // TODO: Method 'Commit'
    // TODO: Method 'Revert'
    // TODO: Method 'EnumElements'
    // TODO: Method 'DestroyElement'
    // TODO: Method 'RenameElement'
    // TODO: Method 'SetElementTimes'
    // TODO: Method 'SetClass'
    // TODO: Method 'SetStateBits'
    // TODO: Method 'Stat'
};
// --------------------------------------------------------
// Type: ILockBytes
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ILockBytes = *opaque{
    // TODO: Method 'ReadAt'
    // TODO: Method 'WriteAt'
    // TODO: Method 'Flush'
    // TODO: Method 'SetSize'
    // TODO: Method 'LockRegion'
    // TODO: Method 'UnlockRegion'
    // TODO: Method 'Stat'
};
// --------------------------------------------------------
// Type: IRootStorage
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IRootStorage = *opaque{
    // TODO: Method 'SwitchToFile'
};
// --------------------------------------------------------
// Type: IFillLockBytes
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IFillLockBytes = *opaque{
    // TODO: Method 'FillAppend'
    // TODO: Method 'FillAt'
    // TODO: Method 'SetFillSize'
    // TODO: Method 'Terminate'
};
// --------------------------------------------------------
// Type: StorageLayout
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const StorageLayout = extern struct {
    LayoutType: u32,
    pwcsElementName: ?*u16,
    cOffset: LARGE_INTEGER,
    cBytes: LARGE_INTEGER,
};
// --------------------------------------------------------
// Type: ILayoutStorage
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ILayoutStorage = *opaque{
    // TODO: Method 'LayoutScript'
    // TODO: Method 'BeginMonitor'
    // TODO: Method 'EndMonitor'
    // TODO: Method 'ReLayoutDocfile'
    // TODO: Method 'ReLayoutDocfileOnILockBytes'
};
// --------------------------------------------------------
// Type: IDirectWriterLock
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IDirectWriterLock = *opaque{
    // TODO: Method 'WaitForWriteAccess'
    // TODO: Method 'ReleaseWriteAccess'
    // TODO: Method 'HaveWriteAccess'
};
// --------------------------------------------------------
// Type: VERSIONEDSTREAM
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const VERSIONEDSTREAM = extern struct {
    guidVersion: Guid,
    pStream: IStream,
};
// --------------------------------------------------------
// Type: CAC
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CAC = extern struct {
    cElems: u32,
    pElems: ?*i8,
};
// --------------------------------------------------------
// Type: CAUB
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CAUB = extern struct {
    cElems: u32,
    pElems: ?*u8,
};
// --------------------------------------------------------
// Type: CAI
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CAI = extern struct {
    cElems: u32,
    pElems: ?*i16,
};
// --------------------------------------------------------
// Type: CAUI
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CAUI = extern struct {
    cElems: u32,
    pElems: ?*u16,
};
// --------------------------------------------------------
// Type: CAL
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CAL = extern struct {
    cElems: u32,
    pElems: ?*i32,
};
// --------------------------------------------------------
// Type: CAUL
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CAUL = extern struct {
    cElems: u32,
    pElems: ?*u32,
};
// --------------------------------------------------------
// Type: CAFLT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CAFLT = extern struct {
    cElems: u32,
    pElems: ?*f32,
};
// --------------------------------------------------------
// Type: CADBL
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CADBL = extern struct {
    cElems: u32,
    pElems: ?*f64,
};
// --------------------------------------------------------
// Type: CACY
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CACY = extern struct {
    cElems: u32,
    pElems: ?*CY,
};
// --------------------------------------------------------
// Type: CADATE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CADATE = extern struct {
    cElems: u32,
    pElems: ?*f64,
};
// --------------------------------------------------------
// Type: CABSTR
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CABSTR = extern struct {
    cElems: u32,
    pElems: ?*BSTR,
};
// --------------------------------------------------------
// Type: CABSTRBLOB
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CABSTRBLOB = extern struct {
    cElems: u32,
    pElems: ?*BSTRBLOB,
};
// --------------------------------------------------------
// Type: CABOOL
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CABOOL = extern struct {
    cElems: u32,
    pElems: ?*i16,
};
// --------------------------------------------------------
// Type: CASCODE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CASCODE = extern struct {
    cElems: u32,
    pElems: ?*i32,
};
// --------------------------------------------------------
// Type: CAPROPVARIANT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CAPROPVARIANT = extern struct {
    cElems: u32,
    pElems: ?*PROPVARIANT,
};
// --------------------------------------------------------
// Type: CAH
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CAH = extern struct {
    cElems: u32,
    pElems: ?*LARGE_INTEGER,
};
// --------------------------------------------------------
// Type: CAUH
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CAUH = extern struct {
    cElems: u32,
    pElems: ?*ULARGE_INTEGER,
};
// --------------------------------------------------------
// Type: CALPSTR
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CALPSTR = extern struct {
    cElems: u32,
    pElems: ?*?*i8,
};
// --------------------------------------------------------
// Type: CALPWSTR
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CALPWSTR = extern struct {
    cElems: u32,
    pElems: ?*?*u16,
};
// --------------------------------------------------------
// Type: CAFILETIME
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CAFILETIME = extern struct {
    cElems: u32,
    pElems: ?*FILETIME,
};
// --------------------------------------------------------
// Type: CACLIPDATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CACLIPDATA = extern struct {
    cElems: u32,
    pElems: ?*CLIPDATA,
};
// --------------------------------------------------------
// Type: CACLSID
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CACLSID = extern struct {
    cElems: u32,
    pElems: ?*Guid,
};
// --------------------------------------------------------
// Type: PROPVARIANT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PROPVARIANT = extern struct {
    Anonymous: _Anonymous_e__Union,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
        // --------------------------------------------------------
        // Type: _Anonymous_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _Anonymous_e__Struct = extern struct {
            vt: u16,
            wReserved1: u16,
            wReserved2: u16,
            wReserved3: u16,
            Anonymous: _Anonymous_e__Union,
            // --------------------------------------------------------
            // Type: _Anonymous_e__Union
            // TypeLayoutAttr: explicit
            // not generating the actual code for this type because it has an explicit layout
            pub const _Anonymous_e__Union = *opaque{
            };
        };
    };
};
// --------------------------------------------------------
// Type: PROPSPEC
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PROPSPEC = extern struct {
    ulKind: u32,
    Anonymous: _Anonymous_e__Union,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: STATPROPSTG
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const STATPROPSTG = extern struct {
    lpwstrName: ?*u16,
    propid: u32,
    vt: u16,
};
// --------------------------------------------------------
// Type: STATPROPSETSTG
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const STATPROPSETSTG = extern struct {
    fmtid: Guid,
    clsid: Guid,
    grfFlags: u32,
    mtime: FILETIME,
    ctime: FILETIME,
    atime: FILETIME,
    dwOSVersion: u32,
};
// --------------------------------------------------------
// Type: IPropertyStorage
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IPropertyStorage = *opaque{
    // TODO: Method 'ReadMultiple'
    // TODO: Method 'WriteMultiple'
    // TODO: Method 'DeleteMultiple'
    // TODO: Method 'ReadPropertyNames'
    // TODO: Method 'WritePropertyNames'
    // TODO: Method 'DeletePropertyNames'
    // TODO: Method 'Commit'
    // TODO: Method 'Revert'
    // TODO: Method 'Enum'
    // TODO: Method 'SetTimes'
    // TODO: Method 'SetClass'
    // TODO: Method 'Stat'
};
// --------------------------------------------------------
// Type: IPropertySetStorage
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IPropertySetStorage = *opaque{
    // TODO: Method 'Create'
    // TODO: Method 'Open'
    // TODO: Method 'Delete'
    // TODO: Method 'Enum'
};
// --------------------------------------------------------
// Type: IEnumSTATPROPSTG
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IEnumSTATPROPSTG = *opaque{
    // TODO: Method 'Next'
    // TODO: Method 'Skip'
    // TODO: Method 'Reset'
    // TODO: Method 'Clone'
};
// --------------------------------------------------------
// Type: IEnumSTATPROPSETSTG
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IEnumSTATPROPSETSTG = *opaque{
    // TODO: Method 'Next'
    // TODO: Method 'Skip'
    // TODO: Method 'Reset'
    // TODO: Method 'Clone'
};
// --------------------------------------------------------
// Type: STGOPTIONS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const STGOPTIONS = extern struct {
    usVersion: u16,
    reserved: u16,
    ulSectorSize: u32,
    pwcsTemplateFile: ?*u16,
};
// --------------------------------------------------------
// Type: PIDMSI_STATUS_VALUE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PIDMSI_STATUS_VALUE = *opaque{
};
// --------------------------------------------------------
// Type: PMemoryAllocator
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const PMemoryAllocator = opaque {
};
// --------------------------------------------------------
// Type: JET_INDEXID
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const JET_INDEXID = extern struct {
    cbStruct: u32,
    rgbIndexId: ?[*]u8,
};
// --------------------------------------------------------
// Type: JET_PFNSTATUS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const JET_PFNSTATUS = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: JET_RSTMAP_A
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const JET_RSTMAP_A = extern struct {
    szDatabaseName: ?*i8,
    szNewDatabaseName: ?*i8,
};
// --------------------------------------------------------
// Type: JET_RSTMAP_W
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const JET_RSTMAP_W = extern struct {
    szDatabaseName: ?*u16,
    szNewDatabaseName: ?*u16,
};
// --------------------------------------------------------
// Type: tagCONVERT_A
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const tagCONVERT_A = extern struct {
    szOldDll: ?*i8,
    Anonymous: _Anonymous_e__Union,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
        // --------------------------------------------------------
        // Type: _Anonymous_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _Anonymous_e__Struct = extern struct {
            _bitfield: u32,
        };
    };
};
// --------------------------------------------------------
// Type: tagCONVERT_W
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const tagCONVERT_W = extern struct {
    szOldDll: ?*u16,
    Anonymous: _Anonymous_e__Union,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
        // --------------------------------------------------------
        // Type: _Anonymous_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _Anonymous_e__Struct = extern struct {
            _bitfield: u32,
        };
    };
};
// --------------------------------------------------------
// Type: JET_CALLBACK
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const JET_CALLBACK = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: JET_SNPROG
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const JET_SNPROG = extern struct {
    cbStruct: u32,
    cunitDone: u32,
    cunitTotal: u32,
};
// --------------------------------------------------------
// Type: JET_DBINFOUPGRADE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const JET_DBINFOUPGRADE = extern struct {
    cbStruct: u32,
    cbFilesizeLow: u32,
    cbFilesizeHigh: u32,
    cbFreeSpaceRequiredLow: u32,
    cbFreeSpaceRequiredHigh: u32,
    csecToUpgrade: u32,
    Anonymous: _Anonymous_e__Union,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
        // --------------------------------------------------------
        // Type: _Anonymous_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _Anonymous_e__Struct = extern struct {
            _bitfield: u32,
        };
    };
};
// --------------------------------------------------------
// Type: JET_OBJECTINFO
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=4 Size=0
pub const JET_OBJECTINFO = *opaque{
};
// --------------------------------------------------------
// Type: JET_OBJECTLIST
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const JET_OBJECTLIST = extern struct {
    cbStruct: u32,
    tableid: u32,
    cRecord: u32,
    columnidcontainername: u32,
    columnidobjectname: u32,
    columnidobjtyp: u32,
    columniddtCreate: u32,
    columniddtUpdate: u32,
    columnidgrbit: u32,
    columnidflags: u32,
    columnidcRecord: u32,
    columnidcPage: u32,
};
// --------------------------------------------------------
// Type: JET_COLUMNLIST
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const JET_COLUMNLIST = extern struct {
    cbStruct: u32,
    tableid: u32,
    cRecord: u32,
    columnidPresentationOrder: u32,
    columnidcolumnname: u32,
    columnidcolumnid: u32,
    columnidcoltyp: u32,
    columnidCountry: u32,
    columnidLangid: u32,
    columnidCp: u32,
    columnidCollate: u32,
    columnidcbMax: u32,
    columnidgrbit: u32,
    columnidDefault: u32,
    columnidBaseTableName: u32,
    columnidBaseColumnName: u32,
    columnidDefinitionName: u32,
};
// --------------------------------------------------------
// Type: JET_COLUMNDEF
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const JET_COLUMNDEF = extern struct {
    cbStruct: u32,
    columnid: u32,
    coltyp: u32,
    wCountry: u16,
    langid: u16,
    cp: u16,
    wCollate: u16,
    cbMax: u32,
    grbit: u32,
};
// --------------------------------------------------------
// Type: JET_COLUMNBASE_A
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const JET_COLUMNBASE_A = extern struct {
    cbStruct: u32,
    columnid: u32,
    coltyp: u32,
    wCountry: u16,
    langid: u16,
    cp: u16,
    wFiller: u16,
    cbMax: u32,
    grbit: u32,
    szBaseTableName: ?[*]i8,
    szBaseColumnName: ?[*]i8,
};
// --------------------------------------------------------
// Type: JET_COLUMNBASE_W
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const JET_COLUMNBASE_W = extern struct {
    cbStruct: u32,
    columnid: u32,
    coltyp: u32,
    wCountry: u16,
    langid: u16,
    cp: u16,
    wFiller: u16,
    cbMax: u32,
    grbit: u32,
    szBaseTableName: ?[*]u16,
    szBaseColumnName: ?[*]u16,
};
// --------------------------------------------------------
// Type: JET_INDEXLIST
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const JET_INDEXLIST = extern struct {
    cbStruct: u32,
    tableid: u32,
    cRecord: u32,
    columnidindexname: u32,
    columnidgrbitIndex: u32,
    columnidcKey: u32,
    columnidcEntry: u32,
    columnidcPage: u32,
    columnidcColumn: u32,
    columnidiColumn: u32,
    columnidcolumnid: u32,
    columnidcoltyp: u32,
    columnidCountry: u32,
    columnidLangid: u32,
    columnidCp: u32,
    columnidCollate: u32,
    columnidgrbitColumn: u32,
    columnidcolumnname: u32,
    columnidLCMapFlags: u32,
};
// --------------------------------------------------------
// Type: tag_JET_COLUMNCREATE_A
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const tag_JET_COLUMNCREATE_A = extern struct {
    cbStruct: u32,
    szColumnName: ?*i8,
    coltyp: u32,
    cbMax: u32,
    grbit: u32,
    pvDefault: ?*opaque{},
    cbDefault: u32,
    cp: u32,
    columnid: u32,
    err: i32,
};
// --------------------------------------------------------
// Type: tag_JET_COLUMNCREATE_W
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const tag_JET_COLUMNCREATE_W = extern struct {
    cbStruct: u32,
    szColumnName: ?*u16,
    coltyp: u32,
    cbMax: u32,
    grbit: u32,
    pvDefault: ?*opaque{},
    cbDefault: u32,
    cp: u32,
    columnid: u32,
    err: i32,
};
// --------------------------------------------------------
// Type: tag_JET_USERDEFINEDDEFAULT_A
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const tag_JET_USERDEFINEDDEFAULT_A = extern struct {
    szCallback: ?*i8,
    pbUserData: ?*u8,
    cbUserData: u32,
    szDependantColumns: ?*i8,
};
// --------------------------------------------------------
// Type: tag_JET_USERDEFINEDDEFAULT_W
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const tag_JET_USERDEFINEDDEFAULT_W = extern struct {
    szCallback: ?*u16,
    pbUserData: ?*u8,
    cbUserData: u32,
    szDependantColumns: ?*u16,
};
// --------------------------------------------------------
// Type: JET_CONDITIONALCOLUMN_A
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const JET_CONDITIONALCOLUMN_A = extern struct {
    cbStruct: u32,
    szColumnName: ?*i8,
    grbit: u32,
};
// --------------------------------------------------------
// Type: JET_CONDITIONALCOLUMN_W
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const JET_CONDITIONALCOLUMN_W = extern struct {
    cbStruct: u32,
    szColumnName: ?*u16,
    grbit: u32,
};
// --------------------------------------------------------
// Type: JET_UNICODEINDEX
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const JET_UNICODEINDEX = extern struct {
    lcid: u32,
    dwMapFlags: u32,
};
// --------------------------------------------------------
// Type: JET_UNICODEINDEX2
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const JET_UNICODEINDEX2 = extern struct {
    szLocaleName: ?*u16,
    dwMapFlags: u32,
};
// --------------------------------------------------------
// Type: JET_TUPLELIMITS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const JET_TUPLELIMITS = extern struct {
    chLengthMin: u32,
    chLengthMax: u32,
    chToIndexMax: u32,
    cchIncrement: u32,
    ichStart: u32,
};
// --------------------------------------------------------
// Type: JET_SPACEHINTS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const JET_SPACEHINTS = extern struct {
    cbStruct: u32,
    ulInitialDensity: u32,
    cbInitial: u32,
    grbit: u32,
    ulMaintDensity: u32,
    ulGrowth: u32,
    cbMinExtent: u32,
    cbMaxExtent: u32,
};
// --------------------------------------------------------
// Type: JET_INDEXCREATE_A
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const JET_INDEXCREATE_A = extern struct {
    cbStruct: u32,
    szIndexName: ?*i8,
    szKey: ?*i8,
    cbKey: u32,
    grbit: u32,
    ulDensity: u32,
    Anonymous1: _Anonymous1_e__Union,
    Anonymous2: _Anonymous2_e__Union,
    rgconditionalcolumn: ?*JET_CONDITIONALCOLUMN_A,
    cConditionalColumn: u32,
    err: i32,
    cbKeyMost: u32,
    // --------------------------------------------------------
    // Type: _Anonymous1_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous1_e__Union = *opaque{
    };
    // --------------------------------------------------------
    // Type: _Anonymous2_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous2_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: JET_INDEXCREATE_W
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const JET_INDEXCREATE_W = extern struct {
    cbStruct: u32,
    szIndexName: ?*u16,
    szKey: ?*u16,
    cbKey: u32,
    grbit: u32,
    ulDensity: u32,
    Anonymous1: _Anonymous1_e__Union,
    Anonymous2: _Anonymous2_e__Union,
    rgconditionalcolumn: ?*JET_CONDITIONALCOLUMN_W,
    cConditionalColumn: u32,
    err: i32,
    cbKeyMost: u32,
    // --------------------------------------------------------
    // Type: _Anonymous1_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous1_e__Union = *opaque{
    };
    // --------------------------------------------------------
    // Type: _Anonymous2_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous2_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: JET_INDEXCREATE2_A
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const JET_INDEXCREATE2_A = extern struct {
    cbStruct: u32,
    szIndexName: ?*i8,
    szKey: ?*i8,
    cbKey: u32,
    grbit: u32,
    ulDensity: u32,
    Anonymous1: _Anonymous1_e__Union,
    Anonymous2: _Anonymous2_e__Union,
    rgconditionalcolumn: ?*JET_CONDITIONALCOLUMN_A,
    cConditionalColumn: u32,
    err: i32,
    cbKeyMost: u32,
    pSpacehints: ?*JET_SPACEHINTS,
    // --------------------------------------------------------
    // Type: _Anonymous1_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous1_e__Union = *opaque{
    };
    // --------------------------------------------------------
    // Type: _Anonymous2_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous2_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: JET_INDEXCREATE2_W
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const JET_INDEXCREATE2_W = extern struct {
    cbStruct: u32,
    szIndexName: ?*u16,
    szKey: ?*u16,
    cbKey: u32,
    grbit: u32,
    ulDensity: u32,
    Anonymous1: _Anonymous1_e__Union,
    Anonymous2: _Anonymous2_e__Union,
    rgconditionalcolumn: ?*JET_CONDITIONALCOLUMN_W,
    cConditionalColumn: u32,
    err: i32,
    cbKeyMost: u32,
    pSpacehints: ?*JET_SPACEHINTS,
    // --------------------------------------------------------
    // Type: _Anonymous1_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous1_e__Union = *opaque{
    };
    // --------------------------------------------------------
    // Type: _Anonymous2_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous2_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: JET_INDEXCREATE3_A
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const JET_INDEXCREATE3_A = extern struct {
    cbStruct: u32,
    szIndexName: ?*i8,
    szKey: ?*i8,
    cbKey: u32,
    grbit: u32,
    ulDensity: u32,
    pidxunicode: ?*JET_UNICODEINDEX2,
    Anonymous: _Anonymous_e__Union,
    rgconditionalcolumn: ?*JET_CONDITIONALCOLUMN_A,
    cConditionalColumn: u32,
    err: i32,
    cbKeyMost: u32,
    pSpacehints: ?*JET_SPACEHINTS,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: JET_INDEXCREATE3_W
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const JET_INDEXCREATE3_W = extern struct {
    cbStruct: u32,
    szIndexName: ?*u16,
    szKey: ?*u16,
    cbKey: u32,
    grbit: u32,
    ulDensity: u32,
    pidxunicode: ?*JET_UNICODEINDEX2,
    Anonymous: _Anonymous_e__Union,
    rgconditionalcolumn: ?*JET_CONDITIONALCOLUMN_W,
    cConditionalColumn: u32,
    err: i32,
    cbKeyMost: u32,
    pSpacehints: ?*JET_SPACEHINTS,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: JET_TABLECREATE_A
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const JET_TABLECREATE_A = extern struct {
    cbStruct: u32,
    szTableName: ?*i8,
    szTemplateTableName: ?*i8,
    ulPages: u32,
    ulDensity: u32,
    rgcolumncreate: ?*tag_JET_COLUMNCREATE_A,
    cColumns: u32,
    rgindexcreate: ?*JET_INDEXCREATE_A,
    cIndexes: u32,
    grbit: u32,
    tableid: u32,
    cCreated: u32,
};
// --------------------------------------------------------
// Type: JET_TABLECREATE_W
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const JET_TABLECREATE_W = extern struct {
    cbStruct: u32,
    szTableName: ?*u16,
    szTemplateTableName: ?*u16,
    ulPages: u32,
    ulDensity: u32,
    rgcolumncreate: ?*tag_JET_COLUMNCREATE_W,
    cColumns: u32,
    rgindexcreate: ?*JET_INDEXCREATE_W,
    cIndexes: u32,
    grbit: u32,
    tableid: u32,
    cCreated: u32,
};
// --------------------------------------------------------
// Type: JET_TABLECREATE2_A
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const JET_TABLECREATE2_A = extern struct {
    cbStruct: u32,
    szTableName: ?*i8,
    szTemplateTableName: ?*i8,
    ulPages: u32,
    ulDensity: u32,
    rgcolumncreate: ?*tag_JET_COLUMNCREATE_A,
    cColumns: u32,
    rgindexcreate: ?*JET_INDEXCREATE_A,
    cIndexes: u32,
    szCallback: ?*i8,
    cbtyp: u32,
    grbit: u32,
    tableid: u32,
    cCreated: u32,
};
// --------------------------------------------------------
// Type: JET_TABLECREATE2_W
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const JET_TABLECREATE2_W = extern struct {
    cbStruct: u32,
    szTableName: ?*u16,
    szTemplateTableName: ?*u16,
    ulPages: u32,
    ulDensity: u32,
    rgcolumncreate: ?*tag_JET_COLUMNCREATE_W,
    cColumns: u32,
    rgindexcreate: ?*JET_INDEXCREATE_W,
    cIndexes: u32,
    szCallback: ?*u16,
    cbtyp: u32,
    grbit: u32,
    tableid: u32,
    cCreated: u32,
};
// --------------------------------------------------------
// Type: JET_TABLECREATE3_A
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const JET_TABLECREATE3_A = extern struct {
    cbStruct: u32,
    szTableName: ?*i8,
    szTemplateTableName: ?*i8,
    ulPages: u32,
    ulDensity: u32,
    rgcolumncreate: ?*tag_JET_COLUMNCREATE_A,
    cColumns: u32,
    rgindexcreate: ?*JET_INDEXCREATE2_A,
    cIndexes: u32,
    szCallback: ?*i8,
    cbtyp: u32,
    grbit: u32,
    pSeqSpacehints: ?*JET_SPACEHINTS,
    pLVSpacehints: ?*JET_SPACEHINTS,
    cbSeparateLV: u32,
    tableid: u32,
    cCreated: u32,
};
// --------------------------------------------------------
// Type: JET_TABLECREATE3_W
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const JET_TABLECREATE3_W = extern struct {
    cbStruct: u32,
    szTableName: ?*u16,
    szTemplateTableName: ?*u16,
    ulPages: u32,
    ulDensity: u32,
    rgcolumncreate: ?*tag_JET_COLUMNCREATE_W,
    cColumns: u32,
    rgindexcreate: ?*JET_INDEXCREATE2_W,
    cIndexes: u32,
    szCallback: ?*u16,
    cbtyp: u32,
    grbit: u32,
    pSeqSpacehints: ?*JET_SPACEHINTS,
    pLVSpacehints: ?*JET_SPACEHINTS,
    cbSeparateLV: u32,
    tableid: u32,
    cCreated: u32,
};
// --------------------------------------------------------
// Type: JET_TABLECREATE4_A
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const JET_TABLECREATE4_A = extern struct {
    cbStruct: u32,
    szTableName: ?*i8,
    szTemplateTableName: ?*i8,
    ulPages: u32,
    ulDensity: u32,
    rgcolumncreate: ?*tag_JET_COLUMNCREATE_A,
    cColumns: u32,
    rgindexcreate: ?*JET_INDEXCREATE3_A,
    cIndexes: u32,
    szCallback: ?*i8,
    cbtyp: u32,
    grbit: u32,
    pSeqSpacehints: ?*JET_SPACEHINTS,
    pLVSpacehints: ?*JET_SPACEHINTS,
    cbSeparateLV: u32,
    tableid: u32,
    cCreated: u32,
};
// --------------------------------------------------------
// Type: JET_TABLECREATE4_W
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const JET_TABLECREATE4_W = extern struct {
    cbStruct: u32,
    szTableName: ?*u16,
    szTemplateTableName: ?*u16,
    ulPages: u32,
    ulDensity: u32,
    rgcolumncreate: ?*tag_JET_COLUMNCREATE_W,
    cColumns: u32,
    rgindexcreate: ?*JET_INDEXCREATE3_W,
    cIndexes: u32,
    szCallback: ?*u16,
    cbtyp: u32,
    grbit: u32,
    pSeqSpacehints: ?*JET_SPACEHINTS,
    pLVSpacehints: ?*JET_SPACEHINTS,
    cbSeparateLV: u32,
    tableid: u32,
    cCreated: u32,
};
// --------------------------------------------------------
// Type: JET_OPENTEMPORARYTABLE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const JET_OPENTEMPORARYTABLE = extern struct {
    cbStruct: u32,
    prgcolumndef: ?*JET_COLUMNDEF,
    ccolumn: u32,
    pidxunicode: ?*JET_UNICODEINDEX,
    grbit: u32,
    prgcolumnid: ?*u32,
    cbKeyMost: u32,
    cbVarSegMac: u32,
    tableid: u32,
};
// --------------------------------------------------------
// Type: JET_OPENTEMPORARYTABLE2
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const JET_OPENTEMPORARYTABLE2 = extern struct {
    cbStruct: u32,
    prgcolumndef: ?*JET_COLUMNDEF,
    ccolumn: u32,
    pidxunicode: ?*JET_UNICODEINDEX2,
    grbit: u32,
    prgcolumnid: ?*u32,
    cbKeyMost: u32,
    cbVarSegMac: u32,
    tableid: u32,
};
// --------------------------------------------------------
// Type: JET_RETINFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const JET_RETINFO = extern struct {
    cbStruct: u32,
    ibLongValue: u32,
    itagSequence: u32,
    columnidNextTagged: u32,
};
// --------------------------------------------------------
// Type: JET_SETINFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const JET_SETINFO = extern struct {
    cbStruct: u32,
    ibLongValue: u32,
    itagSequence: u32,
};
// --------------------------------------------------------
// Type: JET_RECPOS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const JET_RECPOS = extern struct {
    cbStruct: u32,
    centriesLT: u32,
    centriesInRange: u32,
    centriesTotal: u32,
};
// --------------------------------------------------------
// Type: JET_RECORDLIST
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const JET_RECORDLIST = extern struct {
    cbStruct: u32,
    tableid: u32,
    cRecord: u32,
    columnidBookmark: u32,
};
// --------------------------------------------------------
// Type: JET_INDEXRANGE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const JET_INDEXRANGE = extern struct {
    cbStruct: u32,
    tableid: u32,
    grbit: u32,
};
// --------------------------------------------------------
// Type: JET_RELOP
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const JET_RELOP = *opaque{
};
// --------------------------------------------------------
// Type: JET_INDEX_COLUMN
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const JET_INDEX_COLUMN = extern struct {
    columnid: u32,
    relop: JET_RELOP,
    pv: ?*opaque{},
    cb: u32,
    grbit: u32,
};
// --------------------------------------------------------
// Type: JET_INDEX_RANGE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const JET_INDEX_RANGE = extern struct {
    rgStartColumns: ?*JET_INDEX_COLUMN,
    cStartColumns: u32,
    rgEndColumns: ?*JET_INDEX_COLUMN,
    cEndColumns: u32,
};
// --------------------------------------------------------
// Type: JET_LOGTIME
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const JET_LOGTIME = extern struct {
    bSeconds: i8,
    bMinutes: i8,
    bHours: i8,
    bDay: i8,
    bMonth: i8,
    bYear: i8,
    Anonymous1: _Anonymous1_e__Union,
    Anonymous2: _Anonymous2_e__Union,
    // --------------------------------------------------------
    // Type: _Anonymous2_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous2_e__Union = *opaque{
        // --------------------------------------------------------
        // Type: _Anonymous_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _Anonymous_e__Struct = extern struct {
            _bitfield: u8,
        };
    };
    // --------------------------------------------------------
    // Type: _Anonymous1_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous1_e__Union = *opaque{
        // --------------------------------------------------------
        // Type: _Anonymous_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _Anonymous_e__Struct = extern struct {
            _bitfield: u8,
        };
    };
};
// --------------------------------------------------------
// Type: JET_BKLOGTIME
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const JET_BKLOGTIME = extern struct {
    bSeconds: i8,
    bMinutes: i8,
    bHours: i8,
    bDay: i8,
    bMonth: i8,
    bYear: i8,
    Anonymous1: _Anonymous1_e__Union,
    Anonymous2: _Anonymous2_e__Union,
    // --------------------------------------------------------
    // Type: _Anonymous2_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous2_e__Union = *opaque{
        // --------------------------------------------------------
        // Type: _Anonymous_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _Anonymous_e__Struct = extern struct {
            _bitfield: u8,
        };
    };
    // --------------------------------------------------------
    // Type: _Anonymous1_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous1_e__Union = *opaque{
        // --------------------------------------------------------
        // Type: _Anonymous_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _Anonymous_e__Struct = extern struct {
            _bitfield: u8,
        };
    };
};
// --------------------------------------------------------
// Type: JET_LGPOS
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const JET_LGPOS = *opaque{
};
// --------------------------------------------------------
// Type: JET_SIGNATURE
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const JET_SIGNATURE = *opaque{
};
// --------------------------------------------------------
// Type: JET_BKINFO
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const JET_BKINFO = *opaque{
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: JET_DBINFOMISC
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const JET_DBINFOMISC = extern struct {
    ulVersion: u32,
    ulUpdate: u32,
    signDb: JET_SIGNATURE,
    dbstate: u32,
    lgposConsistent: JET_LGPOS,
    logtimeConsistent: JET_LOGTIME,
    logtimeAttach: JET_LOGTIME,
    lgposAttach: JET_LGPOS,
    logtimeDetach: JET_LOGTIME,
    lgposDetach: JET_LGPOS,
    signLog: JET_SIGNATURE,
    bkinfoFullPrev: JET_BKINFO,
    bkinfoIncPrev: JET_BKINFO,
    bkinfoFullCur: JET_BKINFO,
    fShadowingDisabled: u32,
    fUpgradeDb: u32,
    dwMajorVersion: u32,
    dwMinorVersion: u32,
    dwBuildNumber: u32,
    lSPNumber: i32,
    cbPageSize: u32,
};
// --------------------------------------------------------
// Type: JET_DBINFOMISC2
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const JET_DBINFOMISC2 = extern struct {
    ulVersion: u32,
    ulUpdate: u32,
    signDb: JET_SIGNATURE,
    dbstate: u32,
    lgposConsistent: JET_LGPOS,
    logtimeConsistent: JET_LOGTIME,
    logtimeAttach: JET_LOGTIME,
    lgposAttach: JET_LGPOS,
    logtimeDetach: JET_LOGTIME,
    lgposDetach: JET_LGPOS,
    signLog: JET_SIGNATURE,
    bkinfoFullPrev: JET_BKINFO,
    bkinfoIncPrev: JET_BKINFO,
    bkinfoFullCur: JET_BKINFO,
    fShadowingDisabled: u32,
    fUpgradeDb: u32,
    dwMajorVersion: u32,
    dwMinorVersion: u32,
    dwBuildNumber: u32,
    lSPNumber: i32,
    cbPageSize: u32,
    genMinRequired: u32,
    genMaxRequired: u32,
    logtimeGenMaxCreate: JET_LOGTIME,
    ulRepairCount: u32,
    logtimeRepair: JET_LOGTIME,
    ulRepairCountOld: u32,
    ulECCFixSuccess: u32,
    logtimeECCFixSuccess: JET_LOGTIME,
    ulECCFixSuccessOld: u32,
    ulECCFixFail: u32,
    logtimeECCFixFail: JET_LOGTIME,
    ulECCFixFailOld: u32,
    ulBadChecksum: u32,
    logtimeBadChecksum: JET_LOGTIME,
    ulBadChecksumOld: u32,
};
// --------------------------------------------------------
// Type: JET_DBINFOMISC3
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const JET_DBINFOMISC3 = extern struct {
    ulVersion: u32,
    ulUpdate: u32,
    signDb: JET_SIGNATURE,
    dbstate: u32,
    lgposConsistent: JET_LGPOS,
    logtimeConsistent: JET_LOGTIME,
    logtimeAttach: JET_LOGTIME,
    lgposAttach: JET_LGPOS,
    logtimeDetach: JET_LOGTIME,
    lgposDetach: JET_LGPOS,
    signLog: JET_SIGNATURE,
    bkinfoFullPrev: JET_BKINFO,
    bkinfoIncPrev: JET_BKINFO,
    bkinfoFullCur: JET_BKINFO,
    fShadowingDisabled: u32,
    fUpgradeDb: u32,
    dwMajorVersion: u32,
    dwMinorVersion: u32,
    dwBuildNumber: u32,
    lSPNumber: i32,
    cbPageSize: u32,
    genMinRequired: u32,
    genMaxRequired: u32,
    logtimeGenMaxCreate: JET_LOGTIME,
    ulRepairCount: u32,
    logtimeRepair: JET_LOGTIME,
    ulRepairCountOld: u32,
    ulECCFixSuccess: u32,
    logtimeECCFixSuccess: JET_LOGTIME,
    ulECCFixSuccessOld: u32,
    ulECCFixFail: u32,
    logtimeECCFixFail: JET_LOGTIME,
    ulECCFixFailOld: u32,
    ulBadChecksum: u32,
    logtimeBadChecksum: JET_LOGTIME,
    ulBadChecksumOld: u32,
    genCommitted: u32,
};
// --------------------------------------------------------
// Type: JET_DBINFOMISC4
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const JET_DBINFOMISC4 = extern struct {
    ulVersion: u32,
    ulUpdate: u32,
    signDb: JET_SIGNATURE,
    dbstate: u32,
    lgposConsistent: JET_LGPOS,
    logtimeConsistent: JET_LOGTIME,
    logtimeAttach: JET_LOGTIME,
    lgposAttach: JET_LGPOS,
    logtimeDetach: JET_LOGTIME,
    lgposDetach: JET_LGPOS,
    signLog: JET_SIGNATURE,
    bkinfoFullPrev: JET_BKINFO,
    bkinfoIncPrev: JET_BKINFO,
    bkinfoFullCur: JET_BKINFO,
    fShadowingDisabled: u32,
    fUpgradeDb: u32,
    dwMajorVersion: u32,
    dwMinorVersion: u32,
    dwBuildNumber: u32,
    lSPNumber: i32,
    cbPageSize: u32,
    genMinRequired: u32,
    genMaxRequired: u32,
    logtimeGenMaxCreate: JET_LOGTIME,
    ulRepairCount: u32,
    logtimeRepair: JET_LOGTIME,
    ulRepairCountOld: u32,
    ulECCFixSuccess: u32,
    logtimeECCFixSuccess: JET_LOGTIME,
    ulECCFixSuccessOld: u32,
    ulECCFixFail: u32,
    logtimeECCFixFail: JET_LOGTIME,
    ulECCFixFailOld: u32,
    ulBadChecksum: u32,
    logtimeBadChecksum: JET_LOGTIME,
    ulBadChecksumOld: u32,
    genCommitted: u32,
    bkinfoCopyPrev: JET_BKINFO,
    bkinfoDiffPrev: JET_BKINFO,
};
// --------------------------------------------------------
// Type: JET_THREADSTATS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const JET_THREADSTATS = extern struct {
    cbStruct: u32,
    cPageReferenced: u32,
    cPageRead: u32,
    cPagePreread: u32,
    cPageDirtied: u32,
    cPageRedirtied: u32,
    cLogRecord: u32,
    cbLogRecord: u32,
};
// --------------------------------------------------------
// Type: JET_THREADSTATS2
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=4 Size=0
pub const JET_THREADSTATS2 = *opaque{
};
// --------------------------------------------------------
// Type: JET_RSTINFO_A
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const JET_RSTINFO_A = extern struct {
    cbStruct: u32,
    rgrstmap: ?*JET_RSTMAP_A,
    crstmap: i32,
    lgposStop: JET_LGPOS,
    logtimeStop: JET_LOGTIME,
    pfnStatus: JET_PFNSTATUS,
};
// --------------------------------------------------------
// Type: JET_RSTINFO_W
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const JET_RSTINFO_W = extern struct {
    cbStruct: u32,
    rgrstmap: ?*JET_RSTMAP_W,
    crstmap: i32,
    lgposStop: JET_LGPOS,
    logtimeStop: JET_LOGTIME,
    pfnStatus: JET_PFNSTATUS,
};
// --------------------------------------------------------
// Type: JET_ERRCAT
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const JET_ERRCAT = *opaque{
};
// --------------------------------------------------------
// Type: JET_ERRINFOBASIC_W
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const JET_ERRINFOBASIC_W = extern struct {
    cbStruct: u32,
    errValue: i32,
    errcatMostSpecific: JET_ERRCAT,
    rgCategoricalHierarchy: ?[*]u8,
    lSourceLine: u32,
    rgszSourceFile: ?[*]u16,
};
// --------------------------------------------------------
// Type: JET_COMMIT_ID
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=4 Size=0
pub const JET_COMMIT_ID = *opaque{
};
// --------------------------------------------------------
// Type: JET_PFNDURABLECOMMITCALLBACK
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const JET_PFNDURABLECOMMITCALLBACK = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: JET_INDEXCHECKING
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const JET_INDEXCHECKING = *opaque{
};
// --------------------------------------------------------
// Type: JET_OPERATIONCONTEXT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const JET_OPERATIONCONTEXT = extern struct {
    ulUserID: u32,
    nOperationID: u8,
    nOperationType: u8,
    nClientType: u8,
    fFlags: u8,
};
// --------------------------------------------------------
// Type: JET_SETCOLUMN
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const JET_SETCOLUMN = extern struct {
    columnid: u32,
    pvData: ?*opaque{},
    cbData: u32,
    grbit: u32,
    ibLongValue: u32,
    itagSequence: u32,
    err: i32,
};
// --------------------------------------------------------
// Type: JET_SETSYSPARAM_A
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const JET_SETSYSPARAM_A = extern struct {
    paramid: u32,
    lParam: u32,
    sz: ?*i8,
    err: i32,
};
// --------------------------------------------------------
// Type: JET_SETSYSPARAM_W
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const JET_SETSYSPARAM_W = extern struct {
    paramid: u32,
    lParam: u32,
    sz: ?*u16,
    err: i32,
};
// --------------------------------------------------------
// Type: JET_RETRIEVECOLUMN
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const JET_RETRIEVECOLUMN = extern struct {
    columnid: u32,
    pvData: ?*opaque{},
    cbData: u32,
    cbActual: u32,
    grbit: u32,
    ibLongValue: u32,
    itagSequence: u32,
    columnidNextTagged: u32,
    err: i32,
};
// --------------------------------------------------------
// Type: JET_ENUMCOLUMNID
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const JET_ENUMCOLUMNID = extern struct {
    columnid: u32,
    ctagSequence: u32,
    rgtagSequence: ?*u32,
};
// --------------------------------------------------------
// Type: JET_ENUMCOLUMNVALUE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const JET_ENUMCOLUMNVALUE = extern struct {
    itagSequence: u32,
    err: i32,
    cbData: u32,
    pvData: ?*opaque{},
};
// --------------------------------------------------------
// Type: JET_ENUMCOLUMN
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const JET_ENUMCOLUMN = extern struct {
    columnid: u32,
    err: i32,
    Anonymous: _Anonymous_e__Union,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
        // --------------------------------------------------------
        // Type: _Anonymous1_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _Anonymous1_e__Struct = extern struct {
            cEnumColumnValue: u32,
            rgEnumColumnValue: ?*JET_ENUMCOLUMNVALUE,
        };
        // --------------------------------------------------------
        // Type: _Anonymous2_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _Anonymous2_e__Struct = extern struct {
            cbData: u32,
            pvData: ?*opaque{},
        };
    };
};
// --------------------------------------------------------
// Type: JET_PFNREALLOC
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const JET_PFNREALLOC = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: JET_RECSIZE
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=4 Size=0
pub const JET_RECSIZE = *opaque{
};
// --------------------------------------------------------
// Type: JET_RECSIZE2
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=4 Size=0
pub const JET_RECSIZE2 = *opaque{
};
// --------------------------------------------------------
// Type: JET_LOGINFO_A
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const JET_LOGINFO_A = extern struct {
    cbSize: u32,
    ulGenLow: u32,
    ulGenHigh: u32,
    szBaseName: ?[*]i8,
};
// --------------------------------------------------------
// Type: JET_LOGINFO_W
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const JET_LOGINFO_W = extern struct {
    cbSize: u32,
    ulGenLow: u32,
    ulGenHigh: u32,
    szBaseName: ?[*]u16,
};
// --------------------------------------------------------
// Type: JET_INSTANCE_INFO_A
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const JET_INSTANCE_INFO_A = extern struct {
    hInstanceId: u32,
    szInstanceName: ?*i8,
    cDatabases: u32,
    szDatabaseFileName: ?*?*i8,
    szDatabaseDisplayName: ?*?*i8,
    szDatabaseSLVFileName_Obsolete: ?*?*i8,
};
// --------------------------------------------------------
// Type: JET_INSTANCE_INFO_W
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const JET_INSTANCE_INFO_W = extern struct {
    hInstanceId: u32,
    szInstanceName: ?*u16,
    cDatabases: u32,
    szDatabaseFileName: ?*?*u16,
    szDatabaseDisplayName: ?*?*u16,
    szDatabaseSLVFileName_Obsolete: ?*?*u16,
};
// --------------------------------------------------------
// Type: STGC
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const STGC = *opaque{
};
// --------------------------------------------------------
// Type: STGMOVE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const STGMOVE = *opaque{
};
// --------------------------------------------------------
// Type: STATFLAG
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const STATFLAG = *opaque{
};

//
// functions
//

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn CreateStreamOnHGlobal(
    hGlobal: ?*opaque{},
    fDeleteOnRelease: BOOL,
    ppstm: ?*IStream,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn GetHGlobalFromStream(
    pstm: IStream,
    phglobal: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn PropVariantCopy(
    pvarDest: ?*PROPVARIANT,
    pvarSrc: ?*PROPVARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn PropVariantClear(
    pvar: ?*PROPVARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn FreePropVariantArray(
    cVariants: u32,
    rgvars: ?*PROPVARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn WriteFmtUserTypeStg(
    pstg: IStorage,
    cf: u16,
    lpszUserType: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn ReadFmtUserTypeStg(
    pstg: IStorage,
    pcf: ?*u16,
    lplpszUserType: ?*?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "ole32" fn OleConvertOLESTREAMToIStorage(
    lpolestream: ?*OLESTREAM,
    pstg: IStorage,
    ptd: ?*DVTARGETDEVICE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "ole32" fn OleConvertIStorageToOLESTREAM(
    pstg: IStorage,
    lpolestream: ?*OLESTREAM,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn SetConvertStg(
    pStg: IStorage,
    fConvert: BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "ole32" fn OleConvertIStorageToOLESTREAMEx(
    pstg: IStorage,
    cfFormat: u16,
    lWidth: i32,
    lHeight: i32,
    dwSize: u32,
    pmedium: ?*STGMEDIUM,
    polestm: ?*OLESTREAM,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "ole32" fn OleConvertOLESTREAMToIStorageEx(
    polestm: ?*OLESTREAM,
    pstg: IStorage,
    pcfFormat: ?*u16,
    plwWidth: ?*i32,
    plHeight: ?*i32,
    pdwSize: ?*u32,
    pmedium: ?*STGMEDIUM,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn StgCreateDocfile(
    pwcsName: ?*u16,
    grfMode: u32,
    reserved: u32,
    ppstgOpen: ?*IStorage,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn StgCreateDocfileOnILockBytes(
    plkbyt: ILockBytes,
    grfMode: u32,
    reserved: u32,
    ppstgOpen: ?*IStorage,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn StgOpenStorage(
    pwcsName: ?*u16,
    pstgPriority: IStorage,
    grfMode: u32,
    snbExclude: ?*?*u16,
    reserved: u32,
    ppstgOpen: ?*IStorage,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn StgOpenStorageOnILockBytes(
    plkbyt: ILockBytes,
    pstgPriority: IStorage,
    grfMode: u32,
    snbExclude: ?*?*u16,
    reserved: u32,
    ppstgOpen: ?*IStorage,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn StgIsStorageFile(
    pwcsName: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn StgIsStorageILockBytes(
    plkbyt: ILockBytes,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn StgSetTimes(
    lpszName: ?*u16,
    pctime: ?*FILETIME,
    patime: ?*FILETIME,
    pmtime: ?*FILETIME,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn StgCreateStorageEx(
    pwcsName: ?*u16,
    grfMode: u32,
    stgfmt: u32,
    grfAttrs: u32,
    pStgOptions: ?*STGOPTIONS,
    pSecurityDescriptor: ?*opaque{},
    riid: ?*Guid,
    ppObjectOpen: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn StgOpenStorageEx(
    pwcsName: ?*u16,
    grfMode: u32,
    stgfmt: u32,
    grfAttrs: u32,
    pStgOptions: ?*STGOPTIONS,
    pSecurityDescriptor: ?*opaque{},
    riid: ?*Guid,
    ppObjectOpen: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn StgCreatePropStg(
    pUnk: IUnknown,
    fmtid: ?*Guid,
    pclsid: ?*Guid,
    grfFlags: u32,
    dwReserved: u32,
    ppPropStg: ?*IPropertyStorage,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn StgOpenPropStg(
    pUnk: IUnknown,
    fmtid: ?*Guid,
    grfFlags: u32,
    dwReserved: u32,
    ppPropStg: ?*IPropertyStorage,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn StgCreatePropSetStg(
    pStorage: IStorage,
    dwReserved: u32,
    ppPropSetStg: ?*IPropertySetStorage,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn FmtIdToPropStgName(
    pfmtid: ?*Guid,
    oszName: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn PropStgNameToFmtId(
    oszName: ?*u16,
    pfmtid: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn ReadClassStg(
    pStg: IStorage,
    pclsid: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn WriteClassStg(
    pStg: IStorage,
    rclsid: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn ReadClassStm(
    pStm: IStream,
    pclsid: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn WriteClassStm(
    pStm: IStream,
    rclsid: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn GetHGlobalFromILockBytes(
    plkbyt: ILockBytes,
    phglobal: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn CreateILockBytesOnHGlobal(
    hGlobal: ?*opaque{},
    fDeleteOnRelease: BOOL,
    pplkbyt: ?*ILockBytes,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn GetConvertStg(
    pStg: IStorage,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "ole32" fn CoBuildVersion(
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "ole32" fn DcomChannelSetHResult(
    pvReserved: ?*opaque{},
    pulReserved: ?*u32,
    appsHR: HRESULT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "ole32" fn StgOpenAsyncDocfileOnIFillLockBytes(
    pflb: IFillLockBytes,
    grfMode: u32,
    asyncFlags: u32,
    ppstgOpen: ?*IStorage,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "ole32" fn StgGetIFillLockBytesOnILockBytes(
    pilb: ILockBytes,
    ppflb: ?*IFillLockBytes,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "ole32" fn StgGetIFillLockBytesOnFile(
    pwcsName: ?*u16,
    ppflb: ?*IFillLockBytes,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "dflayout" fn StgOpenLayoutDocfile(
    pwcsDfName: ?*u16,
    grfMode: u32,
    reserved: u32,
    ppstgOpen: ?*IStorage,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "ole32" fn StgConvertVariantToProperty(
    pvar: ?*PROPVARIANT,
    CodePage: u16,
    pprop: ?*SERIALIZEDPROPERTYVALUE,
    pcb: ?*u32,
    pid: u32,
    fReserved: u8,
    pcIndirect: ?*u32,
) callconv(@import("std").os.windows.WINAPI) ?*SERIALIZEDPROPERTYVALUE;

// set_last_errror=False (can and should we use this?)
pub extern "ole32" fn StgConvertPropertyToVariant(
    pprop: ?*SERIALIZEDPROPERTYVALUE,
    CodePage: u16,
    pvar: ?*PROPVARIANT,
    pma: ?*PMemoryAllocator,
) callconv(@import("std").os.windows.WINAPI) u8;

// set_last_errror=False (can and should we use this?)
pub extern "ole32" fn CreateStdProgressIndicator(
    hwndParent: HWND,
    pszTitle: ?*u16,
    pIbscCaller: IBindStatusCallback,
    ppIbsc: ?*IBindStatusCallback,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "ole32" fn StgPropertyLengthAsVariant(
    pProp: ?*SERIALIZEDPROPERTYVALUE,
    cbProp: u32,
    CodePage: u16,
    bReserved: u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetInit(
    pinstance: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetInit2(
    pinstance: ?*u32,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetInit3A(
    pinstance: ?*u32,
    prstInfo: ?*JET_RSTINFO_A,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetInit3W(
    pinstance: ?*u32,
    prstInfo: ?*JET_RSTINFO_W,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetCreateInstanceA(
    pinstance: ?*u32,
    szInstanceName: ?*i8,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetCreateInstanceW(
    pinstance: ?*u32,
    szInstanceName: ?*u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetCreateInstance2A(
    pinstance: ?*u32,
    szInstanceName: ?*i8,
    szDisplayName: ?*i8,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetCreateInstance2W(
    pinstance: ?*u32,
    szInstanceName: ?*u16,
    szDisplayName: ?*u16,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetGetInstanceMiscInfo(
    instance: u32,
    pvResult: ?*opaque{},
    cbMax: u32,
    InfoLevel: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetTerm(
    instance: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetTerm2(
    instance: u32,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetStopService(
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetStopServiceInstance(
    instance: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetStopServiceInstance2(
    instance: u32,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetStopBackup(
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetStopBackupInstance(
    instance: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetSetSystemParameterA(
    pinstance: ?*u32,
    sesid: u32,
    paramid: u32,
    lParam: u32,
    szParam: ?*i8,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetSetSystemParameterW(
    pinstance: ?*u32,
    sesid: u32,
    paramid: u32,
    lParam: u32,
    szParam: ?*u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetGetSystemParameterA(
    instance: u32,
    sesid: u32,
    paramid: u32,
    plParam: ?*u32,
    szParam: ?*i8,
    cbMax: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetGetSystemParameterW(
    instance: u32,
    sesid: u32,
    paramid: u32,
    plParam: ?*u32,
    szParam: ?*u16,
    cbMax: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetEnableMultiInstanceA(
    psetsysparam: ?*JET_SETSYSPARAM_A,
    csetsysparam: u32,
    pcsetsucceed: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetEnableMultiInstanceW(
    psetsysparam: ?*JET_SETSYSPARAM_W,
    csetsysparam: u32,
    pcsetsucceed: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetGetThreadStats(
    pvResult: ?*opaque{},
    cbMax: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetBeginSessionA(
    instance: u32,
    psesid: ?*u32,
    szUserName: ?*i8,
    szPassword: ?*i8,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetBeginSessionW(
    instance: u32,
    psesid: ?*u32,
    szUserName: ?*u16,
    szPassword: ?*u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetDupSession(
    sesid: u32,
    psesid: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetEndSession(
    sesid: u32,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetGetVersion(
    sesid: u32,
    pwVersion: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetIdle(
    sesid: u32,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetCreateDatabaseA(
    sesid: u32,
    szFilename: ?*i8,
    szConnect: ?*i8,
    pdbid: ?*u32,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetCreateDatabaseW(
    sesid: u32,
    szFilename: ?*u16,
    szConnect: ?*u16,
    pdbid: ?*u32,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetCreateDatabase2A(
    sesid: u32,
    szFilename: ?*i8,
    cpgDatabaseSizeMax: u32,
    pdbid: ?*u32,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetCreateDatabase2W(
    sesid: u32,
    szFilename: ?*u16,
    cpgDatabaseSizeMax: u32,
    pdbid: ?*u32,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetAttachDatabaseA(
    sesid: u32,
    szFilename: ?*i8,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetAttachDatabaseW(
    sesid: u32,
    szFilename: ?*u16,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetAttachDatabase2A(
    sesid: u32,
    szFilename: ?*i8,
    cpgDatabaseSizeMax: u32,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetAttachDatabase2W(
    sesid: u32,
    szFilename: ?*u16,
    cpgDatabaseSizeMax: u32,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetDetachDatabaseA(
    sesid: u32,
    szFilename: ?*i8,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetDetachDatabaseW(
    sesid: u32,
    szFilename: ?*u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetDetachDatabase2A(
    sesid: u32,
    szFilename: ?*i8,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetDetachDatabase2W(
    sesid: u32,
    szFilename: ?*u16,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetGetObjectInfoA(
    sesid: u32,
    dbid: u32,
    objtyp: u32,
    szContainerName: ?*i8,
    szObjectName: ?*i8,
    pvResult: ?*opaque{},
    cbMax: u32,
    InfoLevel: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetGetObjectInfoW(
    sesid: u32,
    dbid: u32,
    objtyp: u32,
    szContainerName: ?*u16,
    szObjectName: ?*u16,
    pvResult: ?*opaque{},
    cbMax: u32,
    InfoLevel: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetGetTableInfoA(
    sesid: u32,
    tableid: u32,
    pvResult: ?*opaque{},
    cbMax: u32,
    InfoLevel: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetGetTableInfoW(
    sesid: u32,
    tableid: u32,
    pvResult: ?*opaque{},
    cbMax: u32,
    InfoLevel: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetCreateTableA(
    sesid: u32,
    dbid: u32,
    szTableName: ?*i8,
    lPages: u32,
    lDensity: u32,
    ptableid: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetCreateTableW(
    sesid: u32,
    dbid: u32,
    szTableName: ?*u16,
    lPages: u32,
    lDensity: u32,
    ptableid: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetCreateTableColumnIndexA(
    sesid: u32,
    dbid: u32,
    ptablecreate: ?*JET_TABLECREATE_A,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetCreateTableColumnIndexW(
    sesid: u32,
    dbid: u32,
    ptablecreate: ?*JET_TABLECREATE_W,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetCreateTableColumnIndex2A(
    sesid: u32,
    dbid: u32,
    ptablecreate: ?*JET_TABLECREATE2_A,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetCreateTableColumnIndex2W(
    sesid: u32,
    dbid: u32,
    ptablecreate: ?*JET_TABLECREATE2_W,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetCreateTableColumnIndex3A(
    sesid: u32,
    dbid: u32,
    ptablecreate: ?*JET_TABLECREATE3_A,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetCreateTableColumnIndex3W(
    sesid: u32,
    dbid: u32,
    ptablecreate: ?*JET_TABLECREATE3_W,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetCreateTableColumnIndex4A(
    sesid: u32,
    dbid: u32,
    ptablecreate: ?*JET_TABLECREATE4_A,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetCreateTableColumnIndex4W(
    sesid: u32,
    dbid: u32,
    ptablecreate: ?*JET_TABLECREATE4_W,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetDeleteTableA(
    sesid: u32,
    dbid: u32,
    szTableName: ?*i8,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetDeleteTableW(
    sesid: u32,
    dbid: u32,
    szTableName: ?*u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetRenameTableA(
    sesid: u32,
    dbid: u32,
    szName: ?*i8,
    szNameNew: ?*i8,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetRenameTableW(
    sesid: u32,
    dbid: u32,
    szName: ?*u16,
    szNameNew: ?*u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetGetTableColumnInfoA(
    sesid: u32,
    tableid: u32,
    szColumnName: ?*i8,
    pvResult: ?*opaque{},
    cbMax: u32,
    InfoLevel: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetGetTableColumnInfoW(
    sesid: u32,
    tableid: u32,
    szColumnName: ?*u16,
    pvResult: ?*opaque{},
    cbMax: u32,
    InfoLevel: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetGetColumnInfoA(
    sesid: u32,
    dbid: u32,
    szTableName: ?*i8,
    pColumnNameOrId: ?*i8,
    pvResult: ?*opaque{},
    cbMax: u32,
    InfoLevel: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetGetColumnInfoW(
    sesid: u32,
    dbid: u32,
    szTableName: ?*u16,
    pwColumnNameOrId: ?*u16,
    pvResult: ?*opaque{},
    cbMax: u32,
    InfoLevel: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetAddColumnA(
    sesid: u32,
    tableid: u32,
    szColumnName: ?*i8,
    pcolumndef: ?*JET_COLUMNDEF,
    pvDefault: ?*opaque{},
    cbDefault: u32,
    pcolumnid: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetAddColumnW(
    sesid: u32,
    tableid: u32,
    szColumnName: ?*u16,
    pcolumndef: ?*JET_COLUMNDEF,
    pvDefault: ?*opaque{},
    cbDefault: u32,
    pcolumnid: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetDeleteColumnA(
    sesid: u32,
    tableid: u32,
    szColumnName: ?*i8,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetDeleteColumnW(
    sesid: u32,
    tableid: u32,
    szColumnName: ?*u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetDeleteColumn2A(
    sesid: u32,
    tableid: u32,
    szColumnName: ?*i8,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetDeleteColumn2W(
    sesid: u32,
    tableid: u32,
    szColumnName: ?*u16,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetRenameColumnA(
    sesid: u32,
    tableid: u32,
    szName: ?*i8,
    szNameNew: ?*i8,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetRenameColumnW(
    sesid: u32,
    tableid: u32,
    szName: ?*u16,
    szNameNew: ?*u16,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetSetColumnDefaultValueA(
    sesid: u32,
    dbid: u32,
    szTableName: ?*i8,
    szColumnName: ?*i8,
    pvData: ?*opaque{},
    cbData: u32,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetSetColumnDefaultValueW(
    sesid: u32,
    dbid: u32,
    szTableName: ?*u16,
    szColumnName: ?*u16,
    pvData: ?*opaque{},
    cbData: u32,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetGetTableIndexInfoA(
    sesid: u32,
    tableid: u32,
    szIndexName: ?*i8,
    pvResult: ?*opaque{},
    cbResult: u32,
    InfoLevel: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetGetTableIndexInfoW(
    sesid: u32,
    tableid: u32,
    szIndexName: ?*u16,
    pvResult: ?*opaque{},
    cbResult: u32,
    InfoLevel: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetGetIndexInfoA(
    sesid: u32,
    dbid: u32,
    szTableName: ?*i8,
    szIndexName: ?*i8,
    pvResult: ?*opaque{},
    cbResult: u32,
    InfoLevel: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetGetIndexInfoW(
    sesid: u32,
    dbid: u32,
    szTableName: ?*u16,
    szIndexName: ?*u16,
    pvResult: ?*opaque{},
    cbResult: u32,
    InfoLevel: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetCreateIndexA(
    sesid: u32,
    tableid: u32,
    szIndexName: ?*i8,
    grbit: u32,
    szKey: ?*i8,
    cbKey: u32,
    lDensity: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetCreateIndexW(
    sesid: u32,
    tableid: u32,
    szIndexName: ?*u16,
    grbit: u32,
    szKey: ?*u16,
    cbKey: u32,
    lDensity: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetCreateIndex2A(
    sesid: u32,
    tableid: u32,
    pindexcreate: ?*JET_INDEXCREATE_A,
    cIndexCreate: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetCreateIndex2W(
    sesid: u32,
    tableid: u32,
    pindexcreate: ?*JET_INDEXCREATE_W,
    cIndexCreate: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetCreateIndex3A(
    sesid: u32,
    tableid: u32,
    pindexcreate: ?*JET_INDEXCREATE2_A,
    cIndexCreate: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetCreateIndex3W(
    sesid: u32,
    tableid: u32,
    pindexcreate: ?*JET_INDEXCREATE2_W,
    cIndexCreate: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetCreateIndex4A(
    sesid: u32,
    tableid: u32,
    pindexcreate: ?*JET_INDEXCREATE3_A,
    cIndexCreate: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetCreateIndex4W(
    sesid: u32,
    tableid: u32,
    pindexcreate: ?*JET_INDEXCREATE3_W,
    cIndexCreate: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetDeleteIndexA(
    sesid: u32,
    tableid: u32,
    szIndexName: ?*i8,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetDeleteIndexW(
    sesid: u32,
    tableid: u32,
    szIndexName: ?*u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetBeginTransaction(
    sesid: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetBeginTransaction2(
    sesid: u32,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetBeginTransaction3(
    sesid: u32,
    trxid: i64,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetCommitTransaction(
    sesid: u32,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetCommitTransaction2(
    sesid: u32,
    grbit: u32,
    cmsecDurableCommit: u32,
    pCommitId: ?*JET_COMMIT_ID,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetRollback(
    sesid: u32,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetGetDatabaseInfoA(
    sesid: u32,
    dbid: u32,
    pvResult: ?*opaque{},
    cbMax: u32,
    InfoLevel: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetGetDatabaseInfoW(
    sesid: u32,
    dbid: u32,
    pvResult: ?*opaque{},
    cbMax: u32,
    InfoLevel: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetGetDatabaseFileInfoA(
    szDatabaseName: ?*i8,
    pvResult: ?*opaque{},
    cbMax: u32,
    InfoLevel: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetGetDatabaseFileInfoW(
    szDatabaseName: ?*u16,
    pvResult: ?*opaque{},
    cbMax: u32,
    InfoLevel: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetOpenDatabaseA(
    sesid: u32,
    szFilename: ?*i8,
    szConnect: ?*i8,
    pdbid: ?*u32,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetOpenDatabaseW(
    sesid: u32,
    szFilename: ?*u16,
    szConnect: ?*u16,
    pdbid: ?*u32,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetCloseDatabase(
    sesid: u32,
    dbid: u32,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetOpenTableA(
    sesid: u32,
    dbid: u32,
    szTableName: ?*i8,
    pvParameters: ?*opaque{},
    cbParameters: u32,
    grbit: u32,
    ptableid: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetOpenTableW(
    sesid: u32,
    dbid: u32,
    szTableName: ?*u16,
    pvParameters: ?*opaque{},
    cbParameters: u32,
    grbit: u32,
    ptableid: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetSetTableSequential(
    sesid: u32,
    tableid: u32,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetResetTableSequential(
    sesid: u32,
    tableid: u32,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetCloseTable(
    sesid: u32,
    tableid: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetDelete(
    sesid: u32,
    tableid: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetUpdate(
    sesid: u32,
    tableid: u32,
    pvBookmark: ?*opaque{},
    cbBookmark: u32,
    pcbActual: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetUpdate2(
    sesid: u32,
    tableid: u32,
    pvBookmark: ?*opaque{},
    cbBookmark: u32,
    pcbActual: ?*u32,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetEscrowUpdate(
    sesid: u32,
    tableid: u32,
    columnid: u32,
    pv: ?*opaque{},
    cbMax: u32,
    pvOld: ?*opaque{},
    cbOldMax: u32,
    pcbOldActual: ?*u32,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetRetrieveColumn(
    sesid: u32,
    tableid: u32,
    columnid: u32,
    pvData: ?*opaque{},
    cbData: u32,
    pcbActual: ?*u32,
    grbit: u32,
    pretinfo: ?*JET_RETINFO,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetRetrieveColumns(
    sesid: u32,
    tableid: u32,
    pretrievecolumn: ?*JET_RETRIEVECOLUMN,
    cretrievecolumn: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetEnumerateColumns(
    sesid: u32,
    tableid: u32,
    cEnumColumnId: u32,
    rgEnumColumnId: ?*JET_ENUMCOLUMNID,
    pcEnumColumn: ?*u32,
    prgEnumColumn: ?*?*JET_ENUMCOLUMN,
    pfnRealloc: JET_PFNREALLOC,
    pvReallocContext: ?*opaque{},
    cbDataMost: u32,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetGetRecordSize(
    sesid: u32,
    tableid: u32,
    precsize: ?*JET_RECSIZE,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetGetRecordSize2(
    sesid: u32,
    tableid: u32,
    precsize: ?*JET_RECSIZE2,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetSetColumn(
    sesid: u32,
    tableid: u32,
    columnid: u32,
    pvData: ?*opaque{},
    cbData: u32,
    grbit: u32,
    psetinfo: ?*JET_SETINFO,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetSetColumns(
    sesid: u32,
    tableid: u32,
    psetcolumn: ?*JET_SETCOLUMN,
    csetcolumn: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetPrepareUpdate(
    sesid: u32,
    tableid: u32,
    prep: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetGetRecordPosition(
    sesid: u32,
    tableid: u32,
    precpos: ?*JET_RECPOS,
    cbRecpos: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetGotoPosition(
    sesid: u32,
    tableid: u32,
    precpos: ?*JET_RECPOS,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetGetCursorInfo(
    sesid: u32,
    tableid: u32,
    pvResult: ?*opaque{},
    cbMax: u32,
    InfoLevel: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetDupCursor(
    sesid: u32,
    tableid: u32,
    ptableid: ?*u32,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetGetCurrentIndexA(
    sesid: u32,
    tableid: u32,
    szIndexName: ?*i8,
    cbIndexName: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetGetCurrentIndexW(
    sesid: u32,
    tableid: u32,
    szIndexName: ?*u16,
    cbIndexName: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetSetCurrentIndexA(
    sesid: u32,
    tableid: u32,
    szIndexName: ?*i8,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetSetCurrentIndexW(
    sesid: u32,
    tableid: u32,
    szIndexName: ?*u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetSetCurrentIndex2A(
    sesid: u32,
    tableid: u32,
    szIndexName: ?*i8,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetSetCurrentIndex2W(
    sesid: u32,
    tableid: u32,
    szIndexName: ?*u16,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetSetCurrentIndex3A(
    sesid: u32,
    tableid: u32,
    szIndexName: ?*i8,
    grbit: u32,
    itagSequence: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetSetCurrentIndex3W(
    sesid: u32,
    tableid: u32,
    szIndexName: ?*u16,
    grbit: u32,
    itagSequence: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetSetCurrentIndex4A(
    sesid: u32,
    tableid: u32,
    szIndexName: ?*i8,
    pindexid: ?*JET_INDEXID,
    grbit: u32,
    itagSequence: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetSetCurrentIndex4W(
    sesid: u32,
    tableid: u32,
    szIndexName: ?*u16,
    pindexid: ?*JET_INDEXID,
    grbit: u32,
    itagSequence: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetMove(
    sesid: u32,
    tableid: u32,
    cRow: i32,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetSetCursorFilter(
    sesid: u32,
    tableid: u32,
    rgColumnFilters: ?*JET_INDEX_COLUMN,
    cColumnFilters: u32,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetGetLock(
    sesid: u32,
    tableid: u32,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetMakeKey(
    sesid: u32,
    tableid: u32,
    pvData: ?*opaque{},
    cbData: u32,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetSeek(
    sesid: u32,
    tableid: u32,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetPrereadKeys(
    sesid: u32,
    tableid: u32,
    rgpvKeys: ?*?*opaque{},
    rgcbKeys: ?*u32,
    ckeys: i32,
    pckeysPreread: ?*i32,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetPrereadIndexRanges(
    sesid: u32,
    tableid: u32,
    rgIndexRanges: ?*JET_INDEX_RANGE,
    cIndexRanges: u32,
    pcRangesPreread: ?*u32,
    rgcolumnidPreread: ?*u32,
    ccolumnidPreread: u32,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetGetBookmark(
    sesid: u32,
    tableid: u32,
    pvBookmark: ?*opaque{},
    cbMax: u32,
    pcbActual: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetGetSecondaryIndexBookmark(
    sesid: u32,
    tableid: u32,
    pvSecondaryKey: ?*opaque{},
    cbSecondaryKeyMax: u32,
    pcbSecondaryKeyActual: ?*u32,
    pvPrimaryBookmark: ?*opaque{},
    cbPrimaryBookmarkMax: u32,
    pcbPrimaryBookmarkActual: ?*u32,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetCompactA(
    sesid: u32,
    szDatabaseSrc: ?*i8,
    szDatabaseDest: ?*i8,
    pfnStatus: JET_PFNSTATUS,
    pconvert: ?*tagCONVERT_A,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetCompactW(
    sesid: u32,
    szDatabaseSrc: ?*u16,
    szDatabaseDest: ?*u16,
    pfnStatus: JET_PFNSTATUS,
    pconvert: ?*tagCONVERT_W,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetDefragmentA(
    sesid: u32,
    dbid: u32,
    szTableName: ?*i8,
    pcPasses: ?*u32,
    pcSeconds: ?*u32,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetDefragmentW(
    sesid: u32,
    dbid: u32,
    szTableName: ?*u16,
    pcPasses: ?*u32,
    pcSeconds: ?*u32,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetDefragment2A(
    sesid: u32,
    dbid: u32,
    szTableName: ?*i8,
    pcPasses: ?*u32,
    pcSeconds: ?*u32,
    callback: JET_CALLBACK,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetDefragment2W(
    sesid: u32,
    dbid: u32,
    szTableName: ?*u16,
    pcPasses: ?*u32,
    pcSeconds: ?*u32,
    callback: JET_CALLBACK,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetDefragment3A(
    sesid: u32,
    szDatabaseName: ?*i8,
    szTableName: ?*i8,
    pcPasses: ?*u32,
    pcSeconds: ?*u32,
    callback: JET_CALLBACK,
    pvContext: ?*opaque{},
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetDefragment3W(
    sesid: u32,
    szDatabaseName: ?*u16,
    szTableName: ?*u16,
    pcPasses: ?*u32,
    pcSeconds: ?*u32,
    callback: JET_CALLBACK,
    pvContext: ?*opaque{},
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetSetDatabaseSizeA(
    sesid: u32,
    szDatabaseName: ?*i8,
    cpg: u32,
    pcpgReal: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetSetDatabaseSizeW(
    sesid: u32,
    szDatabaseName: ?*u16,
    cpg: u32,
    pcpgReal: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetGrowDatabase(
    sesid: u32,
    dbid: u32,
    cpg: u32,
    pcpgReal: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetResizeDatabase(
    sesid: u32,
    dbid: u32,
    cpgTarget: u32,
    pcpgActual: ?*u32,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetSetSessionContext(
    sesid: u32,
    ulContext: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetResetSessionContext(
    sesid: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetGotoBookmark(
    sesid: u32,
    tableid: u32,
    pvBookmark: ?*opaque{},
    cbBookmark: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetGotoSecondaryIndexBookmark(
    sesid: u32,
    tableid: u32,
    pvSecondaryKey: ?*opaque{},
    cbSecondaryKey: u32,
    pvPrimaryBookmark: ?*opaque{},
    cbPrimaryBookmark: u32,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetIntersectIndexes(
    sesid: u32,
    rgindexrange: ?*JET_INDEXRANGE,
    cindexrange: u32,
    precordlist: ?*JET_RECORDLIST,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetComputeStats(
    sesid: u32,
    tableid: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetOpenTempTable(
    sesid: u32,
    prgcolumndef: ?*JET_COLUMNDEF,
    ccolumn: u32,
    grbit: u32,
    ptableid: ?*u32,
    prgcolumnid: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetOpenTempTable2(
    sesid: u32,
    prgcolumndef: ?*JET_COLUMNDEF,
    ccolumn: u32,
    lcid: u32,
    grbit: u32,
    ptableid: ?*u32,
    prgcolumnid: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetOpenTempTable3(
    sesid: u32,
    prgcolumndef: ?*JET_COLUMNDEF,
    ccolumn: u32,
    pidxunicode: ?*JET_UNICODEINDEX,
    grbit: u32,
    ptableid: ?*u32,
    prgcolumnid: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetOpenTemporaryTable(
    sesid: u32,
    popentemporarytable: ?*JET_OPENTEMPORARYTABLE,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetOpenTemporaryTable2(
    sesid: u32,
    popentemporarytable: ?*JET_OPENTEMPORARYTABLE2,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetBackupA(
    szBackupPath: ?*i8,
    grbit: u32,
    pfnStatus: JET_PFNSTATUS,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetBackupW(
    szBackupPath: ?*u16,
    grbit: u32,
    pfnStatus: JET_PFNSTATUS,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetBackupInstanceA(
    instance: u32,
    szBackupPath: ?*i8,
    grbit: u32,
    pfnStatus: JET_PFNSTATUS,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetBackupInstanceW(
    instance: u32,
    szBackupPath: ?*u16,
    grbit: u32,
    pfnStatus: JET_PFNSTATUS,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetRestoreA(
    szSource: ?*i8,
    pfn: JET_PFNSTATUS,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetRestoreW(
    szSource: ?*u16,
    pfn: JET_PFNSTATUS,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetRestore2A(
    sz: ?*i8,
    szDest: ?*i8,
    pfn: JET_PFNSTATUS,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetRestore2W(
    sz: ?*u16,
    szDest: ?*u16,
    pfn: JET_PFNSTATUS,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetRestoreInstanceA(
    instance: u32,
    sz: ?*i8,
    szDest: ?*i8,
    pfn: JET_PFNSTATUS,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetRestoreInstanceW(
    instance: u32,
    sz: ?*u16,
    szDest: ?*u16,
    pfn: JET_PFNSTATUS,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetSetIndexRange(
    sesid: u32,
    tableidSrc: u32,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetIndexRecordCount(
    sesid: u32,
    tableid: u32,
    pcrec: ?*u32,
    crecMax: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetRetrieveKey(
    sesid: u32,
    tableid: u32,
    pvKey: ?*opaque{},
    cbMax: u32,
    pcbActual: ?*u32,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetBeginExternalBackup(
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetBeginExternalBackupInstance(
    instance: u32,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetGetAttachInfoA(
    szzDatabases: ?*i8,
    cbMax: u32,
    pcbActual: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetGetAttachInfoW(
    wszzDatabases: ?*u16,
    cbMax: u32,
    pcbActual: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetGetAttachInfoInstanceA(
    instance: u32,
    szzDatabases: ?*i8,
    cbMax: u32,
    pcbActual: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetGetAttachInfoInstanceW(
    instance: u32,
    szzDatabases: ?*u16,
    cbMax: u32,
    pcbActual: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetOpenFileA(
    szFileName: ?*i8,
    phfFile: ?*u32,
    pulFileSizeLow: ?*u32,
    pulFileSizeHigh: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetOpenFileW(
    szFileName: ?*u16,
    phfFile: ?*u32,
    pulFileSizeLow: ?*u32,
    pulFileSizeHigh: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetOpenFileInstanceA(
    instance: u32,
    szFileName: ?*i8,
    phfFile: ?*u32,
    pulFileSizeLow: ?*u32,
    pulFileSizeHigh: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetOpenFileInstanceW(
    instance: u32,
    szFileName: ?*u16,
    phfFile: ?*u32,
    pulFileSizeLow: ?*u32,
    pulFileSizeHigh: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetReadFile(
    hfFile: u32,
    pv: ?*opaque{},
    cb: u32,
    pcbActual: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetReadFileInstance(
    instance: u32,
    hfFile: u32,
    pv: ?*opaque{},
    cb: u32,
    pcbActual: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetCloseFile(
    hfFile: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetCloseFileInstance(
    instance: u32,
    hfFile: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetGetLogInfoA(
    szzLogs: ?*i8,
    cbMax: u32,
    pcbActual: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetGetLogInfoW(
    szzLogs: ?*u16,
    cbMax: u32,
    pcbActual: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetGetLogInfoInstanceA(
    instance: u32,
    szzLogs: ?*i8,
    cbMax: u32,
    pcbActual: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetGetLogInfoInstanceW(
    instance: u32,
    wszzLogs: ?*u16,
    cbMax: u32,
    pcbActual: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetGetLogInfoInstance2A(
    instance: u32,
    szzLogs: ?*i8,
    cbMax: u32,
    pcbActual: ?*u32,
    pLogInfo: ?*JET_LOGINFO_A,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetGetLogInfoInstance2W(
    instance: u32,
    wszzLogs: ?*u16,
    cbMax: u32,
    pcbActual: ?*u32,
    pLogInfo: ?*JET_LOGINFO_W,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetGetTruncateLogInfoInstanceA(
    instance: u32,
    szzLogs: ?*i8,
    cbMax: u32,
    pcbActual: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetGetTruncateLogInfoInstanceW(
    instance: u32,
    wszzLogs: ?*u16,
    cbMax: u32,
    pcbActual: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetTruncateLog(
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetTruncateLogInstance(
    instance: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetEndExternalBackup(
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetEndExternalBackupInstance(
    instance: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetEndExternalBackupInstance2(
    instance: u32,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetExternalRestoreA(
    szCheckpointFilePath: ?*i8,
    szLogPath: ?*i8,
    rgrstmap: ?*JET_RSTMAP_A,
    crstfilemap: i32,
    szBackupLogPath: ?*i8,
    genLow: i32,
    genHigh: i32,
    pfn: JET_PFNSTATUS,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetExternalRestoreW(
    szCheckpointFilePath: ?*u16,
    szLogPath: ?*u16,
    rgrstmap: ?*JET_RSTMAP_W,
    crstfilemap: i32,
    szBackupLogPath: ?*u16,
    genLow: i32,
    genHigh: i32,
    pfn: JET_PFNSTATUS,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetExternalRestore2A(
    szCheckpointFilePath: ?*i8,
    szLogPath: ?*i8,
    rgrstmap: ?*JET_RSTMAP_A,
    crstfilemap: i32,
    szBackupLogPath: ?*i8,
    pLogInfo: ?*JET_LOGINFO_A,
    szTargetInstanceName: ?*i8,
    szTargetInstanceLogPath: ?*i8,
    szTargetInstanceCheckpointPath: ?*i8,
    pfn: JET_PFNSTATUS,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetExternalRestore2W(
    szCheckpointFilePath: ?*u16,
    szLogPath: ?*u16,
    rgrstmap: ?*JET_RSTMAP_W,
    crstfilemap: i32,
    szBackupLogPath: ?*u16,
    pLogInfo: ?*JET_LOGINFO_W,
    szTargetInstanceName: ?*u16,
    szTargetInstanceLogPath: ?*u16,
    szTargetInstanceCheckpointPath: ?*u16,
    pfn: JET_PFNSTATUS,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetRegisterCallback(
    sesid: u32,
    tableid: u32,
    cbtyp: u32,
    pCallback: JET_CALLBACK,
    pvContext: ?*opaque{},
    phCallbackId: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetUnregisterCallback(
    sesid: u32,
    tableid: u32,
    cbtyp: u32,
    hCallbackId: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetGetInstanceInfoA(
    pcInstanceInfo: ?*u32,
    paInstanceInfo: ?*?*JET_INSTANCE_INFO_A,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetGetInstanceInfoW(
    pcInstanceInfo: ?*u32,
    paInstanceInfo: ?*?*JET_INSTANCE_INFO_W,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetFreeBuffer(
    pbBuf: ?*i8,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetSetLS(
    sesid: u32,
    tableid: u32,
    ls: u32,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetGetLS(
    sesid: u32,
    tableid: u32,
    pls: ?*u32,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetOSSnapshotPrepare(
    psnapId: ?*u32,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetOSSnapshotPrepareInstance(
    snapId: u32,
    instance: u32,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetOSSnapshotFreezeA(
    snapId: u32,
    pcInstanceInfo: ?*u32,
    paInstanceInfo: ?*?*JET_INSTANCE_INFO_A,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetOSSnapshotFreezeW(
    snapId: u32,
    pcInstanceInfo: ?*u32,
    paInstanceInfo: ?*?*JET_INSTANCE_INFO_W,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetOSSnapshotThaw(
    snapId: u32,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetOSSnapshotAbort(
    snapId: u32,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetOSSnapshotTruncateLog(
    snapId: u32,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetOSSnapshotTruncateLogInstance(
    snapId: u32,
    instance: u32,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetOSSnapshotGetFreezeInfoA(
    snapId: u32,
    pcInstanceInfo: ?*u32,
    paInstanceInfo: ?*?*JET_INSTANCE_INFO_A,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetOSSnapshotGetFreezeInfoW(
    snapId: u32,
    pcInstanceInfo: ?*u32,
    paInstanceInfo: ?*?*JET_INSTANCE_INFO_W,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetOSSnapshotEnd(
    snapId: u32,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetConfigureProcessForCrashDump(
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetGetErrorInfoW(
    pvContext: ?*opaque{},
    pvResult: ?*opaque{},
    cbMax: u32,
    InfoLevel: u32,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetSetSessionParameter(
    sesid: u32,
    sesparamid: u32,
    pvParam: ?*opaque{},
    cbParam: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ESENT" fn JetGetSessionParameter(
    sesid: u32,
    sesparamid: u32,
    pvParam: ?*opaque{},
    cbParamMax: u32,
    pcbParamActual: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "PROPSYS" fn StgSerializePropVariant(
    ppropvar: ?*PROPVARIANT,
    ppProp: ?*?*SERIALIZEDPROPERTYVALUE,
    pcb: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "PROPSYS" fn StgDeserializePropVariant(
    pprop: ?*SERIALIZEDPROPERTYVALUE,
    cbMax: u32,
    ppropvar: ?*PROPVARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

//
// Unicode Symbol Aliases
//
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {
        pub const JET_RSTMAP_ = JET_RSTMAP_A;
        pub const tagCONVERT_ = tagCONVERT_A;
        pub const JET_COLUMNBASE_ = JET_COLUMNBASE_A;
        pub const tag_JET_COLUMNCREATE_ = tag_JET_COLUMNCREATE_A;
        pub const tag_JET_USERDEFINEDDEFAULT_ = tag_JET_USERDEFINEDDEFAULT_A;
        pub const JET_CONDITIONALCOLUMN_ = JET_CONDITIONALCOLUMN_A;
        pub const JET_INDEXCREATE_ = JET_INDEXCREATE_A;
        pub const JET_INDEXCREATE2_ = JET_INDEXCREATE2_A;
        pub const JET_INDEXCREATE3_ = JET_INDEXCREATE3_A;
        pub const JET_TABLECREATE_ = JET_TABLECREATE_A;
        pub const JET_TABLECREATE2_ = JET_TABLECREATE2_A;
        pub const JET_TABLECREATE3_ = JET_TABLECREATE3_A;
        pub const JET_TABLECREATE4_ = JET_TABLECREATE4_A;
        pub const JET_RSTINFO_ = JET_RSTINFO_A;
        pub const JET_SETSYSPARAM_ = JET_SETSYSPARAM_A;
        pub const JET_LOGINFO_ = JET_LOGINFO_A;
        pub const JET_INSTANCE_INFO_ = JET_INSTANCE_INFO_A;
        pub const JetInit3 = JetInit3A;
        pub const JetCreateInstance = JetCreateInstanceA;
        pub const JetCreateInstance2 = JetCreateInstance2A;
        pub const JetSetSystemParameter = JetSetSystemParameterA;
        pub const JetGetSystemParameter = JetGetSystemParameterA;
        pub const JetEnableMultiInstance = JetEnableMultiInstanceA;
        pub const JetBeginSession = JetBeginSessionA;
        pub const JetCreateDatabase = JetCreateDatabaseA;
        pub const JetCreateDatabase2 = JetCreateDatabase2A;
        pub const JetAttachDatabase = JetAttachDatabaseA;
        pub const JetAttachDatabase2 = JetAttachDatabase2A;
        pub const JetDetachDatabase = JetDetachDatabaseA;
        pub const JetDetachDatabase2 = JetDetachDatabase2A;
        pub const JetGetObjectInfo = JetGetObjectInfoA;
        pub const JetGetTableInfo = JetGetTableInfoA;
        pub const JetCreateTable = JetCreateTableA;
        pub const JetCreateTableColumnIndex = JetCreateTableColumnIndexA;
        pub const JetCreateTableColumnIndex2 = JetCreateTableColumnIndex2A;
        pub const JetCreateTableColumnIndex3 = JetCreateTableColumnIndex3A;
        pub const JetCreateTableColumnIndex4 = JetCreateTableColumnIndex4A;
        pub const JetDeleteTable = JetDeleteTableA;
        pub const JetRenameTable = JetRenameTableA;
        pub const JetGetTableColumnInfo = JetGetTableColumnInfoA;
        pub const JetGetColumnInfo = JetGetColumnInfoA;
        pub const JetAddColumn = JetAddColumnA;
        pub const JetDeleteColumn = JetDeleteColumnA;
        pub const JetDeleteColumn2 = JetDeleteColumn2A;
        pub const JetRenameColumn = JetRenameColumnA;
        pub const JetSetColumnDefaultValue = JetSetColumnDefaultValueA;
        pub const JetGetTableIndexInfo = JetGetTableIndexInfoA;
        pub const JetGetIndexInfo = JetGetIndexInfoA;
        pub const JetCreateIndex = JetCreateIndexA;
        pub const JetCreateIndex2 = JetCreateIndex2A;
        pub const JetCreateIndex3 = JetCreateIndex3A;
        pub const JetCreateIndex4 = JetCreateIndex4A;
        pub const JetDeleteIndex = JetDeleteIndexA;
        pub const JetGetDatabaseInfo = JetGetDatabaseInfoA;
        pub const JetGetDatabaseFileInfo = JetGetDatabaseFileInfoA;
        pub const JetOpenDatabase = JetOpenDatabaseA;
        pub const JetOpenTable = JetOpenTableA;
        pub const JetGetCurrentIndex = JetGetCurrentIndexA;
        pub const JetSetCurrentIndex = JetSetCurrentIndexA;
        pub const JetSetCurrentIndex2 = JetSetCurrentIndex2A;
        pub const JetSetCurrentIndex3 = JetSetCurrentIndex3A;
        pub const JetSetCurrentIndex4 = JetSetCurrentIndex4A;
        pub const JetCompact = JetCompactA;
        pub const JetDefragment = JetDefragmentA;
        pub const JetDefragment2 = JetDefragment2A;
        pub const JetDefragment3 = JetDefragment3A;
        pub const JetSetDatabaseSize = JetSetDatabaseSizeA;
        pub const JetBackup = JetBackupA;
        pub const JetBackupInstance = JetBackupInstanceA;
        pub const JetRestore = JetRestoreA;
        pub const JetRestore2 = JetRestore2A;
        pub const JetRestoreInstance = JetRestoreInstanceA;
        pub const JetGetAttachInfo = JetGetAttachInfoA;
        pub const JetGetAttachInfoInstance = JetGetAttachInfoInstanceA;
        pub const JetOpenFile = JetOpenFileA;
        pub const JetOpenFileInstance = JetOpenFileInstanceA;
        pub const JetGetLogInfo = JetGetLogInfoA;
        pub const JetGetLogInfoInstance = JetGetLogInfoInstanceA;
        pub const JetGetLogInfoInstance2 = JetGetLogInfoInstance2A;
        pub const JetGetTruncateLogInfoInstance = JetGetTruncateLogInfoInstanceA;
        pub const JetExternalRestore = JetExternalRestoreA;
        pub const JetExternalRestore2 = JetExternalRestore2A;
        pub const JetGetInstanceInfo = JetGetInstanceInfoA;
        pub const JetOSSnapshotFreeze = JetOSSnapshotFreezeA;
        pub const JetOSSnapshotGetFreezeInfo = JetOSSnapshotGetFreezeInfoA;
    },
    .wide => struct {
        pub const JET_RSTMAP_ = JET_RSTMAP_W;
        pub const tagCONVERT_ = tagCONVERT_W;
        pub const JET_COLUMNBASE_ = JET_COLUMNBASE_W;
        pub const tag_JET_COLUMNCREATE_ = tag_JET_COLUMNCREATE_W;
        pub const tag_JET_USERDEFINEDDEFAULT_ = tag_JET_USERDEFINEDDEFAULT_W;
        pub const JET_CONDITIONALCOLUMN_ = JET_CONDITIONALCOLUMN_W;
        pub const JET_INDEXCREATE_ = JET_INDEXCREATE_W;
        pub const JET_INDEXCREATE2_ = JET_INDEXCREATE2_W;
        pub const JET_INDEXCREATE3_ = JET_INDEXCREATE3_W;
        pub const JET_TABLECREATE_ = JET_TABLECREATE_W;
        pub const JET_TABLECREATE2_ = JET_TABLECREATE2_W;
        pub const JET_TABLECREATE3_ = JET_TABLECREATE3_W;
        pub const JET_TABLECREATE4_ = JET_TABLECREATE4_W;
        pub const JET_RSTINFO_ = JET_RSTINFO_W;
        pub const JET_SETSYSPARAM_ = JET_SETSYSPARAM_W;
        pub const JET_LOGINFO_ = JET_LOGINFO_W;
        pub const JET_INSTANCE_INFO_ = JET_INSTANCE_INFO_W;
        pub const JetInit3 = JetInit3W;
        pub const JetCreateInstance = JetCreateInstanceW;
        pub const JetCreateInstance2 = JetCreateInstance2W;
        pub const JetSetSystemParameter = JetSetSystemParameterW;
        pub const JetGetSystemParameter = JetGetSystemParameterW;
        pub const JetEnableMultiInstance = JetEnableMultiInstanceW;
        pub const JetBeginSession = JetBeginSessionW;
        pub const JetCreateDatabase = JetCreateDatabaseW;
        pub const JetCreateDatabase2 = JetCreateDatabase2W;
        pub const JetAttachDatabase = JetAttachDatabaseW;
        pub const JetAttachDatabase2 = JetAttachDatabase2W;
        pub const JetDetachDatabase = JetDetachDatabaseW;
        pub const JetDetachDatabase2 = JetDetachDatabase2W;
        pub const JetGetObjectInfo = JetGetObjectInfoW;
        pub const JetGetTableInfo = JetGetTableInfoW;
        pub const JetCreateTable = JetCreateTableW;
        pub const JetCreateTableColumnIndex = JetCreateTableColumnIndexW;
        pub const JetCreateTableColumnIndex2 = JetCreateTableColumnIndex2W;
        pub const JetCreateTableColumnIndex3 = JetCreateTableColumnIndex3W;
        pub const JetCreateTableColumnIndex4 = JetCreateTableColumnIndex4W;
        pub const JetDeleteTable = JetDeleteTableW;
        pub const JetRenameTable = JetRenameTableW;
        pub const JetGetTableColumnInfo = JetGetTableColumnInfoW;
        pub const JetGetColumnInfo = JetGetColumnInfoW;
        pub const JetAddColumn = JetAddColumnW;
        pub const JetDeleteColumn = JetDeleteColumnW;
        pub const JetDeleteColumn2 = JetDeleteColumn2W;
        pub const JetRenameColumn = JetRenameColumnW;
        pub const JetSetColumnDefaultValue = JetSetColumnDefaultValueW;
        pub const JetGetTableIndexInfo = JetGetTableIndexInfoW;
        pub const JetGetIndexInfo = JetGetIndexInfoW;
        pub const JetCreateIndex = JetCreateIndexW;
        pub const JetCreateIndex2 = JetCreateIndex2W;
        pub const JetCreateIndex3 = JetCreateIndex3W;
        pub const JetCreateIndex4 = JetCreateIndex4W;
        pub const JetDeleteIndex = JetDeleteIndexW;
        pub const JetGetDatabaseInfo = JetGetDatabaseInfoW;
        pub const JetGetDatabaseFileInfo = JetGetDatabaseFileInfoW;
        pub const JetOpenDatabase = JetOpenDatabaseW;
        pub const JetOpenTable = JetOpenTableW;
        pub const JetGetCurrentIndex = JetGetCurrentIndexW;
        pub const JetSetCurrentIndex = JetSetCurrentIndexW;
        pub const JetSetCurrentIndex2 = JetSetCurrentIndex2W;
        pub const JetSetCurrentIndex3 = JetSetCurrentIndex3W;
        pub const JetSetCurrentIndex4 = JetSetCurrentIndex4W;
        pub const JetCompact = JetCompactW;
        pub const JetDefragment = JetDefragmentW;
        pub const JetDefragment2 = JetDefragment2W;
        pub const JetDefragment3 = JetDefragment3W;
        pub const JetSetDatabaseSize = JetSetDatabaseSizeW;
        pub const JetBackup = JetBackupW;
        pub const JetBackupInstance = JetBackupInstanceW;
        pub const JetRestore = JetRestoreW;
        pub const JetRestore2 = JetRestore2W;
        pub const JetRestoreInstance = JetRestoreInstanceW;
        pub const JetGetAttachInfo = JetGetAttachInfoW;
        pub const JetGetAttachInfoInstance = JetGetAttachInfoInstanceW;
        pub const JetOpenFile = JetOpenFileW;
        pub const JetOpenFileInstance = JetOpenFileInstanceW;
        pub const JetGetLogInfo = JetGetLogInfoW;
        pub const JetGetLogInfoInstance = JetGetLogInfoInstanceW;
        pub const JetGetLogInfoInstance2 = JetGetLogInfoInstance2W;
        pub const JetGetTruncateLogInfoInstance = JetGetTruncateLogInfoInstanceW;
        pub const JetExternalRestore = JetExternalRestoreW;
        pub const JetExternalRestore2 = JetExternalRestore2W;
        pub const JetGetInstanceInfo = JetGetInstanceInfoW;
        pub const JetOSSnapshotFreeze = JetOSSnapshotFreezeW;
        pub const JetOSSnapshotGetFreezeInfo = JetOSSnapshotGetFreezeInfoW;
    },
    else => if (@import("builtin").is_test) struct {
        pub const JET_RSTMAP_ = *opaque{};
        pub const tagCONVERT_ = *opaque{};
        pub const JET_COLUMNBASE_ = *opaque{};
        pub const tag_JET_COLUMNCREATE_ = *opaque{};
        pub const tag_JET_USERDEFINEDDEFAULT_ = *opaque{};
        pub const JET_CONDITIONALCOLUMN_ = *opaque{};
        pub const JET_INDEXCREATE_ = *opaque{};
        pub const JET_INDEXCREATE2_ = *opaque{};
        pub const JET_INDEXCREATE3_ = *opaque{};
        pub const JET_TABLECREATE_ = *opaque{};
        pub const JET_TABLECREATE2_ = *opaque{};
        pub const JET_TABLECREATE3_ = *opaque{};
        pub const JET_TABLECREATE4_ = *opaque{};
        pub const JET_RSTINFO_ = *opaque{};
        pub const JET_SETSYSPARAM_ = *opaque{};
        pub const JET_LOGINFO_ = *opaque{};
        pub const JET_INSTANCE_INFO_ = *opaque{};
        pub const JetInit3 = *opaque{};
        pub const JetCreateInstance = *opaque{};
        pub const JetCreateInstance2 = *opaque{};
        pub const JetSetSystemParameter = *opaque{};
        pub const JetGetSystemParameter = *opaque{};
        pub const JetEnableMultiInstance = *opaque{};
        pub const JetBeginSession = *opaque{};
        pub const JetCreateDatabase = *opaque{};
        pub const JetCreateDatabase2 = *opaque{};
        pub const JetAttachDatabase = *opaque{};
        pub const JetAttachDatabase2 = *opaque{};
        pub const JetDetachDatabase = *opaque{};
        pub const JetDetachDatabase2 = *opaque{};
        pub const JetGetObjectInfo = *opaque{};
        pub const JetGetTableInfo = *opaque{};
        pub const JetCreateTable = *opaque{};
        pub const JetCreateTableColumnIndex = *opaque{};
        pub const JetCreateTableColumnIndex2 = *opaque{};
        pub const JetCreateTableColumnIndex3 = *opaque{};
        pub const JetCreateTableColumnIndex4 = *opaque{};
        pub const JetDeleteTable = *opaque{};
        pub const JetRenameTable = *opaque{};
        pub const JetGetTableColumnInfo = *opaque{};
        pub const JetGetColumnInfo = *opaque{};
        pub const JetAddColumn = *opaque{};
        pub const JetDeleteColumn = *opaque{};
        pub const JetDeleteColumn2 = *opaque{};
        pub const JetRenameColumn = *opaque{};
        pub const JetSetColumnDefaultValue = *opaque{};
        pub const JetGetTableIndexInfo = *opaque{};
        pub const JetGetIndexInfo = *opaque{};
        pub const JetCreateIndex = *opaque{};
        pub const JetCreateIndex2 = *opaque{};
        pub const JetCreateIndex3 = *opaque{};
        pub const JetCreateIndex4 = *opaque{};
        pub const JetDeleteIndex = *opaque{};
        pub const JetGetDatabaseInfo = *opaque{};
        pub const JetGetDatabaseFileInfo = *opaque{};
        pub const JetOpenDatabase = *opaque{};
        pub const JetOpenTable = *opaque{};
        pub const JetGetCurrentIndex = *opaque{};
        pub const JetSetCurrentIndex = *opaque{};
        pub const JetSetCurrentIndex2 = *opaque{};
        pub const JetSetCurrentIndex3 = *opaque{};
        pub const JetSetCurrentIndex4 = *opaque{};
        pub const JetCompact = *opaque{};
        pub const JetDefragment = *opaque{};
        pub const JetDefragment2 = *opaque{};
        pub const JetDefragment3 = *opaque{};
        pub const JetSetDatabaseSize = *opaque{};
        pub const JetBackup = *opaque{};
        pub const JetBackupInstance = *opaque{};
        pub const JetRestore = *opaque{};
        pub const JetRestore2 = *opaque{};
        pub const JetRestoreInstance = *opaque{};
        pub const JetGetAttachInfo = *opaque{};
        pub const JetGetAttachInfoInstance = *opaque{};
        pub const JetOpenFile = *opaque{};
        pub const JetOpenFileInstance = *opaque{};
        pub const JetGetLogInfo = *opaque{};
        pub const JetGetLogInfoInstance = *opaque{};
        pub const JetGetLogInfoInstance2 = *opaque{};
        pub const JetGetTruncateLogInfoInstance = *opaque{};
        pub const JetExternalRestore = *opaque{};
        pub const JetExternalRestore2 = *opaque{};
        pub const JetGetInstanceInfo = *opaque{};
        pub const JetOSSnapshotFreeze = *opaque{};
        pub const JetOSSnapshotGetFreezeInfo = *opaque{};
    } else struct {
        pub const JET_RSTMAP_ = @compileError("'JET_RSTMAP_' requires that UNICODE be set to true or false in the root module");
        pub const tagCONVERT_ = @compileError("'tagCONVERT_' requires that UNICODE be set to true or false in the root module");
        pub const JET_COLUMNBASE_ = @compileError("'JET_COLUMNBASE_' requires that UNICODE be set to true or false in the root module");
        pub const tag_JET_COLUMNCREATE_ = @compileError("'tag_JET_COLUMNCREATE_' requires that UNICODE be set to true or false in the root module");
        pub const tag_JET_USERDEFINEDDEFAULT_ = @compileError("'tag_JET_USERDEFINEDDEFAULT_' requires that UNICODE be set to true or false in the root module");
        pub const JET_CONDITIONALCOLUMN_ = @compileError("'JET_CONDITIONALCOLUMN_' requires that UNICODE be set to true or false in the root module");
        pub const JET_INDEXCREATE_ = @compileError("'JET_INDEXCREATE_' requires that UNICODE be set to true or false in the root module");
        pub const JET_INDEXCREATE2_ = @compileError("'JET_INDEXCREATE2_' requires that UNICODE be set to true or false in the root module");
        pub const JET_INDEXCREATE3_ = @compileError("'JET_INDEXCREATE3_' requires that UNICODE be set to true or false in the root module");
        pub const JET_TABLECREATE_ = @compileError("'JET_TABLECREATE_' requires that UNICODE be set to true or false in the root module");
        pub const JET_TABLECREATE2_ = @compileError("'JET_TABLECREATE2_' requires that UNICODE be set to true or false in the root module");
        pub const JET_TABLECREATE3_ = @compileError("'JET_TABLECREATE3_' requires that UNICODE be set to true or false in the root module");
        pub const JET_TABLECREATE4_ = @compileError("'JET_TABLECREATE4_' requires that UNICODE be set to true or false in the root module");
        pub const JET_RSTINFO_ = @compileError("'JET_RSTINFO_' requires that UNICODE be set to true or false in the root module");
        pub const JET_SETSYSPARAM_ = @compileError("'JET_SETSYSPARAM_' requires that UNICODE be set to true or false in the root module");
        pub const JET_LOGINFO_ = @compileError("'JET_LOGINFO_' requires that UNICODE be set to true or false in the root module");
        pub const JET_INSTANCE_INFO_ = @compileError("'JET_INSTANCE_INFO_' requires that UNICODE be set to true or false in the root module");
        pub const JetInit3 = @compileError("'JetInit3' requires that UNICODE be set to true or false in the root module");
        pub const JetCreateInstance = @compileError("'JetCreateInstance' requires that UNICODE be set to true or false in the root module");
        pub const JetCreateInstance2 = @compileError("'JetCreateInstance2' requires that UNICODE be set to true or false in the root module");
        pub const JetSetSystemParameter = @compileError("'JetSetSystemParameter' requires that UNICODE be set to true or false in the root module");
        pub const JetGetSystemParameter = @compileError("'JetGetSystemParameter' requires that UNICODE be set to true or false in the root module");
        pub const JetEnableMultiInstance = @compileError("'JetEnableMultiInstance' requires that UNICODE be set to true or false in the root module");
        pub const JetBeginSession = @compileError("'JetBeginSession' requires that UNICODE be set to true or false in the root module");
        pub const JetCreateDatabase = @compileError("'JetCreateDatabase' requires that UNICODE be set to true or false in the root module");
        pub const JetCreateDatabase2 = @compileError("'JetCreateDatabase2' requires that UNICODE be set to true or false in the root module");
        pub const JetAttachDatabase = @compileError("'JetAttachDatabase' requires that UNICODE be set to true or false in the root module");
        pub const JetAttachDatabase2 = @compileError("'JetAttachDatabase2' requires that UNICODE be set to true or false in the root module");
        pub const JetDetachDatabase = @compileError("'JetDetachDatabase' requires that UNICODE be set to true or false in the root module");
        pub const JetDetachDatabase2 = @compileError("'JetDetachDatabase2' requires that UNICODE be set to true or false in the root module");
        pub const JetGetObjectInfo = @compileError("'JetGetObjectInfo' requires that UNICODE be set to true or false in the root module");
        pub const JetGetTableInfo = @compileError("'JetGetTableInfo' requires that UNICODE be set to true or false in the root module");
        pub const JetCreateTable = @compileError("'JetCreateTable' requires that UNICODE be set to true or false in the root module");
        pub const JetCreateTableColumnIndex = @compileError("'JetCreateTableColumnIndex' requires that UNICODE be set to true or false in the root module");
        pub const JetCreateTableColumnIndex2 = @compileError("'JetCreateTableColumnIndex2' requires that UNICODE be set to true or false in the root module");
        pub const JetCreateTableColumnIndex3 = @compileError("'JetCreateTableColumnIndex3' requires that UNICODE be set to true or false in the root module");
        pub const JetCreateTableColumnIndex4 = @compileError("'JetCreateTableColumnIndex4' requires that UNICODE be set to true or false in the root module");
        pub const JetDeleteTable = @compileError("'JetDeleteTable' requires that UNICODE be set to true or false in the root module");
        pub const JetRenameTable = @compileError("'JetRenameTable' requires that UNICODE be set to true or false in the root module");
        pub const JetGetTableColumnInfo = @compileError("'JetGetTableColumnInfo' requires that UNICODE be set to true or false in the root module");
        pub const JetGetColumnInfo = @compileError("'JetGetColumnInfo' requires that UNICODE be set to true or false in the root module");
        pub const JetAddColumn = @compileError("'JetAddColumn' requires that UNICODE be set to true or false in the root module");
        pub const JetDeleteColumn = @compileError("'JetDeleteColumn' requires that UNICODE be set to true or false in the root module");
        pub const JetDeleteColumn2 = @compileError("'JetDeleteColumn2' requires that UNICODE be set to true or false in the root module");
        pub const JetRenameColumn = @compileError("'JetRenameColumn' requires that UNICODE be set to true or false in the root module");
        pub const JetSetColumnDefaultValue = @compileError("'JetSetColumnDefaultValue' requires that UNICODE be set to true or false in the root module");
        pub const JetGetTableIndexInfo = @compileError("'JetGetTableIndexInfo' requires that UNICODE be set to true or false in the root module");
        pub const JetGetIndexInfo = @compileError("'JetGetIndexInfo' requires that UNICODE be set to true or false in the root module");
        pub const JetCreateIndex = @compileError("'JetCreateIndex' requires that UNICODE be set to true or false in the root module");
        pub const JetCreateIndex2 = @compileError("'JetCreateIndex2' requires that UNICODE be set to true or false in the root module");
        pub const JetCreateIndex3 = @compileError("'JetCreateIndex3' requires that UNICODE be set to true or false in the root module");
        pub const JetCreateIndex4 = @compileError("'JetCreateIndex4' requires that UNICODE be set to true or false in the root module");
        pub const JetDeleteIndex = @compileError("'JetDeleteIndex' requires that UNICODE be set to true or false in the root module");
        pub const JetGetDatabaseInfo = @compileError("'JetGetDatabaseInfo' requires that UNICODE be set to true or false in the root module");
        pub const JetGetDatabaseFileInfo = @compileError("'JetGetDatabaseFileInfo' requires that UNICODE be set to true or false in the root module");
        pub const JetOpenDatabase = @compileError("'JetOpenDatabase' requires that UNICODE be set to true or false in the root module");
        pub const JetOpenTable = @compileError("'JetOpenTable' requires that UNICODE be set to true or false in the root module");
        pub const JetGetCurrentIndex = @compileError("'JetGetCurrentIndex' requires that UNICODE be set to true or false in the root module");
        pub const JetSetCurrentIndex = @compileError("'JetSetCurrentIndex' requires that UNICODE be set to true or false in the root module");
        pub const JetSetCurrentIndex2 = @compileError("'JetSetCurrentIndex2' requires that UNICODE be set to true or false in the root module");
        pub const JetSetCurrentIndex3 = @compileError("'JetSetCurrentIndex3' requires that UNICODE be set to true or false in the root module");
        pub const JetSetCurrentIndex4 = @compileError("'JetSetCurrentIndex4' requires that UNICODE be set to true or false in the root module");
        pub const JetCompact = @compileError("'JetCompact' requires that UNICODE be set to true or false in the root module");
        pub const JetDefragment = @compileError("'JetDefragment' requires that UNICODE be set to true or false in the root module");
        pub const JetDefragment2 = @compileError("'JetDefragment2' requires that UNICODE be set to true or false in the root module");
        pub const JetDefragment3 = @compileError("'JetDefragment3' requires that UNICODE be set to true or false in the root module");
        pub const JetSetDatabaseSize = @compileError("'JetSetDatabaseSize' requires that UNICODE be set to true or false in the root module");
        pub const JetBackup = @compileError("'JetBackup' requires that UNICODE be set to true or false in the root module");
        pub const JetBackupInstance = @compileError("'JetBackupInstance' requires that UNICODE be set to true or false in the root module");
        pub const JetRestore = @compileError("'JetRestore' requires that UNICODE be set to true or false in the root module");
        pub const JetRestore2 = @compileError("'JetRestore2' requires that UNICODE be set to true or false in the root module");
        pub const JetRestoreInstance = @compileError("'JetRestoreInstance' requires that UNICODE be set to true or false in the root module");
        pub const JetGetAttachInfo = @compileError("'JetGetAttachInfo' requires that UNICODE be set to true or false in the root module");
        pub const JetGetAttachInfoInstance = @compileError("'JetGetAttachInfoInstance' requires that UNICODE be set to true or false in the root module");
        pub const JetOpenFile = @compileError("'JetOpenFile' requires that UNICODE be set to true or false in the root module");
        pub const JetOpenFileInstance = @compileError("'JetOpenFileInstance' requires that UNICODE be set to true or false in the root module");
        pub const JetGetLogInfo = @compileError("'JetGetLogInfo' requires that UNICODE be set to true or false in the root module");
        pub const JetGetLogInfoInstance = @compileError("'JetGetLogInfoInstance' requires that UNICODE be set to true or false in the root module");
        pub const JetGetLogInfoInstance2 = @compileError("'JetGetLogInfoInstance2' requires that UNICODE be set to true or false in the root module");
        pub const JetGetTruncateLogInfoInstance = @compileError("'JetGetTruncateLogInfoInstance' requires that UNICODE be set to true or false in the root module");
        pub const JetExternalRestore = @compileError("'JetExternalRestore' requires that UNICODE be set to true or false in the root module");
        pub const JetExternalRestore2 = @compileError("'JetExternalRestore2' requires that UNICODE be set to true or false in the root module");
        pub const JetGetInstanceInfo = @compileError("'JetGetInstanceInfo' requires that UNICODE be set to true or false in the root module");
        pub const JetOSSnapshotFreeze = @compileError("'JetOSSnapshotFreeze' requires that UNICODE be set to true or false in the root module");
        pub const JetOSSnapshotGetFreezeInfo = @compileError("'JetOSSnapshotGetFreezeInfo' requires that UNICODE be set to true or false in the root module");
    },
};

//
// type imports
//
const Guid = @import("../zig.zig").Guid;
const ULARGE_INTEGER = @import("systemservices.zig").ULARGE_INTEGER;
const FILETIME = @import("windowsprogramming.zig").FILETIME;
const LARGE_INTEGER = @import("systemservices.zig").LARGE_INTEGER;
const CY = @import("systemservices.zig").CY;
const BSTR = @import("automation.zig").BSTR;
const BSTRBLOB = @import("systemservices.zig").BSTRBLOB;
const CLIPDATA = @import("systemservices.zig").CLIPDATA;
const BOOL = @import("systemservices.zig").BOOL;
const HRESULT = @import("com.zig").HRESULT;
const OLESTREAM = @import("com.zig").OLESTREAM;
const DVTARGETDEVICE = @import("com.zig").DVTARGETDEVICE;
const STGMEDIUM = @import("com.zig").STGMEDIUM;
const IUnknown = @import("com.zig").IUnknown;
const SERIALIZEDPROPERTYVALUE = @import("shell.zig").SERIALIZEDPROPERTYVALUE;
const HWND = @import("windowsandmessaging.zig").HWND;
const IBindStatusCallback = @import("com.zig").IBindStatusCallback;

test "" {
    const constant_export_count = 0;
    const type_export_count = 135;
    const func_count = 274;
    const unicode_alias_count = 85;
    const type_import_count = 17;
    @setEvalBranchQuota(0
        + constant_export_count
        + type_export_count
        + func_count
        + unicode_alias_count
        + type_import_count
        + 2 // TODO: why do I need these extra 2?
    );
    @import("std").testing.refAllDecls(@This());
}
