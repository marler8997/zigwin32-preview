//! NOTE: this source file is autogenerated, DO NOT MODIFY

//
// constants
//

//
// types
//
// --------------------------------------------------------
// Type: NET_ADDRESS_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const NET_ADDRESS_INFO = opaque {
};
// --------------------------------------------------------
// Type: IcmpHandle
// TypeLayoutAttr: sequential
// RAIIFree 'IcmpCloseHandle' (TODO: can we use this information?)
pub const IcmpHandle = ?*opaque{};
// --------------------------------------------------------
// Type: ip_option_information
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const ip_option_information = extern struct {
    Ttl: u8,
    Tos: u8,
    Flags: u8,
    OptionsSize: u8,
    OptionsData: ?*u8,
};
// --------------------------------------------------------
// Type: icmp_echo_reply
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const icmp_echo_reply = extern struct {
    Address: u32,
    Status: u32,
    RoundTripTime: u32,
    DataSize: u16,
    Reserved: u16,
    Data: ?*opaque{},
    Options: ip_option_information,
};
// --------------------------------------------------------
// Type: IPV6_ADDRESS_EX
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const IPV6_ADDRESS_EX = *opaque{
};
// --------------------------------------------------------
// Type: icmpv6_echo_reply_lh
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const icmpv6_echo_reply_lh = extern struct {
    Address: IPV6_ADDRESS_EX,
    Status: u32,
    RoundTripTime: u32,
};
// --------------------------------------------------------
// Type: arp_send_reply
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const arp_send_reply = extern struct {
    DestAddress: u32,
    SrcAddress: u32,
};
// --------------------------------------------------------
// Type: tcp_reserve_port_range
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const tcp_reserve_port_range = extern struct {
    UpperRange: u16,
    LowerRange: u16,
};
// --------------------------------------------------------
// Type: IP_ADAPTER_INDEX_MAP
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const IP_ADAPTER_INDEX_MAP = extern struct {
    Index: u32,
    Name: ?[*]u16,
};
// --------------------------------------------------------
// Type: IP_INTERFACE_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const IP_INTERFACE_INFO = extern struct {
    NumAdapters: i32,
    Adapter: ?[*]IP_ADAPTER_INDEX_MAP,
};
// --------------------------------------------------------
// Type: IP_UNIDIRECTIONAL_ADAPTER_ADDRESS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const IP_UNIDIRECTIONAL_ADAPTER_ADDRESS = extern struct {
    NumAdapters: u32,
    Address: ?[*]u32,
};
// --------------------------------------------------------
// Type: IP_ADAPTER_ORDER_MAP
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const IP_ADAPTER_ORDER_MAP = extern struct {
    NumAdapters: u32,
    AdapterOrder: ?[*]u32,
};
// --------------------------------------------------------
// Type: IP_MCAST_COUNTER_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const IP_MCAST_COUNTER_INFO = extern struct {
    InMcastOctets: u64,
    OutMcastOctets: u64,
    InMcastPkts: u64,
    OutMcastPkts: u64,
};
// --------------------------------------------------------
// Type: IF_ACCESS_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const IF_ACCESS_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: INTERNAL_IF_OPER_STATUS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const INTERNAL_IF_OPER_STATUS = *opaque{
};
// --------------------------------------------------------
// Type: NET_IF_RCV_ADDRESS_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const NET_IF_RCV_ADDRESS_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: NET_IF_RCV_ADDRESS_LH
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NET_IF_RCV_ADDRESS_LH = extern struct {
    ifRcvAddressType: NET_IF_RCV_ADDRESS_TYPE,
    ifRcvAddressLength: u16,
    ifRcvAddressOffset: u16,
};
// --------------------------------------------------------
// Type: NET_IF_ALIAS_LH
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NET_IF_ALIAS_LH = extern struct {
    ifAliasLength: u16,
    ifAliasOffset: u16,
};
// --------------------------------------------------------
// Type: NET_LUID_LH
// TypeLayoutAttr: explicit
// not generating the actual code for this type because it has an explicit layout
pub const NET_LUID_LH = *opaque{
    // --------------------------------------------------------
    // Type: _Info_e__Struct
    // TypeLayoutAttr: sequential
    // TODO: I think this is a struct, but not sure at this point, assuming it is for now
    pub const _Info_e__Struct = extern struct {
        _bitfield: u64,
    };
};
// --------------------------------------------------------
// Type: IF_PHYSICAL_ADDRESS_LH
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const IF_PHYSICAL_ADDRESS_LH = extern struct {
    Length: u16,
    Address: ?[*]u8,
};
// --------------------------------------------------------
// Type: IF_ADMINISTRATIVE_STATE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const IF_ADMINISTRATIVE_STATE = *opaque{
};
// --------------------------------------------------------
// Type: IF_OPER_STATUS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const IF_OPER_STATUS = *opaque{
};
// --------------------------------------------------------
// Type: MIB_IF_ENTRY_LEVEL
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const MIB_IF_ENTRY_LEVEL = *opaque{
};
// --------------------------------------------------------
// Type: PIPINTERFACE_CHANGE_CALLBACK
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PIPINTERFACE_CHANGE_CALLBACK = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PUNICAST_IPADDRESS_CHANGE_CALLBACK
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PUNICAST_IPADDRESS_CHANGE_CALLBACK = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PSTABLE_UNICAST_IPADDRESS_TABLE_CALLBACK
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PSTABLE_UNICAST_IPADDRESS_TABLE_CALLBACK = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: IP_ADDRESS_PREFIX
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const IP_ADDRESS_PREFIX = extern struct {
    Prefix: SOCKADDR_INET,
    PrefixLength: u8,
};
// --------------------------------------------------------
// Type: PIPFORWARD_CHANGE_CALLBACK
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PIPFORWARD_CHANGE_CALLBACK = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PTEREDO_PORT_CHANGE_CALLBACK
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PTEREDO_PORT_CHANGE_CALLBACK = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: DNS_SETTINGS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DNS_SETTINGS = extern struct {
    Version: u32,
    Flags: u64,
    Hostname: ?*u16,
    Domain: ?*u16,
    SearchList: ?*u16,
};
// --------------------------------------------------------
// Type: DNS_INTERFACE_SETTINGS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DNS_INTERFACE_SETTINGS = extern struct {
    Version: u32,
    Flags: u64,
    Domain: ?*u16,
    NameServer: ?*u16,
    SearchList: ?*u16,
    RegistrationEnabled: u32,
    RegisterAdapterName: u32,
    EnableLLMNR: u32,
    QueryAdapterName: u32,
    ProfileNameServer: ?*u16,
};
// --------------------------------------------------------
// Type: DNS_INTERFACE_SETTINGS_EX
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DNS_INTERFACE_SETTINGS_EX = extern struct {
    SettingsV1: DNS_INTERFACE_SETTINGS,
    DisableUnconstrainedQueries: u32,
    SupplementalSearchList: ?*u16,
};
// --------------------------------------------------------
// Type: PNETWORK_CONNECTIVITY_HINT_CHANGE_CALLBACK
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PNETWORK_CONNECTIVITY_HINT_CHANGE_CALLBACK = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: MIB_IPFORWARD_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const MIB_IPFORWARD_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: MIB_IPNET_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const MIB_IPNET_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: MIB_IPSTATS_FORWARDING
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const MIB_IPSTATS_FORWARDING = *opaque{
};
// --------------------------------------------------------
// Type: MIB_TCP_STATE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const MIB_TCP_STATE = *opaque{
};
// --------------------------------------------------------
// Type: TCP_RTO_ALGORITHM
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const TCP_RTO_ALGORITHM = *opaque{
};
// --------------------------------------------------------
// Type: TCP_TABLE_CLASS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const TCP_TABLE_CLASS = *opaque{
};
// --------------------------------------------------------
// Type: UDP_TABLE_CLASS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UDP_TABLE_CLASS = *opaque{
};
// --------------------------------------------------------
// Type: TCPIP_OWNER_MODULE_INFO_CLASS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const TCPIP_OWNER_MODULE_INFO_CLASS = *opaque{
};
// --------------------------------------------------------
// Type: TCPIP_OWNER_MODULE_BASIC_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TCPIP_OWNER_MODULE_BASIC_INFO = extern struct {
    pModuleName: ?*u16,
    pModulePath: ?*u16,
};
// --------------------------------------------------------
// Type: MIB_IPDESTROW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const MIB_IPDESTROW = extern struct {
    ForwardRow: MIB_IPFORWARDROW,
    dwForwardPreference: u32,
    dwForwardViewSet: u32,
};
// --------------------------------------------------------
// Type: MIB_IPDESTTABLE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const MIB_IPDESTTABLE = extern struct {
    dwNumEntries: u32,
    table: ?[*]MIB_IPDESTROW,
};
// --------------------------------------------------------
// Type: MIB_ROUTESTATE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const MIB_ROUTESTATE = extern struct {
    bRoutesSetToStack: BOOL,
};
// --------------------------------------------------------
// Type: IP_ADDRESS_STRING
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const IP_ADDRESS_STRING = extern struct {
    String: ?[*]i8,
};
// --------------------------------------------------------
// Type: IP_ADDR_STRING
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const IP_ADDR_STRING = extern struct {
    Next: ?*IP_ADDR_STRING,
    IpAddress: IP_ADDRESS_STRING,
    IpMask: IP_ADDRESS_STRING,
    Context: u32,
};
// --------------------------------------------------------
// Type: IP_ADAPTER_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const IP_ADAPTER_INFO = extern struct {
    Next: ?*IP_ADAPTER_INFO,
    ComboIndex: u32,
    AdapterName: ?[*]i8,
    Description: ?[*]i8,
    AddressLength: u32,
    Address: ?[*]u8,
    Index: u32,
    Type: u32,
    DhcpEnabled: u32,
    CurrentIpAddress: ?*IP_ADDR_STRING,
    IpAddressList: IP_ADDR_STRING,
    GatewayList: IP_ADDR_STRING,
    DhcpServer: IP_ADDR_STRING,
    HaveWins: BOOL,
    PrimaryWinsServer: IP_ADDR_STRING,
    SecondaryWinsServer: IP_ADDR_STRING,
    LeaseObtained: i64,
    LeaseExpires: i64,
};
// --------------------------------------------------------
// Type: IP_ADAPTER_UNICAST_ADDRESS_LH
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const IP_ADAPTER_UNICAST_ADDRESS_LH = extern struct {
    Anonymous: _Anonymous_e__Union,
    Next: ?*IP_ADAPTER_UNICAST_ADDRESS_LH,
    Address: SOCKET_ADDRESS,
    PrefixOrigin: NL_PREFIX_ORIGIN,
    SuffixOrigin: NL_SUFFIX_ORIGIN,
    DadState: NL_DAD_STATE,
    ValidLifetime: u32,
    PreferredLifetime: u32,
    LeaseLifetime: u32,
    OnLinkPrefixLength: u8,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
        // --------------------------------------------------------
        // Type: _Anonymous_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _Anonymous_e__Struct = extern struct {
            Length: u32,
            Flags: u32,
        };
    };
};
// --------------------------------------------------------
// Type: IP_ADAPTER_UNICAST_ADDRESS_XP
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const IP_ADAPTER_UNICAST_ADDRESS_XP = extern struct {
    Anonymous: _Anonymous_e__Union,
    Next: ?*IP_ADAPTER_UNICAST_ADDRESS_XP,
    Address: SOCKET_ADDRESS,
    PrefixOrigin: NL_PREFIX_ORIGIN,
    SuffixOrigin: NL_SUFFIX_ORIGIN,
    DadState: NL_DAD_STATE,
    ValidLifetime: u32,
    PreferredLifetime: u32,
    LeaseLifetime: u32,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
        // --------------------------------------------------------
        // Type: _Anonymous_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _Anonymous_e__Struct = extern struct {
            Length: u32,
            Flags: u32,
        };
    };
};
// --------------------------------------------------------
// Type: IP_ADAPTER_ANYCAST_ADDRESS_XP
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const IP_ADAPTER_ANYCAST_ADDRESS_XP = extern struct {
    Anonymous: _Anonymous_e__Union,
    Next: ?*IP_ADAPTER_ANYCAST_ADDRESS_XP,
    Address: SOCKET_ADDRESS,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
        // --------------------------------------------------------
        // Type: _Anonymous_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _Anonymous_e__Struct = extern struct {
            Length: u32,
            Flags: u32,
        };
    };
};
// --------------------------------------------------------
// Type: IP_ADAPTER_MULTICAST_ADDRESS_XP
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const IP_ADAPTER_MULTICAST_ADDRESS_XP = extern struct {
    Anonymous: _Anonymous_e__Union,
    Next: ?*IP_ADAPTER_MULTICAST_ADDRESS_XP,
    Address: SOCKET_ADDRESS,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
        // --------------------------------------------------------
        // Type: _Anonymous_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _Anonymous_e__Struct = extern struct {
            Length: u32,
            Flags: u32,
        };
    };
};
// --------------------------------------------------------
// Type: IP_ADAPTER_DNS_SERVER_ADDRESS_XP
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const IP_ADAPTER_DNS_SERVER_ADDRESS_XP = extern struct {
    Anonymous: _Anonymous_e__Union,
    Next: ?*IP_ADAPTER_DNS_SERVER_ADDRESS_XP,
    Address: SOCKET_ADDRESS,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
        // --------------------------------------------------------
        // Type: _Anonymous_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _Anonymous_e__Struct = extern struct {
            Length: u32,
            Reserved: u32,
        };
    };
};
// --------------------------------------------------------
// Type: IP_ADAPTER_WINS_SERVER_ADDRESS_LH
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const IP_ADAPTER_WINS_SERVER_ADDRESS_LH = extern struct {
    Anonymous: _Anonymous_e__Union,
    Next: ?*IP_ADAPTER_WINS_SERVER_ADDRESS_LH,
    Address: SOCKET_ADDRESS,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
        // --------------------------------------------------------
        // Type: _Anonymous_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _Anonymous_e__Struct = extern struct {
            Length: u32,
            Reserved: u32,
        };
    };
};
// --------------------------------------------------------
// Type: IP_ADAPTER_GATEWAY_ADDRESS_LH
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const IP_ADAPTER_GATEWAY_ADDRESS_LH = extern struct {
    Anonymous: _Anonymous_e__Union,
    Next: ?*IP_ADAPTER_GATEWAY_ADDRESS_LH,
    Address: SOCKET_ADDRESS,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
        // --------------------------------------------------------
        // Type: _Anonymous_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _Anonymous_e__Struct = extern struct {
            Length: u32,
            Reserved: u32,
        };
    };
};
// --------------------------------------------------------
// Type: IP_ADAPTER_PREFIX_XP
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const IP_ADAPTER_PREFIX_XP = extern struct {
    Anonymous: _Anonymous_e__Union,
    Next: ?*IP_ADAPTER_PREFIX_XP,
    Address: SOCKET_ADDRESS,
    PrefixLength: u32,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
        // --------------------------------------------------------
        // Type: _Anonymous_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _Anonymous_e__Struct = extern struct {
            Length: u32,
            Flags: u32,
        };
    };
};
// --------------------------------------------------------
// Type: IP_ADAPTER_DNS_SUFFIX
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const IP_ADAPTER_DNS_SUFFIX = extern struct {
    Next: ?*IP_ADAPTER_DNS_SUFFIX,
    String: ?[*]u16,
};
// --------------------------------------------------------
// Type: IP_ADAPTER_ADDRESSES_LH
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const IP_ADAPTER_ADDRESSES_LH = extern struct {
    Anonymous1: _Anonymous1_e__Union,
    Next: ?*IP_ADAPTER_ADDRESSES_LH,
    AdapterName: ?*i8,
    FirstUnicastAddress: ?*IP_ADAPTER_UNICAST_ADDRESS_LH,
    FirstAnycastAddress: ?*IP_ADAPTER_ANYCAST_ADDRESS_XP,
    FirstMulticastAddress: ?*IP_ADAPTER_MULTICAST_ADDRESS_XP,
    FirstDnsServerAddress: ?*IP_ADAPTER_DNS_SERVER_ADDRESS_XP,
    DnsSuffix: ?*u16,
    Description: ?*u16,
    FriendlyName: ?*u16,
    PhysicalAddress: ?[*]u8,
    PhysicalAddressLength: u32,
    Anonymous2: _Anonymous2_e__Union,
    Mtu: u32,
    IfType: u32,
    OperStatus: IF_OPER_STATUS,
    Ipv6IfIndex: u32,
    ZoneIndices: ?[*]u32,
    FirstPrefix: ?*IP_ADAPTER_PREFIX_XP,
    TransmitLinkSpeed: u64,
    ReceiveLinkSpeed: u64,
    FirstWinsServerAddress: ?*IP_ADAPTER_WINS_SERVER_ADDRESS_LH,
    FirstGatewayAddress: ?*IP_ADAPTER_GATEWAY_ADDRESS_LH,
    Ipv4Metric: u32,
    Ipv6Metric: u32,
    Luid: NET_LUID_LH,
    Dhcpv4Server: SOCKET_ADDRESS,
    CompartmentId: u32,
    NetworkGuid: Guid,
    ConnectionType: NET_IF_CONNECTION_TYPE,
    TunnelType: TUNNEL_TYPE,
    Dhcpv6Server: SOCKET_ADDRESS,
    Dhcpv6ClientDuid: ?[*]u8,
    Dhcpv6ClientDuidLength: u32,
    Dhcpv6Iaid: u32,
    FirstDnsSuffix: ?*IP_ADAPTER_DNS_SUFFIX,
    // --------------------------------------------------------
    // Type: _Anonymous2_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous2_e__Union = *opaque{
        // --------------------------------------------------------
        // Type: _Anonymous_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _Anonymous_e__Struct = extern struct {
            _bitfield: u32,
        };
    };
    // --------------------------------------------------------
    // Type: _Anonymous1_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous1_e__Union = *opaque{
        // --------------------------------------------------------
        // Type: _Anonymous_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _Anonymous_e__Struct = extern struct {
            Length: u32,
            IfIndex: u32,
        };
    };
};
// --------------------------------------------------------
// Type: IP_ADAPTER_ADDRESSES_XP
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const IP_ADAPTER_ADDRESSES_XP = extern struct {
    Anonymous: _Anonymous_e__Union,
    Next: ?*IP_ADAPTER_ADDRESSES_XP,
    AdapterName: ?*i8,
    FirstUnicastAddress: ?*IP_ADAPTER_UNICAST_ADDRESS_XP,
    FirstAnycastAddress: ?*IP_ADAPTER_ANYCAST_ADDRESS_XP,
    FirstMulticastAddress: ?*IP_ADAPTER_MULTICAST_ADDRESS_XP,
    FirstDnsServerAddress: ?*IP_ADAPTER_DNS_SERVER_ADDRESS_XP,
    DnsSuffix: ?*u16,
    Description: ?*u16,
    FriendlyName: ?*u16,
    PhysicalAddress: ?[*]u8,
    PhysicalAddressLength: u32,
    Flags: u32,
    Mtu: u32,
    IfType: u32,
    OperStatus: IF_OPER_STATUS,
    Ipv6IfIndex: u32,
    ZoneIndices: ?[*]u32,
    FirstPrefix: ?*IP_ADAPTER_PREFIX_XP,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
        // --------------------------------------------------------
        // Type: _Anonymous_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _Anonymous_e__Struct = extern struct {
            Length: u32,
            IfIndex: u32,
        };
    };
};
// --------------------------------------------------------
// Type: IP_PER_ADAPTER_INFO_W2KSP1
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const IP_PER_ADAPTER_INFO_W2KSP1 = extern struct {
    AutoconfigEnabled: u32,
    AutoconfigActive: u32,
    CurrentDnsServer: ?*IP_ADDR_STRING,
    DnsServerList: IP_ADDR_STRING,
};
// --------------------------------------------------------
// Type: FIXED_INFO_W2KSP1
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const FIXED_INFO_W2KSP1 = extern struct {
    HostName: ?[*]i8,
    DomainName: ?[*]i8,
    CurrentDnsServer: ?*IP_ADDR_STRING,
    DnsServerList: IP_ADDR_STRING,
    NodeType: u32,
    ScopeId: ?[*]i8,
    EnableRouting: u32,
    EnableProxy: u32,
    EnableDns: u32,
};
// --------------------------------------------------------
// Type: ip_interface_name_info_w2ksp1
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const ip_interface_name_info_w2ksp1 = extern struct {
    Index: u32,
    MediaType: u32,
    ConnectionType: u8,
    AccessType: u8,
    DeviceGuid: Guid,
    InterfaceGuid: Guid,
};
// --------------------------------------------------------
// Type: TCP_ESTATS_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const TCP_ESTATS_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: TCP_BOOLEAN_OPTIONAL
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const TCP_BOOLEAN_OPTIONAL = *opaque{
};
// --------------------------------------------------------
// Type: TCP_ESTATS_SYN_OPTS_ROS_v0
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TCP_ESTATS_SYN_OPTS_ROS_v0 = extern struct {
    ActiveOpen: u8,
    MssRcvd: u32,
    MssSent: u32,
};
// --------------------------------------------------------
// Type: TCP_SOFT_ERROR
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const TCP_SOFT_ERROR = *opaque{
};
// --------------------------------------------------------
// Type: TCP_ESTATS_DATA_ROD_v0
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TCP_ESTATS_DATA_ROD_v0 = extern struct {
    DataBytesOut: u64,
    DataSegsOut: u64,
    DataBytesIn: u64,
    DataSegsIn: u64,
    SegsOut: u64,
    SegsIn: u64,
    SoftErrors: u32,
    SoftErrorReason: u32,
    SndUna: u32,
    SndNxt: u32,
    SndMax: u32,
    ThruBytesAcked: u64,
    RcvNxt: u32,
    ThruBytesReceived: u64,
};
// --------------------------------------------------------
// Type: TCP_ESTATS_DATA_RW_v0
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TCP_ESTATS_DATA_RW_v0 = extern struct {
    EnableCollection: u8,
};
// --------------------------------------------------------
// Type: TCP_ESTATS_SND_CONG_ROD_v0
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TCP_ESTATS_SND_CONG_ROD_v0 = extern struct {
    SndLimTransRwin: u32,
    SndLimTimeRwin: u32,
    SndLimBytesRwin: ?*opaque{},
    SndLimTransCwnd: u32,
    SndLimTimeCwnd: u32,
    SndLimBytesCwnd: ?*opaque{},
    SndLimTransSnd: u32,
    SndLimTimeSnd: u32,
    SndLimBytesSnd: ?*opaque{},
    SlowStart: u32,
    CongAvoid: u32,
    OtherReductions: u32,
    CurCwnd: u32,
    MaxSsCwnd: u32,
    MaxCaCwnd: u32,
    CurSsthresh: u32,
    MaxSsthresh: u32,
    MinSsthresh: u32,
};
// --------------------------------------------------------
// Type: TCP_ESTATS_SND_CONG_ROS_v0
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TCP_ESTATS_SND_CONG_ROS_v0 = extern struct {
    LimCwnd: u32,
};
// --------------------------------------------------------
// Type: TCP_ESTATS_SND_CONG_RW_v0
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TCP_ESTATS_SND_CONG_RW_v0 = extern struct {
    EnableCollection: u8,
};
// --------------------------------------------------------
// Type: TCP_ESTATS_PATH_ROD_v0
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TCP_ESTATS_PATH_ROD_v0 = extern struct {
    FastRetran: u32,
    Timeouts: u32,
    SubsequentTimeouts: u32,
    CurTimeoutCount: u32,
    AbruptTimeouts: u32,
    PktsRetrans: u32,
    BytesRetrans: u32,
    DupAcksIn: u32,
    SacksRcvd: u32,
    SackBlocksRcvd: u32,
    CongSignals: u32,
    PreCongSumCwnd: u32,
    PreCongSumRtt: u32,
    PostCongSumRtt: u32,
    PostCongCountRtt: u32,
    EcnSignals: u32,
    EceRcvd: u32,
    SendStall: u32,
    QuenchRcvd: u32,
    RetranThresh: u32,
    SndDupAckEpisodes: u32,
    SumBytesReordered: u32,
    NonRecovDa: u32,
    NonRecovDaEpisodes: u32,
    AckAfterFr: u32,
    DsackDups: u32,
    SampleRtt: u32,
    SmoothedRtt: u32,
    RttVar: u32,
    MaxRtt: u32,
    MinRtt: u32,
    SumRtt: u32,
    CountRtt: u32,
    CurRto: u32,
    MaxRto: u32,
    MinRto: u32,
    CurMss: u32,
    MaxMss: u32,
    MinMss: u32,
    SpuriousRtoDetections: u32,
};
// --------------------------------------------------------
// Type: TCP_ESTATS_PATH_RW_v0
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TCP_ESTATS_PATH_RW_v0 = extern struct {
    EnableCollection: u8,
};
// --------------------------------------------------------
// Type: TCP_ESTATS_SEND_BUFF_ROD_v0
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TCP_ESTATS_SEND_BUFF_ROD_v0 = extern struct {
    CurRetxQueue: ?*opaque{},
    MaxRetxQueue: ?*opaque{},
    CurAppWQueue: ?*opaque{},
    MaxAppWQueue: ?*opaque{},
};
// --------------------------------------------------------
// Type: TCP_ESTATS_SEND_BUFF_RW_v0
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TCP_ESTATS_SEND_BUFF_RW_v0 = extern struct {
    EnableCollection: u8,
};
// --------------------------------------------------------
// Type: TCP_ESTATS_REC_ROD_v0
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TCP_ESTATS_REC_ROD_v0 = extern struct {
    CurRwinSent: u32,
    MaxRwinSent: u32,
    MinRwinSent: u32,
    LimRwin: u32,
    DupAckEpisodes: u32,
    DupAcksOut: u32,
    CeRcvd: u32,
    EcnSent: u32,
    EcnNoncesRcvd: u32,
    CurReasmQueue: u32,
    MaxReasmQueue: u32,
    CurAppRQueue: ?*opaque{},
    MaxAppRQueue: ?*opaque{},
    WinScaleSent: u8,
};
// --------------------------------------------------------
// Type: TCP_ESTATS_REC_RW_v0
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TCP_ESTATS_REC_RW_v0 = extern struct {
    EnableCollection: u8,
};
// --------------------------------------------------------
// Type: TCP_ESTATS_OBS_REC_ROD_v0
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TCP_ESTATS_OBS_REC_ROD_v0 = extern struct {
    CurRwinRcvd: u32,
    MaxRwinRcvd: u32,
    MinRwinRcvd: u32,
    WinScaleRcvd: u8,
};
// --------------------------------------------------------
// Type: TCP_ESTATS_OBS_REC_RW_v0
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TCP_ESTATS_OBS_REC_RW_v0 = extern struct {
    EnableCollection: u8,
};
// --------------------------------------------------------
// Type: TCP_ESTATS_BANDWIDTH_RW_v0
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TCP_ESTATS_BANDWIDTH_RW_v0 = extern struct {
    EnableCollectionOutbound: TCP_BOOLEAN_OPTIONAL,
    EnableCollectionInbound: TCP_BOOLEAN_OPTIONAL,
};
// --------------------------------------------------------
// Type: TCP_ESTATS_BANDWIDTH_ROD_v0
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TCP_ESTATS_BANDWIDTH_ROD_v0 = extern struct {
    OutboundBandwidth: u64,
    InboundBandwidth: u64,
    OutboundInstability: u64,
    InboundInstability: u64,
    OutboundBandwidthPeaked: u8,
    InboundBandwidthPeaked: u8,
};
// --------------------------------------------------------
// Type: TCP_ESTATS_FINE_RTT_RW_v0
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TCP_ESTATS_FINE_RTT_RW_v0 = extern struct {
    EnableCollection: u8,
};
// --------------------------------------------------------
// Type: TCP_ESTATS_FINE_RTT_ROD_v0
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const TCP_ESTATS_FINE_RTT_ROD_v0 = extern struct {
    RttVar: u32,
    MaxRtt: u32,
    MinRtt: u32,
    SumRtt: u32,
};
// --------------------------------------------------------
// Type: INTERFACE_TIMESTAMP_CAPABILITY_FLAGS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const INTERFACE_TIMESTAMP_CAPABILITY_FLAGS = extern struct {
    PtpV2OverUdpIPv4EventMsgReceiveHw: u8,
    PtpV2OverUdpIPv4AllMsgReceiveHw: u8,
    PtpV2OverUdpIPv4EventMsgTransmitHw: u8,
    PtpV2OverUdpIPv4AllMsgTransmitHw: u8,
    PtpV2OverUdpIPv6EventMsgReceiveHw: u8,
    PtpV2OverUdpIPv6AllMsgReceiveHw: u8,
    PtpV2OverUdpIPv6EventMsgTransmitHw: u8,
    PtpV2OverUdpIPv6AllMsgTransmitHw: u8,
    AllReceiveHw: u8,
    AllTransmitHw: u8,
    TaggedTransmitHw: u8,
    AllReceiveSw: u8,
    AllTransmitSw: u8,
    TaggedTransmitSw: u8,
};
// --------------------------------------------------------
// Type: INTERFACE_TIMESTAMP_CAPABILITIES
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const INTERFACE_TIMESTAMP_CAPABILITIES = extern struct {
    Version: u32,
    HardwareClockFrequencyHz: u64,
    CrossTimestamp: u8,
    Reserved1: u64,
    Reserved2: u64,
    TimestampFlags: INTERFACE_TIMESTAMP_CAPABILITY_FLAGS,
};
// --------------------------------------------------------
// Type: INTERFACE_HARDWARE_CROSSTIMESTAMP
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const INTERFACE_HARDWARE_CROSSTIMESTAMP = extern struct {
    Version: u32,
    Flags: u32,
    SystemTimestamp1: u64,
    HardwareClockTimestamp: u64,
    SystemTimestamp2: u64,
};
// --------------------------------------------------------
// Type: HIFTIMESTAMPCHANGE__
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HIFTIMESTAMPCHANGE__ = extern struct {
    unused: i32,
};
// --------------------------------------------------------
// Type: INTERFACE_TIMESTAMP_CONFIG_CHANGE_CALLBACK
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const INTERFACE_TIMESTAMP_CONFIG_CHANGE_CALLBACK = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PINTERFACE_TIMESTAMP_CONFIG_CHANGE_CALLBACK
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PINTERFACE_TIMESTAMP_CONFIG_CHANGE_CALLBACK = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: NET_ADDRESS_FORMAT
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const NET_ADDRESS_FORMAT = *opaque{
};
// --------------------------------------------------------
// Type: SCOPE_LEVEL
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const SCOPE_LEVEL = *opaque{
};
// --------------------------------------------------------
// Type: SOCKADDR_INET
// TypeLayoutAttr: explicit
// not generating the actual code for this type because it has an explicit layout
pub const SOCKADDR_INET = *opaque{
};
// --------------------------------------------------------
// Type: SOCKADDR_IN6_PAIR
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SOCKADDR_IN6_PAIR = extern struct {
    SourceAddress: ?*SOCKADDR_IN6_LH,
    DestinationAddress: ?*SOCKADDR_IN6_LH,
};
// --------------------------------------------------------
// Type: NL_PREFIX_ORIGIN
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const NL_PREFIX_ORIGIN = *opaque{
};
// --------------------------------------------------------
// Type: NL_SUFFIX_ORIGIN
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const NL_SUFFIX_ORIGIN = *opaque{
};
// --------------------------------------------------------
// Type: NL_DAD_STATE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const NL_DAD_STATE = *opaque{
};
// --------------------------------------------------------
// Type: NL_NETWORK_CONNECTIVITY_LEVEL_HINT
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const NL_NETWORK_CONNECTIVITY_LEVEL_HINT = *opaque{
};
// --------------------------------------------------------
// Type: NL_NETWORK_CONNECTIVITY_COST_HINT
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const NL_NETWORK_CONNECTIVITY_COST_HINT = *opaque{
};
// --------------------------------------------------------
// Type: NL_NETWORK_CONNECTIVITY_HINT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NL_NETWORK_CONNECTIVITY_HINT = extern struct {
    ConnectivityLevel: NL_NETWORK_CONNECTIVITY_LEVEL_HINT,
    ConnectivityCost: NL_NETWORK_CONNECTIVITY_COST_HINT,
    ApproachingDataLimit: u8,
    OverDataLimit: u8,
    Roaming: u8,
};
// --------------------------------------------------------
// Type: NL_BANDWIDTH_INFORMATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const NL_BANDWIDTH_INFORMATION = extern struct {
    Bandwidth: u64,
    Instability: u64,
    BandwidthPeaked: u8,
};

//
// functions
//

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn GetIfEntry2(
    Row: ?*MIB_IF_ROW2,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn GetIfEntry2Ex(
    Level: MIB_IF_ENTRY_LEVEL,
    Row: ?*MIB_IF_ROW2,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn GetIfTable2(
    Table: ?*?*MIB_IF_TABLE2,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn GetIfTable2Ex(
    Level: MIB_IF_TABLE_LEVEL,
    Table: ?*?*MIB_IF_TABLE2,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn GetIfStackTable(
    Table: ?*?*MIB_IFSTACK_TABLE,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn GetInvertedIfStackTable(
    Table: ?*?*MIB_INVERTEDIFSTACK_TABLE,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn GetIpInterfaceEntry(
    Row: ?*MIB_IPINTERFACE_ROW,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn GetIpInterfaceTable(
    Family: u16,
    Table: ?*?*MIB_IPINTERFACE_TABLE,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn InitializeIpInterfaceEntry(
    Row: ?*MIB_IPINTERFACE_ROW,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn NotifyIpInterfaceChange(
    Family: u16,
    Callback: PIPINTERFACE_CHANGE_CALLBACK,
    CallerContext: ?*opaque{},
    InitialNotification: u8,
    NotificationHandle: ?*HANDLE,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn SetIpInterfaceEntry(
    Row: ?*MIB_IPINTERFACE_ROW,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn GetIpNetworkConnectionBandwidthEstimates(
    InterfaceIndex: u32,
    AddressFamily: u16,
    BandwidthEstimates: ?*MIB_IP_NETWORK_CONNECTION_BANDWIDTH_ESTIMATES,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn CreateUnicastIpAddressEntry(
    Row: ?*MIB_UNICASTIPADDRESS_ROW,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn DeleteUnicastIpAddressEntry(
    Row: ?*MIB_UNICASTIPADDRESS_ROW,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn GetUnicastIpAddressEntry(
    Row: ?*MIB_UNICASTIPADDRESS_ROW,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn GetUnicastIpAddressTable(
    Family: u16,
    Table: ?*?*MIB_UNICASTIPADDRESS_TABLE,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn InitializeUnicastIpAddressEntry(
    Row: ?*MIB_UNICASTIPADDRESS_ROW,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn NotifyUnicastIpAddressChange(
    Family: u16,
    Callback: PUNICAST_IPADDRESS_CHANGE_CALLBACK,
    CallerContext: ?*opaque{},
    InitialNotification: u8,
    NotificationHandle: ?*HANDLE,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn NotifyStableUnicastIpAddressTable(
    Family: u16,
    Table: ?*?*MIB_UNICASTIPADDRESS_TABLE,
    CallerCallback: PSTABLE_UNICAST_IPADDRESS_TABLE_CALLBACK,
    CallerContext: ?*opaque{},
    NotificationHandle: ?*HANDLE,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn SetUnicastIpAddressEntry(
    Row: ?*MIB_UNICASTIPADDRESS_ROW,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn CreateAnycastIpAddressEntry(
    Row: ?*MIB_ANYCASTIPADDRESS_ROW,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn DeleteAnycastIpAddressEntry(
    Row: ?*MIB_ANYCASTIPADDRESS_ROW,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn GetAnycastIpAddressEntry(
    Row: ?*MIB_ANYCASTIPADDRESS_ROW,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn GetAnycastIpAddressTable(
    Family: u16,
    Table: ?*?*MIB_ANYCASTIPADDRESS_TABLE,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn GetMulticastIpAddressEntry(
    Row: ?*MIB_MULTICASTIPADDRESS_ROW,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn GetMulticastIpAddressTable(
    Family: u16,
    Table: ?*?*MIB_MULTICASTIPADDRESS_TABLE,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn CreateIpForwardEntry2(
    Row: ?*MIB_IPFORWARD_ROW2,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn DeleteIpForwardEntry2(
    Row: ?*MIB_IPFORWARD_ROW2,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn GetBestRoute2(
    InterfaceLuid: ?*NET_LUID_LH,
    InterfaceIndex: u32,
    SourceAddress: ?*SOCKADDR_INET,
    DestinationAddress: ?*SOCKADDR_INET,
    AddressSortOptions: u32,
    BestRoute: ?*MIB_IPFORWARD_ROW2,
    BestSourceAddress: ?*SOCKADDR_INET,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn GetIpForwardEntry2(
    Row: ?*MIB_IPFORWARD_ROW2,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn GetIpForwardTable2(
    Family: u16,
    Table: ?*?*MIB_IPFORWARD_TABLE2,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn InitializeIpForwardEntry(
    Row: ?*MIB_IPFORWARD_ROW2,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn NotifyRouteChange2(
    AddressFamily: u16,
    Callback: PIPFORWARD_CHANGE_CALLBACK,
    CallerContext: ?*opaque{},
    InitialNotification: u8,
    NotificationHandle: ?*HANDLE,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn SetIpForwardEntry2(
    Route: ?*MIB_IPFORWARD_ROW2,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn FlushIpPathTable(
    Family: u16,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn GetIpPathEntry(
    Row: ?*MIB_IPPATH_ROW,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn GetIpPathTable(
    Family: u16,
    Table: ?*?*MIB_IPPATH_TABLE,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn CreateIpNetEntry2(
    Row: ?*MIB_IPNET_ROW2,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn DeleteIpNetEntry2(
    Row: ?*MIB_IPNET_ROW2,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn FlushIpNetTable2(
    Family: u16,
    InterfaceIndex: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn GetIpNetEntry2(
    Row: ?*MIB_IPNET_ROW2,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn GetIpNetTable2(
    Family: u16,
    Table: ?*?*MIB_IPNET_TABLE2,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn ResolveIpNetEntry2(
    Row: ?*MIB_IPNET_ROW2,
    SourceAddress: ?*SOCKADDR_INET,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn SetIpNetEntry2(
    Row: ?*MIB_IPNET_ROW2,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn NotifyTeredoPortChange(
    Callback: PTEREDO_PORT_CHANGE_CALLBACK,
    CallerContext: ?*opaque{},
    InitialNotification: u8,
    NotificationHandle: ?*HANDLE,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn GetTeredoPort(
    Port: ?*u16,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn CancelMibChangeNotify2(
    NotificationHandle: HANDLE,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn FreeMibTable(
    Memory: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn CreateSortedAddressPairs(
    SourceAddressList: ?*SOCKADDR_IN6_LH,
    SourceAddressCount: u32,
    DestinationAddressList: ?*SOCKADDR_IN6_LH,
    DestinationAddressCount: u32,
    AddressSortOptions: u32,
    SortedAddressPairList: ?*?*SOCKADDR_IN6_PAIR,
    SortedAddressPairCount: ?*u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn ConvertCompartmentGuidToId(
    CompartmentGuid: ?*Guid,
    CompartmentId: ?*u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn ConvertCompartmentIdToGuid(
    CompartmentId: u32,
    CompartmentGuid: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn ConvertInterfaceNameToLuidA(
    InterfaceName: ?*i8,
    InterfaceLuid: ?*NET_LUID_LH,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn ConvertInterfaceNameToLuidW(
    InterfaceName: ?*u16,
    InterfaceLuid: ?*NET_LUID_LH,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn ConvertInterfaceLuidToNameA(
    InterfaceLuid: ?*NET_LUID_LH,
    InterfaceName: ?*i8,
    Length: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn ConvertInterfaceLuidToNameW(
    InterfaceLuid: ?*NET_LUID_LH,
    InterfaceName: ?*u16,
    Length: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn ConvertInterfaceLuidToIndex(
    InterfaceLuid: ?*NET_LUID_LH,
    InterfaceIndex: ?*u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn ConvertInterfaceIndexToLuid(
    InterfaceIndex: u32,
    InterfaceLuid: ?*NET_LUID_LH,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn ConvertInterfaceLuidToAlias(
    InterfaceLuid: ?*NET_LUID_LH,
    InterfaceAlias: ?*u16,
    Length: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn ConvertInterfaceAliasToLuid(
    InterfaceAlias: ?*u16,
    InterfaceLuid: ?*NET_LUID_LH,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn ConvertInterfaceLuidToGuid(
    InterfaceLuid: ?*NET_LUID_LH,
    InterfaceGuid: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn ConvertInterfaceGuidToLuid(
    InterfaceGuid: ?*Guid,
    InterfaceLuid: ?*NET_LUID_LH,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn if_nametoindex(
    InterfaceName: ?*i8,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn if_indextoname(
    InterfaceIndex: u32,
    InterfaceName: ?*i8,
) callconv(@import("std").os.windows.WINAPI) ?*i8;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn GetCurrentThreadCompartmentScope(
    CompartmentScope: ?*u32,
    CompartmentId: ?*u32,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn SetCurrentThreadCompartmentScope(
    CompartmentScope: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn GetJobCompartmentId(
    JobHandle: HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn SetJobCompartmentId(
    JobHandle: HANDLE,
    CompartmentId: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn GetDefaultCompartmentId(
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn ConvertLengthToIpv4Mask(
    MaskLength: u32,
    Mask: ?*u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn ConvertIpv4MaskToLength(
    Mask: u32,
    MaskLength: ?*u8,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn GetDnsSettings(
    Settings: ?*DNS_SETTINGS,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn FreeDnsSettings(
    Settings: ?*DNS_SETTINGS,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn SetDnsSettings(
    Settings: ?*DNS_SETTINGS,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn GetInterfaceDnsSettings(
    Interface: Guid,
    Settings: ?*DNS_INTERFACE_SETTINGS,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn FreeInterfaceDnsSettings(
    Settings: ?*DNS_INTERFACE_SETTINGS,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn SetInterfaceDnsSettings(
    Interface: Guid,
    Settings: ?*DNS_INTERFACE_SETTINGS,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn GetNetworkConnectivityHint(
    ConnectivityHint: ?*NL_NETWORK_CONNECTIVITY_HINT,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn GetNetworkConnectivityHintForInterface(
    InterfaceIndex: u32,
    ConnectivityHint: ?*NL_NETWORK_CONNECTIVITY_HINT,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn NotifyNetworkConnectivityHintChange(
    Callback: PNETWORK_CONNECTIVITY_HINT_CHANGE_CALLBACK,
    CallerContext: ?*opaque{},
    InitialNotification: u8,
    NotificationHandle: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// set_last_errror=True (can and should we use this?)
pub extern "IPHLPAPI" fn IcmpCreateFile(
) callconv(@import("std").os.windows.WINAPI) IcmpHandle;

// set_last_errror=True (can and should we use this?)
pub extern "IPHLPAPI" fn Icmp6CreateFile(
) callconv(@import("std").os.windows.WINAPI) IcmpHandle;

// set_last_errror=True (can and should we use this?)
pub extern "IPHLPAPI" fn IcmpCloseHandle(
    IcmpHandle: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "IPHLPAPI" fn IcmpSendEcho(
    IcmpHandle: HANDLE,
    DestinationAddress: u32,
    RequestData: ?*opaque{},
    RequestSize: u16,
    RequestOptions: ?*ip_option_information,
    ReplyBuffer: ?*opaque{},
    ReplySize: u32,
    Timeout: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "IPHLPAPI" fn IcmpSendEcho2(
    IcmpHandle: HANDLE,
    Event: HANDLE,
    ApcRoutine: FARPROC,
    ApcContext: ?*opaque{},
    DestinationAddress: u32,
    RequestData: ?*opaque{},
    RequestSize: u16,
    RequestOptions: ?*ip_option_information,
    ReplyBuffer: ?*opaque{},
    ReplySize: u32,
    Timeout: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "IPHLPAPI" fn IcmpSendEcho2Ex(
    IcmpHandle: HANDLE,
    Event: HANDLE,
    ApcRoutine: FARPROC,
    ApcContext: ?*opaque{},
    SourceAddress: u32,
    DestinationAddress: u32,
    RequestData: ?*opaque{},
    RequestSize: u16,
    RequestOptions: ?*ip_option_information,
    ReplyBuffer: ?*opaque{},
    ReplySize: u32,
    Timeout: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "IPHLPAPI" fn Icmp6SendEcho2(
    IcmpHandle: HANDLE,
    Event: HANDLE,
    ApcRoutine: FARPROC,
    ApcContext: ?*opaque{},
    SourceAddress: ?*SOCKADDR_IN6_LH,
    DestinationAddress: ?*SOCKADDR_IN6_LH,
    RequestData: ?*opaque{},
    RequestSize: u16,
    RequestOptions: ?*ip_option_information,
    ReplyBuffer: ?*opaque{},
    ReplySize: u32,
    Timeout: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "IPHLPAPI" fn IcmpParseReplies(
    ReplyBuffer: ?*opaque{},
    ReplySize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "IPHLPAPI" fn Icmp6ParseReplies(
    ReplyBuffer: ?*opaque{},
    ReplySize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn GetNumberOfInterfaces(
    pdwNumIf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn GetIfEntry(
    pIfRow: ?*MIB_IFROW,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn GetIfTable(
    pIfTable: ?*MIB_IFTABLE,
    pdwSize: ?*u32,
    bOrder: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn GetIpAddrTable(
    pIpAddrTable: ?*MIB_IPADDRTABLE,
    pdwSize: ?*u32,
    bOrder: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn GetIpNetTable(
    IpNetTable: ?*MIB_IPNETTABLE,
    SizePointer: ?*u32,
    Order: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn GetIpForwardTable(
    pIpForwardTable: ?*MIB_IPFORWARDTABLE,
    pdwSize: ?*u32,
    bOrder: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn GetTcpTable(
    TcpTable: ?*MIB_TCPTABLE,
    SizePointer: ?*u32,
    Order: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn GetExtendedTcpTable(
    pTcpTable: ?*opaque{},
    pdwSize: ?*u32,
    bOrder: BOOL,
    ulAf: u32,
    TableClass: TCP_TABLE_CLASS,
    Reserved: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn GetOwnerModuleFromTcpEntry(
    pTcpEntry: ?*MIB_TCPROW_OWNER_MODULE,
    Class: TCPIP_OWNER_MODULE_INFO_CLASS,
    pBuffer: ?*opaque{},
    pdwSize: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn GetUdpTable(
    UdpTable: ?*MIB_UDPTABLE,
    SizePointer: ?*u32,
    Order: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn GetExtendedUdpTable(
    pUdpTable: ?*opaque{},
    pdwSize: ?*u32,
    bOrder: BOOL,
    ulAf: u32,
    TableClass: UDP_TABLE_CLASS,
    Reserved: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn GetOwnerModuleFromUdpEntry(
    pUdpEntry: ?*MIB_UDPROW_OWNER_MODULE,
    Class: TCPIP_OWNER_MODULE_INFO_CLASS,
    pBuffer: ?*opaque{},
    pdwSize: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn GetTcpTable2(
    TcpTable: ?*MIB_TCPTABLE2,
    SizePointer: ?*u32,
    Order: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn GetTcp6Table(
    TcpTable: ?*MIB_TCP6TABLE,
    SizePointer: ?*u32,
    Order: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn GetTcp6Table2(
    TcpTable: ?*MIB_TCP6TABLE2,
    SizePointer: ?*u32,
    Order: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn GetPerTcpConnectionEStats(
    Row: ?*MIB_TCPROW_LH,
    EstatsType: TCP_ESTATS_TYPE,
    Rw: ?*u8,
    RwVersion: u32,
    RwSize: u32,
    Ros: ?*u8,
    RosVersion: u32,
    RosSize: u32,
    Rod: ?*u8,
    RodVersion: u32,
    RodSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn SetPerTcpConnectionEStats(
    Row: ?*MIB_TCPROW_LH,
    EstatsType: TCP_ESTATS_TYPE,
    Rw: ?*u8,
    RwVersion: u32,
    RwSize: u32,
    Offset: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn GetPerTcp6ConnectionEStats(
    Row: ?*MIB_TCP6ROW,
    EstatsType: TCP_ESTATS_TYPE,
    Rw: ?*u8,
    RwVersion: u32,
    RwSize: u32,
    Ros: ?*u8,
    RosVersion: u32,
    RosSize: u32,
    Rod: ?*u8,
    RodVersion: u32,
    RodSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn SetPerTcp6ConnectionEStats(
    Row: ?*MIB_TCP6ROW,
    EstatsType: TCP_ESTATS_TYPE,
    Rw: ?*u8,
    RwVersion: u32,
    RwSize: u32,
    Offset: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn GetOwnerModuleFromTcp6Entry(
    pTcpEntry: ?*MIB_TCP6ROW_OWNER_MODULE,
    Class: TCPIP_OWNER_MODULE_INFO_CLASS,
    pBuffer: ?*opaque{},
    pdwSize: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn GetUdp6Table(
    Udp6Table: ?*MIB_UDP6TABLE,
    SizePointer: ?*u32,
    Order: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn GetOwnerModuleFromUdp6Entry(
    pUdpEntry: ?*MIB_UDP6ROW_OWNER_MODULE,
    Class: TCPIP_OWNER_MODULE_INFO_CLASS,
    pBuffer: ?*opaque{},
    pdwSize: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn GetOwnerModuleFromPidAndInfo(
    ulPid: u32,
    pInfo: ?*u64,
    Class: TCPIP_OWNER_MODULE_INFO_CLASS,
    pBuffer: ?*opaque{},
    pdwSize: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn GetIpStatistics(
    Statistics: ?*MIB_IPSTATS_LH,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn GetIcmpStatistics(
    Statistics: ?*MIB_ICMP,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn GetTcpStatistics(
    Statistics: ?*MIB_TCPSTATS_LH,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn GetUdpStatistics(
    Stats: ?*MIB_UDPSTATS,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn SetIpStatisticsEx(
    Statistics: ?*MIB_IPSTATS_LH,
    Family: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn GetIpStatisticsEx(
    Statistics: ?*MIB_IPSTATS_LH,
    Family: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn GetIcmpStatisticsEx(
    Statistics: ?*MIB_ICMP_EX_XPSP1,
    Family: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn GetTcpStatisticsEx(
    Statistics: ?*MIB_TCPSTATS_LH,
    Family: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn GetUdpStatisticsEx(
    Statistics: ?*MIB_UDPSTATS,
    Family: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn GetTcpStatisticsEx2(
    Statistics: ?*MIB_TCPSTATS2,
    Family: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn GetUdpStatisticsEx2(
    Statistics: ?*MIB_UDPSTATS2,
    Family: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn SetIfEntry(
    pIfRow: ?*MIB_IFROW,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn CreateIpForwardEntry(
    pRoute: ?*MIB_IPFORWARDROW,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn SetIpForwardEntry(
    pRoute: ?*MIB_IPFORWARDROW,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn DeleteIpForwardEntry(
    pRoute: ?*MIB_IPFORWARDROW,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn SetIpStatistics(
    pIpStats: ?*MIB_IPSTATS_LH,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn SetIpTTL(
    nTTL: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn CreateIpNetEntry(
    pArpEntry: ?*MIB_IPNETROW_LH,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn SetIpNetEntry(
    pArpEntry: ?*MIB_IPNETROW_LH,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn DeleteIpNetEntry(
    pArpEntry: ?*MIB_IPNETROW_LH,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn FlushIpNetTable(
    dwIfIndex: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn CreateProxyArpEntry(
    dwAddress: u32,
    dwMask: u32,
    dwIfIndex: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn DeleteProxyArpEntry(
    dwAddress: u32,
    dwMask: u32,
    dwIfIndex: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn SetTcpEntry(
    pTcpRow: ?*MIB_TCPROW_LH,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn GetInterfaceInfo(
    pIfTable: ?*IP_INTERFACE_INFO,
    dwOutBufLen: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn GetUniDirectionalAdapterInfo(
    pIPIfInfo: ?*IP_UNIDIRECTIONAL_ADAPTER_ADDRESS,
    dwOutBufLen: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn NhpAllocateAndGetInterfaceInfoFromStack(
    ppTable: ?*?*ip_interface_name_info_w2ksp1,
    pdwCount: ?*u32,
    bOrder: BOOL,
    hHeap: HANDLE,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn GetBestInterface(
    dwDestAddr: u32,
    pdwBestIfIndex: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn GetBestInterfaceEx(
    pDestAddr: ?*SOCKADDR,
    pdwBestIfIndex: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn GetBestRoute(
    dwDestAddr: u32,
    dwSourceAddr: u32,
    pBestRoute: ?*MIB_IPFORWARDROW,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn NotifyAddrChange(
    Handle: ?*?*opaque{},
    overlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn NotifyRouteChange(
    Handle: ?*?*opaque{},
    overlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn CancelIPChangeNotify(
    notifyOverlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn GetAdapterIndex(
    AdapterName: ?*u16,
    IfIndex: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn AddIPAddress(
    Address: u32,
    IpMask: u32,
    IfIndex: u32,
    NTEContext: ?*u32,
    NTEInstance: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn DeleteIPAddress(
    NTEContext: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn GetNetworkParams(
    pFixedInfo: ?*FIXED_INFO_W2KSP1,
    pOutBufLen: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn GetAdaptersInfo(
    AdapterInfo: ?*IP_ADAPTER_INFO,
    SizePointer: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn GetAdapterOrderMap(
) callconv(@import("std").os.windows.WINAPI) ?*IP_ADAPTER_ORDER_MAP;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn GetAdaptersAddresses(
    Family: u32,
    Flags: u32,
    Reserved: ?*opaque{},
    AdapterAddresses: ?*IP_ADAPTER_ADDRESSES_LH,
    SizePointer: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn GetPerAdapterInfo(
    IfIndex: u32,
    pPerAdapterInfo: ?*IP_PER_ADAPTER_INFO_W2KSP1,
    pOutBufLen: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn GetInterfaceCurrentTimestampCapabilities(
    InterfaceLuid: ?*NET_LUID_LH,
    TimestampCapabilites: ?*INTERFACE_TIMESTAMP_CAPABILITIES,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn GetInterfaceHardwareTimestampCapabilities(
    InterfaceLuid: ?*NET_LUID_LH,
    TimestampCapabilites: ?*INTERFACE_TIMESTAMP_CAPABILITIES,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn CaptureInterfaceHardwareCrossTimestamp(
    InterfaceLuid: ?*NET_LUID_LH,
    CrossTimestamp: ?*INTERFACE_HARDWARE_CROSSTIMESTAMP,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn NotifyIfTimestampConfigChange(
    CallerContext: ?*opaque{},
    Callback: PINTERFACE_TIMESTAMP_CONFIG_CHANGE_CALLBACK,
    NotificationHandle: ?*?*HIFTIMESTAMPCHANGE__,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn CancelIfTimestampConfigChange(
    NotificationHandle: ?*HIFTIMESTAMPCHANGE__,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn IpReleaseAddress(
    AdapterInfo: ?*IP_ADAPTER_INDEX_MAP,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn IpRenewAddress(
    AdapterInfo: ?*IP_ADAPTER_INDEX_MAP,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn SendARP(
    DestIP: u32,
    SrcIP: u32,
    pMacAddr: ?*opaque{},
    PhyAddrLen: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "IPHLPAPI" fn GetRTTAndHopCount(
    DestIpAddress: u32,
    HopCount: ?*u32,
    MaxHops: u32,
    RTT: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn GetFriendlyIfIndex(
    IfIndex: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn EnableRouter(
    pHandle: ?*HANDLE,
    pOverlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn UnenableRouter(
    pOverlapped: ?*OVERLAPPED,
    lpdwEnableCount: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn DisableMediaSense(
    pHandle: ?*HANDLE,
    pOverLapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn RestoreMediaSense(
    pOverlapped: ?*OVERLAPPED,
    lpdwEnableCount: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn GetIpErrorString(
    ErrorCode: u32,
    Buffer: ?*u16,
    Size: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn ResolveNeighbor(
    NetworkAddress: ?*SOCKADDR,
    PhysicalAddress: ?*opaque{},
    PhysicalAddressLength: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn CreatePersistentTcpPortReservation(
    StartPort: u16,
    NumberOfPorts: u16,
    Token: ?*u64,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn CreatePersistentUdpPortReservation(
    StartPort: u16,
    NumberOfPorts: u16,
    Token: ?*u64,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn DeletePersistentTcpPortReservation(
    StartPort: u16,
    NumberOfPorts: u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn DeletePersistentUdpPortReservation(
    StartPort: u16,
    NumberOfPorts: u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn LookupPersistentTcpPortReservation(
    StartPort: u16,
    NumberOfPorts: u16,
    Token: ?*u64,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "IPHLPAPI" fn LookupPersistentUdpPortReservation(
    StartPort: u16,
    NumberOfPorts: u16,
    Token: ?*u64,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "ntdll" fn RtlIpv4AddressToStringA(
    Addr: ?*in_addr,
    S: ?*i8,
) callconv(@import("std").os.windows.WINAPI) ?*i8;

// set_last_errror=False (can and should we use this?)
pub extern "ntdll" fn RtlIpv4AddressToStringW(
    Addr: ?*in_addr,
    S: ?*u16,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

// set_last_errror=False (can and should we use this?)
pub extern "ntdll" fn RtlIpv4AddressToStringExW(
    Address: ?*in_addr,
    Port: u16,
    AddressString: ?*u16,
    AddressStringLength: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ntdll" fn RtlIpv4StringToAddressA(
    S: ?*i8,
    Strict: u8,
    Terminator: ?*?*i8,
    Addr: ?*in_addr,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ntdll" fn RtlIpv4StringToAddressW(
    S: ?*u16,
    Strict: u8,
    Terminator: ?*?*u16,
    Addr: ?*in_addr,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ntdll" fn RtlIpv4StringToAddressExW(
    AddressString: ?*u16,
    Strict: u8,
    Address: ?*in_addr,
    Port: ?*u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ntdll" fn RtlIpv6AddressToStringA(
    Addr: ?*in6_addr,
    S: ?*i8,
) callconv(@import("std").os.windows.WINAPI) ?*i8;

// set_last_errror=False (can and should we use this?)
pub extern "ntdll" fn RtlIpv6AddressToStringW(
    Addr: ?*in6_addr,
    S: ?*u16,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

// set_last_errror=False (can and should we use this?)
pub extern "ntdll" fn RtlIpv6AddressToStringExW(
    Address: ?*in6_addr,
    ScopeId: u32,
    Port: u16,
    AddressString: ?*u16,
    AddressStringLength: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ntdll" fn RtlIpv6StringToAddressA(
    S: ?*i8,
    Terminator: ?*?*i8,
    Addr: ?*in6_addr,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ntdll" fn RtlIpv6StringToAddressW(
    S: ?*u16,
    Terminator: ?*?*u16,
    Addr: ?*in6_addr,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ntdll" fn RtlIpv6StringToAddressExW(
    AddressString: ?*u16,
    Address: ?*in6_addr,
    ScopeId: ?*u32,
    Port: ?*u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ntdll" fn RtlEthernetAddressToStringA(
    Addr: ?*DL_EUI48,
    S: ?*i8,
) callconv(@import("std").os.windows.WINAPI) ?*i8;

// set_last_errror=False (can and should we use this?)
pub extern "ntdll" fn RtlEthernetAddressToStringW(
    Addr: ?*DL_EUI48,
    S: ?*u16,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

// set_last_errror=False (can and should we use this?)
pub extern "ntdll" fn RtlEthernetStringToAddressA(
    S: ?*i8,
    Terminator: ?*?*i8,
    Addr: ?*DL_EUI48,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "ntdll" fn RtlEthernetStringToAddressW(
    S: ?*u16,
    Terminator: ?*?*u16,
    Addr: ?*DL_EUI48,
) callconv(@import("std").os.windows.WINAPI) i32;

//
// Unicode Symbol Aliases
//
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {
        pub const ConvertInterfaceNameToLuid = ConvertInterfaceNameToLuidA;
        pub const ConvertInterfaceLuidToName = ConvertInterfaceLuidToNameA;
        pub const RtlIpv4AddressToString = RtlIpv4AddressToStringA;
        pub const RtlIpv4StringToAddress = RtlIpv4StringToAddressA;
        pub const RtlIpv6AddressToString = RtlIpv6AddressToStringA;
        pub const RtlIpv6StringToAddress = RtlIpv6StringToAddressA;
        pub const RtlEthernetAddressToString = RtlEthernetAddressToStringA;
        pub const RtlEthernetStringToAddress = RtlEthernetStringToAddressA;
    },
    .wide => struct {
        pub const ConvertInterfaceNameToLuid = ConvertInterfaceNameToLuidW;
        pub const ConvertInterfaceLuidToName = ConvertInterfaceLuidToNameW;
        pub const RtlIpv4AddressToString = RtlIpv4AddressToStringW;
        pub const RtlIpv4StringToAddress = RtlIpv4StringToAddressW;
        pub const RtlIpv6AddressToString = RtlIpv6AddressToStringW;
        pub const RtlIpv6StringToAddress = RtlIpv6StringToAddressW;
        pub const RtlEthernetAddressToString = RtlEthernetAddressToStringW;
        pub const RtlEthernetStringToAddress = RtlEthernetStringToAddressW;
    },
    else => if (@import("builtin").is_test) struct {
        pub const ConvertInterfaceNameToLuid = *opaque{};
        pub const ConvertInterfaceLuidToName = *opaque{};
        pub const RtlIpv4AddressToString = *opaque{};
        pub const RtlIpv4StringToAddress = *opaque{};
        pub const RtlIpv6AddressToString = *opaque{};
        pub const RtlIpv6StringToAddress = *opaque{};
        pub const RtlEthernetAddressToString = *opaque{};
        pub const RtlEthernetStringToAddress = *opaque{};
    } else struct {
        pub const ConvertInterfaceNameToLuid = @compileError("'ConvertInterfaceNameToLuid' requires that UNICODE be set to true or false in the root module");
        pub const ConvertInterfaceLuidToName = @compileError("'ConvertInterfaceLuidToName' requires that UNICODE be set to true or false in the root module");
        pub const RtlIpv4AddressToString = @compileError("'RtlIpv4AddressToString' requires that UNICODE be set to true or false in the root module");
        pub const RtlIpv4StringToAddress = @compileError("'RtlIpv4StringToAddress' requires that UNICODE be set to true or false in the root module");
        pub const RtlIpv6AddressToString = @compileError("'RtlIpv6AddressToString' requires that UNICODE be set to true or false in the root module");
        pub const RtlIpv6StringToAddress = @compileError("'RtlIpv6StringToAddress' requires that UNICODE be set to true or false in the root module");
        pub const RtlEthernetAddressToString = @compileError("'RtlEthernetAddressToString' requires that UNICODE be set to true or false in the root module");
        pub const RtlEthernetStringToAddress = @compileError("'RtlEthernetStringToAddress' requires that UNICODE be set to true or false in the root module");
    },
};

//
// type imports
//
const Guid = @import("../zig.zig").Guid;
const MIB_IPFORWARDROW = @import("mib.zig").MIB_IPFORWARDROW;
const BOOL = @import("systemservices.zig").BOOL;
const SOCKET_ADDRESS = @import("winsock.zig").SOCKET_ADDRESS;
const NET_IF_CONNECTION_TYPE = @import("networkdrivers.zig").NET_IF_CONNECTION_TYPE;
const TUNNEL_TYPE = @import("networkdrivers.zig").TUNNEL_TYPE;
const SOCKADDR_IN6_LH = @import("networkdrivers.zig").SOCKADDR_IN6_LH;
const MIB_IF_ROW2 = @import("mib.zig").MIB_IF_ROW2;
const NTSTATUS = @import("systemservices.zig").NTSTATUS;
const MIB_IF_TABLE2 = @import("mib.zig").MIB_IF_TABLE2;
const MIB_IF_TABLE_LEVEL = @import("networkdrivers.zig").MIB_IF_TABLE_LEVEL;
const MIB_IFSTACK_TABLE = @import("mib.zig").MIB_IFSTACK_TABLE;
const MIB_INVERTEDIFSTACK_TABLE = @import("mib.zig").MIB_INVERTEDIFSTACK_TABLE;
const MIB_IPINTERFACE_ROW = @import("mib.zig").MIB_IPINTERFACE_ROW;
const MIB_IPINTERFACE_TABLE = @import("mib.zig").MIB_IPINTERFACE_TABLE;
const HANDLE = @import("systemservices.zig").HANDLE;
const MIB_IP_NETWORK_CONNECTION_BANDWIDTH_ESTIMATES = @import("mib.zig").MIB_IP_NETWORK_CONNECTION_BANDWIDTH_ESTIMATES;
const MIB_UNICASTIPADDRESS_ROW = @import("mib.zig").MIB_UNICASTIPADDRESS_ROW;
const MIB_UNICASTIPADDRESS_TABLE = @import("mib.zig").MIB_UNICASTIPADDRESS_TABLE;
const MIB_ANYCASTIPADDRESS_ROW = @import("mib.zig").MIB_ANYCASTIPADDRESS_ROW;
const MIB_ANYCASTIPADDRESS_TABLE = @import("mib.zig").MIB_ANYCASTIPADDRESS_TABLE;
const MIB_MULTICASTIPADDRESS_ROW = @import("mib.zig").MIB_MULTICASTIPADDRESS_ROW;
const MIB_MULTICASTIPADDRESS_TABLE = @import("mib.zig").MIB_MULTICASTIPADDRESS_TABLE;
const MIB_IPFORWARD_ROW2 = @import("mib.zig").MIB_IPFORWARD_ROW2;
const MIB_IPFORWARD_TABLE2 = @import("mib.zig").MIB_IPFORWARD_TABLE2;
const MIB_IPPATH_ROW = @import("mib.zig").MIB_IPPATH_ROW;
const MIB_IPPATH_TABLE = @import("mib.zig").MIB_IPPATH_TABLE;
const MIB_IPNET_ROW2 = @import("mib.zig").MIB_IPNET_ROW2;
const MIB_IPNET_TABLE2 = @import("mib.zig").MIB_IPNET_TABLE2;
const FARPROC = @import("systemservices.zig").FARPROC;
const MIB_IFROW = @import("mib.zig").MIB_IFROW;
const MIB_IFTABLE = @import("mib.zig").MIB_IFTABLE;
const MIB_IPADDRTABLE = @import("mib.zig").MIB_IPADDRTABLE;
const MIB_IPNETTABLE = @import("mib.zig").MIB_IPNETTABLE;
const MIB_IPFORWARDTABLE = @import("mib.zig").MIB_IPFORWARDTABLE;
const MIB_TCPTABLE = @import("mib.zig").MIB_TCPTABLE;
const MIB_TCPROW_OWNER_MODULE = @import("mib.zig").MIB_TCPROW_OWNER_MODULE;
const MIB_UDPTABLE = @import("mib.zig").MIB_UDPTABLE;
const MIB_UDPROW_OWNER_MODULE = @import("mib.zig").MIB_UDPROW_OWNER_MODULE;
const MIB_TCPTABLE2 = @import("mib.zig").MIB_TCPTABLE2;
const MIB_TCP6TABLE = @import("mib.zig").MIB_TCP6TABLE;
const MIB_TCP6TABLE2 = @import("mib.zig").MIB_TCP6TABLE2;
const MIB_TCPROW_LH = @import("mib.zig").MIB_TCPROW_LH;
const MIB_TCP6ROW = @import("mib.zig").MIB_TCP6ROW;
const MIB_TCP6ROW_OWNER_MODULE = @import("mib.zig").MIB_TCP6ROW_OWNER_MODULE;
const MIB_UDP6TABLE = @import("mib.zig").MIB_UDP6TABLE;
const MIB_UDP6ROW_OWNER_MODULE = @import("mib.zig").MIB_UDP6ROW_OWNER_MODULE;
const MIB_IPSTATS_LH = @import("mib.zig").MIB_IPSTATS_LH;
const MIB_ICMP = @import("mib.zig").MIB_ICMP;
const MIB_TCPSTATS_LH = @import("mib.zig").MIB_TCPSTATS_LH;
const MIB_UDPSTATS = @import("mib.zig").MIB_UDPSTATS;
const MIB_ICMP_EX_XPSP1 = @import("mib.zig").MIB_ICMP_EX_XPSP1;
const MIB_TCPSTATS2 = @import("mib.zig").MIB_TCPSTATS2;
const MIB_UDPSTATS2 = @import("mib.zig").MIB_UDPSTATS2;
const MIB_IPNETROW_LH = @import("mib.zig").MIB_IPNETROW_LH;
const SOCKADDR = @import("winsock.zig").SOCKADDR;
const OVERLAPPED = @import("systemservices.zig").OVERLAPPED;
const in_addr = @import("winsock.zig").in_addr;
const in6_addr = @import("winsock.zig").in6_addr;
const DL_EUI48 = @import("windowsfiltering.zig").DL_EUI48;

test "" {
    const constant_export_count = 0;
    const type_export_count = 100;
    const func_count = 190;
    const unicode_alias_count = 8;
    const type_import_count = 60;
    @setEvalBranchQuota(0
        + constant_export_count
        + type_export_count
        + func_count
        + unicode_alias_count
        + type_import_count
        + 2 // TODO: why do I need these extra 2?
    );
    @import("std").testing.refAllDecls(@This());
}
