//! NOTE: this source file is autogenerated, DO NOT MODIFY

//
// constants
//

//
// types
//
// --------------------------------------------------------
// Type: POINTER_BUTTON_CHANGE_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const POINTER_BUTTON_CHANGE_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: POINTER_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const POINTER_INFO = extern struct {
    pointerType: u32,
    pointerId: u32,
    frameId: u32,
    pointerFlags: u32,
    sourceDevice: HANDLE,
    hwndTarget: HWND,
    ptPixelLocation: POINT,
    ptHimetricLocation: POINT,
    ptPixelLocationRaw: POINT,
    ptHimetricLocationRaw: POINT,
    dwTime: u32,
    historyCount: u32,
    InputData: i32,
    dwKeyStates: u32,
    PerformanceCount: u64,
    ButtonChangeType: POINTER_BUTTON_CHANGE_TYPE,
};
// --------------------------------------------------------
// Type: POINTER_TOUCH_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const POINTER_TOUCH_INFO = extern struct {
    pointerInfo: POINTER_INFO,
    touchFlags: u32,
    touchMask: u32,
    rcContact: RECT,
    rcContactRaw: RECT,
    orientation: u32,
    pressure: u32,
};
// --------------------------------------------------------
// Type: POINTER_PEN_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const POINTER_PEN_INFO = extern struct {
    pointerInfo: POINTER_INFO,
    penFlags: u32,
    penMask: u32,
    pressure: u32,
    rotation: u32,
    tiltX: i32,
    tiltY: i32,
};
// --------------------------------------------------------
// Type: INPUT_TRANSFORM
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const INPUT_TRANSFORM = extern struct {
    Anonymous: _Anonymous_e__Union,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
        // --------------------------------------------------------
        // Type: _Anonymous_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _Anonymous_e__Struct = extern struct {
            _11: f32,
            _12: f32,
            _13: f32,
            _14: f32,
            _21: f32,
            _22: f32,
            _23: f32,
            _24: f32,
            _31: f32,
            _32: f32,
            _33: f32,
            _34: f32,
            _41: f32,
            _42: f32,
            _43: f32,
            _44: f32,
        };
    };
};

//
// functions
//

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn GetUnpredictedMessagePos(
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn GetPointerType(
    pointerId: u32,
    pointerType: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn GetPointerCursorId(
    pointerId: u32,
    cursorId: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn GetPointerInfo(
    pointerId: u32,
    pointerInfo: ?*POINTER_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn GetPointerInfoHistory(
    pointerId: u32,
    entriesCount: ?*u32,
    pointerInfo: ?*POINTER_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn GetPointerFrameInfo(
    pointerId: u32,
    pointerCount: ?*u32,
    pointerInfo: ?*POINTER_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn GetPointerFrameInfoHistory(
    pointerId: u32,
    entriesCount: ?*u32,
    pointerCount: ?*u32,
    pointerInfo: ?*POINTER_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn GetPointerTouchInfo(
    pointerId: u32,
    touchInfo: ?*POINTER_TOUCH_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn GetPointerTouchInfoHistory(
    pointerId: u32,
    entriesCount: ?*u32,
    touchInfo: ?*POINTER_TOUCH_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn GetPointerFrameTouchInfo(
    pointerId: u32,
    pointerCount: ?*u32,
    touchInfo: ?*POINTER_TOUCH_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn GetPointerFrameTouchInfoHistory(
    pointerId: u32,
    entriesCount: ?*u32,
    pointerCount: ?*u32,
    touchInfo: ?*POINTER_TOUCH_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn GetPointerPenInfo(
    pointerId: u32,
    penInfo: ?*POINTER_PEN_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn GetPointerPenInfoHistory(
    pointerId: u32,
    entriesCount: ?*u32,
    penInfo: ?*POINTER_PEN_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn GetPointerFramePenInfo(
    pointerId: u32,
    pointerCount: ?*u32,
    penInfo: ?*POINTER_PEN_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn GetPointerFramePenInfoHistory(
    pointerId: u32,
    entriesCount: ?*u32,
    pointerCount: ?*u32,
    penInfo: ?*POINTER_PEN_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn SkipPointerFrameMessages(
    pointerId: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn EnableMouseInPointer(
    fEnable: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "USER32" fn IsMouseInPointerEnabled(
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=True (can and should we use this?)
pub extern "USER32" fn GetPointerInputTransform(
    pointerId: u32,
    historyCount: u32,
    inputTransform: ?*INPUT_TRANSFORM,
) callconv(@import("std").os.windows.WINAPI) BOOL;

//
// Unicode Symbol Aliases
//
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {
    },
    .wide => struct {
    },
    else => if (@import("builtin").is_test) struct {
    } else struct {
    },
};

//
// type imports
//
const HANDLE = @import("systemservices.zig").HANDLE;
const HWND = @import("windowsandmessaging.zig").HWND;
const POINT = @import("displaydevices.zig").POINT;
const RECT = @import("displaydevices.zig").RECT;
const BOOL = @import("systemservices.zig").BOOL;

test "" {
    const constant_export_count = 0;
    const type_export_count = 5;
    const func_count = 19;
    const unicode_alias_count = 0;
    const type_import_count = 5;
    @setEvalBranchQuota(0
        + constant_export_count
        + type_export_count
        + func_count
        + unicode_alias_count
        + type_import_count
        + 2 // TODO: why do I need these extra 2?
    );
    @import("std").testing.refAllDecls(@This());
}
