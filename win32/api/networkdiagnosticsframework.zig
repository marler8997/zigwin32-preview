//! NOTE: this source file is autogenerated, DO NOT MODIFY

//
// constants
//

//
// types
//
// --------------------------------------------------------
// Type: ATTRIBUTE_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const ATTRIBUTE_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: OCTET_STRING
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const OCTET_STRING = extern struct {
    dwLength: u32,
    lpValue: ?*u8,
};
// --------------------------------------------------------
// Type: LIFE_TIME
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const LIFE_TIME = extern struct {
    startTime: FILETIME,
    endTime: FILETIME,
};
// --------------------------------------------------------
// Type: DIAG_SOCKADDR
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DIAG_SOCKADDR = extern struct {
    family: u16,
    data: ?[*]i8,
};
// --------------------------------------------------------
// Type: HELPER_ATTRIBUTE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HELPER_ATTRIBUTE = extern struct {
    pwszName: ?*u16,
    type: ATTRIBUTE_TYPE,
    Anonymous: _Anonymous_e__Union,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: REPAIR_SCOPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const REPAIR_SCOPE = *opaque{
};
// --------------------------------------------------------
// Type: REPAIR_RISK
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const REPAIR_RISK = *opaque{
};
// --------------------------------------------------------
// Type: UI_INFO_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UI_INFO_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: ShellCommandInfo
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const ShellCommandInfo = extern struct {
    pwszOperation: ?*u16,
    pwszFile: ?*u16,
    pwszParameters: ?*u16,
    pwszDirectory: ?*u16,
    nShowCmd: u32,
};
// --------------------------------------------------------
// Type: UiInfo
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const UiInfo = extern struct {
    type: UI_INFO_TYPE,
    Anonymous: _Anonymous_e__Union,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: RepairInfo
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const RepairInfo = extern struct {
    guid: Guid,
    pwszClassName: ?*u16,
    pwszDescription: ?*u16,
    sidType: u32,
    cost: i32,
    flags: u32,
    scope: REPAIR_SCOPE,
    risk: REPAIR_RISK,
    UiInfo: UiInfo,
    rootCauseIndex: i32,
};
// --------------------------------------------------------
// Type: RepairInfoEx
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const RepairInfoEx = extern struct {
    repair: RepairInfo,
    repairRank: u16,
};
// --------------------------------------------------------
// Type: RootCauseInfo
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const RootCauseInfo = extern struct {
    pwszDescription: ?*u16,
    rootCauseID: Guid,
    rootCauseFlags: u32,
    networkInterfaceID: Guid,
    pRepairs: ?*RepairInfoEx,
    repairCount: u16,
};
// --------------------------------------------------------
// Type: DIAGNOSIS_STATUS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const DIAGNOSIS_STATUS = *opaque{
};
// --------------------------------------------------------
// Type: REPAIR_STATUS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const REPAIR_STATUS = *opaque{
};
// --------------------------------------------------------
// Type: PROBLEM_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PROBLEM_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: HYPOTHESIS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HYPOTHESIS = extern struct {
    pwszClassName: ?*u16,
    pwszDescription: ?*u16,
    celt: u32,
    rgAttributes: ?*HELPER_ATTRIBUTE,
};
// --------------------------------------------------------
// Type: HelperAttributeInfo
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HelperAttributeInfo = extern struct {
    pwszName: ?*u16,
    type: ATTRIBUTE_TYPE,
};
// --------------------------------------------------------
// Type: DiagnosticsInfo
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DiagnosticsInfo = extern struct {
    cost: i32,
    flags: u32,
};
// --------------------------------------------------------
// Type: INetDiagHelper
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const INetDiagHelper = *opaque{
    // TODO: Method 'Initialize'
    // TODO: Method 'GetDiagnosticsInfo'
    // TODO: Method 'GetKeyAttributes'
    // TODO: Method 'LowHealth'
    // TODO: Method 'HighUtilization'
    // TODO: Method 'GetLowerHypotheses'
    // TODO: Method 'GetDownStreamHypotheses'
    // TODO: Method 'GetHigherHypotheses'
    // TODO: Method 'GetUpStreamHypotheses'
    // TODO: Method 'Repair'
    // TODO: Method 'Validate'
    // TODO: Method 'GetRepairInfo'
    // TODO: Method 'GetLifeTime'
    // TODO: Method 'SetLifeTime'
    // TODO: Method 'GetCacheTime'
    // TODO: Method 'GetAttributes'
    // TODO: Method 'Cancel'
    // TODO: Method 'Cleanup'
};
// --------------------------------------------------------
// Type: HypothesisResult
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HypothesisResult = extern struct {
    hypothesis: HYPOTHESIS,
    pathStatus: DIAGNOSIS_STATUS,
};
// --------------------------------------------------------
// Type: INetDiagHelperUtilFactory
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const INetDiagHelperUtilFactory = *opaque{
    // TODO: Method 'CreateUtilityInstance'
};
// --------------------------------------------------------
// Type: INetDiagHelperEx
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const INetDiagHelperEx = *opaque{
    // TODO: Method 'ReconfirmLowHealth'
    // TODO: Method 'SetUtilities'
    // TODO: Method 'ReproduceFailure'
};
// --------------------------------------------------------
// Type: INetDiagHelperInfo
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const INetDiagHelperInfo = *opaque{
    // TODO: Method 'GetAttributeInfo'
};
// --------------------------------------------------------
// Type: INetDiagExtensibleHelper
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const INetDiagExtensibleHelper = *opaque{
    // TODO: Method 'ResolveAttributes'
};

//
// functions
//

// set_last_errror=False (can and should we use this?)
pub extern "NDFAPI" fn NdfCreateIncident(
    helperClassName: ?*u16,
    celt: u32,
    attributes: ?*HELPER_ATTRIBUTE,
    handle: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "NDFAPI" fn NdfCreateWinSockIncident(
    sock: ?*opaque{},
    host: ?*u16,
    port: u16,
    appId: ?*u16,
    userId: ?*SID,
    handle: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "NDFAPI" fn NdfCreateWebIncident(
    url: ?*u16,
    handle: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "NDFAPI" fn NdfCreateWebIncidentEx(
    url: ?*u16,
    useWinHTTP: BOOL,
    moduleName: ?*u16,
    handle: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "NDFAPI" fn NdfCreateSharingIncident(
    UNCPath: ?*u16,
    handle: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "NDFAPI" fn NdfCreateDNSIncident(
    hostname: ?*u16,
    queryType: u16,
    handle: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "NDFAPI" fn NdfCreateConnectivityIncident(
    handle: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "NDFAPI" fn NdfCreateNetConnectionIncident(
    handle: ?*?*opaque{},
    id: Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "NDFAPI" fn NdfCreatePnrpIncident(
    cloudname: ?*u16,
    peername: ?*u16,
    diagnosePublish: BOOL,
    appId: ?*u16,
    handle: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "NDFAPI" fn NdfCreateGroupingIncident(
    CloudName: ?*u16,
    GroupName: ?*u16,
    Identity: ?*u16,
    Invitation: ?*u16,
    Addresses: ?*SOCKET_ADDRESS_LIST,
    appId: ?*u16,
    handle: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "NDFAPI" fn NdfExecuteDiagnosis(
    handle: ?*opaque{},
    hwnd: HWND,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "NDFAPI" fn NdfCloseIncident(
    handle: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "NDFAPI" fn NdfDiagnoseIncident(
    Handle: ?*opaque{},
    RootCauseCount: ?*u32,
    RootCauses: ?*?*RootCauseInfo,
    dwWait: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "NDFAPI" fn NdfRepairIncident(
    Handle: ?*opaque{},
    RepairEx: ?*RepairInfoEx,
    dwWait: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "NDFAPI" fn NdfCancelIncident(
    Handle: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "NDFAPI" fn NdfGetTraceFile(
    Handle: ?*opaque{},
    TraceFileLocation: ?*?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

//
// Unicode Symbol Aliases
//
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {
    },
    .wide => struct {
    },
    else => if (@import("builtin").is_test) struct {
    } else struct {
    },
};

//
// type imports
//
const Guid = @import("../zig.zig").Guid;
const FILETIME = @import("windowsprogramming.zig").FILETIME;
const HRESULT = @import("com.zig").HRESULT;
const SID = @import("security.zig").SID;
const BOOL = @import("systemservices.zig").BOOL;
const SOCKET_ADDRESS_LIST = @import("networkdrivers.zig").SOCKET_ADDRESS_LIST;
const HWND = @import("windowsandmessaging.zig").HWND;

test "" {
    const constant_export_count = 0;
    const type_export_count = 25;
    const func_count = 16;
    const unicode_alias_count = 0;
    const type_import_count = 7;
    @setEvalBranchQuota(0
        + constant_export_count
        + type_export_count
        + func_count
        + unicode_alias_count
        + type_import_count
        + 2 // TODO: why do I need these extra 2?
    );
    @import("std").testing.refAllDecls(@This());
}
