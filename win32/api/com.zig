//! NOTE: this source file is autogenerated, DO NOT MODIFY

//
// constants
//

//
// types
//
// --------------------------------------------------------
// Type: COAUTHIDENTITY
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const COAUTHIDENTITY = extern struct {
    User: ?*u16,
    UserLength: u32,
    Domain: ?*u16,
    DomainLength: u32,
    Password: ?*u16,
    PasswordLength: u32,
    Flags: u32,
};
// --------------------------------------------------------
// Type: COAUTHINFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const COAUTHINFO = extern struct {
    dwAuthnSvc: u32,
    dwAuthzSvc: u32,
    pwszServerPrincName: ?*u16,
    dwAuthnLevel: u32,
    dwImpersonationLevel: u32,
    pAuthIdentityData: ?*COAUTHIDENTITY,
    dwCapabilities: u32,
};
// --------------------------------------------------------
// Type: MEMCTX
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const MEMCTX = *opaque{
};
// --------------------------------------------------------
// Type: CLSCTX
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const CLSCTX = *opaque{
};
// --------------------------------------------------------
// Type: MSHLFLAGS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const MSHLFLAGS = *opaque{
};
// --------------------------------------------------------
// Type: MSHCTX
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const MSHCTX = *opaque{
};
// --------------------------------------------------------
// Type: BYTE_BLOB
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const BYTE_BLOB = extern struct {
    clSize: u32,
    abData: ?[*]u8,
};
// --------------------------------------------------------
// Type: WORD_BLOB
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const WORD_BLOB = extern struct {
    clSize: u32,
    asData: ?[*]u16,
};
// --------------------------------------------------------
// Type: DWORD_BLOB
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DWORD_BLOB = extern struct {
    clSize: u32,
    alData: ?[*]u32,
};
// --------------------------------------------------------
// Type: FLAGGED_BYTE_BLOB
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const FLAGGED_BYTE_BLOB = extern struct {
    fFlags: u32,
    clSize: u32,
    abData: ?[*]u8,
};
// --------------------------------------------------------
// Type: FLAGGED_WORD_BLOB
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const FLAGGED_WORD_BLOB = extern struct {
    fFlags: u32,
    clSize: u32,
    asData: ?[*]u16,
};
// --------------------------------------------------------
// Type: BYTE_SIZEDARR
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const BYTE_SIZEDARR = extern struct {
    clSize: u32,
    pData: ?*u8,
};
// --------------------------------------------------------
// Type: SHORT_SIZEDARR
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SHORT_SIZEDARR = extern struct {
    clSize: u32,
    pData: ?*u16,
};
// --------------------------------------------------------
// Type: LONG_SIZEDARR
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const LONG_SIZEDARR = extern struct {
    clSize: u32,
    pData: ?*u32,
};
// --------------------------------------------------------
// Type: HYPER_SIZEDARR
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HYPER_SIZEDARR = extern struct {
    clSize: u32,
    pData: ?*i64,
};
// --------------------------------------------------------
// Type: REGCLS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const REGCLS = *opaque{
};
// --------------------------------------------------------
// Type: COINITBASE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const COINITBASE = *opaque{
};
// --------------------------------------------------------
// Type: IUnknown
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IUnknown = *opaque{
    // TODO: Method 'QueryInterface'
    // TODO: Method 'AddRef'
    // TODO: Method 'Release'
};
// --------------------------------------------------------
// Type: AsyncIUnknown
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const AsyncIUnknown = *opaque{
    // TODO: Method 'Begin_QueryInterface'
    // TODO: Method 'Finish_QueryInterface'
    // TODO: Method 'Begin_AddRef'
    // TODO: Method 'Finish_AddRef'
    // TODO: Method 'Begin_Release'
    // TODO: Method 'Finish_Release'
};
// --------------------------------------------------------
// Type: IClassFactory
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IClassFactory = *opaque{
    // TODO: Method 'CreateInstance'
    // TODO: Method 'LockServer'
};
// --------------------------------------------------------
// Type: IEnumContextProps
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const IEnumContextProps = opaque {
};
// --------------------------------------------------------
// Type: IContext
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const IContext = opaque {
};
// --------------------------------------------------------
// Type: IObjContext
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
// a struct with no fields? this means Zig can't use it in extern structs, so we're making it opaque
pub const IObjContext = opaque {
};
// --------------------------------------------------------
// Type: COSERVERINFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const COSERVERINFO = extern struct {
    dwReserved1: u32,
    pwszName: ?*u16,
    pAuthInfo: ?*COAUTHINFO,
    dwReserved2: u32,
};
// --------------------------------------------------------
// Type: IMarshal
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IMarshal = *opaque{
    // TODO: Method 'GetUnmarshalClass'
    // TODO: Method 'GetMarshalSizeMax'
    // TODO: Method 'MarshalInterface'
    // TODO: Method 'UnmarshalInterface'
    // TODO: Method 'ReleaseMarshalData'
    // TODO: Method 'DisconnectObject'
};
// --------------------------------------------------------
// Type: INoMarshal
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const INoMarshal = *opaque{
};
// --------------------------------------------------------
// Type: IAgileObject
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IAgileObject = *opaque{
};
// --------------------------------------------------------
// Type: IActivationFilter
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IActivationFilter = *opaque{
    // TODO: Method 'HandleActivation'
};
// --------------------------------------------------------
// Type: IMarshal2
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IMarshal2 = *opaque{
};
// --------------------------------------------------------
// Type: IMalloc
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IMalloc = *opaque{
    // TODO: Method 'Alloc'
    // TODO: Method 'Realloc'
    // TODO: Method 'Free'
    // TODO: Method 'GetSize'
    // TODO: Method 'DidAlloc'
    // TODO: Method 'HeapMinimize'
};
// --------------------------------------------------------
// Type: IStdMarshalInfo
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IStdMarshalInfo = *opaque{
    // TODO: Method 'GetClassForHandler'
};
// --------------------------------------------------------
// Type: EXTCONN
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const EXTCONN = *opaque{
};
// --------------------------------------------------------
// Type: IExternalConnection
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IExternalConnection = *opaque{
    // TODO: Method 'AddConnection'
    // TODO: Method 'ReleaseConnection'
};
// --------------------------------------------------------
// Type: MULTI_QI
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const MULTI_QI = extern struct {
    pIID: ?*Guid,
    pItf: IUnknown,
    hr: HRESULT,
};
// --------------------------------------------------------
// Type: IMultiQI
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IMultiQI = *opaque{
    // TODO: Method 'QueryMultipleInterfaces'
};
// --------------------------------------------------------
// Type: AsyncIMultiQI
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const AsyncIMultiQI = *opaque{
    // TODO: Method 'Begin_QueryMultipleInterfaces'
    // TODO: Method 'Finish_QueryMultipleInterfaces'
};
// --------------------------------------------------------
// Type: IInternalUnknown
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IInternalUnknown = *opaque{
    // TODO: Method 'QueryInternalInterface'
};
// --------------------------------------------------------
// Type: IEnumUnknown
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IEnumUnknown = *opaque{
    // TODO: Method 'Next'
    // TODO: Method 'Skip'
    // TODO: Method 'Reset'
    // TODO: Method 'Clone'
};
// --------------------------------------------------------
// Type: IEnumString
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IEnumString = *opaque{
    // TODO: Method 'Next'
    // TODO: Method 'Skip'
    // TODO: Method 'Reset'
    // TODO: Method 'Clone'
};
// --------------------------------------------------------
// Type: RPCOLEMESSAGE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const RPCOLEMESSAGE = extern struct {
    reserved1: ?*opaque{},
    dataRepresentation: u32,
    Buffer: ?*opaque{},
    cbBuffer: u32,
    iMethod: u32,
    reserved2: ?[*]?*opaque{},
    rpcFlags: u32,
};
// --------------------------------------------------------
// Type: IRpcChannelBuffer
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IRpcChannelBuffer = *opaque{
    // TODO: Method 'GetBuffer'
    // TODO: Method 'SendReceive'
    // TODO: Method 'FreeBuffer'
    // TODO: Method 'GetDestCtx'
    // TODO: Method 'IsConnected'
};
// --------------------------------------------------------
// Type: IRpcChannelBuffer2
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IRpcChannelBuffer2 = *opaque{
    // TODO: Method 'GetProtocolVersion'
};
// --------------------------------------------------------
// Type: IAsyncRpcChannelBuffer
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IAsyncRpcChannelBuffer = *opaque{
    // TODO: Method 'Send'
    // TODO: Method 'Receive'
    // TODO: Method 'GetDestCtxEx'
};
// --------------------------------------------------------
// Type: IRpcChannelBuffer3
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IRpcChannelBuffer3 = *opaque{
    // TODO: Method 'Send'
    // TODO: Method 'Receive'
    // TODO: Method 'Cancel'
    // TODO: Method 'GetCallContext'
    // TODO: Method 'GetDestCtxEx'
    // TODO: Method 'GetState'
    // TODO: Method 'RegisterAsync'
};
// --------------------------------------------------------
// Type: IRpcSyntaxNegotiate
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IRpcSyntaxNegotiate = *opaque{
    // TODO: Method 'NegotiateSyntax'
};
// --------------------------------------------------------
// Type: IRpcProxyBuffer
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IRpcProxyBuffer = *opaque{
    // TODO: Method 'Connect'
    // TODO: Method 'Disconnect'
};
// --------------------------------------------------------
// Type: IRpcStubBuffer
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IRpcStubBuffer = *opaque{
    // TODO: Method 'Connect'
    // TODO: Method 'Disconnect'
    // TODO: Method 'Invoke'
    // TODO: Method 'IsIIDSupported'
    // TODO: Method 'CountRefs'
    // TODO: Method 'DebugServerQueryInterface'
    // TODO: Method 'DebugServerRelease'
};
// --------------------------------------------------------
// Type: IPSFactoryBuffer
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IPSFactoryBuffer = *opaque{
    // TODO: Method 'CreateProxy'
    // TODO: Method 'CreateStub'
};
// --------------------------------------------------------
// Type: SChannelHookCallInfo
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SChannelHookCallInfo = extern struct {
    iid: Guid,
    cbSize: u32,
    uCausality: Guid,
    dwServerPid: u32,
    iMethod: u32,
    pObject: ?*opaque{},
};
// --------------------------------------------------------
// Type: IChannelHook
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IChannelHook = *opaque{
    // TODO: Method 'ClientGetSize'
    // TODO: Method 'ClientFillBuffer'
    // TODO: Method 'ClientNotify'
    // TODO: Method 'ServerNotify'
    // TODO: Method 'ServerGetSize'
    // TODO: Method 'ServerFillBuffer'
};
// --------------------------------------------------------
// Type: SOLE_AUTHENTICATION_SERVICE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SOLE_AUTHENTICATION_SERVICE = extern struct {
    dwAuthnSvc: u32,
    dwAuthzSvc: u32,
    pPrincipalName: ?*u16,
    hr: HRESULT,
};
// --------------------------------------------------------
// Type: EOLE_AUTHENTICATION_CAPABILITIES
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const EOLE_AUTHENTICATION_CAPABILITIES = *opaque{
};
// --------------------------------------------------------
// Type: SOLE_AUTHENTICATION_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SOLE_AUTHENTICATION_INFO = extern struct {
    dwAuthnSvc: u32,
    dwAuthzSvc: u32,
    pAuthInfo: ?*opaque{},
};
// --------------------------------------------------------
// Type: SOLE_AUTHENTICATION_LIST
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const SOLE_AUTHENTICATION_LIST = extern struct {
    cAuthInfo: u32,
    aAuthInfo: ?*SOLE_AUTHENTICATION_INFO,
};
// --------------------------------------------------------
// Type: IClientSecurity
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IClientSecurity = *opaque{
    // TODO: Method 'QueryBlanket'
    // TODO: Method 'SetBlanket'
    // TODO: Method 'CopyProxy'
};
// --------------------------------------------------------
// Type: IServerSecurity
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IServerSecurity = *opaque{
    // TODO: Method 'QueryBlanket'
    // TODO: Method 'ImpersonateClient'
    // TODO: Method 'RevertToSelf'
    // TODO: Method 'IsImpersonating'
};
// --------------------------------------------------------
// Type: RPCOPT_PROPERTIES
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const RPCOPT_PROPERTIES = *opaque{
};
// --------------------------------------------------------
// Type: RPCOPT_SERVER_LOCALITY_VALUES
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const RPCOPT_SERVER_LOCALITY_VALUES = *opaque{
};
// --------------------------------------------------------
// Type: IRpcOptions
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IRpcOptions = *opaque{
    // TODO: Method 'Set'
    // TODO: Method 'Query'
};
// --------------------------------------------------------
// Type: GLOBALOPT_PROPERTIES
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const GLOBALOPT_PROPERTIES = *opaque{
};
// --------------------------------------------------------
// Type: GLOBALOPT_EH_VALUES
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const GLOBALOPT_EH_VALUES = *opaque{
};
// --------------------------------------------------------
// Type: GLOBALOPT_RPCTP_VALUES
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const GLOBALOPT_RPCTP_VALUES = *opaque{
};
// --------------------------------------------------------
// Type: GLOBALOPT_RO_FLAGS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const GLOBALOPT_RO_FLAGS = *opaque{
};
// --------------------------------------------------------
// Type: GLOBALOPT_UNMARSHALING_POLICY_VALUES
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const GLOBALOPT_UNMARSHALING_POLICY_VALUES = *opaque{
};
// --------------------------------------------------------
// Type: IGlobalOptions
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IGlobalOptions = *opaque{
    // TODO: Method 'Set'
    // TODO: Method 'Query'
};
// --------------------------------------------------------
// Type: ISurrogate
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ISurrogate = *opaque{
    // TODO: Method 'LoadDllServer'
    // TODO: Method 'FreeSurrogate'
};
// --------------------------------------------------------
// Type: IGlobalInterfaceTable
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IGlobalInterfaceTable = *opaque{
    // TODO: Method 'RegisterInterfaceInGlobal'
    // TODO: Method 'RevokeInterfaceFromGlobal'
    // TODO: Method 'GetInterfaceFromGlobal'
};
// --------------------------------------------------------
// Type: ISynchronize
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ISynchronize = *opaque{
    // TODO: Method 'Wait'
    // TODO: Method 'Signal'
    // TODO: Method 'Reset'
};
// --------------------------------------------------------
// Type: ISynchronizeHandle
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ISynchronizeHandle = *opaque{
    // TODO: Method 'GetHandle'
};
// --------------------------------------------------------
// Type: ISynchronizeEvent
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ISynchronizeEvent = *opaque{
    // TODO: Method 'SetEventHandle'
};
// --------------------------------------------------------
// Type: ISynchronizeContainer
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ISynchronizeContainer = *opaque{
    // TODO: Method 'AddSynchronize'
    // TODO: Method 'WaitMultiple'
};
// --------------------------------------------------------
// Type: ISynchronizeMutex
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ISynchronizeMutex = *opaque{
    // TODO: Method 'ReleaseMutex'
};
// --------------------------------------------------------
// Type: ICancelMethodCalls
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ICancelMethodCalls = *opaque{
    // TODO: Method 'Cancel'
    // TODO: Method 'TestCancel'
};
// --------------------------------------------------------
// Type: DCOM_CALL_STATE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const DCOM_CALL_STATE = *opaque{
};
// --------------------------------------------------------
// Type: IAsyncManager
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IAsyncManager = *opaque{
    // TODO: Method 'CompleteCall'
    // TODO: Method 'GetCallContext'
    // TODO: Method 'GetState'
};
// --------------------------------------------------------
// Type: ICallFactory
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ICallFactory = *opaque{
    // TODO: Method 'CreateCall'
};
// --------------------------------------------------------
// Type: IRpcHelper
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IRpcHelper = *opaque{
    // TODO: Method 'GetDCOMProtocolVersion'
    // TODO: Method 'GetIIDFromOBJREF'
};
// --------------------------------------------------------
// Type: IReleaseMarshalBuffers
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IReleaseMarshalBuffers = *opaque{
    // TODO: Method 'ReleaseMarshalBuffer'
};
// --------------------------------------------------------
// Type: IWaitMultiple
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IWaitMultiple = *opaque{
    // TODO: Method 'WaitMultiple'
    // TODO: Method 'AddSynchronize'
};
// --------------------------------------------------------
// Type: IAddrTrackingControl
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IAddrTrackingControl = *opaque{
    // TODO: Method 'EnableCOMDynamicAddrTracking'
    // TODO: Method 'DisableCOMDynamicAddrTracking'
};
// --------------------------------------------------------
// Type: IAddrExclusionControl
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IAddrExclusionControl = *opaque{
    // TODO: Method 'GetCurrentAddrExclusionList'
    // TODO: Method 'UpdateAddrExclusionList'
};
// --------------------------------------------------------
// Type: IPipeByte
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IPipeByte = *opaque{
    // TODO: Method 'Pull'
    // TODO: Method 'Push'
};
// --------------------------------------------------------
// Type: AsyncIPipeByte
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const AsyncIPipeByte = *opaque{
    // TODO: Method 'Begin_Pull'
    // TODO: Method 'Finish_Pull'
    // TODO: Method 'Begin_Push'
    // TODO: Method 'Finish_Push'
};
// --------------------------------------------------------
// Type: IPipeLong
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IPipeLong = *opaque{
    // TODO: Method 'Pull'
    // TODO: Method 'Push'
};
// --------------------------------------------------------
// Type: AsyncIPipeLong
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const AsyncIPipeLong = *opaque{
    // TODO: Method 'Begin_Pull'
    // TODO: Method 'Finish_Pull'
    // TODO: Method 'Begin_Push'
    // TODO: Method 'Finish_Push'
};
// --------------------------------------------------------
// Type: IPipeDouble
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IPipeDouble = *opaque{
    // TODO: Method 'Pull'
    // TODO: Method 'Push'
};
// --------------------------------------------------------
// Type: AsyncIPipeDouble
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const AsyncIPipeDouble = *opaque{
    // TODO: Method 'Begin_Pull'
    // TODO: Method 'Finish_Pull'
    // TODO: Method 'Begin_Push'
    // TODO: Method 'Finish_Push'
};
// --------------------------------------------------------
// Type: APTTYPEQUALIFIER
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const APTTYPEQUALIFIER = *opaque{
};
// --------------------------------------------------------
// Type: APTTYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const APTTYPE = *opaque{
};
// --------------------------------------------------------
// Type: THDTYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const THDTYPE = *opaque{
};
// --------------------------------------------------------
// Type: IComThreadingInfo
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IComThreadingInfo = *opaque{
    // TODO: Method 'GetCurrentApartmentType'
    // TODO: Method 'GetCurrentThreadType'
    // TODO: Method 'GetCurrentLogicalThreadId'
    // TODO: Method 'SetCurrentLogicalThreadId'
};
// --------------------------------------------------------
// Type: IProcessInitControl
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IProcessInitControl = *opaque{
    // TODO: Method 'ResetInitializerTimeout'
};
// --------------------------------------------------------
// Type: IFastRundown
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IFastRundown = *opaque{
};
// --------------------------------------------------------
// Type: CO_MARSHALING_CONTEXT_ATTRIBUTES
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const CO_MARSHALING_CONTEXT_ATTRIBUTES = *opaque{
};
// --------------------------------------------------------
// Type: IMarshalingStream
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IMarshalingStream = *opaque{
    // TODO: Method 'GetMarshalingContextAttribute'
};
// --------------------------------------------------------
// Type: CO_MTA_USAGE_COOKIE__
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CO_MTA_USAGE_COOKIE__ = extern struct {
    unused: i32,
};
// --------------------------------------------------------
// Type: STDMSHLFLAGS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const STDMSHLFLAGS = *opaque{
};
// --------------------------------------------------------
// Type: COWAIT_FLAGS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const COWAIT_FLAGS = *opaque{
};
// --------------------------------------------------------
// Type: CWMO_FLAGS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const CWMO_FLAGS = *opaque{
};
// --------------------------------------------------------
// Type: LPFNGETCLASSOBJECT
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const LPFNGETCLASSOBJECT = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: LPFNCANUNLOADNOW
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const LPFNCANUNLOADNOW = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: CO_DEVICE_CATALOG_COOKIE__
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CO_DEVICE_CATALOG_COOKIE__ = extern struct {
    unused: i32,
};
// --------------------------------------------------------
// Type: IMallocSpy
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IMallocSpy = *opaque{
    // TODO: Method 'PreAlloc'
    // TODO: Method 'PostAlloc'
    // TODO: Method 'PreFree'
    // TODO: Method 'PostFree'
    // TODO: Method 'PreRealloc'
    // TODO: Method 'PostRealloc'
    // TODO: Method 'PreGetSize'
    // TODO: Method 'PostGetSize'
    // TODO: Method 'PreDidAlloc'
    // TODO: Method 'PostDidAlloc'
    // TODO: Method 'PreHeapMinimize'
    // TODO: Method 'PostHeapMinimize'
};
// --------------------------------------------------------
// Type: BIND_OPTS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const BIND_OPTS = extern struct {
    cbStruct: u32,
    grfFlags: u32,
    grfMode: u32,
    dwTickCountDeadline: u32,
};
// --------------------------------------------------------
// Type: BIND_OPTS2
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const BIND_OPTS2 = extern struct {
    __AnonymousBase_objidl_L8451_C36: BIND_OPTS,
    dwTrackFlags: u32,
    dwClassContext: u32,
    locale: u32,
    pServerInfo: ?*COSERVERINFO,
};
// --------------------------------------------------------
// Type: BIND_OPTS3
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const BIND_OPTS3 = extern struct {
    __AnonymousBase_objidl_L8475_C36: BIND_OPTS2,
    hwnd: HWND,
};
// --------------------------------------------------------
// Type: BIND_FLAGS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const BIND_FLAGS = *opaque{
};
// --------------------------------------------------------
// Type: IBindCtx
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IBindCtx = *opaque{
    // TODO: Method 'RegisterObjectBound'
    // TODO: Method 'RevokeObjectBound'
    // TODO: Method 'ReleaseBoundObjects'
    // TODO: Method 'SetBindOptions'
    // TODO: Method 'GetBindOptions'
    // TODO: Method 'GetRunningObjectTable'
    // TODO: Method 'RegisterObjectParam'
    // TODO: Method 'GetObjectParam'
    // TODO: Method 'EnumObjectParam'
    // TODO: Method 'RevokeObjectParam'
};
// --------------------------------------------------------
// Type: IEnumMoniker
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IEnumMoniker = *opaque{
    // TODO: Method 'Next'
    // TODO: Method 'Skip'
    // TODO: Method 'Reset'
    // TODO: Method 'Clone'
};
// --------------------------------------------------------
// Type: IRunnableObject
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IRunnableObject = *opaque{
    // TODO: Method 'GetRunningClass'
    // TODO: Method 'Run'
    // TODO: Method 'IsRunning'
    // TODO: Method 'LockRunning'
    // TODO: Method 'SetContainedObject'
};
// --------------------------------------------------------
// Type: IRunningObjectTable
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IRunningObjectTable = *opaque{
    // TODO: Method 'Register'
    // TODO: Method 'Revoke'
    // TODO: Method 'IsRunning'
    // TODO: Method 'GetObjectA'
    // TODO: Method 'NoteChangeTime'
    // TODO: Method 'GetTimeOfLastChange'
    // TODO: Method 'EnumRunning'
};
// --------------------------------------------------------
// Type: IPersist
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IPersist = *opaque{
    // TODO: Method 'GetClassID'
};
// --------------------------------------------------------
// Type: IPersistStream
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IPersistStream = *opaque{
    // TODO: Method 'IsDirty'
    // TODO: Method 'Load'
    // TODO: Method 'Save'
    // TODO: Method 'GetSizeMax'
};
// --------------------------------------------------------
// Type: MKSYS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const MKSYS = *opaque{
};
// --------------------------------------------------------
// Type: MKREDUCE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const MKREDUCE = *opaque{
};
// --------------------------------------------------------
// Type: IMoniker
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IMoniker = *opaque{
    // TODO: Method 'BindToObject'
    // TODO: Method 'BindToStorage'
    // TODO: Method 'Reduce'
    // TODO: Method 'ComposeWith'
    // TODO: Method 'Enum'
    // TODO: Method 'IsEqual'
    // TODO: Method 'Hash'
    // TODO: Method 'IsRunning'
    // TODO: Method 'GetTimeOfLastChange'
    // TODO: Method 'Inverse'
    // TODO: Method 'CommonPrefixWith'
    // TODO: Method 'RelativePathTo'
    // TODO: Method 'GetDisplayName'
    // TODO: Method 'ParseDisplayName'
    // TODO: Method 'IsSystemMoniker'
};
// --------------------------------------------------------
// Type: IROTData
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IROTData = *opaque{
    // TODO: Method 'GetComparisonData'
};
// --------------------------------------------------------
// Type: IPersistFile
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IPersistFile = *opaque{
    // TODO: Method 'IsDirty'
    // TODO: Method 'Load'
    // TODO: Method 'Save'
    // TODO: Method 'SaveCompleted'
    // TODO: Method 'GetCurFile'
};
// --------------------------------------------------------
// Type: IPersistStorage
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IPersistStorage = *opaque{
    // TODO: Method 'IsDirty'
    // TODO: Method 'InitNew'
    // TODO: Method 'Load'
    // TODO: Method 'Save'
    // TODO: Method 'SaveCompleted'
    // TODO: Method 'HandsOffStorage'
};
// --------------------------------------------------------
// Type: DVTARGETDEVICE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DVTARGETDEVICE = extern struct {
    tdSize: u32,
    tdDriverNameOffset: u16,
    tdDeviceNameOffset: u16,
    tdPortNameOffset: u16,
    tdExtDevmodeOffset: u16,
    tdData: ?[*]u8,
};
// --------------------------------------------------------
// Type: FORMATETC
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const FORMATETC = extern struct {
    cfFormat: u16,
    ptd: ?*DVTARGETDEVICE,
    dwAspect: u32,
    lindex: i32,
    tymed: u32,
};
// --------------------------------------------------------
// Type: IEnumFORMATETC
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IEnumFORMATETC = *opaque{
    // TODO: Method 'Next'
    // TODO: Method 'Skip'
    // TODO: Method 'Reset'
    // TODO: Method 'Clone'
};
// --------------------------------------------------------
// Type: ADVF
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const ADVF = *opaque{
};
// --------------------------------------------------------
// Type: STATDATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const STATDATA = extern struct {
    formatetc: FORMATETC,
    advf: u32,
    pAdvSink: IAdviseSink,
    dwConnection: u32,
};
// --------------------------------------------------------
// Type: IEnumSTATDATA
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IEnumSTATDATA = *opaque{
    // TODO: Method 'Next'
    // TODO: Method 'Skip'
    // TODO: Method 'Reset'
    // TODO: Method 'Clone'
};
// --------------------------------------------------------
// Type: TYMED
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const TYMED = *opaque{
};
// --------------------------------------------------------
// Type: RemSTGMEDIUM
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const RemSTGMEDIUM = extern struct {
    tymed: u32,
    dwHandleType: u32,
    pData: u32,
    pUnkForRelease: u32,
    cbData: u32,
    data: ?[*]u8,
};
// --------------------------------------------------------
// Type: STGMEDIUM
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const STGMEDIUM = extern struct {
    tymed: u32,
    Anonymous: _Anonymous_e__Union,
    pUnkForRelease: IUnknown,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: GDI_OBJECT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const GDI_OBJECT = extern struct {
    ObjectType: u32,
    u: _u_e__Struct,
    // --------------------------------------------------------
    // Type: _u_e__Struct
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _u_e__Struct = *opaque{
    };
};
// --------------------------------------------------------
// Type: userSTGMEDIUM
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const userSTGMEDIUM = extern struct {
    pUnkForRelease: IUnknown,
    // --------------------------------------------------------
    // Type: _STGMEDIUM_UNION
    // TypeLayoutAttr: sequential
    // TODO: I think this is a struct, but not sure at this point, assuming it is for now
    pub const _STGMEDIUM_UNION = extern struct {
        tymed: u32,
        u: _u_e__Struct,
        // --------------------------------------------------------
        // Type: _u_e__Struct
        // TypeLayoutAttr: explicit
        // not generating the actual code for this type because it has an explicit layout
        pub const _u_e__Struct = *opaque{
        };
    };
};
// --------------------------------------------------------
// Type: userFLAG_STGMEDIUM
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const userFLAG_STGMEDIUM = extern struct {
    ContextFlags: i32,
    fPassOwnership: i32,
    Stgmed: userSTGMEDIUM,
};
// --------------------------------------------------------
// Type: FLAG_STGMEDIUM
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const FLAG_STGMEDIUM = extern struct {
    ContextFlags: i32,
    fPassOwnership: i32,
    Stgmed: STGMEDIUM,
};
// --------------------------------------------------------
// Type: IAdviseSink
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IAdviseSink = *opaque{
    // TODO: Method 'OnDataChange'
    // TODO: Method 'OnViewChange'
    // TODO: Method 'OnRename'
    // TODO: Method 'OnSave'
    // TODO: Method 'OnClose'
};
// --------------------------------------------------------
// Type: AsyncIAdviseSink
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const AsyncIAdviseSink = *opaque{
    // TODO: Method 'Begin_OnDataChange'
    // TODO: Method 'Finish_OnDataChange'
    // TODO: Method 'Begin_OnViewChange'
    // TODO: Method 'Finish_OnViewChange'
    // TODO: Method 'Begin_OnRename'
    // TODO: Method 'Finish_OnRename'
    // TODO: Method 'Begin_OnSave'
    // TODO: Method 'Finish_OnSave'
    // TODO: Method 'Begin_OnClose'
    // TODO: Method 'Finish_OnClose'
};
// --------------------------------------------------------
// Type: IAdviseSink2
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IAdviseSink2 = *opaque{
    // TODO: Method 'OnLinkSrcChange'
};
// --------------------------------------------------------
// Type: AsyncIAdviseSink2
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const AsyncIAdviseSink2 = *opaque{
    // TODO: Method 'Begin_OnLinkSrcChange'
    // TODO: Method 'Finish_OnLinkSrcChange'
};
// --------------------------------------------------------
// Type: DATADIR
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const DATADIR = *opaque{
};
// --------------------------------------------------------
// Type: IDataObject
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IDataObject = *opaque{
    // TODO: Method 'GetData'
    // TODO: Method 'GetDataHere'
    // TODO: Method 'QueryGetData'
    // TODO: Method 'GetCanonicalFormatEtc'
    // TODO: Method 'SetData'
    // TODO: Method 'EnumFormatEtc'
    // TODO: Method 'DAdvise'
    // TODO: Method 'DUnadvise'
    // TODO: Method 'EnumDAdvise'
};
// --------------------------------------------------------
// Type: IDataAdviseHolder
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IDataAdviseHolder = *opaque{
    // TODO: Method 'Advise'
    // TODO: Method 'Unadvise'
    // TODO: Method 'EnumAdvise'
    // TODO: Method 'SendOnDataChange'
};
// --------------------------------------------------------
// Type: CALLTYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const CALLTYPE = *opaque{
};
// --------------------------------------------------------
// Type: SERVERCALL
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const SERVERCALL = *opaque{
};
// --------------------------------------------------------
// Type: PENDINGTYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PENDINGTYPE = *opaque{
};
// --------------------------------------------------------
// Type: PENDINGMSG
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PENDINGMSG = *opaque{
};
// --------------------------------------------------------
// Type: INTERFACEINFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const INTERFACEINFO = extern struct {
    pUnk: IUnknown,
    iid: Guid,
    wMethod: u16,
};
// --------------------------------------------------------
// Type: IMessageFilter
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IMessageFilter = *opaque{
    // TODO: Method 'HandleInComingCall'
    // TODO: Method 'RetryRejectedCall'
    // TODO: Method 'MessagePending'
};
// --------------------------------------------------------
// Type: IClassActivator
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IClassActivator = *opaque{
    // TODO: Method 'GetClassObject'
};
// --------------------------------------------------------
// Type: IProgressNotify
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IProgressNotify = *opaque{
    // TODO: Method 'OnProgress'
};
// --------------------------------------------------------
// Type: IBlockingLock
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IBlockingLock = *opaque{
    // TODO: Method 'Lock'
    // TODO: Method 'Unlock'
};
// --------------------------------------------------------
// Type: ITimeAndNoticeControl
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ITimeAndNoticeControl = *opaque{
    // TODO: Method 'SuppressChanges'
};
// --------------------------------------------------------
// Type: IOplockStorage
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IOplockStorage = *opaque{
    // TODO: Method 'CreateStorageEx'
    // TODO: Method 'OpenStorageEx'
};
// --------------------------------------------------------
// Type: IUrlMon
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IUrlMon = *opaque{
    // TODO: Method 'AsyncGetClassBits'
};
// --------------------------------------------------------
// Type: IForegroundTransfer
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IForegroundTransfer = *opaque{
    // TODO: Method 'AllowForegroundTransfer'
};
// --------------------------------------------------------
// Type: IThumbnailExtractor
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IThumbnailExtractor = *opaque{
    // TODO: Method 'ExtractThumbnail'
    // TODO: Method 'OnFileUpdated'
};
// --------------------------------------------------------
// Type: IDummyHICONIncluder
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IDummyHICONIncluder = *opaque{
    // TODO: Method 'Dummy'
};
// --------------------------------------------------------
// Type: ApplicationType
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const ApplicationType = *opaque{
};
// --------------------------------------------------------
// Type: ShutdownType
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const ShutdownType = *opaque{
};
// --------------------------------------------------------
// Type: IProcessLock
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IProcessLock = *opaque{
    // TODO: Method 'AddRefOnProcess'
    // TODO: Method 'ReleaseRefOnProcess'
};
// --------------------------------------------------------
// Type: ISurrogateService
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ISurrogateService = *opaque{
    // TODO: Method 'Init'
    // TODO: Method 'ApplicationLaunch'
    // TODO: Method 'ApplicationFree'
    // TODO: Method 'CatalogRefresh'
    // TODO: Method 'ProcessShutdown'
};
// --------------------------------------------------------
// Type: IInitializeSpy
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IInitializeSpy = *opaque{
    // TODO: Method 'PreInitialize'
    // TODO: Method 'PostInitialize'
    // TODO: Method 'PreUninitialize'
    // TODO: Method 'PostUninitialize'
};
// --------------------------------------------------------
// Type: IOleAdviseHolder
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IOleAdviseHolder = *opaque{
    // TODO: Method 'Advise'
    // TODO: Method 'Unadvise'
    // TODO: Method 'EnumAdvise'
    // TODO: Method 'SendOnRename'
    // TODO: Method 'SendOnSave'
    // TODO: Method 'SendOnClose'
};
// --------------------------------------------------------
// Type: IOleCache
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IOleCache = *opaque{
    // TODO: Method 'Cache'
    // TODO: Method 'Uncache'
    // TODO: Method 'EnumCache'
    // TODO: Method 'InitCache'
    // TODO: Method 'SetData'
};
// --------------------------------------------------------
// Type: DISCARDCACHE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const DISCARDCACHE = *opaque{
};
// --------------------------------------------------------
// Type: IOleCache2
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IOleCache2 = *opaque{
    // TODO: Method 'UpdateCache'
    // TODO: Method 'DiscardCache'
};
// --------------------------------------------------------
// Type: IOleCacheControl
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IOleCacheControl = *opaque{
    // TODO: Method 'OnRun'
    // TODO: Method 'OnStop'
};
// --------------------------------------------------------
// Type: IParseDisplayName
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IParseDisplayName = *opaque{
    // TODO: Method 'ParseDisplayName'
};
// --------------------------------------------------------
// Type: IOleContainer
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IOleContainer = *opaque{
    // TODO: Method 'EnumObjects'
    // TODO: Method 'LockContainer'
};
// --------------------------------------------------------
// Type: IOleClientSite
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IOleClientSite = *opaque{
    // TODO: Method 'SaveObject'
    // TODO: Method 'GetMoniker'
    // TODO: Method 'GetContainer'
    // TODO: Method 'ShowObject'
    // TODO: Method 'OnShowWindow'
    // TODO: Method 'RequestNewObjectLayout'
};
// --------------------------------------------------------
// Type: OLEGETMONIKER
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const OLEGETMONIKER = *opaque{
};
// --------------------------------------------------------
// Type: OLEWHICHMK
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const OLEWHICHMK = *opaque{
};
// --------------------------------------------------------
// Type: USERCLASSTYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const USERCLASSTYPE = *opaque{
};
// --------------------------------------------------------
// Type: OLEMISC
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const OLEMISC = *opaque{
};
// --------------------------------------------------------
// Type: OLECLOSE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const OLECLOSE = *opaque{
};
// --------------------------------------------------------
// Type: IOleObject
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IOleObject = *opaque{
    // TODO: Method 'SetClientSite'
    // TODO: Method 'GetClientSite'
    // TODO: Method 'SetHostNames'
    // TODO: Method 'Close'
    // TODO: Method 'SetMoniker'
    // TODO: Method 'GetMoniker'
    // TODO: Method 'InitFromData'
    // TODO: Method 'GetClipboardData'
    // TODO: Method 'DoVerb'
    // TODO: Method 'EnumVerbs'
    // TODO: Method 'Update'
    // TODO: Method 'IsUpToDate'
    // TODO: Method 'GetUserClassID'
    // TODO: Method 'GetUserType'
    // TODO: Method 'SetExtent'
    // TODO: Method 'GetExtent'
    // TODO: Method 'Advise'
    // TODO: Method 'Unadvise'
    // TODO: Method 'EnumAdvise'
    // TODO: Method 'GetMiscStatus'
    // TODO: Method 'SetColorScheme'
};
// --------------------------------------------------------
// Type: OLERENDER
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const OLERENDER = *opaque{
};
// --------------------------------------------------------
// Type: OBJECTDESCRIPTOR
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const OBJECTDESCRIPTOR = extern struct {
    cbSize: u32,
    clsid: Guid,
    dwDrawAspect: u32,
    sizel: SIZE,
    pointl: POINTL,
    dwStatus: u32,
    dwFullUserTypeName: u32,
    dwSrcOfCopy: u32,
};
// --------------------------------------------------------
// Type: IOleWindow
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IOleWindow = *opaque{
    // TODO: Method 'GetWindow'
    // TODO: Method 'ContextSensitiveHelp'
};
// --------------------------------------------------------
// Type: OLEUPDATE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const OLEUPDATE = *opaque{
};
// --------------------------------------------------------
// Type: OLELINKBIND
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const OLELINKBIND = *opaque{
};
// --------------------------------------------------------
// Type: IOleLink
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IOleLink = *opaque{
    // TODO: Method 'SetUpdateOptions'
    // TODO: Method 'GetUpdateOptions'
    // TODO: Method 'SetSourceMoniker'
    // TODO: Method 'GetSourceMoniker'
    // TODO: Method 'SetSourceDisplayName'
    // TODO: Method 'GetSourceDisplayName'
    // TODO: Method 'BindToSource'
    // TODO: Method 'BindIfRunning'
    // TODO: Method 'GetBoundSource'
    // TODO: Method 'UnbindSource'
    // TODO: Method 'Update'
};
// --------------------------------------------------------
// Type: BINDSPEED
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const BINDSPEED = *opaque{
};
// --------------------------------------------------------
// Type: OLECONTF
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const OLECONTF = *opaque{
};
// --------------------------------------------------------
// Type: IOleItemContainer
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IOleItemContainer = *opaque{
    // TODO: Method 'GetObjectA'
    // TODO: Method 'GetObjectStorage'
    // TODO: Method 'IsRunning'
};
// --------------------------------------------------------
// Type: IOleInPlaceUIWindow
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IOleInPlaceUIWindow = *opaque{
    // TODO: Method 'GetBorder'
    // TODO: Method 'RequestBorderSpace'
    // TODO: Method 'SetBorderSpace'
    // TODO: Method 'SetActiveObject'
};
// --------------------------------------------------------
// Type: IOleInPlaceActiveObject
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IOleInPlaceActiveObject = *opaque{
    // TODO: Method 'TranslateAcceleratorA'
    // TODO: Method 'OnFrameWindowActivate'
    // TODO: Method 'OnDocWindowActivate'
    // TODO: Method 'ResizeBorder'
    // TODO: Method 'EnableModeless'
};
// --------------------------------------------------------
// Type: OIFI
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const OIFI = extern struct {
    cb: u32,
    fMDIApp: BOOL,
    hwndFrame: HWND,
    haccel: HACCEL,
    cAccelEntries: u32,
};
// --------------------------------------------------------
// Type: OleMenuGroupWidths
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const OleMenuGroupWidths = extern struct {
    width: ?[*]i32,
};
// --------------------------------------------------------
// Type: IOleInPlaceFrame
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IOleInPlaceFrame = *opaque{
    // TODO: Method 'InsertMenus'
    // TODO: Method 'SetMenu'
    // TODO: Method 'RemoveMenus'
    // TODO: Method 'SetStatusText'
    // TODO: Method 'EnableModeless'
    // TODO: Method 'TranslateAcceleratorA'
};
// --------------------------------------------------------
// Type: IOleInPlaceObject
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IOleInPlaceObject = *opaque{
    // TODO: Method 'InPlaceDeactivate'
    // TODO: Method 'UIDeactivate'
    // TODO: Method 'SetObjectRects'
    // TODO: Method 'ReactivateAndUndo'
};
// --------------------------------------------------------
// Type: IOleInPlaceSite
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IOleInPlaceSite = *opaque{
    // TODO: Method 'CanInPlaceActivate'
    // TODO: Method 'OnInPlaceActivate'
    // TODO: Method 'OnUIActivate'
    // TODO: Method 'GetWindowContext'
    // TODO: Method 'Scroll'
    // TODO: Method 'OnUIDeactivate'
    // TODO: Method 'OnInPlaceDeactivate'
    // TODO: Method 'DiscardUndoState'
    // TODO: Method 'DeactivateAndUndo'
    // TODO: Method 'OnPosRectChange'
};
// --------------------------------------------------------
// Type: IContinue
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IContinue = *opaque{
    // TODO: Method 'FContinue'
};
// --------------------------------------------------------
// Type: IViewObject
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IViewObject = *opaque{
    // TODO: Method 'Draw'
    // TODO: Method 'GetColorSet'
    // TODO: Method 'Freeze'
    // TODO: Method 'Unfreeze'
    // TODO: Method 'SetAdvise'
    // TODO: Method 'GetAdvise'
};
// --------------------------------------------------------
// Type: IViewObject2
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IViewObject2 = *opaque{
    // TODO: Method 'GetExtent'
};
// --------------------------------------------------------
// Type: IDropSource
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IDropSource = *opaque{
    // TODO: Method 'QueryContinueDrag'
    // TODO: Method 'GiveFeedback'
};
// --------------------------------------------------------
// Type: IDropTarget
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IDropTarget = *opaque{
    // TODO: Method 'DragEnter'
    // TODO: Method 'DragOver'
    // TODO: Method 'DragLeave'
    // TODO: Method 'Drop'
};
// --------------------------------------------------------
// Type: IDropSourceNotify
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IDropSourceNotify = *opaque{
    // TODO: Method 'DragEnterTarget'
    // TODO: Method 'DragLeaveTarget'
};
// --------------------------------------------------------
// Type: IEnterpriseDropTarget
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IEnterpriseDropTarget = *opaque{
    // TODO: Method 'SetDropSourceEnterpriseId'
    // TODO: Method 'IsEvaluatingEdpPolicy'
};
// --------------------------------------------------------
// Type: OLEVERB
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const OLEVERB = extern struct {
    lVerb: i32,
    lpszVerbName: ?*u16,
    fuFlags: u32,
    grfAttribs: u32,
};
// --------------------------------------------------------
// Type: OLEVERBATTRIB
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const OLEVERBATTRIB = *opaque{
};
// --------------------------------------------------------
// Type: IEnumOLEVERB
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IEnumOLEVERB = *opaque{
    // TODO: Method 'Next'
    // TODO: Method 'Skip'
    // TODO: Method 'Reset'
    // TODO: Method 'Clone'
};
// --------------------------------------------------------
// Type: IEObjectType
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const IEObjectType = *opaque{
};
// --------------------------------------------------------
// Type: IPersistMoniker
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IPersistMoniker = *opaque{
    // TODO: Method 'GetClassID'
    // TODO: Method 'IsDirty'
    // TODO: Method 'Load'
    // TODO: Method 'Save'
    // TODO: Method 'SaveCompleted'
    // TODO: Method 'GetCurMoniker'
};
// --------------------------------------------------------
// Type: MONIKERPROPERTY
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const MONIKERPROPERTY = *opaque{
};
// --------------------------------------------------------
// Type: IMonikerProp
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IMonikerProp = *opaque{
    // TODO: Method 'PutProperty'
};
// --------------------------------------------------------
// Type: IBindProtocol
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IBindProtocol = *opaque{
    // TODO: Method 'CreateBinding'
};
// --------------------------------------------------------
// Type: IBinding
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IBinding = *opaque{
    // TODO: Method 'Abort'
    // TODO: Method 'Suspend'
    // TODO: Method 'Resume'
    // TODO: Method 'SetPriority'
    // TODO: Method 'GetPriority'
    // TODO: Method 'GetBindResult'
};
// --------------------------------------------------------
// Type: BINDVERB
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const BINDVERB = *opaque{
};
// --------------------------------------------------------
// Type: BINDINFOF
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const BINDINFOF = *opaque{
};
// --------------------------------------------------------
// Type: BINDF
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const BINDF = *opaque{
};
// --------------------------------------------------------
// Type: URL_ENCODING
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const URL_ENCODING = *opaque{
};
// --------------------------------------------------------
// Type: BINDINFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const BINDINFO = extern struct {
    cbSize: u32,
    szExtraInfo: ?*u16,
    stgmedData: STGMEDIUM,
    grfBindInfoF: u32,
    dwBindVerb: u32,
    szCustomVerb: ?*u16,
    cbstgmedData: u32,
    dwOptions: u32,
    dwOptionsFlags: u32,
    dwCodePage: u32,
    securityAttributes: SECURITY_ATTRIBUTES,
    iid: Guid,
    pUnk: IUnknown,
    dwReserved: u32,
};
// --------------------------------------------------------
// Type: REMSECURITY_ATTRIBUTES
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const REMSECURITY_ATTRIBUTES = extern struct {
    nLength: u32,
    lpSecurityDescriptor: u32,
    bInheritHandle: BOOL,
};
// --------------------------------------------------------
// Type: RemBINDINFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const RemBINDINFO = extern struct {
    cbSize: u32,
    szExtraInfo: ?*u16,
    grfBindInfoF: u32,
    dwBindVerb: u32,
    szCustomVerb: ?*u16,
    cbstgmedData: u32,
    dwOptions: u32,
    dwOptionsFlags: u32,
    dwCodePage: u32,
    securityAttributes: REMSECURITY_ATTRIBUTES,
    iid: Guid,
    pUnk: IUnknown,
    dwReserved: u32,
};
// --------------------------------------------------------
// Type: RemFORMATETC
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const RemFORMATETC = extern struct {
    cfFormat: u32,
    ptd: u32,
    dwAspect: u32,
    lindex: i32,
    tymed: u32,
};
// --------------------------------------------------------
// Type: BINDINFO_OPTIONS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const BINDINFO_OPTIONS = *opaque{
};
// --------------------------------------------------------
// Type: BSCF
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const BSCF = *opaque{
};
// --------------------------------------------------------
// Type: BINDSTATUS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const BINDSTATUS = *opaque{
};
// --------------------------------------------------------
// Type: IBindStatusCallback
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IBindStatusCallback = *opaque{
    // TODO: Method 'OnStartBinding'
    // TODO: Method 'GetPriority'
    // TODO: Method 'OnLowResource'
    // TODO: Method 'OnProgress'
    // TODO: Method 'OnStopBinding'
    // TODO: Method 'GetBindInfo'
    // TODO: Method 'OnDataAvailable'
    // TODO: Method 'OnObjectAvailable'
};
// --------------------------------------------------------
// Type: BINDF2
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const BINDF2 = *opaque{
};
// --------------------------------------------------------
// Type: IBindStatusCallbackEx
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IBindStatusCallbackEx = *opaque{
    // TODO: Method 'GetBindInfoEx'
};
// --------------------------------------------------------
// Type: IAuthenticate
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IAuthenticate = *opaque{
    // TODO: Method 'Authenticate'
};
// --------------------------------------------------------
// Type: AUTHENTICATEF
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const AUTHENTICATEF = *opaque{
};
// --------------------------------------------------------
// Type: AUTHENTICATEINFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const AUTHENTICATEINFO = extern struct {
    dwFlags: u32,
    dwReserved: u32,
};
// --------------------------------------------------------
// Type: IAuthenticateEx
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IAuthenticateEx = *opaque{
    // TODO: Method 'AuthenticateEx'
};
// --------------------------------------------------------
// Type: IHttpNegotiate
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IHttpNegotiate = *opaque{
    // TODO: Method 'BeginningTransaction'
    // TODO: Method 'OnResponse'
};
// --------------------------------------------------------
// Type: IHttpNegotiate2
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IHttpNegotiate2 = *opaque{
    // TODO: Method 'GetRootSecurityId'
};
// --------------------------------------------------------
// Type: IHttpNegotiate3
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IHttpNegotiate3 = *opaque{
    // TODO: Method 'GetSerializedClientCertContext'
};
// --------------------------------------------------------
// Type: IWinInetFileStream
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IWinInetFileStream = *opaque{
    // TODO: Method 'SetHandleForUnlock'
    // TODO: Method 'SetDeleteFile'
};
// --------------------------------------------------------
// Type: IWindowForBindingUI
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IWindowForBindingUI = *opaque{
    // TODO: Method 'GetWindow'
};
// --------------------------------------------------------
// Type: CIP_STATUS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const CIP_STATUS = *opaque{
};
// --------------------------------------------------------
// Type: ICodeInstall
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ICodeInstall = *opaque{
    // TODO: Method 'OnCodeInstallProblem'
};
// --------------------------------------------------------
// Type: Uri_PROPERTY
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const Uri_PROPERTY = *opaque{
};
// --------------------------------------------------------
// Type: Uri_HOST_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const Uri_HOST_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: IUri
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IUri = *opaque{
    // TODO: Method 'GetPropertyBSTR'
    // TODO: Method 'GetPropertyLength'
    // TODO: Method 'GetPropertyDWORD'
    // TODO: Method 'HasProperty'
    // TODO: Method 'GetAbsoluteUri'
    // TODO: Method 'GetAuthority'
    // TODO: Method 'GetDisplayUri'
    // TODO: Method 'GetDomain'
    // TODO: Method 'GetExtension'
    // TODO: Method 'GetFragment'
    // TODO: Method 'GetHost'
    // TODO: Method 'GetPassword'
    // TODO: Method 'GetPath'
    // TODO: Method 'GetPathAndQuery'
    // TODO: Method 'GetQuery'
    // TODO: Method 'GetRawUri'
    // TODO: Method 'GetSchemeName'
    // TODO: Method 'GetUserInfo'
    // TODO: Method 'GetUserNameA'
    // TODO: Method 'GetHostType'
    // TODO: Method 'GetPort'
    // TODO: Method 'GetScheme'
    // TODO: Method 'GetZone'
    // TODO: Method 'GetProperties'
    // TODO: Method 'IsEqual'
};
// --------------------------------------------------------
// Type: IUriContainer
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IUriContainer = *opaque{
    // TODO: Method 'GetIUri'
};
// --------------------------------------------------------
// Type: IUriBuilder
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IUriBuilder = *opaque{
    // TODO: Method 'CreateUriSimple'
    // TODO: Method 'CreateUri'
    // TODO: Method 'CreateUriWithFlags'
    // TODO: Method 'GetIUri'
    // TODO: Method 'SetIUri'
    // TODO: Method 'GetFragment'
    // TODO: Method 'GetHost'
    // TODO: Method 'GetPassword'
    // TODO: Method 'GetPath'
    // TODO: Method 'GetPort'
    // TODO: Method 'GetQuery'
    // TODO: Method 'GetSchemeName'
    // TODO: Method 'GetUserNameA'
    // TODO: Method 'SetFragment'
    // TODO: Method 'SetHost'
    // TODO: Method 'SetPassword'
    // TODO: Method 'SetPath'
    // TODO: Method 'SetPortA'
    // TODO: Method 'SetQuery'
    // TODO: Method 'SetSchemeName'
    // TODO: Method 'SetUserName'
    // TODO: Method 'RemoveProperties'
    // TODO: Method 'HasBeenModified'
};
// --------------------------------------------------------
// Type: IUriBuilderFactory
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IUriBuilderFactory = *opaque{
    // TODO: Method 'CreateIUriBuilder'
    // TODO: Method 'CreateInitializedIUriBuilder'
};
// --------------------------------------------------------
// Type: IWinInetInfo
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IWinInetInfo = *opaque{
    // TODO: Method 'QueryOption'
};
// --------------------------------------------------------
// Type: IHttpSecurity
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IHttpSecurity = *opaque{
    // TODO: Method 'OnSecurityProblem'
};
// --------------------------------------------------------
// Type: IWinInetHttpInfo
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IWinInetHttpInfo = *opaque{
    // TODO: Method 'QueryInfo'
};
// --------------------------------------------------------
// Type: IWinInetHttpTimeouts
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IWinInetHttpTimeouts = *opaque{
    // TODO: Method 'GetRequestTimeouts'
};
// --------------------------------------------------------
// Type: IWinInetCacheHints
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IWinInetCacheHints = *opaque{
    // TODO: Method 'SetCacheExtension'
};
// --------------------------------------------------------
// Type: IWinInetCacheHints2
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IWinInetCacheHints2 = *opaque{
    // TODO: Method 'SetCacheExtension2'
};
// --------------------------------------------------------
// Type: IBindHost
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IBindHost = *opaque{
    // TODO: Method 'CreateMoniker'
    // TODO: Method 'MonikerBindToStorage'
    // TODO: Method 'MonikerBindToObject'
};
// --------------------------------------------------------
// Type: IInternet
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IInternet = *opaque{
};
// --------------------------------------------------------
// Type: BINDSTRING
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const BINDSTRING = *opaque{
};
// --------------------------------------------------------
// Type: IInternetBindInfo
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IInternetBindInfo = *opaque{
    // TODO: Method 'GetBindInfo'
    // TODO: Method 'GetBindString'
};
// --------------------------------------------------------
// Type: IInternetBindInfoEx
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IInternetBindInfoEx = *opaque{
    // TODO: Method 'GetBindInfoEx'
};
// --------------------------------------------------------
// Type: PI_FLAGS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PI_FLAGS = *opaque{
};
// --------------------------------------------------------
// Type: PROTOCOLDATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PROTOCOLDATA = extern struct {
    grfFlags: u32,
    dwState: u32,
    pData: ?*opaque{},
    cbData: u32,
};
// --------------------------------------------------------
// Type: StartParam
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const StartParam = extern struct {
    iid: Guid,
    pIBindCtx: IBindCtx,
    pItf: IUnknown,
};
// --------------------------------------------------------
// Type: IInternetProtocolRoot
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IInternetProtocolRoot = *opaque{
    // TODO: Method 'Start'
    // TODO: Method 'Continue'
    // TODO: Method 'Abort'
    // TODO: Method 'Terminate'
    // TODO: Method 'Suspend'
    // TODO: Method 'Resume'
};
// --------------------------------------------------------
// Type: IInternetProtocol
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IInternetProtocol = *opaque{
    // TODO: Method 'Read'
    // TODO: Method 'Seek'
    // TODO: Method 'LockRequest'
    // TODO: Method 'UnlockRequest'
};
// --------------------------------------------------------
// Type: IInternetProtocolEx
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IInternetProtocolEx = *opaque{
    // TODO: Method 'StartEx'
};
// --------------------------------------------------------
// Type: IInternetProtocolSink
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IInternetProtocolSink = *opaque{
    // TODO: Method 'Switch'
    // TODO: Method 'ReportProgress'
    // TODO: Method 'ReportData'
    // TODO: Method 'ReportResult'
};
// --------------------------------------------------------
// Type: IInternetProtocolSinkStackable
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IInternetProtocolSinkStackable = *opaque{
    // TODO: Method 'SwitchSink'
    // TODO: Method 'CommitSwitch'
    // TODO: Method 'RollbackSwitch'
};
// --------------------------------------------------------
// Type: OIBDG_FLAGS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const OIBDG_FLAGS = *opaque{
};
// --------------------------------------------------------
// Type: IInternetSession
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IInternetSession = *opaque{
    // TODO: Method 'RegisterNameSpace'
    // TODO: Method 'UnregisterNameSpace'
    // TODO: Method 'RegisterMimeFilter'
    // TODO: Method 'UnregisterMimeFilter'
    // TODO: Method 'CreateBinding'
    // TODO: Method 'SetSessionOption'
    // TODO: Method 'GetSessionOption'
};
// --------------------------------------------------------
// Type: IInternetThreadSwitch
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IInternetThreadSwitch = *opaque{
    // TODO: Method 'Prepare'
    // TODO: Method 'Continue'
};
// --------------------------------------------------------
// Type: IInternetPriority
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IInternetPriority = *opaque{
    // TODO: Method 'SetPriority'
    // TODO: Method 'GetPriority'
};
// --------------------------------------------------------
// Type: PARSEACTION
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PARSEACTION = *opaque{
};
// --------------------------------------------------------
// Type: PSUACTION
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PSUACTION = *opaque{
};
// --------------------------------------------------------
// Type: QUERYOPTION
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const QUERYOPTION = *opaque{
};
// --------------------------------------------------------
// Type: IInternetProtocolInfo
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IInternetProtocolInfo = *opaque{
    // TODO: Method 'ParseUrl'
    // TODO: Method 'CombineUrl'
    // TODO: Method 'CompareUrl'
    // TODO: Method 'QueryInfo'
};
// --------------------------------------------------------
// Type: INTERNETFEATURELIST
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const INTERNETFEATURELIST = *opaque{
};
// --------------------------------------------------------
// Type: IInternetSecurityMgrSite
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IInternetSecurityMgrSite = *opaque{
    // TODO: Method 'GetWindow'
    // TODO: Method 'EnableModeless'
};
// --------------------------------------------------------
// Type: PUAF
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PUAF = *opaque{
};
// --------------------------------------------------------
// Type: PUAFOUT
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PUAFOUT = *opaque{
};
// --------------------------------------------------------
// Type: SZM_FLAGS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const SZM_FLAGS = *opaque{
};
// --------------------------------------------------------
// Type: IInternetSecurityManager
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IInternetSecurityManager = *opaque{
    // TODO: Method 'SetSecuritySite'
    // TODO: Method 'GetSecuritySite'
    // TODO: Method 'MapUrlToZone'
    // TODO: Method 'GetSecurityId'
    // TODO: Method 'ProcessUrlAction'
    // TODO: Method 'QueryCustomPolicy'
    // TODO: Method 'SetZoneMapping'
    // TODO: Method 'GetZoneMappings'
};
// --------------------------------------------------------
// Type: IInternetSecurityManagerEx
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IInternetSecurityManagerEx = *opaque{
    // TODO: Method 'ProcessUrlActionEx'
};
// --------------------------------------------------------
// Type: IInternetSecurityManagerEx2
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IInternetSecurityManagerEx2 = *opaque{
    // TODO: Method 'MapUrlToZoneEx2'
    // TODO: Method 'ProcessUrlActionEx2'
    // TODO: Method 'GetSecurityIdEx2'
    // TODO: Method 'QueryCustomPolicyEx2'
};
// --------------------------------------------------------
// Type: IZoneIdentifier
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IZoneIdentifier = *opaque{
    // TODO: Method 'GetId'
    // TODO: Method 'SetId'
    // TODO: Method 'Remove'
};
// --------------------------------------------------------
// Type: IZoneIdentifier2
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IZoneIdentifier2 = *opaque{
    // TODO: Method 'GetLastWriterPackageFamilyName'
    // TODO: Method 'SetLastWriterPackageFamilyName'
    // TODO: Method 'RemoveLastWriterPackageFamilyName'
    // TODO: Method 'GetAppZoneId'
    // TODO: Method 'SetAppZoneId'
    // TODO: Method 'RemoveAppZoneId'
};
// --------------------------------------------------------
// Type: IInternetHostSecurityManager
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IInternetHostSecurityManager = *opaque{
    // TODO: Method 'GetSecurityId'
    // TODO: Method 'ProcessUrlAction'
    // TODO: Method 'QueryCustomPolicy'
};
// --------------------------------------------------------
// Type: URLZONE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const URLZONE = *opaque{
};
// --------------------------------------------------------
// Type: URLTEMPLATE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const URLTEMPLATE = *opaque{
};
// --------------------------------------------------------
// Type: __MIDL_IInternetZoneManager_0001
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const __MIDL_IInternetZoneManager_0001 = *opaque{
};
// --------------------------------------------------------
// Type: ZAFLAGS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const ZAFLAGS = *opaque{
};
// --------------------------------------------------------
// Type: ZONEATTRIBUTES
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const ZONEATTRIBUTES = extern struct {
    cbSize: u32,
    szDisplayName: ?[*]u16,
    szDescription: ?[*]u16,
    szIconPath: ?[*]u16,
    dwTemplateMinLevel: u32,
    dwTemplateRecommended: u32,
    dwTemplateCurrentLevel: u32,
    dwFlags: u32,
};
// --------------------------------------------------------
// Type: URLZONEREG
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const URLZONEREG = *opaque{
};
// --------------------------------------------------------
// Type: IInternetZoneManager
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IInternetZoneManager = *opaque{
    // TODO: Method 'GetZoneAttributes'
    // TODO: Method 'SetZoneAttributes'
    // TODO: Method 'GetZoneCustomPolicy'
    // TODO: Method 'SetZoneCustomPolicy'
    // TODO: Method 'GetZoneActionPolicy'
    // TODO: Method 'SetZoneActionPolicy'
    // TODO: Method 'PromptAction'
    // TODO: Method 'LogAction'
    // TODO: Method 'CreateZoneEnumerator'
    // TODO: Method 'GetZoneAt'
    // TODO: Method 'DestroyZoneEnumerator'
    // TODO: Method 'CopyTemplatePoliciesToZone'
};
// --------------------------------------------------------
// Type: IInternetZoneManagerEx
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IInternetZoneManagerEx = *opaque{
    // TODO: Method 'GetZoneActionPolicyEx'
    // TODO: Method 'SetZoneActionPolicyEx'
};
// --------------------------------------------------------
// Type: IInternetZoneManagerEx2
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IInternetZoneManagerEx2 = *opaque{
    // TODO: Method 'GetZoneAttributesEx'
    // TODO: Method 'GetZoneSecurityState'
    // TODO: Method 'GetIESecurityState'
    // TODO: Method 'FixUnsecureSettings'
};
// --------------------------------------------------------
// Type: CODEBASEHOLD
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CODEBASEHOLD = extern struct {
    cbSize: u32,
    szDistUnit: ?*u16,
    szCodeBase: ?*u16,
    dwVersionMS: u32,
    dwVersionLS: u32,
    dwStyle: u32,
};
// --------------------------------------------------------
// Type: ISoftDistExt
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ISoftDistExt = *opaque{
    // TODO: Method 'ProcessSoftDist'
    // TODO: Method 'GetFirstCodeBase'
    // TODO: Method 'GetNextCodeBase'
    // TODO: Method 'AsyncInstallDistributionUnit'
};
// --------------------------------------------------------
// Type: ICatalogFileInfo
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ICatalogFileInfo = *opaque{
    // TODO: Method 'GetCatalogFile'
    // TODO: Method 'GetJavaTrust'
};
// --------------------------------------------------------
// Type: IDataFilter
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IDataFilter = *opaque{
    // TODO: Method 'DoEncode'
    // TODO: Method 'DoDecode'
    // TODO: Method 'SetEncodingLevel'
};
// --------------------------------------------------------
// Type: PROTOCOLFILTERDATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PROTOCOLFILTERDATA = extern struct {
    cbSize: u32,
    pProtocolSink: IInternetProtocolSink,
    pProtocol: IInternetProtocol,
    pUnk: IUnknown,
    dwFilterFlags: u32,
};
// --------------------------------------------------------
// Type: DATAINFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DATAINFO = extern struct {
    ulTotalSize: u32,
    ulavrPacketSize: u32,
    ulConnectSpeed: u32,
    ulProcessorSpeed: u32,
};
// --------------------------------------------------------
// Type: IEncodingFilterFactory
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IEncodingFilterFactory = *opaque{
    // TODO: Method 'FindBestFilter'
    // TODO: Method 'GetDefaultFilter'
};
// --------------------------------------------------------
// Type: HIT_LOGGING_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const HIT_LOGGING_INFO = extern struct {
    dwStructSize: u32,
    lpszLoggedUrlName: ?*i8,
    StartTime: SYSTEMTIME,
    EndTime: SYSTEMTIME,
    lpszExtendedInfo: ?*i8,
};
// --------------------------------------------------------
// Type: CONFIRMSAFETY
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CONFIRMSAFETY = extern struct {
    clsid: Guid,
    pUnk: IUnknown,
    dwFlags: u32,
};
// --------------------------------------------------------
// Type: IWrappedProtocol
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IWrappedProtocol = *opaque{
    // TODO: Method 'GetWrapperCode'
};
// --------------------------------------------------------
// Type: BINDHANDLETYPES
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const BINDHANDLETYPES = *opaque{
};
// --------------------------------------------------------
// Type: IGetBindHandle
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IGetBindHandle = *opaque{
    // TODO: Method 'GetBindHandle'
};
// --------------------------------------------------------
// Type: PROTOCOL_ARGUMENT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PROTOCOL_ARGUMENT = extern struct {
    szMethod: ?*u16,
    szTargetUrl: ?*u16,
};
// --------------------------------------------------------
// Type: IBindCallbackRedirect
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IBindCallbackRedirect = *opaque{
    // TODO: Method 'Redirect'
};
// --------------------------------------------------------
// Type: IBindHttpSecurity
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IBindHttpSecurity = *opaque{
    // TODO: Method 'GetIgnoreCertMask'
};
// --------------------------------------------------------
// Type: OLESTREAMVTBL
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const OLESTREAMVTBL = extern struct {
    Get: ?*opaque{},
    Put: ?*opaque{},
};
// --------------------------------------------------------
// Type: OLESTREAM
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const OLESTREAM = extern struct {
    lpstbl: ?*OLESTREAMVTBL,
};
// --------------------------------------------------------
// Type: UASFLAGS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const UASFLAGS = *opaque{
};
// --------------------------------------------------------
// Type: CONNECTDATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CONNECTDATA = extern struct {
    pUnk: IUnknown,
    dwCookie: u32,
};
// --------------------------------------------------------
// Type: IEnumConnections
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IEnumConnections = *opaque{
    // TODO: Method 'Next'
    // TODO: Method 'Skip'
    // TODO: Method 'Reset'
    // TODO: Method 'Clone'
};
// --------------------------------------------------------
// Type: IConnectionPoint
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IConnectionPoint = *opaque{
    // TODO: Method 'GetConnectionInterface'
    // TODO: Method 'GetConnectionPointContainer'
    // TODO: Method 'Advise'
    // TODO: Method 'Unadvise'
    // TODO: Method 'EnumConnections'
};
// --------------------------------------------------------
// Type: IEnumConnectionPoints
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IEnumConnectionPoints = *opaque{
    // TODO: Method 'Next'
    // TODO: Method 'Skip'
    // TODO: Method 'Reset'
    // TODO: Method 'Clone'
};
// --------------------------------------------------------
// Type: IConnectionPointContainer
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IConnectionPointContainer = *opaque{
    // TODO: Method 'EnumConnectionPoints'
    // TODO: Method 'FindConnectionPoint'
};
// --------------------------------------------------------
// Type: LICINFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const LICINFO = extern struct {
    cbLicInfo: i32,
    fRuntimeKeyAvail: BOOL,
    fLicVerified: BOOL,
};
// --------------------------------------------------------
// Type: IClassFactory2
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IClassFactory2 = *opaque{
    // TODO: Method 'GetLicInfo'
    // TODO: Method 'RequestLicKey'
    // TODO: Method 'CreateInstanceLic'
};
// --------------------------------------------------------
// Type: IProvideClassInfo
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IProvideClassInfo = *opaque{
    // TODO: Method 'GetClassInfoA'
};
// --------------------------------------------------------
// Type: GUIDKIND
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const GUIDKIND = *opaque{
};
// --------------------------------------------------------
// Type: IProvideClassInfo2
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IProvideClassInfo2 = *opaque{
    // TODO: Method 'GetGUID'
};
// --------------------------------------------------------
// Type: IProvideMultipleClassInfo
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IProvideMultipleClassInfo = *opaque{
    // TODO: Method 'GetMultiTypeInfoCount'
    // TODO: Method 'GetInfoOfIndex'
};
// --------------------------------------------------------
// Type: CONTROLINFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CONTROLINFO = extern struct {
    cb: u32,
    hAccel: HACCEL,
    cAccel: u16,
    dwFlags: u32,
};
// --------------------------------------------------------
// Type: CTRLINFO
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const CTRLINFO = *opaque{
};
// --------------------------------------------------------
// Type: IOleControl
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IOleControl = *opaque{
    // TODO: Method 'GetControlInfo'
    // TODO: Method 'OnMnemonic'
    // TODO: Method 'OnAmbientPropertyChange'
    // TODO: Method 'FreezeEvents'
};
// --------------------------------------------------------
// Type: POINTF
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const POINTF = extern struct {
    x: f32,
    y: f32,
};
// --------------------------------------------------------
// Type: XFORMCOORDS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const XFORMCOORDS = *opaque{
};
// --------------------------------------------------------
// Type: IOleControlSite
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IOleControlSite = *opaque{
    // TODO: Method 'OnControlInfoChanged'
    // TODO: Method 'LockInPlaceActive'
    // TODO: Method 'GetExtendedControl'
    // TODO: Method 'TransformCoords'
    // TODO: Method 'TranslateAcceleratorA'
    // TODO: Method 'OnFocus'
    // TODO: Method 'ShowPropertyFrame'
};
// --------------------------------------------------------
// Type: PROPPAGEINFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PROPPAGEINFO = extern struct {
    cb: u32,
    pszTitle: ?*u16,
    size: SIZE,
    pszDocString: ?*u16,
    pszHelpFile: ?*u16,
    dwHelpContext: u32,
};
// --------------------------------------------------------
// Type: IPropertyPage
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IPropertyPage = *opaque{
    // TODO: Method 'SetPageSite'
    // TODO: Method 'Activate'
    // TODO: Method 'Deactivate'
    // TODO: Method 'GetPageInfo'
    // TODO: Method 'SetObjects'
    // TODO: Method 'Show'
    // TODO: Method 'Move'
    // TODO: Method 'IsPageDirty'
    // TODO: Method 'Apply'
    // TODO: Method 'Help'
    // TODO: Method 'TranslateAcceleratorA'
};
// --------------------------------------------------------
// Type: IPropertyPage2
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IPropertyPage2 = *opaque{
    // TODO: Method 'EditProperty'
};
// --------------------------------------------------------
// Type: PROPPAGESTATUS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PROPPAGESTATUS = *opaque{
};
// --------------------------------------------------------
// Type: IPropertyPageSite
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IPropertyPageSite = *opaque{
    // TODO: Method 'OnStatusChange'
    // TODO: Method 'GetLocaleID'
    // TODO: Method 'GetPageContainer'
    // TODO: Method 'TranslateAcceleratorA'
};
// --------------------------------------------------------
// Type: IPropertyNotifySink
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IPropertyNotifySink = *opaque{
    // TODO: Method 'OnChanged'
    // TODO: Method 'OnRequestEdit'
};
// --------------------------------------------------------
// Type: CAUUID
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CAUUID = extern struct {
    cElems: u32,
    pElems: ?*Guid,
};
// --------------------------------------------------------
// Type: ISpecifyPropertyPages
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ISpecifyPropertyPages = *opaque{
    // TODO: Method 'GetPages'
};
// --------------------------------------------------------
// Type: IPersistMemory
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IPersistMemory = *opaque{
    // TODO: Method 'IsDirty'
    // TODO: Method 'Load'
    // TODO: Method 'Save'
    // TODO: Method 'GetSizeMax'
    // TODO: Method 'InitNew'
};
// --------------------------------------------------------
// Type: IPersistStreamInit
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IPersistStreamInit = *opaque{
    // TODO: Method 'IsDirty'
    // TODO: Method 'Load'
    // TODO: Method 'Save'
    // TODO: Method 'GetSizeMax'
    // TODO: Method 'InitNew'
};
// --------------------------------------------------------
// Type: IPersistPropertyBag
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IPersistPropertyBag = *opaque{
    // TODO: Method 'InitNew'
    // TODO: Method 'Load'
    // TODO: Method 'Save'
};
// --------------------------------------------------------
// Type: ISimpleFrameSite
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ISimpleFrameSite = *opaque{
    // TODO: Method 'PreMessageFilter'
    // TODO: Method 'PostMessageFilter'
};
// --------------------------------------------------------
// Type: IFont
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IFont = *opaque{
    // TODO: Method 'get_Name'
    // TODO: Method 'put_Name'
    // TODO: Method 'get_Size'
    // TODO: Method 'put_Size'
    // TODO: Method 'get_Bold'
    // TODO: Method 'put_Bold'
    // TODO: Method 'get_Italic'
    // TODO: Method 'put_Italic'
    // TODO: Method 'get_Underline'
    // TODO: Method 'put_Underline'
    // TODO: Method 'get_Strikethrough'
    // TODO: Method 'put_Strikethrough'
    // TODO: Method 'get_Weight'
    // TODO: Method 'put_Weight'
    // TODO: Method 'get_Charset'
    // TODO: Method 'put_Charset'
    // TODO: Method 'get_hFont'
    // TODO: Method 'Clone'
    // TODO: Method 'IsEqual'
    // TODO: Method 'SetRatio'
    // TODO: Method 'QueryTextMetrics'
    // TODO: Method 'AddRefHfont'
    // TODO: Method 'ReleaseHfont'
    // TODO: Method 'SetHdc'
};
// --------------------------------------------------------
// Type: PictureAttributes
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PictureAttributes = *opaque{
};
// --------------------------------------------------------
// Type: IPicture
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IPicture = *opaque{
    // TODO: Method 'get_Handle'
    // TODO: Method 'get_hPal'
    // TODO: Method 'get_Type'
    // TODO: Method 'get_Width'
    // TODO: Method 'get_Height'
    // TODO: Method 'Render'
    // TODO: Method 'set_hPal'
    // TODO: Method 'get_CurDC'
    // TODO: Method 'SelectPicture'
    // TODO: Method 'get_KeepOriginalFormat'
    // TODO: Method 'put_KeepOriginalFormat'
    // TODO: Method 'PictureChanged'
    // TODO: Method 'SaveAsFile'
    // TODO: Method 'get_Attributes'
};
// --------------------------------------------------------
// Type: IPicture2
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IPicture2 = *opaque{
    // TODO: Method 'get_Handle'
    // TODO: Method 'get_hPal'
    // TODO: Method 'get_Type'
    // TODO: Method 'get_Width'
    // TODO: Method 'get_Height'
    // TODO: Method 'Render'
    // TODO: Method 'set_hPal'
    // TODO: Method 'get_CurDC'
    // TODO: Method 'SelectPicture'
    // TODO: Method 'get_KeepOriginalFormat'
    // TODO: Method 'put_KeepOriginalFormat'
    // TODO: Method 'PictureChanged'
    // TODO: Method 'SaveAsFile'
    // TODO: Method 'get_Attributes'
};
// --------------------------------------------------------
// Type: IFontEventsDisp
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IFontEventsDisp = *opaque{
};
// --------------------------------------------------------
// Type: IFontDisp
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IFontDisp = *opaque{
};
// --------------------------------------------------------
// Type: IPictureDisp
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IPictureDisp = *opaque{
};
// --------------------------------------------------------
// Type: IOleInPlaceObjectWindowless
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IOleInPlaceObjectWindowless = *opaque{
    // TODO: Method 'OnWindowMessage'
    // TODO: Method 'GetDropTarget'
};
// --------------------------------------------------------
// Type: ACTIVATEFLAGS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const ACTIVATEFLAGS = *opaque{
};
// --------------------------------------------------------
// Type: IOleInPlaceSiteEx
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IOleInPlaceSiteEx = *opaque{
    // TODO: Method 'OnInPlaceActivateEx'
    // TODO: Method 'OnInPlaceDeactivateEx'
    // TODO: Method 'RequestUIActivate'
};
// --------------------------------------------------------
// Type: OLEDCFLAGS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const OLEDCFLAGS = *opaque{
};
// --------------------------------------------------------
// Type: IOleInPlaceSiteWindowless
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IOleInPlaceSiteWindowless = *opaque{
    // TODO: Method 'CanWindowlessActivate'
    // TODO: Method 'GetCapture'
    // TODO: Method 'SetCapture'
    // TODO: Method 'GetFocus'
    // TODO: Method 'SetFocus'
    // TODO: Method 'GetDC'
    // TODO: Method 'ReleaseDC'
    // TODO: Method 'InvalidateRect'
    // TODO: Method 'InvalidateRgn'
    // TODO: Method 'ScrollRect'
    // TODO: Method 'AdjustRect'
    // TODO: Method 'OnDefWindowMessage'
};
// --------------------------------------------------------
// Type: VIEWSTATUS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const VIEWSTATUS = *opaque{
};
// --------------------------------------------------------
// Type: HITRESULT
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const HITRESULT = *opaque{
};
// --------------------------------------------------------
// Type: DVASPECT2
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const DVASPECT2 = *opaque{
};
// --------------------------------------------------------
// Type: ExtentInfo
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const ExtentInfo = extern struct {
    cb: u32,
    dwExtentMode: u32,
    sizelProposed: SIZE,
};
// --------------------------------------------------------
// Type: ExtentMode
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const ExtentMode = *opaque{
};
// --------------------------------------------------------
// Type: AspectInfoFlag
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const AspectInfoFlag = *opaque{
};
// --------------------------------------------------------
// Type: AspectInfo
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const AspectInfo = extern struct {
    cb: u32,
    dwFlags: u32,
};
// --------------------------------------------------------
// Type: IViewObjectEx
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IViewObjectEx = *opaque{
    // TODO: Method 'GetRect'
    // TODO: Method 'GetViewStatus'
    // TODO: Method 'QueryHitPoint'
    // TODO: Method 'QueryHitRect'
    // TODO: Method 'GetNaturalExtent'
};
// --------------------------------------------------------
// Type: IOleUndoUnit
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IOleUndoUnit = *opaque{
    // TODO: Method 'Do'
    // TODO: Method 'GetDescription'
    // TODO: Method 'GetUnitType'
    // TODO: Method 'OnNextAdd'
};
// --------------------------------------------------------
// Type: IOleParentUndoUnit
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IOleParentUndoUnit = *opaque{
    // TODO: Method 'Open'
    // TODO: Method 'Close'
    // TODO: Method 'Add'
    // TODO: Method 'FindUnit'
    // TODO: Method 'GetParentState'
};
// --------------------------------------------------------
// Type: IEnumOleUndoUnits
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IEnumOleUndoUnits = *opaque{
    // TODO: Method 'Next'
    // TODO: Method 'Skip'
    // TODO: Method 'Reset'
    // TODO: Method 'Clone'
};
// --------------------------------------------------------
// Type: IOleUndoManager
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IOleUndoManager = *opaque{
    // TODO: Method 'Open'
    // TODO: Method 'Close'
    // TODO: Method 'Add'
    // TODO: Method 'GetOpenParentState'
    // TODO: Method 'DiscardFrom'
    // TODO: Method 'UndoTo'
    // TODO: Method 'RedoTo'
    // TODO: Method 'EnumUndoable'
    // TODO: Method 'EnumRedoable'
    // TODO: Method 'GetLastUndoDescription'
    // TODO: Method 'GetLastRedoDescription'
    // TODO: Method 'Enable'
};
// --------------------------------------------------------
// Type: POINTERINACTIVE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const POINTERINACTIVE = *opaque{
};
// --------------------------------------------------------
// Type: IPointerInactive
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IPointerInactive = *opaque{
    // TODO: Method 'GetActivationPolicy'
    // TODO: Method 'OnInactiveMouseMove'
    // TODO: Method 'OnInactiveSetCursor'
};
// --------------------------------------------------------
// Type: IObjectWithSite
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IObjectWithSite = *opaque{
    // TODO: Method 'SetSite'
    // TODO: Method 'GetSite'
};
// --------------------------------------------------------
// Type: CALPOLESTR
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CALPOLESTR = extern struct {
    cElems: u32,
    pElems: ?*?*u16,
};
// --------------------------------------------------------
// Type: CADWORD
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CADWORD = extern struct {
    cElems: u32,
    pElems: ?*u32,
};
// --------------------------------------------------------
// Type: IPerPropertyBrowsing
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IPerPropertyBrowsing = *opaque{
    // TODO: Method 'GetDisplayString'
    // TODO: Method 'MapPropertyToPage'
    // TODO: Method 'GetPredefinedStrings'
    // TODO: Method 'GetPredefinedValue'
};
// --------------------------------------------------------
// Type: PROPBAG2_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PROPBAG2_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: PROPBAG2
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PROPBAG2 = extern struct {
    dwType: u32,
    vt: u16,
    cfType: u16,
    dwHint: u32,
    pstrName: ?*u16,
    clsid: Guid,
};
// --------------------------------------------------------
// Type: IPropertyBag2
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IPropertyBag2 = *opaque{
    // TODO: Method 'Read'
    // TODO: Method 'Write'
    // TODO: Method 'CountProperties'
    // TODO: Method 'GetPropertyInfo'
    // TODO: Method 'LoadObject'
};
// --------------------------------------------------------
// Type: IPersistPropertyBag2
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IPersistPropertyBag2 = *opaque{
    // TODO: Method 'InitNew'
    // TODO: Method 'Load'
    // TODO: Method 'Save'
    // TODO: Method 'IsDirty'
};
// --------------------------------------------------------
// Type: IAdviseSinkEx
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IAdviseSinkEx = *opaque{
    // TODO: Method 'OnViewStatusChange'
};
// --------------------------------------------------------
// Type: QACONTAINERFLAGS
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const QACONTAINERFLAGS = *opaque{
};
// --------------------------------------------------------
// Type: QACONTAINER
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const QACONTAINER = extern struct {
    cbSize: u32,
    pClientSite: IOleClientSite,
    pAdviseSink: IAdviseSinkEx,
    pPropertyNotifySink: IPropertyNotifySink,
    pUnkEventSink: IUnknown,
    dwAmbientFlags: u32,
    colorFore: u32,
    colorBack: u32,
    pFont: IFont,
    pUndoMgr: IOleUndoManager,
    dwAppearance: u32,
    lcid: i32,
    hpal: HPALETTE,
    pBindHost: IBindHost,
    pOleControlSite: IOleControlSite,
    pServiceProvider: IServiceProvider,
};
// --------------------------------------------------------
// Type: QACONTROL
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const QACONTROL = extern struct {
    cbSize: u32,
    dwMiscStatus: u32,
    dwViewStatus: u32,
    dwEventCookie: u32,
    dwPropNotifyCookie: u32,
    dwPointerActivationPolicy: u32,
};
// --------------------------------------------------------
// Type: IQuickActivate
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IQuickActivate = *opaque{
    // TODO: Method 'QuickActivate'
    // TODO: Method 'SetContentExtent'
    // TODO: Method 'GetContentExtent'
};
// --------------------------------------------------------
// Type: OCPFIPARAMS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const OCPFIPARAMS = extern struct {
    cbStructSize: u32,
    hWndOwner: HWND,
    x: i32,
    y: i32,
    lpszCaption: ?*u16,
    cObjects: u32,
    lplpUnk: ?*IUnknown,
    cPages: u32,
    lpPages: ?*Guid,
    lcid: u32,
    dispidInitialProperty: i32,
};
// --------------------------------------------------------
// Type: FONTDESC
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const FONTDESC = extern struct {
    cbSizeofstruct: u32,
    lpstrName: ?*u16,
    cySize: CY,
    sWeight: i16,
    sCharset: i16,
    fItalic: BOOL,
    fUnderline: BOOL,
    fStrikethrough: BOOL,
};
// --------------------------------------------------------
// Type: PICTDESC
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PICTDESC = extern struct {
    cbSizeofstruct: u32,
    picType: u32,
    Anonymous: _Anonymous_e__Union,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
        // --------------------------------------------------------
        // Type: _emf_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _emf_e__Struct = extern struct {
            hemf: ?*opaque{},
        };
        // --------------------------------------------------------
        // Type: _wmf_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _wmf_e__Struct = extern struct {
            hmeta: ?*opaque{},
            xExt: i32,
            yExt: i32,
        };
        // --------------------------------------------------------
        // Type: _bmp_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _bmp_e__Struct = extern struct {
            hbitmap: HBITMAP,
            hpal: HPALETTE,
        };
        // --------------------------------------------------------
        // Type: _icon_e__Struct
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _icon_e__Struct = extern struct {
            hicon: HICON,
        };
    };
};
// --------------------------------------------------------
// Type: OLE_TRISTATE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const OLE_TRISTATE = *opaque{
};
// --------------------------------------------------------
// Type: IVBGetControl
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IVBGetControl = *opaque{
    // TODO: Method 'EnumControls'
};
// --------------------------------------------------------
// Type: IGetOleObject
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IGetOleObject = *opaque{
    // TODO: Method 'GetOleObject'
};
// --------------------------------------------------------
// Type: IVBFormat
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IVBFormat = *opaque{
    // TODO: Method 'Format'
};
// --------------------------------------------------------
// Type: IGetVBAObject
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IGetVBAObject = *opaque{
    // TODO: Method 'GetObjectA'
};
// --------------------------------------------------------
// Type: DOCMISC
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const DOCMISC = *opaque{
};
// --------------------------------------------------------
// Type: IOleDocument
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IOleDocument = *opaque{
    // TODO: Method 'CreateView'
    // TODO: Method 'GetDocMiscStatus'
    // TODO: Method 'EnumViews'
};
// --------------------------------------------------------
// Type: IOleDocumentSite
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IOleDocumentSite = *opaque{
    // TODO: Method 'ActivateMe'
};
// --------------------------------------------------------
// Type: IOleDocumentView
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IOleDocumentView = *opaque{
    // TODO: Method 'SetInPlaceSite'
    // TODO: Method 'GetInPlaceSite'
    // TODO: Method 'GetDocument'
    // TODO: Method 'SetRect'
    // TODO: Method 'GetRect'
    // TODO: Method 'SetRectComplex'
    // TODO: Method 'Show'
    // TODO: Method 'UIActivate'
    // TODO: Method 'Open'
    // TODO: Method 'CloseView'
    // TODO: Method 'SaveViewState'
    // TODO: Method 'ApplyViewState'
    // TODO: Method 'Clone'
};
// --------------------------------------------------------
// Type: IEnumOleDocumentViews
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IEnumOleDocumentViews = *opaque{
    // TODO: Method 'Next'
    // TODO: Method 'Skip'
    // TODO: Method 'Reset'
    // TODO: Method 'Clone'
};
// --------------------------------------------------------
// Type: IContinueCallback
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IContinueCallback = *opaque{
    // TODO: Method 'FContinue'
    // TODO: Method 'FContinuePrinting'
};
// --------------------------------------------------------
// Type: __MIDL_IPrint_0001
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const __MIDL_IPrint_0001 = *opaque{
};
// --------------------------------------------------------
// Type: PAGERANGE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PAGERANGE = extern struct {
    nFromPage: i32,
    nToPage: i32,
};
// --------------------------------------------------------
// Type: PAGESET
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const PAGESET = extern struct {
    cbStruct: u32,
    fOddPages: BOOL,
    fEvenPages: BOOL,
    cPageRange: u32,
    rgPages: ?[*]PAGERANGE,
};
// --------------------------------------------------------
// Type: IPrint
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IPrint = *opaque{
    // TODO: Method 'SetInitialPageNum'
    // TODO: Method 'GetPageInfo'
    // TODO: Method 'Print'
};
// --------------------------------------------------------
// Type: OLECMDF
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const OLECMDF = *opaque{
};
// --------------------------------------------------------
// Type: OLECMD
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const OLECMD = extern struct {
    cmdID: u32,
    cmdf: u32,
};
// --------------------------------------------------------
// Type: OLECMDTEXT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const OLECMDTEXT = extern struct {
    cmdtextf: u32,
    cwActual: u32,
    cwBuf: u32,
    rgwz: ?[*]u16,
};
// --------------------------------------------------------
// Type: OLECMDTEXTF
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const OLECMDTEXTF = *opaque{
};
// --------------------------------------------------------
// Type: OLECMDEXECOPT
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const OLECMDEXECOPT = *opaque{
};
// --------------------------------------------------------
// Type: OLECMDID
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const OLECMDID = *opaque{
};
// --------------------------------------------------------
// Type: MEDIAPLAYBACK_STATE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const MEDIAPLAYBACK_STATE = *opaque{
};
// --------------------------------------------------------
// Type: IGNOREMIME
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const IGNOREMIME = *opaque{
};
// --------------------------------------------------------
// Type: WPCSETTING
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const WPCSETTING = *opaque{
};
// --------------------------------------------------------
// Type: IOleCommandTarget
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IOleCommandTarget = *opaque{
    // TODO: Method 'QueryStatus'
    // TODO: Method 'Exec'
};
// --------------------------------------------------------
// Type: OLECMDID_REFRESHFLAG
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const OLECMDID_REFRESHFLAG = *opaque{
};
// --------------------------------------------------------
// Type: OLECMDID_PAGEACTIONFLAG
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const OLECMDID_PAGEACTIONFLAG = *opaque{
};
// --------------------------------------------------------
// Type: OLECMDID_BROWSERSTATEFLAG
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const OLECMDID_BROWSERSTATEFLAG = *opaque{
};
// --------------------------------------------------------
// Type: OLECMDID_OPTICAL_ZOOMFLAG
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const OLECMDID_OPTICAL_ZOOMFLAG = *opaque{
};
// --------------------------------------------------------
// Type: PAGEACTION_UI
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PAGEACTION_UI = *opaque{
};
// --------------------------------------------------------
// Type: OLECMDID_WINDOWSTATE_FLAG
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const OLECMDID_WINDOWSTATE_FLAG = *opaque{
};
// --------------------------------------------------------
// Type: OLECMDID_VIEWPORT_MODE_FLAG
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const OLECMDID_VIEWPORT_MODE_FLAG = *opaque{
};
// --------------------------------------------------------
// Type: IZoomEvents
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IZoomEvents = *opaque{
    // TODO: Method 'OnZoomPercentChanged'
};
// --------------------------------------------------------
// Type: IProtectFocus
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IProtectFocus = *opaque{
    // TODO: Method 'AllowFocusChange'
};
// --------------------------------------------------------
// Type: IProtectedModeMenuServices
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IProtectedModeMenuServices = *opaque{
    // TODO: Method 'CreateMenu'
    // TODO: Method 'LoadMenuA'
    // TODO: Method 'LoadMenuID'
};
// --------------------------------------------------------
// Type: LPFNOLEUIHOOK
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const LPFNOLEUIHOOK = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: OLEUIINSERTOBJECTW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const OLEUIINSERTOBJECTW = extern struct {
    cbStruct: u32,
    dwFlags: u32,
    hWndOwner: HWND,
    lpszCaption: ?*u16,
    lpfnHook: LPFNOLEUIHOOK,
    lCustData: LPARAM,
    hInstance: HINSTANCE,
    lpszTemplate: ?*u16,
    hResource: ?*opaque{},
    clsid: Guid,
    lpszFile: ?*u16,
    cchFile: u32,
    cClsidExclude: u32,
    lpClsidExclude: ?*Guid,
    iid: Guid,
    oleRender: u32,
    lpFormatEtc: ?*FORMATETC,
    lpIOleClientSite: IOleClientSite,
    lpIStorage: IStorage,
    ppvObj: ?*?*opaque{},
    sc: i32,
    hMetaPict: ?*opaque{},
};
// --------------------------------------------------------
// Type: OLEUIINSERTOBJECTA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const OLEUIINSERTOBJECTA = extern struct {
    cbStruct: u32,
    dwFlags: u32,
    hWndOwner: HWND,
    lpszCaption: ?*i8,
    lpfnHook: LPFNOLEUIHOOK,
    lCustData: LPARAM,
    hInstance: HINSTANCE,
    lpszTemplate: ?*i8,
    hResource: ?*opaque{},
    clsid: Guid,
    lpszFile: ?*i8,
    cchFile: u32,
    cClsidExclude: u32,
    lpClsidExclude: ?*Guid,
    iid: Guid,
    oleRender: u32,
    lpFormatEtc: ?*FORMATETC,
    lpIOleClientSite: IOleClientSite,
    lpIStorage: IStorage,
    ppvObj: ?*?*opaque{},
    sc: i32,
    hMetaPict: ?*opaque{},
};
// --------------------------------------------------------
// Type: OLEUIPASTEFLAG
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const OLEUIPASTEFLAG = *opaque{
};
// --------------------------------------------------------
// Type: OLEUIPASTEENTRYW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const OLEUIPASTEENTRYW = extern struct {
    fmtetc: FORMATETC,
    lpstrFormatName: ?*u16,
    lpstrResultText: ?*u16,
    dwFlags: u32,
    dwScratchSpace: u32,
};
// --------------------------------------------------------
// Type: OLEUIPASTEENTRYA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const OLEUIPASTEENTRYA = extern struct {
    fmtetc: FORMATETC,
    lpstrFormatName: ?*i8,
    lpstrResultText: ?*i8,
    dwFlags: u32,
    dwScratchSpace: u32,
};
// --------------------------------------------------------
// Type: OLEUIPASTESPECIALW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const OLEUIPASTESPECIALW = extern struct {
    cbStruct: u32,
    dwFlags: u32,
    hWndOwner: HWND,
    lpszCaption: ?*u16,
    lpfnHook: LPFNOLEUIHOOK,
    lCustData: LPARAM,
    hInstance: HINSTANCE,
    lpszTemplate: ?*u16,
    hResource: ?*opaque{},
    lpSrcDataObj: IDataObject,
    arrPasteEntries: ?*OLEUIPASTEENTRYW,
    cPasteEntries: i32,
    arrLinkTypes: ?*u32,
    cLinkTypes: i32,
    cClsidExclude: u32,
    lpClsidExclude: ?*Guid,
    nSelectedIndex: i32,
    fLink: BOOL,
    hMetaPict: ?*opaque{},
    sizel: SIZE,
};
// --------------------------------------------------------
// Type: OLEUIPASTESPECIALA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const OLEUIPASTESPECIALA = extern struct {
    cbStruct: u32,
    dwFlags: u32,
    hWndOwner: HWND,
    lpszCaption: ?*i8,
    lpfnHook: LPFNOLEUIHOOK,
    lCustData: LPARAM,
    hInstance: HINSTANCE,
    lpszTemplate: ?*i8,
    hResource: ?*opaque{},
    lpSrcDataObj: IDataObject,
    arrPasteEntries: ?*OLEUIPASTEENTRYA,
    cPasteEntries: i32,
    arrLinkTypes: ?*u32,
    cLinkTypes: i32,
    cClsidExclude: u32,
    lpClsidExclude: ?*Guid,
    nSelectedIndex: i32,
    fLink: BOOL,
    hMetaPict: ?*opaque{},
    sizel: SIZE,
};
// --------------------------------------------------------
// Type: IOleUILinkContainerW
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IOleUILinkContainerW = *opaque{
    // TODO: Method 'GetNextLink'
    // TODO: Method 'SetLinkUpdateOptions'
    // TODO: Method 'GetLinkUpdateOptions'
    // TODO: Method 'SetLinkSource'
    // TODO: Method 'GetLinkSource'
    // TODO: Method 'OpenLinkSource'
    // TODO: Method 'UpdateLink'
    // TODO: Method 'CancelLink'
};
// --------------------------------------------------------
// Type: IOleUILinkContainerA
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IOleUILinkContainerA = *opaque{
    // TODO: Method 'GetNextLink'
    // TODO: Method 'SetLinkUpdateOptions'
    // TODO: Method 'GetLinkUpdateOptions'
    // TODO: Method 'SetLinkSource'
    // TODO: Method 'GetLinkSource'
    // TODO: Method 'OpenLinkSource'
    // TODO: Method 'UpdateLink'
    // TODO: Method 'CancelLink'
};
// --------------------------------------------------------
// Type: OLEUIEDITLINKSW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const OLEUIEDITLINKSW = extern struct {
    cbStruct: u32,
    dwFlags: u32,
    hWndOwner: HWND,
    lpszCaption: ?*u16,
    lpfnHook: LPFNOLEUIHOOK,
    lCustData: LPARAM,
    hInstance: HINSTANCE,
    lpszTemplate: ?*u16,
    hResource: ?*opaque{},
    lpOleUILinkContainer: IOleUILinkContainerW,
};
// --------------------------------------------------------
// Type: OLEUIEDITLINKSA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const OLEUIEDITLINKSA = extern struct {
    cbStruct: u32,
    dwFlags: u32,
    hWndOwner: HWND,
    lpszCaption: ?*i8,
    lpfnHook: LPFNOLEUIHOOK,
    lCustData: LPARAM,
    hInstance: HINSTANCE,
    lpszTemplate: ?*i8,
    hResource: ?*opaque{},
    lpOleUILinkContainer: IOleUILinkContainerA,
};
// --------------------------------------------------------
// Type: OLEUICHANGEICONW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const OLEUICHANGEICONW = extern struct {
    cbStruct: u32,
    dwFlags: u32,
    hWndOwner: HWND,
    lpszCaption: ?*u16,
    lpfnHook: LPFNOLEUIHOOK,
    lCustData: LPARAM,
    hInstance: HINSTANCE,
    lpszTemplate: ?*u16,
    hResource: ?*opaque{},
    hMetaPict: ?*opaque{},
    clsid: Guid,
    szIconExe: ?[*]u16,
    cchIconExe: i32,
};
// --------------------------------------------------------
// Type: OLEUICHANGEICONA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const OLEUICHANGEICONA = extern struct {
    cbStruct: u32,
    dwFlags: u32,
    hWndOwner: HWND,
    lpszCaption: ?*i8,
    lpfnHook: LPFNOLEUIHOOK,
    lCustData: LPARAM,
    hInstance: HINSTANCE,
    lpszTemplate: ?*i8,
    hResource: ?*opaque{},
    hMetaPict: ?*opaque{},
    clsid: Guid,
    szIconExe: ?[*]i8,
    cchIconExe: i32,
};
// --------------------------------------------------------
// Type: OLEUICONVERTW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const OLEUICONVERTW = extern struct {
    cbStruct: u32,
    dwFlags: u32,
    hWndOwner: HWND,
    lpszCaption: ?*u16,
    lpfnHook: LPFNOLEUIHOOK,
    lCustData: LPARAM,
    hInstance: HINSTANCE,
    lpszTemplate: ?*u16,
    hResource: ?*opaque{},
    clsid: Guid,
    clsidConvertDefault: Guid,
    clsidActivateDefault: Guid,
    clsidNew: Guid,
    dvAspect: u32,
    wFormat: u16,
    fIsLinkedObject: BOOL,
    hMetaPict: ?*opaque{},
    lpszUserType: ?*u16,
    fObjectsIconChanged: BOOL,
    lpszDefLabel: ?*u16,
    cClsidExclude: u32,
    lpClsidExclude: ?*Guid,
};
// --------------------------------------------------------
// Type: OLEUICONVERTA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const OLEUICONVERTA = extern struct {
    cbStruct: u32,
    dwFlags: u32,
    hWndOwner: HWND,
    lpszCaption: ?*i8,
    lpfnHook: LPFNOLEUIHOOK,
    lCustData: LPARAM,
    hInstance: HINSTANCE,
    lpszTemplate: ?*i8,
    hResource: ?*opaque{},
    clsid: Guid,
    clsidConvertDefault: Guid,
    clsidActivateDefault: Guid,
    clsidNew: Guid,
    dvAspect: u32,
    wFormat: u16,
    fIsLinkedObject: BOOL,
    hMetaPict: ?*opaque{},
    lpszUserType: ?*i8,
    fObjectsIconChanged: BOOL,
    lpszDefLabel: ?*i8,
    cClsidExclude: u32,
    lpClsidExclude: ?*Guid,
};
// --------------------------------------------------------
// Type: OLEUIBUSYW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const OLEUIBUSYW = extern struct {
    cbStruct: u32,
    dwFlags: u32,
    hWndOwner: HWND,
    lpszCaption: ?*u16,
    lpfnHook: LPFNOLEUIHOOK,
    lCustData: LPARAM,
    hInstance: HINSTANCE,
    lpszTemplate: ?*u16,
    hResource: ?*opaque{},
    hTask: ?*opaque{},
    lphWndDialog: ?*HWND,
};
// --------------------------------------------------------
// Type: OLEUIBUSYA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const OLEUIBUSYA = extern struct {
    cbStruct: u32,
    dwFlags: u32,
    hWndOwner: HWND,
    lpszCaption: ?*i8,
    lpfnHook: LPFNOLEUIHOOK,
    lCustData: LPARAM,
    hInstance: HINSTANCE,
    lpszTemplate: ?*i8,
    hResource: ?*opaque{},
    hTask: ?*opaque{},
    lphWndDialog: ?*HWND,
};
// --------------------------------------------------------
// Type: OLEUICHANGESOURCEW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const OLEUICHANGESOURCEW = extern struct {
    cbStruct: u32,
    dwFlags: u32,
    hWndOwner: HWND,
    lpszCaption: ?*u16,
    lpfnHook: LPFNOLEUIHOOK,
    lCustData: LPARAM,
    hInstance: HINSTANCE,
    lpszTemplate: ?*u16,
    hResource: ?*opaque{},
    lpOFN: ?*OPENFILENAMEW,
    dwReserved1: ?[*]u32,
    lpOleUILinkContainer: IOleUILinkContainerW,
    dwLink: u32,
    lpszDisplayName: ?*u16,
    nFileLength: u32,
    lpszFrom: ?*u16,
    lpszTo: ?*u16,
};
// --------------------------------------------------------
// Type: OLEUICHANGESOURCEA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const OLEUICHANGESOURCEA = extern struct {
    cbStruct: u32,
    dwFlags: u32,
    hWndOwner: HWND,
    lpszCaption: ?*i8,
    lpfnHook: LPFNOLEUIHOOK,
    lCustData: LPARAM,
    hInstance: HINSTANCE,
    lpszTemplate: ?*i8,
    hResource: ?*opaque{},
    lpOFN: ?*OPENFILENAMEA,
    dwReserved1: ?[*]u32,
    lpOleUILinkContainer: IOleUILinkContainerA,
    dwLink: u32,
    lpszDisplayName: ?*i8,
    nFileLength: u32,
    lpszFrom: ?*i8,
    lpszTo: ?*i8,
};
// --------------------------------------------------------
// Type: IOleUIObjInfoW
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IOleUIObjInfoW = *opaque{
    // TODO: Method 'GetObjectInfo'
    // TODO: Method 'GetConvertInfo'
    // TODO: Method 'ConvertObject'
    // TODO: Method 'GetViewInfo'
    // TODO: Method 'SetViewInfo'
};
// --------------------------------------------------------
// Type: IOleUIObjInfoA
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IOleUIObjInfoA = *opaque{
    // TODO: Method 'GetObjectInfo'
    // TODO: Method 'GetConvertInfo'
    // TODO: Method 'ConvertObject'
    // TODO: Method 'GetViewInfo'
    // TODO: Method 'SetViewInfo'
};
// --------------------------------------------------------
// Type: IOleUILinkInfoW
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IOleUILinkInfoW = *opaque{
    // TODO: Method 'GetLastUpdate'
};
// --------------------------------------------------------
// Type: IOleUILinkInfoA
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IOleUILinkInfoA = *opaque{
    // TODO: Method 'GetLastUpdate'
};
// --------------------------------------------------------
// Type: OLEUIGNRLPROPSW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const OLEUIGNRLPROPSW = extern struct {
    cbStruct: u32,
    dwFlags: u32,
    dwReserved1: ?[*]u32,
    lpfnHook: LPFNOLEUIHOOK,
    lCustData: LPARAM,
    dwReserved2: ?[*]u32,
    lpOP: ?*OLEUIOBJECTPROPSW,
};
// --------------------------------------------------------
// Type: OLEUIGNRLPROPSA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const OLEUIGNRLPROPSA = extern struct {
    cbStruct: u32,
    dwFlags: u32,
    dwReserved1: ?[*]u32,
    lpfnHook: LPFNOLEUIHOOK,
    lCustData: LPARAM,
    dwReserved2: ?[*]u32,
    lpOP: ?*OLEUIOBJECTPROPSA,
};
// --------------------------------------------------------
// Type: OLEUIVIEWPROPSW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const OLEUIVIEWPROPSW = extern struct {
    cbStruct: u32,
    dwFlags: u32,
    dwReserved1: ?[*]u32,
    lpfnHook: LPFNOLEUIHOOK,
    lCustData: LPARAM,
    dwReserved2: ?[*]u32,
    lpOP: ?*OLEUIOBJECTPROPSW,
    nScaleMin: i32,
    nScaleMax: i32,
};
// --------------------------------------------------------
// Type: OLEUIVIEWPROPSA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const OLEUIVIEWPROPSA = extern struct {
    cbStruct: u32,
    dwFlags: u32,
    dwReserved1: ?[*]u32,
    lpfnHook: LPFNOLEUIHOOK,
    lCustData: LPARAM,
    dwReserved2: ?[*]u32,
    lpOP: ?*OLEUIOBJECTPROPSA,
    nScaleMin: i32,
    nScaleMax: i32,
};
// --------------------------------------------------------
// Type: OLEUILINKPROPSW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const OLEUILINKPROPSW = extern struct {
    cbStruct: u32,
    dwFlags: u32,
    dwReserved1: ?[*]u32,
    lpfnHook: LPFNOLEUIHOOK,
    lCustData: LPARAM,
    dwReserved2: ?[*]u32,
    lpOP: ?*OLEUIOBJECTPROPSW,
};
// --------------------------------------------------------
// Type: OLEUILINKPROPSA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const OLEUILINKPROPSA = extern struct {
    cbStruct: u32,
    dwFlags: u32,
    dwReserved1: ?[*]u32,
    lpfnHook: LPFNOLEUIHOOK,
    lCustData: LPARAM,
    dwReserved2: ?[*]u32,
    lpOP: ?*OLEUIOBJECTPROPSA,
};
// --------------------------------------------------------
// Type: OLEUIOBJECTPROPSW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const OLEUIOBJECTPROPSW = extern struct {
    cbStruct: u32,
    dwFlags: u32,
    lpPS: ?*PROPSHEETHEADERW_V2,
    dwObject: u32,
    lpObjInfo: IOleUIObjInfoW,
    dwLink: u32,
    lpLinkInfo: IOleUILinkInfoW,
    lpGP: ?*OLEUIGNRLPROPSW,
    lpVP: ?*OLEUIVIEWPROPSW,
    lpLP: ?*OLEUILINKPROPSW,
};
// --------------------------------------------------------
// Type: OLEUIOBJECTPROPSA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const OLEUIOBJECTPROPSA = extern struct {
    cbStruct: u32,
    dwFlags: u32,
    lpPS: ?*PROPSHEETHEADERA_V2,
    dwObject: u32,
    lpObjInfo: IOleUIObjInfoA,
    dwLink: u32,
    lpLinkInfo: IOleUILinkInfoA,
    lpGP: ?*OLEUIGNRLPROPSA,
    lpVP: ?*OLEUIVIEWPROPSA,
    lpLP: ?*OLEUILINKPROPSA,
};
// --------------------------------------------------------
// Type: CALLFRAMEINFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CALLFRAMEINFO = extern struct {
    iMethod: u32,
    fHasInValues: BOOL,
    fHasInOutValues: BOOL,
    fHasOutValues: BOOL,
    fDerivesFromIDispatch: BOOL,
    cInInterfacesMax: i32,
    cInOutInterfacesMax: i32,
    cOutInterfacesMax: i32,
    cTopLevelInInterfaces: i32,
    iid: Guid,
    cMethod: u32,
    cParams: u32,
};
// --------------------------------------------------------
// Type: CALLFRAMEPARAMINFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CALLFRAMEPARAMINFO = extern struct {
    fIn: u8,
    fOut: u8,
    stackOffset: u32,
    cbParam: u32,
};
// --------------------------------------------------------
// Type: CALLFRAME_COPY
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const CALLFRAME_COPY = *opaque{
};
// --------------------------------------------------------
// Type: CALLFRAME_FREE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const CALLFRAME_FREE = *opaque{
};
// --------------------------------------------------------
// Type: CALLFRAME_NULL
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const CALLFRAME_NULL = *opaque{
};
// --------------------------------------------------------
// Type: CALLFRAME_WALK
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const CALLFRAME_WALK = *opaque{
};
// --------------------------------------------------------
// Type: CALLFRAME_MARSHALCONTEXT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CALLFRAME_MARSHALCONTEXT = extern struct {
    fIn: u8,
    dwDestContext: u32,
    pvDestContext: ?*opaque{},
    punkReserved: IUnknown,
    guidTransferSyntax: Guid,
};
// --------------------------------------------------------
// Type: ICallFrame
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ICallFrame = *opaque{
    // TODO: Method 'GetInfo'
    // TODO: Method 'GetIIDAndMethod'
    // TODO: Method 'GetNames'
    // TODO: Method 'GetStackLocation'
    // TODO: Method 'SetStackLocation'
    // TODO: Method 'SetReturnValue'
    // TODO: Method 'GetReturnValue'
    // TODO: Method 'GetParamInfo'
    // TODO: Method 'SetParam'
    // TODO: Method 'GetParam'
    // TODO: Method 'Copy'
    // TODO: Method 'Free'
    // TODO: Method 'FreeParam'
    // TODO: Method 'WalkFrame'
    // TODO: Method 'GetMarshalSizeMax'
    // TODO: Method 'Marshal'
    // TODO: Method 'Unmarshal'
    // TODO: Method 'ReleaseMarshalData'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: ICallIndirect
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ICallIndirect = *opaque{
    // TODO: Method 'CallIndirect'
    // TODO: Method 'GetMethodInfo'
    // TODO: Method 'GetStackSize'
    // TODO: Method 'GetIID'
};
// --------------------------------------------------------
// Type: ICallInterceptor
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ICallInterceptor = *opaque{
    // TODO: Method 'RegisterSink'
    // TODO: Method 'GetRegisteredSink'
};
// --------------------------------------------------------
// Type: ICallFrameEvents
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ICallFrameEvents = *opaque{
    // TODO: Method 'OnCall'
};
// --------------------------------------------------------
// Type: ICallUnmarshal
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ICallUnmarshal = *opaque{
    // TODO: Method 'Unmarshal'
    // TODO: Method 'ReleaseMarshalData'
};
// --------------------------------------------------------
// Type: ICallFrameWalker
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ICallFrameWalker = *opaque{
    // TODO: Method 'OnWalkInterface'
};
// --------------------------------------------------------
// Type: IInterfaceRelated
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IInterfaceRelated = *opaque{
    // TODO: Method 'SetIID'
    // TODO: Method 'GetIID'
};
// --------------------------------------------------------
// Type: RECORD_READING_POLICY
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const RECORD_READING_POLICY = *opaque{
};
// --------------------------------------------------------
// Type: ILog
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ILog = *opaque{
    // TODO: Method 'Force'
    // TODO: Method 'AppendRecord'
    // TODO: Method 'ReadRecord'
    // TODO: Method 'ReadRecordPrefix'
    // TODO: Method 'GetLogLimits'
    // TODO: Method 'TruncatePrefix'
    // TODO: Method 'SetAccessPolicyHint'
};
// --------------------------------------------------------
// Type: IFileBasedLogInit
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IFileBasedLogInit = *opaque{
    // TODO: Method 'InitNew'
};
// --------------------------------------------------------
// Type: IEnumGUID
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IEnumGUID = *opaque{
    // TODO: Method 'Next'
    // TODO: Method 'Skip'
    // TODO: Method 'Reset'
    // TODO: Method 'Clone'
};
// --------------------------------------------------------
// Type: CATEGORYINFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CATEGORYINFO = extern struct {
    catid: Guid,
    lcid: u32,
    szDescription: ?[*]u16,
};
// --------------------------------------------------------
// Type: IEnumCATEGORYINFO
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IEnumCATEGORYINFO = *opaque{
    // TODO: Method 'Next'
    // TODO: Method 'Skip'
    // TODO: Method 'Reset'
    // TODO: Method 'Clone'
};
// --------------------------------------------------------
// Type: ICatRegister
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ICatRegister = *opaque{
    // TODO: Method 'RegisterCategories'
    // TODO: Method 'UnRegisterCategories'
    // TODO: Method 'RegisterClassImplCategories'
    // TODO: Method 'UnRegisterClassImplCategories'
    // TODO: Method 'RegisterClassReqCategories'
    // TODO: Method 'UnRegisterClassReqCategories'
};
// --------------------------------------------------------
// Type: ICatInformation
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const ICatInformation = *opaque{
    // TODO: Method 'EnumCategories'
    // TODO: Method 'GetCategoryDesc'
    // TODO: Method 'EnumClassesOfCategories'
    // TODO: Method 'IsClassOfCategories'
    // TODO: Method 'EnumImplCategoriesOfClass'
    // TODO: Method 'EnumReqCategoriesOfClass'
};
// --------------------------------------------------------
// Type: IAccessControl
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IAccessControl = *opaque{
    // TODO: Method 'GrantAccessRights'
    // TODO: Method 'SetAccessRights'
    // TODO: Method 'SetOwner'
    // TODO: Method 'RevokeAccessRights'
    // TODO: Method 'GetAllAccessRights'
    // TODO: Method 'IsAccessAllowed'
};
// --------------------------------------------------------
// Type: IAuditControl
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IAuditControl = *opaque{
    // TODO: Method 'GrantAuditRights'
    // TODO: Method 'SetAuditRights'
    // TODO: Method 'RevokeAuditRights'
    // TODO: Method 'GetAllAuditRights'
    // TODO: Method 'IsAccessAudited'
};
// --------------------------------------------------------
// Type: ComCallData
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const ComCallData = extern struct {
    dwDispid: u32,
    dwReserved: u32,
    pUserDefined: ?*opaque{},
};
// --------------------------------------------------------
// Type: PFNCONTEXTCALL
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PFNCONTEXTCALL = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: IContextCallback
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IContextCallback = *opaque{
    // TODO: Method 'ContextCallback'
};
// --------------------------------------------------------
// Type: IMessageDispatcher
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IMessageDispatcher = *opaque{
    // TODO: Method 'PumpMessages'
};
// --------------------------------------------------------
// Type: IAccessibilityDockingServiceCallback
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IAccessibilityDockingServiceCallback = *opaque{
    // TODO: Method 'Undocked'
};
// --------------------------------------------------------
// Type: IAccessibilityDockingService
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IAccessibilityDockingService = *opaque{
    // TODO: Method 'GetAvailableSize'
    // TODO: Method 'DockWindow'
    // TODO: Method 'UndockWindow'
};
// --------------------------------------------------------
// Type: HRESULT
// TypeLayoutAttr: sequential
pub const HRESULT = i32;
// --------------------------------------------------------
// Type: COINIT
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const COINIT = *opaque{
};
// --------------------------------------------------------
// Type: COMSD
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const COMSD = *opaque{
};
// --------------------------------------------------------
// Type: DVASPECT
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const DVASPECT = *opaque{
};
// --------------------------------------------------------
// Type: CSPLATFORM
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const CSPLATFORM = extern struct {
    dwPlatformId: u32,
    dwVersionHi: u32,
    dwVersionLo: u32,
    dwProcessorArch: u32,
};
// --------------------------------------------------------
// Type: QUERYCONTEXT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const QUERYCONTEXT = extern struct {
    dwContext: u32,
    Platform: CSPLATFORM,
    Locale: u32,
    dwVersionHi: u32,
    dwVersionLo: u32,
};
// --------------------------------------------------------
// Type: TYSPEC
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const TYSPEC = *opaque{
};
// --------------------------------------------------------
// Type: ACTRL_ACCESS_ENTRYA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const ACTRL_ACCESS_ENTRYA = extern struct {
    Trustee: TRUSTEE_A,
    fAccessFlags: u32,
    Access: u32,
    ProvSpecificAccess: u32,
    Inheritance: u32,
    lpInheritProperty: ?*i8,
};
// --------------------------------------------------------
// Type: ACTRL_ACCESS_ENTRYW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const ACTRL_ACCESS_ENTRYW = extern struct {
    Trustee: TRUSTEE_W,
    fAccessFlags: u32,
    Access: u32,
    ProvSpecificAccess: u32,
    Inheritance: u32,
    lpInheritProperty: ?*u16,
};
// --------------------------------------------------------
// Type: ACTRL_ACCESS_ENTRY_LISTA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const ACTRL_ACCESS_ENTRY_LISTA = extern struct {
    cEntries: u32,
    pAccessList: ?*ACTRL_ACCESS_ENTRYA,
};
// --------------------------------------------------------
// Type: ACTRL_ACCESS_ENTRY_LISTW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const ACTRL_ACCESS_ENTRY_LISTW = extern struct {
    cEntries: u32,
    pAccessList: ?*ACTRL_ACCESS_ENTRYW,
};
// --------------------------------------------------------
// Type: ACTRL_PROPERTY_ENTRYA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const ACTRL_PROPERTY_ENTRYA = extern struct {
    lpProperty: ?*i8,
    pAccessEntryList: ?*ACTRL_ACCESS_ENTRY_LISTA,
    fListFlags: u32,
};
// --------------------------------------------------------
// Type: ACTRL_PROPERTY_ENTRYW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const ACTRL_PROPERTY_ENTRYW = extern struct {
    lpProperty: ?*u16,
    pAccessEntryList: ?*ACTRL_ACCESS_ENTRY_LISTW,
    fListFlags: u32,
};
// --------------------------------------------------------
// Type: ACTRL_ACCESSA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const ACTRL_ACCESSA = extern struct {
    cEntries: u32,
    pPropertyAccessList: ?*ACTRL_PROPERTY_ENTRYA,
};
// --------------------------------------------------------
// Type: ACTRL_ACCESSW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const ACTRL_ACCESSW = extern struct {
    cEntries: u32,
    pPropertyAccessList: ?*ACTRL_PROPERTY_ENTRYW,
};
// --------------------------------------------------------
// Type: IEventPublisher
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IEventPublisher = *opaque{
    // TODO: Method 'get_PublisherID'
    // TODO: Method 'put_PublisherID'
    // TODO: Method 'get_PublisherName'
    // TODO: Method 'put_PublisherName'
    // TODO: Method 'get_PublisherType'
    // TODO: Method 'put_PublisherType'
    // TODO: Method 'get_OwnerSID'
    // TODO: Method 'put_OwnerSID'
    // TODO: Method 'get_Description'
    // TODO: Method 'put_Description'
    // TODO: Method 'GetDefaultProperty'
    // TODO: Method 'PutDefaultProperty'
    // TODO: Method 'RemoveDefaultProperty'
    // TODO: Method 'GetDefaultPropertyCollection'
};
// --------------------------------------------------------
// Type: EOC_ChangeType
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const EOC_ChangeType = *opaque{
};
// --------------------------------------------------------
// Type: IEventProperty
// TypeLayoutAttr: auto
// not generating the actual code for this type because its an abstract type (probably a COM type?)
pub const IEventProperty = *opaque{
    // TODO: Method 'get_Name'
    // TODO: Method 'put_Name'
    // TODO: Method 'get_Value'
    // TODO: Method 'put_Value'
};

//
// functions
//

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn CoGetMalloc(
    dwMemContext: u32,
    ppMalloc: ?*IMalloc,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn CoUninitialize(
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn CoGetCurrentProcess(
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn CoInitializeEx(
    pvReserved: ?*opaque{},
    dwCoInit: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn CoGetCallerTID(
    lpdwTID: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn CoGetCurrentLogicalThreadId(
    pguid: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn CoGetContextToken(
    pToken: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn CoGetApartmentType(
    pAptType: ?*APTTYPE,
    pAptQualifier: ?*APTTYPEQUALIFIER,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn CoIncrementMTAUsage(
    pCookie: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn CoDecrementMTAUsage(
    Cookie: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn CoAllowUnmarshalerCLSID(
    clsid: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn CoGetObjectContext(
    riid: ?*Guid,
    ppv: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn CoGetClassObject(
    rclsid: ?*Guid,
    dwClsContext: u32,
    pvReserved: ?*opaque{},
    riid: ?*Guid,
    ppv: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn CoRegisterClassObject(
    rclsid: ?*Guid,
    pUnk: IUnknown,
    dwClsContext: u32,
    flags: u32,
    lpdwRegister: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn CoRevokeClassObject(
    dwRegister: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn CoResumeClassObjects(
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn CoSuspendClassObjects(
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn CoAddRefServerProcess(
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn CoReleaseServerProcess(
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn CoGetPSClsid(
    riid: ?*Guid,
    pClsid: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn CoRegisterPSClsid(
    riid: ?*Guid,
    rclsid: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn CoRegisterSurrogate(
    pSurrogate: ISurrogate,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn CoGetMarshalSizeMax(
    pulSize: ?*u32,
    riid: ?*Guid,
    pUnk: IUnknown,
    dwDestContext: u32,
    pvDestContext: ?*opaque{},
    mshlflags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn CoMarshalInterface(
    pStm: IStream,
    riid: ?*Guid,
    pUnk: IUnknown,
    dwDestContext: u32,
    pvDestContext: ?*opaque{},
    mshlflags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn CoUnmarshalInterface(
    pStm: IStream,
    riid: ?*Guid,
    ppv: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn CoMarshalHresult(
    pstm: IStream,
    hresult: HRESULT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn CoUnmarshalHresult(
    pstm: IStream,
    phresult: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn CoReleaseMarshalData(
    pStm: IStream,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn CoDisconnectObject(
    pUnk: IUnknown,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn CoLockObjectExternal(
    pUnk: IUnknown,
    fLock: BOOL,
    fLastUnlockReleases: BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn CoGetStandardMarshal(
    riid: ?*Guid,
    pUnk: IUnknown,
    dwDestContext: u32,
    pvDestContext: ?*opaque{},
    mshlflags: u32,
    ppMarshal: ?*IMarshal,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn CoGetStdMarshalEx(
    pUnkOuter: IUnknown,
    smexflags: u32,
    ppUnkInner: ?*IUnknown,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn CoIsHandlerConnected(
    pUnk: IUnknown,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn CoMarshalInterThreadInterfaceInStream(
    riid: ?*Guid,
    pUnk: IUnknown,
    ppStm: ?*IStream,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn CoGetInterfaceAndReleaseStream(
    pStm: IStream,
    iid: ?*Guid,
    ppv: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn CoCreateFreeThreadedMarshaler(
    punkOuter: IUnknown,
    ppunkMarshal: ?*IUnknown,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn CoFreeUnusedLibraries(
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn CoFreeUnusedLibrariesEx(
    dwUnloadDelay: u32,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn CoDisconnectContext(
    dwTimeout: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn CoInitializeSecurity(
    pSecDesc: ?*opaque{},
    cAuthSvc: i32,
    asAuthSvc: ?*SOLE_AUTHENTICATION_SERVICE,
    pReserved1: ?*opaque{},
    dwAuthnLevel: u32,
    dwImpLevel: u32,
    pAuthList: ?*opaque{},
    dwCapabilities: u32,
    pReserved3: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn CoGetCallContext(
    riid: ?*Guid,
    ppInterface: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn CoQueryProxyBlanket(
    pProxy: IUnknown,
    pwAuthnSvc: ?*u32,
    pAuthzSvc: ?*u32,
    pServerPrincName: ?*?*u16,
    pAuthnLevel: ?*u32,
    pImpLevel: ?*u32,
    pAuthInfo: ?*?*opaque{},
    pCapabilites: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn CoSetProxyBlanket(
    pProxy: IUnknown,
    dwAuthnSvc: u32,
    dwAuthzSvc: u32,
    pServerPrincName: ?*u16,
    dwAuthnLevel: u32,
    dwImpLevel: u32,
    pAuthInfo: ?*opaque{},
    dwCapabilities: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn CoCopyProxy(
    pProxy: IUnknown,
    ppCopy: ?*IUnknown,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn CoQueryClientBlanket(
    pAuthnSvc: ?*u32,
    pAuthzSvc: ?*u32,
    pServerPrincName: ?*?*u16,
    pAuthnLevel: ?*u32,
    pImpLevel: ?*u32,
    pPrivs: ?*?*opaque{},
    pCapabilities: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn CoImpersonateClient(
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn CoRevertToSelf(
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn CoQueryAuthenticationServices(
    pcAuthSvc: ?*u32,
    asAuthSvc: ?*?*SOLE_AUTHENTICATION_SERVICE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn CoSwitchCallContext(
    pNewObject: IUnknown,
    ppOldObject: ?*IUnknown,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn CoCreateInstance(
    rclsid: ?*Guid,
    pUnkOuter: IUnknown,
    dwClsContext: u32,
    riid: ?*Guid,
    ppv: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn CoCreateInstanceEx(
    Clsid: ?*Guid,
    punkOuter: IUnknown,
    dwClsCtx: u32,
    pServerInfo: ?*COSERVERINFO,
    dwCount: u32,
    pResults: ?*MULTI_QI,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn CoCreateInstanceFromApp(
    Clsid: ?*Guid,
    punkOuter: IUnknown,
    dwClsCtx: u32,
    reserved: ?*opaque{},
    dwCount: u32,
    pResults: ?*MULTI_QI,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn CoRegisterActivationFilter(
    pActivationFilter: IActivationFilter,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn CoGetCancelObject(
    dwThreadId: u32,
    iid: ?*Guid,
    ppUnk: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn CoSetCancelObject(
    pUnk: IUnknown,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn CoCancelCall(
    dwThreadId: u32,
    ulTimeout: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn CoTestCancel(
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn CoEnableCallCancellation(
    pReserved: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn CoDisableCallCancellation(
    pReserved: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn StringFromCLSID(
    rclsid: ?*Guid,
    lplpsz: ?*?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn CLSIDFromString(
    lpsz: ?*u16,
    pclsid: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn StringFromIID(
    rclsid: ?*Guid,
    lplpsz: ?*?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn IIDFromString(
    lpsz: ?*u16,
    lpiid: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn ProgIDFromCLSID(
    clsid: ?*Guid,
    lplpszProgID: ?*?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn CLSIDFromProgID(
    lpszProgID: ?*u16,
    lpclsid: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn StringFromGUID2(
    rguid: ?*Guid,
    lpsz: ?*u16,
    cchMax: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn CoCreateGuid(
    pguid: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn CoWaitForMultipleHandles(
    dwFlags: u32,
    dwTimeout: u32,
    cHandles: u32,
    pHandles: ?*?*opaque{},
    lpdwindex: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn CoWaitForMultipleObjects(
    dwFlags: u32,
    dwTimeout: u32,
    cHandles: u32,
    pHandles: ?*?*opaque{},
    lpdwindex: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn CoGetTreatAsClass(
    clsidOld: ?*Guid,
    pClsidNew: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn CoInvalidateRemoteMachineBindings(
    pszMachineName: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn CoTaskMemAlloc(
    cb: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn CoTaskMemRealloc(
    pv: ?*opaque{},
    cb: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn CoTaskMemFree(
    pv: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn CoFileTimeNow(
    lpFileTime: ?*FILETIME,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn CLSIDFromProgIDEx(
    lpszProgID: ?*u16,
    lpclsid: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn CoRegisterDeviceCatalog(
    deviceInstanceId: ?*u16,
    cookie: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn CoRevokeDeviceCatalog(
    cookie: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn CLIPFORMAT_UserSize(
    param0: ?*u32,
    param1: u32,
    param2: ?*u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn CLIPFORMAT_UserMarshal(
    param0: ?*u32,
    param1: ?*u8,
    param2: ?*u16,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn CLIPFORMAT_UserUnmarshal(
    param0: ?*u32,
    param1: ?*u8,
    param2: ?*u16,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn CLIPFORMAT_UserFree(
    param0: ?*u32,
    param1: ?*u16,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn HBITMAP_UserSize(
    param0: ?*u32,
    param1: u32,
    param2: ?*HBITMAP,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn HBITMAP_UserMarshal(
    param0: ?*u32,
    param1: ?*u8,
    param2: ?*HBITMAP,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn HBITMAP_UserUnmarshal(
    param0: ?*u32,
    param1: ?*u8,
    param2: ?*HBITMAP,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn HBITMAP_UserFree(
    param0: ?*u32,
    param1: ?*HBITMAP,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn HDC_UserSize(
    param0: ?*u32,
    param1: u32,
    param2: ?*HDC,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn HDC_UserMarshal(
    param0: ?*u32,
    param1: ?*u8,
    param2: ?*HDC,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn HDC_UserUnmarshal(
    param0: ?*u32,
    param1: ?*u8,
    param2: ?*HDC,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn HDC_UserFree(
    param0: ?*u32,
    param1: ?*HDC,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn HICON_UserSize(
    param0: ?*u32,
    param1: u32,
    param2: ?*HICON,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn HICON_UserMarshal(
    param0: ?*u32,
    param1: ?*u8,
    param2: ?*HICON,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn HICON_UserUnmarshal(
    param0: ?*u32,
    param1: ?*u8,
    param2: ?*HICON,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn HICON_UserFree(
    param0: ?*u32,
    param1: ?*HICON,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "ole32" fn SNB_UserSize(
    param0: ?*u32,
    param1: u32,
    param2: ?*?*?*u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "ole32" fn SNB_UserMarshal(
    param0: ?*u32,
    param1: ?*u8,
    param2: ?*?*?*u16,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

// set_last_errror=False (can and should we use this?)
pub extern "ole32" fn SNB_UserUnmarshal(
    param0: ?*u32,
    param1: ?*u8,
    param2: ?*?*?*u16,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

// set_last_errror=False (can and should we use this?)
pub extern "ole32" fn SNB_UserFree(
    param0: ?*u32,
    param1: ?*?*?*u16,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn CLIPFORMAT_UserSize64(
    param0: ?*u32,
    param1: u32,
    param2: ?*u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn CLIPFORMAT_UserMarshal64(
    param0: ?*u32,
    param1: ?*u8,
    param2: ?*u16,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn CLIPFORMAT_UserUnmarshal64(
    param0: ?*u32,
    param1: ?*u8,
    param2: ?*u16,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn CLIPFORMAT_UserFree64(
    param0: ?*u32,
    param1: ?*u16,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn HBITMAP_UserSize64(
    param0: ?*u32,
    param1: u32,
    param2: ?*HBITMAP,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn HBITMAP_UserMarshal64(
    param0: ?*u32,
    param1: ?*u8,
    param2: ?*HBITMAP,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn HBITMAP_UserUnmarshal64(
    param0: ?*u32,
    param1: ?*u8,
    param2: ?*HBITMAP,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn HBITMAP_UserFree64(
    param0: ?*u32,
    param1: ?*HBITMAP,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn HDC_UserSize64(
    param0: ?*u32,
    param1: u32,
    param2: ?*HDC,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn HDC_UserMarshal64(
    param0: ?*u32,
    param1: ?*u8,
    param2: ?*HDC,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn HDC_UserUnmarshal64(
    param0: ?*u32,
    param1: ?*u8,
    param2: ?*HDC,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn HDC_UserFree64(
    param0: ?*u32,
    param1: ?*HDC,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn HICON_UserSize64(
    param0: ?*u32,
    param1: u32,
    param2: ?*HICON,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn HICON_UserMarshal64(
    param0: ?*u32,
    param1: ?*u8,
    param2: ?*HICON,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn HICON_UserUnmarshal64(
    param0: ?*u32,
    param1: ?*u8,
    param2: ?*HICON,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn HICON_UserFree64(
    param0: ?*u32,
    param1: ?*HICON,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "ole32" fn SNB_UserSize64(
    param0: ?*u32,
    param1: u32,
    param2: ?*?*?*u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "ole32" fn SNB_UserMarshal64(
    param0: ?*u32,
    param1: ?*u8,
    param2: ?*?*?*u16,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

// set_last_errror=False (can and should we use this?)
pub extern "ole32" fn SNB_UserUnmarshal64(
    param0: ?*u32,
    param1: ?*u8,
    param2: ?*?*?*u16,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

// set_last_errror=False (can and should we use this?)
pub extern "ole32" fn SNB_UserFree64(
    param0: ?*u32,
    param1: ?*?*?*u16,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn HACCEL_UserSize(
    param0: ?*u32,
    param1: u32,
    param2: ?*HACCEL,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn HACCEL_UserMarshal(
    param0: ?*u32,
    param1: ?*u8,
    param2: ?*HACCEL,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn HACCEL_UserUnmarshal(
    param0: ?*u32,
    param1: ?*u8,
    param2: ?*HACCEL,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn HACCEL_UserFree(
    param0: ?*u32,
    param1: ?*HACCEL,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn HGLOBAL_UserSize(
    param0: ?*u32,
    param1: u32,
    param2: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn HGLOBAL_UserMarshal(
    param0: ?*u32,
    param1: ?*u8,
    param2: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) ?*u8;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn HGLOBAL_UserUnmarshal(
    param0: ?*u32,
    param1: ?*u8,
    param2: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) ?*u8;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn HGLOBAL_UserFree(
    param0: ?*u32,
    param1: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn HMENU_UserSize(
    param0: ?*u32,
    param1: u32,
    param2: ?*HMENU,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn HMENU_UserMarshal(
    param0: ?*u32,
    param1: ?*u8,
    param2: ?*HMENU,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn HMENU_UserUnmarshal(
    param0: ?*u32,
    param1: ?*u8,
    param2: ?*HMENU,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn HMENU_UserFree(
    param0: ?*u32,
    param1: ?*HMENU,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn HACCEL_UserSize64(
    param0: ?*u32,
    param1: u32,
    param2: ?*HACCEL,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn HACCEL_UserMarshal64(
    param0: ?*u32,
    param1: ?*u8,
    param2: ?*HACCEL,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn HACCEL_UserUnmarshal64(
    param0: ?*u32,
    param1: ?*u8,
    param2: ?*HACCEL,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn HACCEL_UserFree64(
    param0: ?*u32,
    param1: ?*HACCEL,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn HGLOBAL_UserSize64(
    param0: ?*u32,
    param1: u32,
    param2: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn HGLOBAL_UserMarshal64(
    param0: ?*u32,
    param1: ?*u8,
    param2: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) ?*u8;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn HGLOBAL_UserUnmarshal64(
    param0: ?*u32,
    param1: ?*u8,
    param2: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) ?*u8;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn HGLOBAL_UserFree64(
    param0: ?*u32,
    param1: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn HMENU_UserSize64(
    param0: ?*u32,
    param1: u32,
    param2: ?*HMENU,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn HMENU_UserMarshal64(
    param0: ?*u32,
    param1: ?*u8,
    param2: ?*HMENU,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn HMENU_UserUnmarshal64(
    param0: ?*u32,
    param1: ?*u8,
    param2: ?*HMENU,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn HMENU_UserFree64(
    param0: ?*u32,
    param1: ?*HMENU,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "urlmon" fn CreateURLMoniker(
    pMkCtx: IMoniker,
    szURL: ?*u16,
    ppmk: ?*IMoniker,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "urlmon" fn CreateURLMonikerEx(
    pMkCtx: IMoniker,
    szURL: ?*u16,
    ppmk: ?*IMoniker,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "urlmon" fn GetClassURL(
    szURL: ?*u16,
    pClsID: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "urlmon" fn CreateAsyncBindCtx(
    reserved: u32,
    pBSCb: IBindStatusCallback,
    pEFetc: IEnumFORMATETC,
    ppBC: ?*IBindCtx,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "urlmon" fn CreateURLMonikerEx2(
    pMkCtx: IMoniker,
    pUri: IUri,
    ppmk: ?*IMoniker,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "urlmon" fn CreateAsyncBindCtxEx(
    pbc: IBindCtx,
    dwOptions: u32,
    pBSCb: IBindStatusCallback,
    pEnum: IEnumFORMATETC,
    ppBC: ?*IBindCtx,
    reserved: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "urlmon" fn MkParseDisplayNameEx(
    pbc: IBindCtx,
    szDisplayName: ?*u16,
    pchEaten: ?*u32,
    ppmk: ?*IMoniker,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "urlmon" fn RegisterBindStatusCallback(
    pBC: IBindCtx,
    pBSCb: IBindStatusCallback,
    ppBSCBPrev: ?*IBindStatusCallback,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "urlmon" fn RevokeBindStatusCallback(
    pBC: IBindCtx,
    pBSCb: IBindStatusCallback,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "urlmon" fn GetClassFileOrMime(
    pBC: IBindCtx,
    szFilename: ?*u16,
    pBuffer: ?*opaque{},
    cbSize: u32,
    szMime: ?*u16,
    dwReserved: u32,
    pclsid: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "urlmon" fn IsValidURL(
    pBC: IBindCtx,
    szURL: ?*u16,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "urlmon" fn CoGetClassObjectFromURL(
    rCLASSID: ?*Guid,
    szCODE: ?*u16,
    dwFileVersionMS: u32,
    dwFileVersionLS: u32,
    szTYPE: ?*u16,
    pBindCtx: IBindCtx,
    dwClsContext: u32,
    pvReserved: ?*opaque{},
    riid: ?*Guid,
    ppv: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "urlmon" fn IEInstallScope(
    pdwScope: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "urlmon" fn FaultInIEFeature(
    hWnd: HWND,
    pClassSpec: ?*uCLSSPEC,
    pQuery: ?*QUERYCONTEXT,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "urlmon" fn GetComponentIDFromCLSSPEC(
    pClassspec: ?*uCLSSPEC,
    ppszComponentID: ?*?*i8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "urlmon" fn IsAsyncMoniker(
    pmk: IMoniker,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "urlmon" fn RegisterMediaTypes(
    ctypes: u32,
    rgszTypes: ?*?*i8,
    rgcfTypes: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "urlmon" fn FindMediaType(
    rgszTypes: ?*i8,
    rgcfTypes: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "urlmon" fn CreateFormatEnumerator(
    cfmtetc: u32,
    rgfmtetc: ?*FORMATETC,
    ppenumfmtetc: ?*IEnumFORMATETC,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "urlmon" fn RegisterFormatEnumerator(
    pBC: IBindCtx,
    pEFetc: IEnumFORMATETC,
    reserved: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "urlmon" fn RevokeFormatEnumerator(
    pBC: IBindCtx,
    pEFetc: IEnumFORMATETC,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "urlmon" fn RegisterMediaTypeClass(
    pBC: IBindCtx,
    ctypes: u32,
    rgszTypes: ?*?*i8,
    rgclsID: ?*Guid,
    reserved: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "urlmon" fn FindMediaTypeClass(
    pBC: IBindCtx,
    szType: ?*i8,
    pclsID: ?*Guid,
    reserved: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "urlmon" fn UrlMkSetSessionOption(
    dwOption: u32,
    pBuffer: ?*opaque{},
    dwBufferLength: u32,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "urlmon" fn UrlMkGetSessionOption(
    dwOption: u32,
    pBuffer: ?*opaque{},
    dwBufferLength: u32,
    pdwBufferLengthOut: ?*u32,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "urlmon" fn FindMimeFromData(
    pBC: IBindCtx,
    pwzUrl: ?*u16,
    pBuffer: ?*opaque{},
    cbSize: u32,
    pwzMimeProposed: ?*u16,
    dwMimeFlags: u32,
    ppwzMimeOut: ?*?*u16,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "urlmon" fn ObtainUserAgentString(
    dwOption: u32,
    pszUAOut: ?*i8,
    cbSize: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "urlmon" fn CompareSecurityIds(
    pbSecurityId1: ?*u8,
    dwLen1: u32,
    pbSecurityId2: ?*u8,
    dwLen2: u32,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "urlmon" fn CompatFlagsFromClsid(
    pclsid: ?*Guid,
    pdwCompatFlags: ?*u32,
    pdwMiscStatusFlags: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "urlmon" fn SetAccessForIEAppContainer(
    hObject: HANDLE,
    ieObjectType: IEObjectType,
    dwAccessMask: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "URLMON" fn CreateUri(
    pwzURI: ?*u16,
    dwFlags: u32,
    dwReserved: ?*opaque{},
    ppURI: ?*IUri,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "URLMON" fn CreateUriWithFragment(
    pwzURI: ?*u16,
    pwzFragment: ?*u16,
    dwFlags: u32,
    dwReserved: ?*opaque{},
    ppURI: ?*IUri,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "urlmon" fn CreateUriFromMultiByteString(
    pszANSIInputUri: ?*i8,
    dwEncodingFlags: u32,
    dwCodePage: u32,
    dwCreateFlags: u32,
    dwReserved: ?*opaque{},
    ppUri: ?*IUri,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "URLMON" fn CreateIUriBuilder(
    pIUri: IUri,
    dwFlags: u32,
    dwReserved: ?*opaque{},
    ppIUriBuilder: ?*IUriBuilder,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "urlmon" fn HlinkSimpleNavigateToString(
    szTarget: ?*u16,
    szLocation: ?*u16,
    szTargetFrameName: ?*u16,
    pUnk: IUnknown,
    pbc: IBindCtx,
    param5: IBindStatusCallback,
    grfHLNF: u32,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "urlmon" fn HlinkSimpleNavigateToMoniker(
    pmkTarget: IMoniker,
    szLocation: ?*u16,
    szTargetFrameName: ?*u16,
    pUnk: IUnknown,
    pbc: IBindCtx,
    param5: IBindStatusCallback,
    grfHLNF: u32,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "urlmon" fn URLOpenStreamA(
    param0: IUnknown,
    param1: ?*i8,
    param2: u32,
    param3: IBindStatusCallback,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "urlmon" fn URLOpenStreamW(
    param0: IUnknown,
    param1: ?*u16,
    param2: u32,
    param3: IBindStatusCallback,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "urlmon" fn URLOpenPullStreamA(
    param0: IUnknown,
    param1: ?*i8,
    param2: u32,
    param3: IBindStatusCallback,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "urlmon" fn URLOpenPullStreamW(
    param0: IUnknown,
    param1: ?*u16,
    param2: u32,
    param3: IBindStatusCallback,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "urlmon" fn URLDownloadToFileA(
    param0: IUnknown,
    param1: ?*i8,
    param2: ?*i8,
    param3: u32,
    param4: IBindStatusCallback,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "urlmon" fn URLDownloadToFileW(
    param0: IUnknown,
    param1: ?*u16,
    param2: ?*u16,
    param3: u32,
    param4: IBindStatusCallback,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "urlmon" fn URLDownloadToCacheFileA(
    param0: IUnknown,
    param1: ?*i8,
    param2: ?*i8,
    cchFileName: u32,
    param4: u32,
    param5: IBindStatusCallback,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "urlmon" fn URLDownloadToCacheFileW(
    param0: IUnknown,
    param1: ?*u16,
    param2: ?*u16,
    cchFileName: u32,
    param4: u32,
    param5: IBindStatusCallback,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "urlmon" fn URLOpenBlockingStreamA(
    param0: IUnknown,
    param1: ?*i8,
    param2: ?*IStream,
    param3: u32,
    param4: IBindStatusCallback,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "urlmon" fn URLOpenBlockingStreamW(
    param0: IUnknown,
    param1: ?*u16,
    param2: ?*IStream,
    param3: u32,
    param4: IBindStatusCallback,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "urlmon" fn HlinkGoBack(
    pUnk: IUnknown,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "urlmon" fn HlinkGoForward(
    pUnk: IUnknown,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "urlmon" fn HlinkNavigateString(
    pUnk: IUnknown,
    szTarget: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "urlmon" fn HlinkNavigateMoniker(
    pUnk: IUnknown,
    pmkTarget: IMoniker,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "urlmon" fn CoInternetParseUrl(
    pwzUrl: ?*u16,
    ParseAction: PARSEACTION,
    dwFlags: u32,
    pszResult: ?*u16,
    cchResult: u32,
    pcchResult: ?*u32,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "urlmon" fn CoInternetParseIUri(
    pIUri: IUri,
    ParseAction: PARSEACTION,
    dwFlags: u32,
    pwzResult: ?*u16,
    cchResult: u32,
    pcchResult: ?*u32,
    dwReserved: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "urlmon" fn CoInternetCombineUrl(
    pwzBaseUrl: ?*u16,
    pwzRelativeUrl: ?*u16,
    dwCombineFlags: u32,
    pszResult: ?*u16,
    cchResult: u32,
    pcchResult: ?*u32,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "urlmon" fn CoInternetCombineUrlEx(
    pBaseUri: IUri,
    pwzRelativeUrl: ?*u16,
    dwCombineFlags: u32,
    ppCombinedUri: ?*IUri,
    dwReserved: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "urlmon" fn CoInternetCombineIUri(
    pBaseUri: IUri,
    pRelativeUri: IUri,
    dwCombineFlags: u32,
    ppCombinedUri: ?*IUri,
    dwReserved: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "urlmon" fn CoInternetCompareUrl(
    pwzUrl1: ?*u16,
    pwzUrl2: ?*u16,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "urlmon" fn CoInternetGetProtocolFlags(
    pwzUrl: ?*u16,
    pdwFlags: ?*u32,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "urlmon" fn CoInternetQueryInfo(
    pwzUrl: ?*u16,
    QueryOptions: QUERYOPTION,
    dwQueryFlags: u32,
    pvBuffer: ?*opaque{},
    cbBuffer: u32,
    pcbBuffer: ?*u32,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "urlmon" fn CoInternetGetSession(
    dwSessionMode: u32,
    ppIInternetSession: ?*IInternetSession,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "urlmon" fn CoInternetGetSecurityUrl(
    pwszUrl: ?*u16,
    ppwszSecUrl: ?*?*u16,
    psuAction: PSUACTION,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "urlmon" fn CoInternetGetSecurityUrlEx(
    pUri: IUri,
    ppSecUri: ?*IUri,
    psuAction: PSUACTION,
    dwReserved: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "urlmon" fn CoInternetSetFeatureEnabled(
    FeatureEntry: INTERNETFEATURELIST,
    dwFlags: u32,
    fEnable: BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "urlmon" fn CoInternetIsFeatureEnabled(
    FeatureEntry: INTERNETFEATURELIST,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "urlmon" fn CoInternetIsFeatureEnabledForUrl(
    FeatureEntry: INTERNETFEATURELIST,
    dwFlags: u32,
    szURL: ?*u16,
    pSecMgr: IInternetSecurityManager,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "urlmon" fn CoInternetIsFeatureEnabledForIUri(
    FeatureEntry: INTERNETFEATURELIST,
    dwFlags: u32,
    pIUri: IUri,
    pSecMgr: IInternetSecurityManagerEx2,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "urlmon" fn CoInternetIsFeatureZoneElevationEnabled(
    szFromURL: ?*u16,
    szToURL: ?*u16,
    pSecMgr: IInternetSecurityManager,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "urlmon" fn CopyStgMedium(
    pcstgmedSrc: ?*STGMEDIUM,
    pstgmedDest: ?*STGMEDIUM,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "urlmon" fn CopyBindInfo(
    pcbiSrc: ?*BINDINFO,
    pbiDest: ?*BINDINFO,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "urlmon" fn ReleaseBindInfo(
    pbindinfo: ?*BINDINFO,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "urlmon" fn IEGetUserPrivateNamespaceName(
) callconv(@import("std").os.windows.WINAPI) ?*u16;

// set_last_errror=False (can and should we use this?)
pub extern "urlmon" fn CoInternetCreateSecurityManager(
    pSP: IServiceProvider,
    ppSM: ?*IInternetSecurityManager,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "urlmon" fn CoInternetCreateZoneManager(
    pSP: IServiceProvider,
    ppZM: ?*IInternetZoneManager,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "urlmon" fn GetSoftwareUpdateInfo(
    szDistUnit: ?*u16,
    psdi: ?*SOFTDISTINFO,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "urlmon" fn SetSoftwareUpdateAdvertisementState(
    szDistUnit: ?*u16,
    dwAdState: u32,
    dwAdvertisedVersionMS: u32,
    dwAdvertisedVersionLS: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "urlmon" fn IsLoggingEnabledA(
    pszUrl: ?*i8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "urlmon" fn IsLoggingEnabledW(
    pwszUrl: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "urlmon" fn WriteHitLogging(
    lpLogginginfo: ?*HIT_LOGGING_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn CreateDataAdviseHolder(
    ppDAHolder: ?*IDataAdviseHolder,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "ole32" fn OleBuildVersion(
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn OleInitialize(
    pvReserved: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn OleUninitialize(
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn OleQueryLinkFromData(
    pSrcDataObject: IDataObject,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn OleQueryCreateFromData(
    pSrcDataObject: IDataObject,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn OleCreate(
    rclsid: ?*Guid,
    riid: ?*Guid,
    renderopt: u32,
    pFormatEtc: ?*FORMATETC,
    pClientSite: IOleClientSite,
    pStg: IStorage,
    ppvObj: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "ole32" fn OleCreateEx(
    rclsid: ?*Guid,
    riid: ?*Guid,
    dwFlags: u32,
    renderopt: u32,
    cFormats: u32,
    rgAdvf: ?*u32,
    rgFormatEtc: ?*FORMATETC,
    lpAdviseSink: IAdviseSink,
    rgdwConnection: ?*u32,
    pClientSite: IOleClientSite,
    pStg: IStorage,
    ppvObj: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn OleCreateFromData(
    pSrcDataObj: IDataObject,
    riid: ?*Guid,
    renderopt: u32,
    pFormatEtc: ?*FORMATETC,
    pClientSite: IOleClientSite,
    pStg: IStorage,
    ppvObj: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "ole32" fn OleCreateFromDataEx(
    pSrcDataObj: IDataObject,
    riid: ?*Guid,
    dwFlags: u32,
    renderopt: u32,
    cFormats: u32,
    rgAdvf: ?*u32,
    rgFormatEtc: ?*FORMATETC,
    lpAdviseSink: IAdviseSink,
    rgdwConnection: ?*u32,
    pClientSite: IOleClientSite,
    pStg: IStorage,
    ppvObj: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn OleCreateLinkFromData(
    pSrcDataObj: IDataObject,
    riid: ?*Guid,
    renderopt: u32,
    pFormatEtc: ?*FORMATETC,
    pClientSite: IOleClientSite,
    pStg: IStorage,
    ppvObj: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "ole32" fn OleCreateLinkFromDataEx(
    pSrcDataObj: IDataObject,
    riid: ?*Guid,
    dwFlags: u32,
    renderopt: u32,
    cFormats: u32,
    rgAdvf: ?*u32,
    rgFormatEtc: ?*FORMATETC,
    lpAdviseSink: IAdviseSink,
    rgdwConnection: ?*u32,
    pClientSite: IOleClientSite,
    pStg: IStorage,
    ppvObj: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn OleCreateStaticFromData(
    pSrcDataObj: IDataObject,
    iid: ?*Guid,
    renderopt: u32,
    pFormatEtc: ?*FORMATETC,
    pClientSite: IOleClientSite,
    pStg: IStorage,
    ppvObj: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "ole32" fn OleCreateLink(
    pmkLinkSrc: IMoniker,
    riid: ?*Guid,
    renderopt: u32,
    lpFormatEtc: ?*FORMATETC,
    pClientSite: IOleClientSite,
    pStg: IStorage,
    ppvObj: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "ole32" fn OleCreateLinkEx(
    pmkLinkSrc: IMoniker,
    riid: ?*Guid,
    dwFlags: u32,
    renderopt: u32,
    cFormats: u32,
    rgAdvf: ?*u32,
    rgFormatEtc: ?*FORMATETC,
    lpAdviseSink: IAdviseSink,
    rgdwConnection: ?*u32,
    pClientSite: IOleClientSite,
    pStg: IStorage,
    ppvObj: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn OleCreateLinkToFile(
    lpszFileName: ?*u16,
    riid: ?*Guid,
    renderopt: u32,
    lpFormatEtc: ?*FORMATETC,
    pClientSite: IOleClientSite,
    pStg: IStorage,
    ppvObj: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "ole32" fn OleCreateLinkToFileEx(
    lpszFileName: ?*u16,
    riid: ?*Guid,
    dwFlags: u32,
    renderopt: u32,
    cFormats: u32,
    rgAdvf: ?*u32,
    rgFormatEtc: ?*FORMATETC,
    lpAdviseSink: IAdviseSink,
    rgdwConnection: ?*u32,
    pClientSite: IOleClientSite,
    pStg: IStorage,
    ppvObj: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn OleCreateFromFile(
    rclsid: ?*Guid,
    lpszFileName: ?*u16,
    riid: ?*Guid,
    renderopt: u32,
    lpFormatEtc: ?*FORMATETC,
    pClientSite: IOleClientSite,
    pStg: IStorage,
    ppvObj: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "ole32" fn OleCreateFromFileEx(
    rclsid: ?*Guid,
    lpszFileName: ?*u16,
    riid: ?*Guid,
    dwFlags: u32,
    renderopt: u32,
    cFormats: u32,
    rgAdvf: ?*u32,
    rgFormatEtc: ?*FORMATETC,
    lpAdviseSink: IAdviseSink,
    rgdwConnection: ?*u32,
    pClientSite: IOleClientSite,
    pStg: IStorage,
    ppvObj: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn OleLoad(
    pStg: IStorage,
    riid: ?*Guid,
    pClientSite: IOleClientSite,
    ppvObj: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn OleSave(
    pPS: IPersistStorage,
    pStg: IStorage,
    fSameAsLoad: BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn OleLoadFromStream(
    pStm: IStream,
    iidInterface: ?*Guid,
    ppvObj: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn OleSaveToStream(
    pPStm: IPersistStream,
    pStm: IStream,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn OleSetContainedObject(
    pUnknown: IUnknown,
    fContained: BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "ole32" fn OleNoteObjectVisible(
    pUnknown: IUnknown,
    fVisible: BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn RegisterDragDrop(
    hwnd: HWND,
    pDropTarget: IDropTarget,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn RevokeDragDrop(
    hwnd: HWND,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn DoDragDrop(
    pDataObj: IDataObject,
    pDropSource: IDropSource,
    dwOKEffects: u32,
    pdwEffect: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn OleSetClipboard(
    pDataObj: IDataObject,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn OleGetClipboard(
    ppDataObj: ?*IDataObject,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "ole32" fn OleGetClipboardWithEnterpriseInfo(
    dataObject: ?*IDataObject,
    dataEnterpriseId: ?*?*u16,
    sourceDescription: ?*?*u16,
    targetDescription: ?*?*u16,
    dataDescription: ?*?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn OleFlushClipboard(
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn OleIsCurrentClipboard(
    pDataObj: IDataObject,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn OleCreateMenuDescriptor(
    hmenuCombined: HMENU,
    lpMenuWidths: ?*OleMenuGroupWidths,
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn OleSetMenuDescriptor(
    holemenu: ?*opaque{},
    hwndFrame: HWND,
    hwndActiveObject: HWND,
    lpFrame: IOleInPlaceFrame,
    lpActiveObj: IOleInPlaceActiveObject,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn OleDestroyMenuDescriptor(
    holemenu: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn OleTranslateAccelerator(
    lpFrame: IOleInPlaceFrame,
    lpFrameInfo: ?*OIFI,
    lpmsg: ?*MSG,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn OleDuplicateData(
    hSrc: HANDLE,
    cfFormat: u16,
    uiFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn OleDraw(
    pUnknown: IUnknown,
    dwAspect: u32,
    hdcDraw: HDC,
    lprcBounds: ?*RECT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn OleRun(
    pUnknown: IUnknown,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn OleIsRunning(
    pObject: IOleObject,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn OleLockRunning(
    pUnknown: IUnknown,
    fLock: BOOL,
    fLastUnlockCloses: BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn ReleaseStgMedium(
    param0: ?*STGMEDIUM,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn CreateOleAdviseHolder(
    ppOAHolder: ?*IOleAdviseHolder,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "ole32" fn OleCreateDefaultHandler(
    clsid: ?*Guid,
    pUnkOuter: IUnknown,
    riid: ?*Guid,
    lplpObj: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn OleCreateEmbeddingHelper(
    clsid: ?*Guid,
    pUnkOuter: IUnknown,
    flags: u32,
    pCF: IClassFactory,
    riid: ?*Guid,
    lplpObj: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn IsAccelerator(
    hAccel: HACCEL,
    cAccelEntries: i32,
    lpMsg: ?*MSG,
    lpwCmd: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "ole32" fn OleGetIconOfFile(
    lpszPath: ?*u16,
    fUseFileAsLabel: BOOL,
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn OleGetIconOfClass(
    rclsid: ?*Guid,
    lpszLabel: ?*u16,
    fUseTypeAsLabel: BOOL,
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=True (can and should we use this?)
pub extern "ole32" fn OleMetafilePictFromIconAndLabel(
    hIcon: HICON,
    lpszLabel: ?*u16,
    lpszSourceFile: ?*u16,
    iIconIndex: u32,
) callconv(@import("std").os.windows.WINAPI) ?*opaque{};

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn OleRegGetUserType(
    clsid: ?*Guid,
    dwFormOfType: u32,
    pszUserType: ?*?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn OleRegGetMiscStatus(
    clsid: ?*Guid,
    dwAspect: u32,
    pdwStatus: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "ole32" fn OleRegEnumFormatEtc(
    clsid: ?*Guid,
    dwDirection: u32,
    ppenum: ?*IEnumFORMATETC,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn OleRegEnumVerbs(
    clsid: ?*Guid,
    ppenum: ?*IEnumOLEVERB,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "ole32" fn OleDoAutoConvert(
    pStg: IStorage,
    pClsidNew: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn OleGetAutoConvert(
    clsidOld: ?*Guid,
    pClsidNew: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "ole32" fn OleSetAutoConvert(
    clsidOld: ?*Guid,
    clsidNew: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn HPALETTE_UserSize(
    param0: ?*u32,
    param1: u32,
    param2: ?*HPALETTE,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn HPALETTE_UserMarshal(
    param0: ?*u32,
    param1: ?*u8,
    param2: ?*HPALETTE,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn HPALETTE_UserUnmarshal(
    param0: ?*u32,
    param1: ?*u8,
    param2: ?*HPALETTE,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn HPALETTE_UserFree(
    param0: ?*u32,
    param1: ?*HPALETTE,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn HRGN_UserSize(
    param0: ?*u32,
    param1: u32,
    param2: ?*HRGN,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn HRGN_UserMarshal(
    param0: ?*u32,
    param1: ?*u8,
    param2: ?*HRGN,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn HRGN_UserUnmarshal(
    param0: ?*u32,
    param1: ?*u8,
    param2: ?*HRGN,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn HRGN_UserFree(
    param0: ?*u32,
    param1: ?*HRGN,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn HPALETTE_UserSize64(
    param0: ?*u32,
    param1: u32,
    param2: ?*HPALETTE,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn HPALETTE_UserMarshal64(
    param0: ?*u32,
    param1: ?*u8,
    param2: ?*HPALETTE,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn HPALETTE_UserUnmarshal64(
    param0: ?*u32,
    param1: ?*u8,
    param2: ?*HPALETTE,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn HPALETTE_UserFree64(
    param0: ?*u32,
    param1: ?*HPALETTE,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn OleCreatePropertyFrame(
    hwndOwner: HWND,
    x: u32,
    y: u32,
    lpszCaption: ?*u16,
    cObjects: u32,
    ppUnk: ?*IUnknown,
    cPages: u32,
    pPageClsID: ?*Guid,
    lcid: u32,
    dwReserved: u32,
    pvReserved: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn OleCreatePropertyFrameIndirect(
    lpParams: ?*OCPFIPARAMS,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn OleTranslateColor(
    clr: u32,
    hpal: HPALETTE,
    lpcolorref: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn OleCreateFontIndirect(
    lpFontDesc: ?*FONTDESC,
    riid: ?*Guid,
    lplpvObj: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn OleCreatePictureIndirect(
    lpPictDesc: ?*PICTDESC,
    riid: ?*Guid,
    fOwn: BOOL,
    lplpvObj: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn OleLoadPicture(
    lpstream: IStream,
    lSize: i32,
    fRunmode: BOOL,
    riid: ?*Guid,
    lplpvObj: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn OleLoadPictureEx(
    lpstream: IStream,
    lSize: i32,
    fRunmode: BOOL,
    riid: ?*Guid,
    xSizeDesired: u32,
    ySizeDesired: u32,
    dwFlags: u32,
    lplpvObj: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn OleLoadPicturePath(
    szURLorPath: ?*u16,
    punkCaller: IUnknown,
    dwReserved: u32,
    clrReserved: u32,
    riid: ?*Guid,
    ppvRet: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLEAUT32" fn OleIconToCursor(
    hinstExe: HINSTANCE,
    hIcon: HICON,
) callconv(@import("std").os.windows.WINAPI) HCURSOR;

// set_last_errror=False (can and should we use this?)
pub extern "oledlg" fn OleUIAddVerbMenuW(
    lpOleObj: IOleObject,
    lpszShortType: ?*u16,
    hMenu: HMENU,
    uPos: u32,
    uIDVerbMin: u32,
    uIDVerbMax: u32,
    bAddConvert: BOOL,
    idConvert: u32,
    lphMenu: ?*HMENU,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "oledlg" fn OleUIAddVerbMenuA(
    lpOleObj: IOleObject,
    lpszShortType: ?*i8,
    hMenu: HMENU,
    uPos: u32,
    uIDVerbMin: u32,
    uIDVerbMax: u32,
    bAddConvert: BOOL,
    idConvert: u32,
    lphMenu: ?*HMENU,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "oledlg" fn OleUIInsertObjectW(
    param0: ?*OLEUIINSERTOBJECTW,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "oledlg" fn OleUIInsertObjectA(
    param0: ?*OLEUIINSERTOBJECTA,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "oledlg" fn OleUIPasteSpecialW(
    param0: ?*OLEUIPASTESPECIALW,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "oledlg" fn OleUIPasteSpecialA(
    param0: ?*OLEUIPASTESPECIALA,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "oledlg" fn OleUIEditLinksW(
    param0: ?*OLEUIEDITLINKSW,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "oledlg" fn OleUIEditLinksA(
    param0: ?*OLEUIEDITLINKSA,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "oledlg" fn OleUIChangeIconW(
    param0: ?*OLEUICHANGEICONW,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "oledlg" fn OleUIChangeIconA(
    param0: ?*OLEUICHANGEICONA,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "oledlg" fn OleUIConvertW(
    param0: ?*OLEUICONVERTW,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "oledlg" fn OleUIConvertA(
    param0: ?*OLEUICONVERTA,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "oledlg" fn OleUICanConvertOrActivateAs(
    rClsid: ?*Guid,
    fIsLinkedObject: BOOL,
    wFormat: u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "oledlg" fn OleUIBusyW(
    param0: ?*OLEUIBUSYW,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "oledlg" fn OleUIBusyA(
    param0: ?*OLEUIBUSYA,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "oledlg" fn OleUIChangeSourceW(
    param0: ?*OLEUICHANGESOURCEW,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "oledlg" fn OleUIChangeSourceA(
    param0: ?*OLEUICHANGESOURCEA,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "oledlg" fn OleUIObjectPropertiesW(
    param0: ?*OLEUIOBJECTPROPSW,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "oledlg" fn OleUIObjectPropertiesA(
    param0: ?*OLEUIOBJECTPROPSA,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "oledlg" fn OleUIPromptUserW(
    nTemplate: i32,
    hwndParent: HWND,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "oledlg" fn OleUIPromptUserA(
    nTemplate: i32,
    hwndParent: HWND,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "oledlg" fn OleUIUpdateLinksW(
    lpOleUILinkCntr: IOleUILinkContainerW,
    hwndParent: HWND,
    lpszTitle: ?*u16,
    cLinks: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "oledlg" fn OleUIUpdateLinksA(
    lpOleUILinkCntr: IOleUILinkContainerA,
    hwndParent: HWND,
    lpszTitle: ?*i8,
    cLinks: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "ole32" fn CoGetInterceptor(
    iidIntercepted: ?*Guid,
    punkOuter: IUnknown,
    iid: ?*Guid,
    ppv: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "ole32" fn CoGetInterceptorFromTypeInfo(
    iidIntercepted: ?*Guid,
    punkOuter: IUnknown,
    typeInfo: ITypeInfo,
    iid: ?*Guid,
    ppv: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "ole32" fn CoSetMessageDispatcher(
    pMessageDispatcher: IMessageDispatcher,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "ole32" fn CoHandlePriorityEventsFromMessagePump(
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn CoInitialize(
    pvReserved: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn CoRegisterMallocSpy(
    pMallocSpy: IMallocSpy,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn CoRevokeMallocSpy(
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn CoRegisterInitializeSpy(
    pSpy: IInitializeSpy,
    puliCookie: ?*ULARGE_INTEGER,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn CoRevokeInitializeSpy(
    uliCookie: ULARGE_INTEGER,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn CoGetSystemSecurityPermissions(
    comSDType: COMSD,
    ppSD: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn CoLoadLibrary(
    lpszLibName: ?*u16,
    bAutoFree: BOOL,
) callconv(@import("std").os.windows.WINAPI) HINSTANCE;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn CoFreeLibrary(
    hInst: HINSTANCE,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn CoFreeAllLibraries(
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn CoGetInstanceFromFile(
    pServerInfo: ?*COSERVERINFO,
    pClsid: ?*Guid,
    punkOuter: IUnknown,
    dwClsCtx: u32,
    grfMode: u32,
    pwszName: ?*u16,
    dwCount: u32,
    pResults: ?*MULTI_QI,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn CoGetInstanceFromIStorage(
    pServerInfo: ?*COSERVERINFO,
    pClsid: ?*Guid,
    punkOuter: IUnknown,
    dwClsCtx: u32,
    pstg: IStorage,
    dwCount: u32,
    pResults: ?*MULTI_QI,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn CoAllowSetForegroundWindow(
    pUnk: IUnknown,
    lpvReserved: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "ole32" fn CoIsOle1Class(
    rclsid: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn CoFileTimeToDosDateTime(
    lpFileTime: ?*FILETIME,
    lpDosDate: ?*u16,
    lpDosTime: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn CoDosDateTimeToFileTime(
    nDosDate: u16,
    nDosTime: u16,
    lpFileTime: ?*FILETIME,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn CoRegisterMessageFilter(
    lpMessageFilter: IMessageFilter,
    lplpMessageFilter: ?*IMessageFilter,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "ole32" fn CoRegisterChannelHook(
    ExtensionUuid: ?*Guid,
    pChannelHook: IChannelHook,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn CoTreatAsClass(
    clsidOld: ?*Guid,
    clsidNew: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn CreateDataCache(
    pUnkOuter: IUnknown,
    rclsid: ?*Guid,
    iid: ?*Guid,
    ppv: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn BindMoniker(
    pmk: IMoniker,
    grfOpt: u32,
    iidResult: ?*Guid,
    ppvResult: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn CoGetObject(
    pszName: ?*u16,
    pBindOptions: ?*BIND_OPTS,
    riid: ?*Guid,
    ppv: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn MkParseDisplayName(
    pbc: IBindCtx,
    szUserName: ?*u16,
    pchEaten: ?*u32,
    ppmk: ?*IMoniker,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "ole32" fn MonikerRelativePathTo(
    pmkSrc: IMoniker,
    pmkDest: IMoniker,
    ppmkRelPath: ?*IMoniker,
    dwReserved: BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "ole32" fn MonikerCommonPrefixWith(
    pmkThis: IMoniker,
    pmkOther: IMoniker,
    ppmkCommon: ?*IMoniker,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn CreateBindCtx(
    reserved: u32,
    ppbc: ?*IBindCtx,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn CreateGenericComposite(
    pmkFirst: IMoniker,
    pmkRest: IMoniker,
    ppmkComposite: ?*IMoniker,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn GetClassFile(
    szFilename: ?*u16,
    pclsid: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn CreateClassMoniker(
    rclsid: ?*Guid,
    ppmk: ?*IMoniker,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn CreateFileMoniker(
    lpszPathName: ?*u16,
    ppmk: ?*IMoniker,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn CreateItemMoniker(
    lpszDelim: ?*u16,
    lpszItem: ?*u16,
    ppmk: ?*IMoniker,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn CreateAntiMoniker(
    ppmk: ?*IMoniker,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn CreatePointerMoniker(
    punk: IUnknown,
    ppmk: ?*IMoniker,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn CreateObjrefMoniker(
    punk: IUnknown,
    ppmk: ?*IMoniker,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// set_last_errror=False (can and should we use this?)
pub extern "OLE32" fn GetRunningObjectTable(
    reserved: u32,
    pprot: ?*IRunningObjectTable,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

//
// Unicode Symbol Aliases
//
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {
        pub const OLEUIINSERTOBJECT = OLEUIINSERTOBJECTA;
        pub const OLEUIPASTEENTRY = OLEUIPASTEENTRYA;
        pub const OLEUIPASTESPECIAL = OLEUIPASTESPECIALA;
        pub const IOleUILinkContainer = IOleUILinkContainerA;
        pub const OLEUIEDITLINKS = OLEUIEDITLINKSA;
        pub const OLEUICHANGEICON = OLEUICHANGEICONA;
        pub const OLEUICONVERT = OLEUICONVERTA;
        pub const OLEUIBUSY = OLEUIBUSYA;
        pub const OLEUICHANGESOURCE = OLEUICHANGESOURCEA;
        pub const IOleUIObjInfo = IOleUIObjInfoA;
        pub const IOleUILinkInfo = IOleUILinkInfoA;
        pub const OLEUIGNRLPROPS = OLEUIGNRLPROPSA;
        pub const OLEUIVIEWPROPS = OLEUIVIEWPROPSA;
        pub const OLEUILINKPROPS = OLEUILINKPROPSA;
        pub const OLEUIOBJECTPROPS = OLEUIOBJECTPROPSA;
        pub const ACTRL_ACCESS_ENTRY = ACTRL_ACCESS_ENTRYA;
        pub const ACTRL_ACCESS_ENTRY_LIST = ACTRL_ACCESS_ENTRY_LISTA;
        pub const ACTRL_PROPERTY_ENTRY = ACTRL_PROPERTY_ENTRYA;
        pub const ACTRL_ACCESS = ACTRL_ACCESSA;
        pub const URLOpenStream = URLOpenStreamA;
        pub const URLOpenPullStream = URLOpenPullStreamA;
        pub const URLDownloadToFile = URLDownloadToFileA;
        pub const URLDownloadToCacheFile = URLDownloadToCacheFileA;
        pub const URLOpenBlockingStream = URLOpenBlockingStreamA;
        pub const IsLoggingEnabled = IsLoggingEnabledA;
        pub const OleUIAddVerbMenu = OleUIAddVerbMenuA;
        pub const OleUIInsertObject = OleUIInsertObjectA;
        pub const OleUIPasteSpecial = OleUIPasteSpecialA;
        pub const OleUIEditLinks = OleUIEditLinksA;
        pub const OleUIChangeIcon = OleUIChangeIconA;
        pub const OleUIConvert = OleUIConvertA;
        pub const OleUIBusy = OleUIBusyA;
        pub const OleUIChangeSource = OleUIChangeSourceA;
        pub const OleUIObjectProperties = OleUIObjectPropertiesA;
        pub const OleUIPromptUser = OleUIPromptUserA;
        pub const OleUIUpdateLinks = OleUIUpdateLinksA;
    },
    .wide => struct {
        pub const OLEUIINSERTOBJECT = OLEUIINSERTOBJECTW;
        pub const OLEUIPASTEENTRY = OLEUIPASTEENTRYW;
        pub const OLEUIPASTESPECIAL = OLEUIPASTESPECIALW;
        pub const IOleUILinkContainer = IOleUILinkContainerW;
        pub const OLEUIEDITLINKS = OLEUIEDITLINKSW;
        pub const OLEUICHANGEICON = OLEUICHANGEICONW;
        pub const OLEUICONVERT = OLEUICONVERTW;
        pub const OLEUIBUSY = OLEUIBUSYW;
        pub const OLEUICHANGESOURCE = OLEUICHANGESOURCEW;
        pub const IOleUIObjInfo = IOleUIObjInfoW;
        pub const IOleUILinkInfo = IOleUILinkInfoW;
        pub const OLEUIGNRLPROPS = OLEUIGNRLPROPSW;
        pub const OLEUIVIEWPROPS = OLEUIVIEWPROPSW;
        pub const OLEUILINKPROPS = OLEUILINKPROPSW;
        pub const OLEUIOBJECTPROPS = OLEUIOBJECTPROPSW;
        pub const ACTRL_ACCESS_ENTRY = ACTRL_ACCESS_ENTRYW;
        pub const ACTRL_ACCESS_ENTRY_LIST = ACTRL_ACCESS_ENTRY_LISTW;
        pub const ACTRL_PROPERTY_ENTRY = ACTRL_PROPERTY_ENTRYW;
        pub const ACTRL_ACCESS = ACTRL_ACCESSW;
        pub const URLOpenStream = URLOpenStreamW;
        pub const URLOpenPullStream = URLOpenPullStreamW;
        pub const URLDownloadToFile = URLDownloadToFileW;
        pub const URLDownloadToCacheFile = URLDownloadToCacheFileW;
        pub const URLOpenBlockingStream = URLOpenBlockingStreamW;
        pub const IsLoggingEnabled = IsLoggingEnabledW;
        pub const OleUIAddVerbMenu = OleUIAddVerbMenuW;
        pub const OleUIInsertObject = OleUIInsertObjectW;
        pub const OleUIPasteSpecial = OleUIPasteSpecialW;
        pub const OleUIEditLinks = OleUIEditLinksW;
        pub const OleUIChangeIcon = OleUIChangeIconW;
        pub const OleUIConvert = OleUIConvertW;
        pub const OleUIBusy = OleUIBusyW;
        pub const OleUIChangeSource = OleUIChangeSourceW;
        pub const OleUIObjectProperties = OleUIObjectPropertiesW;
        pub const OleUIPromptUser = OleUIPromptUserW;
        pub const OleUIUpdateLinks = OleUIUpdateLinksW;
    },
    else => if (@import("builtin").is_test) struct {
        pub const OLEUIINSERTOBJECT = *opaque{};
        pub const OLEUIPASTEENTRY = *opaque{};
        pub const OLEUIPASTESPECIAL = *opaque{};
        pub const IOleUILinkContainer = *opaque{};
        pub const OLEUIEDITLINKS = *opaque{};
        pub const OLEUICHANGEICON = *opaque{};
        pub const OLEUICONVERT = *opaque{};
        pub const OLEUIBUSY = *opaque{};
        pub const OLEUICHANGESOURCE = *opaque{};
        pub const IOleUIObjInfo = *opaque{};
        pub const IOleUILinkInfo = *opaque{};
        pub const OLEUIGNRLPROPS = *opaque{};
        pub const OLEUIVIEWPROPS = *opaque{};
        pub const OLEUILINKPROPS = *opaque{};
        pub const OLEUIOBJECTPROPS = *opaque{};
        pub const ACTRL_ACCESS_ENTRY = *opaque{};
        pub const ACTRL_ACCESS_ENTRY_LIST = *opaque{};
        pub const ACTRL_PROPERTY_ENTRY = *opaque{};
        pub const ACTRL_ACCESS = *opaque{};
        pub const URLOpenStream = *opaque{};
        pub const URLOpenPullStream = *opaque{};
        pub const URLDownloadToFile = *opaque{};
        pub const URLDownloadToCacheFile = *opaque{};
        pub const URLOpenBlockingStream = *opaque{};
        pub const IsLoggingEnabled = *opaque{};
        pub const OleUIAddVerbMenu = *opaque{};
        pub const OleUIInsertObject = *opaque{};
        pub const OleUIPasteSpecial = *opaque{};
        pub const OleUIEditLinks = *opaque{};
        pub const OleUIChangeIcon = *opaque{};
        pub const OleUIConvert = *opaque{};
        pub const OleUIBusy = *opaque{};
        pub const OleUIChangeSource = *opaque{};
        pub const OleUIObjectProperties = *opaque{};
        pub const OleUIPromptUser = *opaque{};
        pub const OleUIUpdateLinks = *opaque{};
    } else struct {
        pub const OLEUIINSERTOBJECT = @compileError("'OLEUIINSERTOBJECT' requires that UNICODE be set to true or false in the root module");
        pub const OLEUIPASTEENTRY = @compileError("'OLEUIPASTEENTRY' requires that UNICODE be set to true or false in the root module");
        pub const OLEUIPASTESPECIAL = @compileError("'OLEUIPASTESPECIAL' requires that UNICODE be set to true or false in the root module");
        pub const IOleUILinkContainer = @compileError("'IOleUILinkContainer' requires that UNICODE be set to true or false in the root module");
        pub const OLEUIEDITLINKS = @compileError("'OLEUIEDITLINKS' requires that UNICODE be set to true or false in the root module");
        pub const OLEUICHANGEICON = @compileError("'OLEUICHANGEICON' requires that UNICODE be set to true or false in the root module");
        pub const OLEUICONVERT = @compileError("'OLEUICONVERT' requires that UNICODE be set to true or false in the root module");
        pub const OLEUIBUSY = @compileError("'OLEUIBUSY' requires that UNICODE be set to true or false in the root module");
        pub const OLEUICHANGESOURCE = @compileError("'OLEUICHANGESOURCE' requires that UNICODE be set to true or false in the root module");
        pub const IOleUIObjInfo = @compileError("'IOleUIObjInfo' requires that UNICODE be set to true or false in the root module");
        pub const IOleUILinkInfo = @compileError("'IOleUILinkInfo' requires that UNICODE be set to true or false in the root module");
        pub const OLEUIGNRLPROPS = @compileError("'OLEUIGNRLPROPS' requires that UNICODE be set to true or false in the root module");
        pub const OLEUIVIEWPROPS = @compileError("'OLEUIVIEWPROPS' requires that UNICODE be set to true or false in the root module");
        pub const OLEUILINKPROPS = @compileError("'OLEUILINKPROPS' requires that UNICODE be set to true or false in the root module");
        pub const OLEUIOBJECTPROPS = @compileError("'OLEUIOBJECTPROPS' requires that UNICODE be set to true or false in the root module");
        pub const ACTRL_ACCESS_ENTRY = @compileError("'ACTRL_ACCESS_ENTRY' requires that UNICODE be set to true or false in the root module");
        pub const ACTRL_ACCESS_ENTRY_LIST = @compileError("'ACTRL_ACCESS_ENTRY_LIST' requires that UNICODE be set to true or false in the root module");
        pub const ACTRL_PROPERTY_ENTRY = @compileError("'ACTRL_PROPERTY_ENTRY' requires that UNICODE be set to true or false in the root module");
        pub const ACTRL_ACCESS = @compileError("'ACTRL_ACCESS' requires that UNICODE be set to true or false in the root module");
        pub const URLOpenStream = @compileError("'URLOpenStream' requires that UNICODE be set to true or false in the root module");
        pub const URLOpenPullStream = @compileError("'URLOpenPullStream' requires that UNICODE be set to true or false in the root module");
        pub const URLDownloadToFile = @compileError("'URLDownloadToFile' requires that UNICODE be set to true or false in the root module");
        pub const URLDownloadToCacheFile = @compileError("'URLDownloadToCacheFile' requires that UNICODE be set to true or false in the root module");
        pub const URLOpenBlockingStream = @compileError("'URLOpenBlockingStream' requires that UNICODE be set to true or false in the root module");
        pub const IsLoggingEnabled = @compileError("'IsLoggingEnabled' requires that UNICODE be set to true or false in the root module");
        pub const OleUIAddVerbMenu = @compileError("'OleUIAddVerbMenu' requires that UNICODE be set to true or false in the root module");
        pub const OleUIInsertObject = @compileError("'OleUIInsertObject' requires that UNICODE be set to true or false in the root module");
        pub const OleUIPasteSpecial = @compileError("'OleUIPasteSpecial' requires that UNICODE be set to true or false in the root module");
        pub const OleUIEditLinks = @compileError("'OleUIEditLinks' requires that UNICODE be set to true or false in the root module");
        pub const OleUIChangeIcon = @compileError("'OleUIChangeIcon' requires that UNICODE be set to true or false in the root module");
        pub const OleUIConvert = @compileError("'OleUIConvert' requires that UNICODE be set to true or false in the root module");
        pub const OleUIBusy = @compileError("'OleUIBusy' requires that UNICODE be set to true or false in the root module");
        pub const OleUIChangeSource = @compileError("'OleUIChangeSource' requires that UNICODE be set to true or false in the root module");
        pub const OleUIObjectProperties = @compileError("'OleUIObjectProperties' requires that UNICODE be set to true or false in the root module");
        pub const OleUIPromptUser = @compileError("'OleUIPromptUser' requires that UNICODE be set to true or false in the root module");
        pub const OleUIUpdateLinks = @compileError("'OleUIUpdateLinks' requires that UNICODE be set to true or false in the root module");
    },
};

//
// type imports
//
const Guid = @import("../zig.zig").Guid;
const HWND = @import("windowsandmessaging.zig").HWND;
const SIZE = @import("displaydevices.zig").SIZE;
const POINTL = @import("displaydevices.zig").POINTL;
const BOOL = @import("systemservices.zig").BOOL;
const HACCEL = @import("menusandresources.zig").HACCEL;
const SECURITY_ATTRIBUTES = @import("systemservices.zig").SECURITY_ATTRIBUTES;
const SYSTEMTIME = @import("windowsprogramming.zig").SYSTEMTIME;
const HPALETTE = @import("gdi.zig").HPALETTE;
const IServiceProvider = @import("systemservices.zig").IServiceProvider;
const CY = @import("systemservices.zig").CY;
const HBITMAP = @import("gdi.zig").HBITMAP;
const HICON = @import("gdi.zig").HICON;
const LPARAM = @import("windowsandmessaging.zig").LPARAM;
const HINSTANCE = @import("systemservices.zig").HINSTANCE;
const IStorage = @import("structuredstorage.zig").IStorage;
const OPENFILENAMEW = @import("windowsandmessaging.zig").OPENFILENAMEW;
const OPENFILENAMEA = @import("windowsandmessaging.zig").OPENFILENAMEA;
const PROPSHEETHEADERW_V2 = @import("controls.zig").PROPSHEETHEADERW_V2;
const PROPSHEETHEADERA_V2 = @import("controls.zig").PROPSHEETHEADERA_V2;
const TRUSTEE_A = @import("security.zig").TRUSTEE_A;
const TRUSTEE_W = @import("security.zig").TRUSTEE_W;
const IStream = @import("structuredstorage.zig").IStream;
const FILETIME = @import("windowsprogramming.zig").FILETIME;
const HDC = @import("gdi.zig").HDC;
const HMENU = @import("menusandresources.zig").HMENU;
const uCLSSPEC = @import("systemservices.zig").uCLSSPEC;
const HANDLE = @import("systemservices.zig").HANDLE;
const SOFTDISTINFO = @import("shell.zig").SOFTDISTINFO;
const MSG = @import("windowsandmessaging.zig").MSG;
const RECT = @import("displaydevices.zig").RECT;
const HRGN = @import("gdi.zig").HRGN;
const HCURSOR = @import("gdi.zig").HCURSOR;
const ITypeInfo = @import("automation.zig").ITypeInfo;
const ULARGE_INTEGER = @import("systemservices.zig").ULARGE_INTEGER;

test "" {
    const constant_export_count = 0;
    const type_export_count = 487;
    const func_count = 358;
    const unicode_alias_count = 36;
    const type_import_count = 35;
    @setEvalBranchQuota(0
        + constant_export_count
        + type_export_count
        + func_count
        + unicode_alias_count
        + type_import_count
        + 2 // TODO: why do I need these extra 2?
    );
    @import("std").testing.refAllDecls(@This());
}
