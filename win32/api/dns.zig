//! NOTE: this source file is autogenerated, DO NOT MODIFY

//
// constants
//

//
// types
//
// --------------------------------------------------------
// Type: IP4_ARRAY
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const IP4_ARRAY = extern struct {
    AddrCount: u32,
    AddrArray: ?[*]u32,
};
// --------------------------------------------------------
// Type: IP6_ADDRESS
// TypeLayoutAttr: explicit
// not generating the actual code for this type because it has an explicit layout
pub const IP6_ADDRESS = *opaque{
};
// --------------------------------------------------------
// Type: DNS_ADDR
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DNS_ADDR = extern struct {
    MaxSa: ?[*]i8,
    Data: _Data_e__Union,
    // --------------------------------------------------------
    // Type: _Data_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Data_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: DNS_ADDR_ARRAY
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const DNS_ADDR_ARRAY = *opaque{
};
// --------------------------------------------------------
// Type: DNS_HEADER
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const DNS_HEADER = *opaque{
};
// --------------------------------------------------------
// Type: DNS_HEADER_EXT
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const DNS_HEADER_EXT = *opaque{
};
// --------------------------------------------------------
// Type: DNS_WIRE_QUESTION
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const DNS_WIRE_QUESTION = *opaque{
};
// --------------------------------------------------------
// Type: DNS_WIRE_RECORD
// TypeLayoutAttr: sequential
// not generating the actual code for this type because it has a non-default layout IsDefault=False PackingSize=1 Size=0
pub const DNS_WIRE_RECORD = *opaque{
};
// --------------------------------------------------------
// Type: DNS_CONFIG_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const DNS_CONFIG_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: DNS_A_DATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DNS_A_DATA = extern struct {
    IpAddress: u32,
};
// --------------------------------------------------------
// Type: DNS_PTR_DATAW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DNS_PTR_DATAW = extern struct {
    pNameHost: ?*u16,
};
// --------------------------------------------------------
// Type: DNS_PTR_DATAA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DNS_PTR_DATAA = extern struct {
    pNameHost: ?*i8,
};
// --------------------------------------------------------
// Type: DNS_SOA_DATAW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DNS_SOA_DATAW = extern struct {
    pNamePrimaryServer: ?*u16,
    pNameAdministrator: ?*u16,
    dwSerialNo: u32,
    dwRefresh: u32,
    dwRetry: u32,
    dwExpire: u32,
    dwDefaultTtl: u32,
};
// --------------------------------------------------------
// Type: DNS_SOA_DATAA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DNS_SOA_DATAA = extern struct {
    pNamePrimaryServer: ?*i8,
    pNameAdministrator: ?*i8,
    dwSerialNo: u32,
    dwRefresh: u32,
    dwRetry: u32,
    dwExpire: u32,
    dwDefaultTtl: u32,
};
// --------------------------------------------------------
// Type: DNS_MINFO_DATAW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DNS_MINFO_DATAW = extern struct {
    pNameMailbox: ?*u16,
    pNameErrorsMailbox: ?*u16,
};
// --------------------------------------------------------
// Type: DNS_MINFO_DATAA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DNS_MINFO_DATAA = extern struct {
    pNameMailbox: ?*i8,
    pNameErrorsMailbox: ?*i8,
};
// --------------------------------------------------------
// Type: DNS_MX_DATAW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DNS_MX_DATAW = extern struct {
    pNameExchange: ?*u16,
    wPreference: u16,
    Pad: u16,
};
// --------------------------------------------------------
// Type: DNS_MX_DATAA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DNS_MX_DATAA = extern struct {
    pNameExchange: ?*i8,
    wPreference: u16,
    Pad: u16,
};
// --------------------------------------------------------
// Type: DNS_TXT_DATAW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DNS_TXT_DATAW = extern struct {
    dwStringCount: u32,
    pStringArray: ?[*]?*u16,
};
// --------------------------------------------------------
// Type: DNS_TXT_DATAA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DNS_TXT_DATAA = extern struct {
    dwStringCount: u32,
    pStringArray: ?[*]?*i8,
};
// --------------------------------------------------------
// Type: DNS_NULL_DATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DNS_NULL_DATA = extern struct {
    dwByteCount: u32,
    Data: ?[*]u8,
};
// --------------------------------------------------------
// Type: DNS_WKS_DATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DNS_WKS_DATA = extern struct {
    IpAddress: u32,
    chProtocol: u8,
    BitMask: ?[*]u8,
};
// --------------------------------------------------------
// Type: DNS_AAAA_DATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DNS_AAAA_DATA = extern struct {
    Ip6Address: IP6_ADDRESS,
};
// --------------------------------------------------------
// Type: DNS_SIG_DATAW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DNS_SIG_DATAW = extern struct {
    wTypeCovered: u16,
    chAlgorithm: u8,
    chLabelCount: u8,
    dwOriginalTtl: u32,
    dwExpiration: u32,
    dwTimeSigned: u32,
    wKeyTag: u16,
    wSignatureLength: u16,
    pNameSigner: ?*u16,
    Signature: ?[*]u8,
};
// --------------------------------------------------------
// Type: DNS_SIG_DATAA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DNS_SIG_DATAA = extern struct {
    wTypeCovered: u16,
    chAlgorithm: u8,
    chLabelCount: u8,
    dwOriginalTtl: u32,
    dwExpiration: u32,
    dwTimeSigned: u32,
    wKeyTag: u16,
    wSignatureLength: u16,
    pNameSigner: ?*i8,
    Signature: ?[*]u8,
};
// --------------------------------------------------------
// Type: DNS_KEY_DATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DNS_KEY_DATA = extern struct {
    wFlags: u16,
    chProtocol: u8,
    chAlgorithm: u8,
    wKeyLength: u16,
    wPad: u16,
    Key: ?[*]u8,
};
// --------------------------------------------------------
// Type: DNS_DHCID_DATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DNS_DHCID_DATA = extern struct {
    dwByteCount: u32,
    DHCID: ?[*]u8,
};
// --------------------------------------------------------
// Type: DNS_NSEC_DATAW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DNS_NSEC_DATAW = extern struct {
    pNextDomainName: ?*u16,
    wTypeBitMapsLength: u16,
    wPad: u16,
    TypeBitMaps: ?[*]u8,
};
// --------------------------------------------------------
// Type: DNS_NSEC_DATAA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DNS_NSEC_DATAA = extern struct {
    pNextDomainName: ?*i8,
    wTypeBitMapsLength: u16,
    wPad: u16,
    TypeBitMaps: ?[*]u8,
};
// --------------------------------------------------------
// Type: DNS_NSEC3_DATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DNS_NSEC3_DATA = extern struct {
    chAlgorithm: u8,
    bFlags: u8,
    wIterations: u16,
    bSaltLength: u8,
    bHashLength: u8,
    wTypeBitMapsLength: u16,
    chData: ?[*]u8,
};
// --------------------------------------------------------
// Type: DNS_NSEC3PARAM_DATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DNS_NSEC3PARAM_DATA = extern struct {
    chAlgorithm: u8,
    bFlags: u8,
    wIterations: u16,
    bSaltLength: u8,
    bPad: ?[*]u8,
    pbSalt: ?[*]u8,
};
// --------------------------------------------------------
// Type: DNS_TLSA_DATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DNS_TLSA_DATA = extern struct {
    bCertUsage: u8,
    bSelector: u8,
    bMatchingType: u8,
    bCertificateAssociationDataLength: u16,
    bPad: ?[*]u8,
    bCertificateAssociationData: ?[*]u8,
};
// --------------------------------------------------------
// Type: DNS_DS_DATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DNS_DS_DATA = extern struct {
    wKeyTag: u16,
    chAlgorithm: u8,
    chDigestType: u8,
    wDigestLength: u16,
    wPad: u16,
    Digest: ?[*]u8,
};
// --------------------------------------------------------
// Type: DNS_OPT_DATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DNS_OPT_DATA = extern struct {
    wDataLength: u16,
    wPad: u16,
    Data: ?[*]u8,
};
// --------------------------------------------------------
// Type: DNS_LOC_DATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DNS_LOC_DATA = extern struct {
    wVersion: u16,
    wSize: u16,
    wHorPrec: u16,
    wVerPrec: u16,
    dwLatitude: u32,
    dwLongitude: u32,
    dwAltitude: u32,
};
// --------------------------------------------------------
// Type: DNS_NXT_DATAW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DNS_NXT_DATAW = extern struct {
    pNameNext: ?*u16,
    wNumTypes: u16,
    wTypes: ?[*]u16,
};
// --------------------------------------------------------
// Type: DNS_NXT_DATAA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DNS_NXT_DATAA = extern struct {
    pNameNext: ?*i8,
    wNumTypes: u16,
    wTypes: ?[*]u16,
};
// --------------------------------------------------------
// Type: DNS_SRV_DATAW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DNS_SRV_DATAW = extern struct {
    pNameTarget: ?*u16,
    wPriority: u16,
    wWeight: u16,
    wPort: u16,
    Pad: u16,
};
// --------------------------------------------------------
// Type: DNS_SRV_DATAA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DNS_SRV_DATAA = extern struct {
    pNameTarget: ?*i8,
    wPriority: u16,
    wWeight: u16,
    wPort: u16,
    Pad: u16,
};
// --------------------------------------------------------
// Type: DNS_NAPTR_DATAW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DNS_NAPTR_DATAW = extern struct {
    wOrder: u16,
    wPreference: u16,
    pFlags: ?*u16,
    pService: ?*u16,
    pRegularExpression: ?*u16,
    pReplacement: ?*u16,
};
// --------------------------------------------------------
// Type: DNS_NAPTR_DATAA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DNS_NAPTR_DATAA = extern struct {
    wOrder: u16,
    wPreference: u16,
    pFlags: ?*i8,
    pService: ?*i8,
    pRegularExpression: ?*i8,
    pReplacement: ?*i8,
};
// --------------------------------------------------------
// Type: DNS_ATMA_DATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DNS_ATMA_DATA = extern struct {
    AddressType: u8,
    Address: ?[*]u8,
};
// --------------------------------------------------------
// Type: DNS_TKEY_DATAW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DNS_TKEY_DATAW = extern struct {
    pNameAlgorithm: ?*u16,
    pAlgorithmPacket: ?*u8,
    pKey: ?*u8,
    pOtherData: ?*u8,
    dwCreateTime: u32,
    dwExpireTime: u32,
    wMode: u16,
    wError: u16,
    wKeyLength: u16,
    wOtherLength: u16,
    cAlgNameLength: u8,
    bPacketPointers: BOOL,
};
// --------------------------------------------------------
// Type: DNS_TKEY_DATAA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DNS_TKEY_DATAA = extern struct {
    pNameAlgorithm: ?*i8,
    pAlgorithmPacket: ?*u8,
    pKey: ?*u8,
    pOtherData: ?*u8,
    dwCreateTime: u32,
    dwExpireTime: u32,
    wMode: u16,
    wError: u16,
    wKeyLength: u16,
    wOtherLength: u16,
    cAlgNameLength: u8,
    bPacketPointers: BOOL,
};
// --------------------------------------------------------
// Type: DNS_TSIG_DATAW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DNS_TSIG_DATAW = extern struct {
    pNameAlgorithm: ?*u16,
    pAlgorithmPacket: ?*u8,
    pSignature: ?*u8,
    pOtherData: ?*u8,
    i64CreateTime: i64,
    wFudgeTime: u16,
    wOriginalXid: u16,
    wError: u16,
    wSigLength: u16,
    wOtherLength: u16,
    cAlgNameLength: u8,
    bPacketPointers: BOOL,
};
// --------------------------------------------------------
// Type: DNS_TSIG_DATAA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DNS_TSIG_DATAA = extern struct {
    pNameAlgorithm: ?*i8,
    pAlgorithmPacket: ?*u8,
    pSignature: ?*u8,
    pOtherData: ?*u8,
    i64CreateTime: i64,
    wFudgeTime: u16,
    wOriginalXid: u16,
    wError: u16,
    wSigLength: u16,
    wOtherLength: u16,
    cAlgNameLength: u8,
    bPacketPointers: BOOL,
};
// --------------------------------------------------------
// Type: DNS_UNKNOWN_DATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DNS_UNKNOWN_DATA = extern struct {
    dwByteCount: u32,
    bData: ?[*]u8,
};
// --------------------------------------------------------
// Type: DNS_WINS_DATA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DNS_WINS_DATA = extern struct {
    dwMappingFlag: u32,
    dwLookupTimeout: u32,
    dwCacheTimeout: u32,
    cWinsServerCount: u32,
    WinsServers: ?[*]u32,
};
// --------------------------------------------------------
// Type: DNS_WINSR_DATAW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DNS_WINSR_DATAW = extern struct {
    dwMappingFlag: u32,
    dwLookupTimeout: u32,
    dwCacheTimeout: u32,
    pNameResultDomain: ?*u16,
};
// --------------------------------------------------------
// Type: DNS_WINSR_DATAA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DNS_WINSR_DATAA = extern struct {
    dwMappingFlag: u32,
    dwLookupTimeout: u32,
    dwCacheTimeout: u32,
    pNameResultDomain: ?*i8,
};
// --------------------------------------------------------
// Type: DNS_RECORD_FLAGS
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DNS_RECORD_FLAGS = extern struct {
    _bitfield: u32,
};
// --------------------------------------------------------
// Type: DNS_SECTION
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const DNS_SECTION = *opaque{
};
// --------------------------------------------------------
// Type: DNS_RECORDW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DNS_RECORDW = extern struct {
    pNext: ?*DNS_RECORDW,
    pName: ?*u16,
    wType: u16,
    wDataLength: u16,
    Flags: _Flags_e__Union,
    dwTtl: u32,
    dwReserved: u32,
    Data: _Data_e__Union,
    // --------------------------------------------------------
    // Type: _Flags_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Flags_e__Union = *opaque{
    };
    // --------------------------------------------------------
    // Type: _Data_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Data_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: _DnsRecordOptW
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const _DnsRecordOptW = extern struct {
    pNext: ?*DNS_RECORDW,
    pName: ?*u16,
    wType: u16,
    wDataLength: u16,
    Flags: _Flags_e__Union,
    ExtHeader: DNS_HEADER_EXT,
    wPayloadSize: u16,
    wReserved: u16,
    Data: _Data_e__Union,
    // --------------------------------------------------------
    // Type: _Flags_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Flags_e__Union = *opaque{
    };
    // --------------------------------------------------------
    // Type: _Data_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Data_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: DNS_RECORDA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DNS_RECORDA = extern struct {
    pNext: ?*DNS_RECORDA,
    pName: ?*i8,
    wType: u16,
    wDataLength: u16,
    Flags: _Flags_e__Union,
    dwTtl: u32,
    dwReserved: u32,
    Data: _Data_e__Union,
    // --------------------------------------------------------
    // Type: _Flags_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Flags_e__Union = *opaque{
    };
    // --------------------------------------------------------
    // Type: _Data_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Data_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: _DnsRecordOptA
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const _DnsRecordOptA = extern struct {
    pNext: ?*DNS_RECORDA,
    pName: ?*i8,
    wType: u16,
    wDataLength: u16,
    Flags: _Flags_e__Union,
    ExtHeader: DNS_HEADER_EXT,
    wPayloadSize: u16,
    wReserved: u16,
    Data: _Data_e__Union,
    // --------------------------------------------------------
    // Type: _Flags_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Flags_e__Union = *opaque{
    };
    // --------------------------------------------------------
    // Type: _Data_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Data_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: DNS_RRSET
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DNS_RRSET = extern struct {
    pFirstRR: ?*DNS_RECORDA,
    pLastRR: ?*DNS_RECORDA,
};
// --------------------------------------------------------
// Type: DNS_PROXY_COMPLETION_ROUTINE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const DNS_PROXY_COMPLETION_ROUTINE = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: DNS_PROXY_INFORMATION_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const DNS_PROXY_INFORMATION_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: DNS_PROXY_INFORMATION
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DNS_PROXY_INFORMATION = extern struct {
    version: u32,
    proxyInformationType: DNS_PROXY_INFORMATION_TYPE,
    proxyName: ?*u16,
};
// --------------------------------------------------------
// Type: DNS_CHARSET
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const DNS_CHARSET = *opaque{
};
// --------------------------------------------------------
// Type: DNS_FREE_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const DNS_FREE_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: DNS_QUERY_RESULT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DNS_QUERY_RESULT = extern struct {
    Version: u32,
    QueryStatus: i32,
    QueryOptions: u64,
    pQueryRecords: ?*DNS_RECORDA,
    Reserved: ?*opaque{},
};
// --------------------------------------------------------
// Type: DNS_QUERY_COMPLETION_ROUTINE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const DNS_QUERY_COMPLETION_ROUTINE = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PDNS_QUERY_COMPLETION_ROUTINE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PDNS_QUERY_COMPLETION_ROUTINE = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: DNS_QUERY_REQUEST
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DNS_QUERY_REQUEST = extern struct {
    Version: u32,
    QueryName: ?*u16,
    QueryType: u16,
    QueryOptions: u64,
    pDnsServerList: ?*DNS_ADDR_ARRAY,
    InterfaceIndex: u32,
    pQueryCompletionCallback: PDNS_QUERY_COMPLETION_ROUTINE,
    pQueryContext: ?*opaque{},
};
// --------------------------------------------------------
// Type: DNS_QUERY_CANCEL
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DNS_QUERY_CANCEL = extern struct {
    Reserved: ?[*]i8,
};
// --------------------------------------------------------
// Type: DNS_NAME_FORMAT
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const DNS_NAME_FORMAT = *opaque{
};
// --------------------------------------------------------
// Type: DNS_MESSAGE_BUFFER
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DNS_MESSAGE_BUFFER = extern struct {
    MessageHead: DNS_HEADER,
    MessageBody: ?[*]i8,
};
// --------------------------------------------------------
// Type: DNS_CONNECTION_PROXY_TYPE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const DNS_CONNECTION_PROXY_TYPE = *opaque{
};
// --------------------------------------------------------
// Type: DNS_CONNECTION_PROXY_INFO_SWITCH
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const DNS_CONNECTION_PROXY_INFO_SWITCH = *opaque{
};
// --------------------------------------------------------
// Type: DNS_CONNECTION_PROXY_INFO
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DNS_CONNECTION_PROXY_INFO = extern struct {
    Version: u32,
    pwszFriendlyName: ?*u16,
    Flags: u32,
    Switch: DNS_CONNECTION_PROXY_INFO_SWITCH,
    Anonymous: _Anonymous_e__Union,
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
        // --------------------------------------------------------
        // Type: _DNS_CONNECTION_PROXY_INFO_CONFIG
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _DNS_CONNECTION_PROXY_INFO_CONFIG = extern struct {
            pwszServer: ?*u16,
            pwszUsername: ?*u16,
            pwszPassword: ?*u16,
            pwszException: ?*u16,
            pwszExtraInfo: ?*u16,
            Port: u16,
        };
        // --------------------------------------------------------
        // Type: _DNS_CONNECTION_PROXY_INFO_SCRIPT
        // TypeLayoutAttr: sequential
        // TODO: I think this is a struct, but not sure at this point, assuming it is for now
        pub const _DNS_CONNECTION_PROXY_INFO_SCRIPT = extern struct {
            pwszScript: ?*u16,
            pwszUsername: ?*u16,
            pwszPassword: ?*u16,
        };
    };
};
// --------------------------------------------------------
// Type: DNS_CONNECTION_PROXY_INFO_EX
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DNS_CONNECTION_PROXY_INFO_EX = extern struct {
    ProxyInfo: DNS_CONNECTION_PROXY_INFO,
    dwInterfaceIndex: u32,
    pwszConnectionName: ?*u16,
    fDirectConfiguration: BOOL,
    hConnection: HANDLE,
};
// --------------------------------------------------------
// Type: DNS_CONNECTION_PROXY_ELEMENT
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DNS_CONNECTION_PROXY_ELEMENT = extern struct {
    Type: DNS_CONNECTION_PROXY_TYPE,
    Info: DNS_CONNECTION_PROXY_INFO,
};
// --------------------------------------------------------
// Type: DNS_CONNECTION_PROXY_LIST
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DNS_CONNECTION_PROXY_LIST = extern struct {
    cProxies: u32,
    pProxies: ?*DNS_CONNECTION_PROXY_ELEMENT,
};
// --------------------------------------------------------
// Type: DNS_CONNECTION_NAME
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DNS_CONNECTION_NAME = extern struct {
    wszName: ?[*]u16,
};
// --------------------------------------------------------
// Type: DNS_CONNECTION_NAME_LIST
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DNS_CONNECTION_NAME_LIST = extern struct {
    cNames: u32,
    pNames: ?*DNS_CONNECTION_NAME,
};
// --------------------------------------------------------
// Type: DNS_CONNECTION_IFINDEX_ENTRY
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DNS_CONNECTION_IFINDEX_ENTRY = extern struct {
    pwszConnectionName: ?*u16,
    dwIfIndex: u32,
};
// --------------------------------------------------------
// Type: DNS_CONNECTION_IFINDEX_LIST
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DNS_CONNECTION_IFINDEX_LIST = extern struct {
    pConnectionIfIndexEntries: ?*DNS_CONNECTION_IFINDEX_ENTRY,
    nEntries: u32,
};
// --------------------------------------------------------
// Type: DNS_CONNECTION_POLICY_ENTRY
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DNS_CONNECTION_POLICY_ENTRY = extern struct {
    pwszHost: ?*u16,
    pwszAppId: ?*u16,
    cbAppSid: u32,
    pbAppSid: ?*u8,
    nConnections: u32,
    ppwszConnections: ?*?*u16,
    dwPolicyEntryFlags: u32,
};
// --------------------------------------------------------
// Type: DNS_CONNECTION_POLICY_ENTRY_LIST
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DNS_CONNECTION_POLICY_ENTRY_LIST = extern struct {
    pPolicyEntries: ?*DNS_CONNECTION_POLICY_ENTRY,
    nEntries: u32,
};
// --------------------------------------------------------
// Type: DNS_CONNECTION_POLICY_TAG
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const DNS_CONNECTION_POLICY_TAG = *opaque{
};
// --------------------------------------------------------
// Type: DNS_SERVICE_INSTANCE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DNS_SERVICE_INSTANCE = extern struct {
    pszInstanceName: ?*u16,
    pszHostName: ?*u16,
    ip4Address: ?*u32,
    ip6Address: ?*IP6_ADDRESS,
    wPort: u16,
    wPriority: u16,
    wWeight: u16,
    dwPropertyCount: u32,
    keys: ?*?*u16,
    values: ?*?*u16,
    dwInterfaceIndex: u32,
};
// --------------------------------------------------------
// Type: DNS_SERVICE_CANCEL
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DNS_SERVICE_CANCEL = extern struct {
    reserved: ?*opaque{},
};
// --------------------------------------------------------
// Type: DNS_SERVICE_BROWSE_CALLBACK
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const DNS_SERVICE_BROWSE_CALLBACK = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PDNS_SERVICE_BROWSE_CALLBACK
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PDNS_SERVICE_BROWSE_CALLBACK = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: DNS_SERVICE_BROWSE_REQUEST
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DNS_SERVICE_BROWSE_REQUEST = extern struct {
    Version: u32,
    InterfaceIndex: u32,
    QueryName: ?*u16,
    Anonymous: _Anonymous_e__Union,
    pQueryContext: ?*opaque{},
    // --------------------------------------------------------
    // Type: _Anonymous_e__Union
    // TypeLayoutAttr: explicit
    // not generating the actual code for this type because it has an explicit layout
    pub const _Anonymous_e__Union = *opaque{
    };
};
// --------------------------------------------------------
// Type: DNS_SERVICE_RESOLVE_COMPLETE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const DNS_SERVICE_RESOLVE_COMPLETE = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PDNS_SERVICE_RESOLVE_COMPLETE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PDNS_SERVICE_RESOLVE_COMPLETE = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: DNS_SERVICE_RESOLVE_REQUEST
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DNS_SERVICE_RESOLVE_REQUEST = extern struct {
    Version: u32,
    InterfaceIndex: u32,
    QueryName: ?*u16,
    pResolveCompletionCallback: PDNS_SERVICE_RESOLVE_COMPLETE,
    pQueryContext: ?*opaque{},
};
// --------------------------------------------------------
// Type: DNS_SERVICE_REGISTER_COMPLETE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const DNS_SERVICE_REGISTER_COMPLETE = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PDNS_SERVICE_REGISTER_COMPLETE
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PDNS_SERVICE_REGISTER_COMPLETE = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: DNS_SERVICE_REGISTER_REQUEST
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const DNS_SERVICE_REGISTER_REQUEST = extern struct {
    Version: u32,
    InterfaceIndex: u32,
    pServiceInstance: ?*DNS_SERVICE_INSTANCE,
    pRegisterCompletionCallback: PDNS_SERVICE_REGISTER_COMPLETE,
    pQueryContext: ?*opaque{},
    hCredentials: HANDLE,
    unicastEnabled: BOOL,
};
// --------------------------------------------------------
// Type: MDNS_QUERY_HANDLE
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const MDNS_QUERY_HANDLE = extern struct {
    nameBuf: ?[*]u16,
    wType: u16,
    pSubscription: ?*opaque{},
    pWnfCallbackParams: ?*opaque{},
    stateNameData: ?[*]u32,
};
// --------------------------------------------------------
// Type: MDNS_QUERY_CALLBACK
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const MDNS_QUERY_CALLBACK = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: PMDNS_QUERY_CALLBACK
// TypeLayoutAttr: auto
// not generating the actual code for this type because it has an 'auto' layout (follow up on https://github.com/microsoft/win32metadata/issues/188)
pub const PMDNS_QUERY_CALLBACK = *opaque{
    // TODO: Method '.ctor'
    // TODO: Method 'Invoke'
};
// --------------------------------------------------------
// Type: MDNS_QUERY_REQUEST
// TypeLayoutAttr: sequential
// TODO: I think this is a struct, but not sure at this point, assuming it is for now
pub const MDNS_QUERY_REQUEST = extern struct {
    Version: u32,
    ulRefCount: u32,
    Query: ?*u16,
    QueryType: u16,
    QueryOptions: u64,
    InterfaceIndex: u32,
    pQueryCallback: PMDNS_QUERY_CALLBACK,
    pQueryContext: ?*opaque{},
    fAnswerReceived: BOOL,
    ulResendCount: u32,
};
// --------------------------------------------------------
// Type: DnsContextHandle
// TypeLayoutAttr: sequential
// RAIIFree 'DnsReleaseContextHandle' (TODO: can we use this information?)
pub const DnsContextHandle = ?*opaque{};

//
// functions
//

// set_last_errror=False (can and should we use this?)
pub extern "DNSAPI" fn DnsQueryConfig(
    Config: DNS_CONFIG_TYPE,
    Flag: u32,
    pwsAdapterName: ?*u16,
    pReserved: ?*opaque{},
    pBuffer: ?*opaque{},
    pBufLen: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "DNSAPI" fn DnsRecordCopyEx(
    pRecord: ?*DNS_RECORDA,
    CharSetIn: DNS_CHARSET,
    CharSetOut: DNS_CHARSET,
) callconv(@import("std").os.windows.WINAPI) ?*DNS_RECORDA;

// set_last_errror=False (can and should we use this?)
pub extern "DNSAPI" fn DnsRecordSetCopyEx(
    pRecordSet: ?*DNS_RECORDA,
    CharSetIn: DNS_CHARSET,
    CharSetOut: DNS_CHARSET,
) callconv(@import("std").os.windows.WINAPI) ?*DNS_RECORDA;

// set_last_errror=False (can and should we use this?)
pub extern "DNSAPI" fn DnsRecordCompare(
    pRecord1: ?*DNS_RECORDA,
    pRecord2: ?*DNS_RECORDA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "DNSAPI" fn DnsRecordSetCompare(
    pRR1: ?*DNS_RECORDA,
    pRR2: ?*DNS_RECORDA,
    ppDiff1: ?*?*DNS_RECORDA,
    ppDiff2: ?*?*DNS_RECORDA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "DNSAPI" fn DnsRecordSetDetach(
    pRecordList: ?*DNS_RECORDA,
) callconv(@import("std").os.windows.WINAPI) ?*DNS_RECORDA;

// set_last_errror=False (can and should we use this?)
pub extern "DNSAPI" fn DnsFree(
    pData: ?*opaque{},
    FreeType: DNS_FREE_TYPE,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "DNSAPI" fn DnsQuery_A(
    pszName: ?*i8,
    wType: u16,
    Options: u32,
    pExtra: ?*opaque{},
    ppQueryResults: ?*?*DNS_RECORDA,
    pReserved: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "DNSAPI" fn DnsQuery_UTF8(
    pszName: ?*i8,
    wType: u16,
    Options: u32,
    pExtra: ?*opaque{},
    ppQueryResults: ?*?*DNS_RECORDA,
    pReserved: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "DNSAPI" fn DnsQuery_W(
    pszName: ?*u16,
    wType: u16,
    Options: u32,
    pExtra: ?*opaque{},
    ppQueryResults: ?*?*DNS_RECORDA,
    pReserved: ?*?*opaque{},
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "DNSAPI" fn DnsQueryEx(
    pQueryRequest: ?*DNS_QUERY_REQUEST,
    pQueryResults: ?*DNS_QUERY_RESULT,
    pCancelHandle: ?*DNS_QUERY_CANCEL,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "DNSAPI" fn DnsCancelQuery(
    pCancelHandle: ?*DNS_QUERY_CANCEL,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "DNSAPI" fn DnsAcquireContextHandle_W(
    CredentialFlags: u32,
    Credentials: ?*opaque{},
    pContext: ?*DnsContextHandle,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "DNSAPI" fn DnsAcquireContextHandle_A(
    CredentialFlags: u32,
    Credentials: ?*opaque{},
    pContext: ?*DnsContextHandle,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "DNSAPI" fn DnsReleaseContextHandle(
    hContext: HANDLE,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "DNSAPI" fn DnsModifyRecordsInSet_W(
    pAddRecords: ?*DNS_RECORDA,
    pDeleteRecords: ?*DNS_RECORDA,
    Options: u32,
    hCredentials: HANDLE,
    pExtraList: ?*opaque{},
    pReserved: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "DNSAPI" fn DnsModifyRecordsInSet_A(
    pAddRecords: ?*DNS_RECORDA,
    pDeleteRecords: ?*DNS_RECORDA,
    Options: u32,
    hCredentials: HANDLE,
    pExtraList: ?*opaque{},
    pReserved: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "DNSAPI" fn DnsModifyRecordsInSet_UTF8(
    pAddRecords: ?*DNS_RECORDA,
    pDeleteRecords: ?*DNS_RECORDA,
    Options: u32,
    hCredentials: HANDLE,
    pExtraList: ?*opaque{},
    pReserved: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "DNSAPI" fn DnsReplaceRecordSetW(
    pReplaceSet: ?*DNS_RECORDA,
    Options: u32,
    hContext: HANDLE,
    pExtraInfo: ?*opaque{},
    pReserved: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "DNSAPI" fn DnsReplaceRecordSetA(
    pReplaceSet: ?*DNS_RECORDA,
    Options: u32,
    hContext: HANDLE,
    pExtraInfo: ?*opaque{},
    pReserved: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "DNSAPI" fn DnsReplaceRecordSetUTF8(
    pReplaceSet: ?*DNS_RECORDA,
    Options: u32,
    hContext: HANDLE,
    pExtraInfo: ?*opaque{},
    pReserved: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "DNSAPI" fn DnsValidateName_W(
    pszName: ?*u16,
    Format: DNS_NAME_FORMAT,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "DNSAPI" fn DnsValidateName_A(
    pszName: ?*i8,
    Format: DNS_NAME_FORMAT,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "DNSAPI" fn DnsValidateName_UTF8(
    pszName: ?*i8,
    Format: DNS_NAME_FORMAT,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "DNSAPI" fn DnsNameCompare_A(
    pName1: ?*i8,
    pName2: ?*i8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "DNSAPI" fn DnsNameCompare_W(
    pName1: ?*u16,
    pName2: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "DNSAPI" fn DnsWriteQuestionToBuffer_W(
    pDnsBuffer: ?*DNS_MESSAGE_BUFFER,
    pdwBufferSize: ?*u32,
    pszName: ?*u16,
    wType: u16,
    Xid: u16,
    fRecursionDesired: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "DNSAPI" fn DnsWriteQuestionToBuffer_UTF8(
    pDnsBuffer: ?*DNS_MESSAGE_BUFFER,
    pdwBufferSize: ?*u32,
    pszName: ?*i8,
    wType: u16,
    Xid: u16,
    fRecursionDesired: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// set_last_errror=False (can and should we use this?)
pub extern "DNSAPI" fn DnsExtractRecordsFromMessage_W(
    pDnsBuffer: ?*DNS_MESSAGE_BUFFER,
    wMessageLength: u16,
    ppRecord: ?*?*DNS_RECORDA,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "DNSAPI" fn DnsExtractRecordsFromMessage_UTF8(
    pDnsBuffer: ?*DNS_MESSAGE_BUFFER,
    wMessageLength: u16,
    ppRecord: ?*?*DNS_RECORDA,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=False (can and should we use this?)
pub extern "DNSAPI" fn DnsGetProxyInformation(
    hostName: ?*u16,
    proxyInformation: ?*DNS_PROXY_INFORMATION,
    defaultProxyInformation: ?*DNS_PROXY_INFORMATION,
    completionRoutine: DNS_PROXY_COMPLETION_ROUTINE,
    completionContext: ?*opaque{},
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "DNSAPI" fn DnsFreeProxyName(
    proxyName: ?*u16,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "DNSAPI" fn DnsConnectionGetProxyInfoForHostUrl(
    pwszHostUrl: ?*u16,
    pSelectionContext: ?*u8,
    dwSelectionContextLength: u32,
    dwExplicitInterfaceIndex: u32,
    pProxyInfoEx: ?*DNS_CONNECTION_PROXY_INFO_EX,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "DNSAPI" fn DnsConnectionFreeProxyInfoEx(
    pProxyInfoEx: ?*DNS_CONNECTION_PROXY_INFO_EX,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "DNSAPI" fn DnsConnectionGetProxyInfo(
    pwszConnectionName: ?*u16,
    Type: DNS_CONNECTION_PROXY_TYPE,
    pProxyInfo: ?*DNS_CONNECTION_PROXY_INFO,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "DNSAPI" fn DnsConnectionFreeProxyInfo(
    pProxyInfo: ?*DNS_CONNECTION_PROXY_INFO,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "DNSAPI" fn DnsConnectionSetProxyInfo(
    pwszConnectionName: ?*u16,
    Type: DNS_CONNECTION_PROXY_TYPE,
    pProxyInfo: ?*DNS_CONNECTION_PROXY_INFO,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "DNSAPI" fn DnsConnectionDeleteProxyInfo(
    pwszConnectionName: ?*u16,
    Type: DNS_CONNECTION_PROXY_TYPE,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "DNSAPI" fn DnsConnectionGetProxyList(
    pwszConnectionName: ?*u16,
    pProxyList: ?*DNS_CONNECTION_PROXY_LIST,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "DNSAPI" fn DnsConnectionFreeProxyList(
    pProxyList: ?*DNS_CONNECTION_PROXY_LIST,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "DNSAPI" fn DnsConnectionGetNameList(
    pNameList: ?*DNS_CONNECTION_NAME_LIST,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "DNSAPI" fn DnsConnectionFreeNameList(
    pNameList: ?*DNS_CONNECTION_NAME_LIST,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=False (can and should we use this?)
pub extern "DNSAPI" fn DnsConnectionUpdateIfIndexTable(
    pConnectionIfIndexEntries: ?*DNS_CONNECTION_IFINDEX_LIST,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "DNSAPI" fn DnsConnectionSetPolicyEntries(
    PolicyEntryTag: DNS_CONNECTION_POLICY_TAG,
    pPolicyEntryList: ?*DNS_CONNECTION_POLICY_ENTRY_LIST,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "DNSAPI" fn DnsConnectionDeletePolicyEntries(
    PolicyEntryTag: DNS_CONNECTION_POLICY_TAG,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "DNSAPI" fn DnsServiceConstructInstance(
    pServiceName: ?*u16,
    pHostName: ?*u16,
    pIp4: ?*u32,
    pIp6: ?*IP6_ADDRESS,
    wPort: u16,
    wPriority: u16,
    wWeight: u16,
    dwPropertiesCount: u32,
    keys: ?*?*u16,
    values: ?*?*u16,
) callconv(@import("std").os.windows.WINAPI) ?*DNS_SERVICE_INSTANCE;

// set_last_errror=False (can and should we use this?)
pub extern "DNSAPI" fn DnsServiceCopyInstance(
    pOrig: ?*DNS_SERVICE_INSTANCE,
) callconv(@import("std").os.windows.WINAPI) ?*DNS_SERVICE_INSTANCE;

// set_last_errror=False (can and should we use this?)
pub extern "DNSAPI" fn DnsServiceFreeInstance(
    pInstance: ?*DNS_SERVICE_INSTANCE,
) callconv(@import("std").os.windows.WINAPI) void;

// set_last_errror=True (can and should we use this?)
pub extern "DNSAPI" fn DnsServiceBrowse(
    pRequest: ?*DNS_SERVICE_BROWSE_REQUEST,
    pCancel: ?*DNS_SERVICE_CANCEL,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=True (can and should we use this?)
pub extern "DNSAPI" fn DnsServiceBrowseCancel(
    pCancelHandle: ?*DNS_SERVICE_CANCEL,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=True (can and should we use this?)
pub extern "DNSAPI" fn DnsServiceResolve(
    pRequest: ?*DNS_SERVICE_RESOLVE_REQUEST,
    pCancel: ?*DNS_SERVICE_CANCEL,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=True (can and should we use this?)
pub extern "DNSAPI" fn DnsServiceResolveCancel(
    pCancelHandle: ?*DNS_SERVICE_CANCEL,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=True (can and should we use this?)
pub extern "DNSAPI" fn DnsServiceRegister(
    pRequest: ?*DNS_SERVICE_REGISTER_REQUEST,
    pCancel: ?*DNS_SERVICE_CANCEL,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "DNSAPI" fn DnsServiceDeRegister(
    pRequest: ?*DNS_SERVICE_REGISTER_REQUEST,
    pCancel: ?*DNS_SERVICE_CANCEL,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=False (can and should we use this?)
pub extern "DNSAPI" fn DnsServiceRegisterCancel(
    pCancelHandle: ?*DNS_SERVICE_CANCEL,
) callconv(@import("std").os.windows.WINAPI) u32;

// set_last_errror=True (can and should we use this?)
pub extern "DNSAPI" fn DnsStartMulticastQuery(
    pQueryRequest: ?*MDNS_QUERY_REQUEST,
    pHandle: ?*MDNS_QUERY_HANDLE,
) callconv(@import("std").os.windows.WINAPI) i32;

// set_last_errror=True (can and should we use this?)
pub extern "DNSAPI" fn DnsStopMulticastQuery(
    pHandle: ?*MDNS_QUERY_HANDLE,
) callconv(@import("std").os.windows.WINAPI) i32;

//
// Unicode Symbol Aliases
//
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {
        pub const DNS_PTR_DATA = DNS_PTR_DATAA;
        pub const DNS_SOA_DATA = DNS_SOA_DATAA;
        pub const DNS_MINFO_DATA = DNS_MINFO_DATAA;
        pub const DNS_MX_DATA = DNS_MX_DATAA;
        pub const DNS_TXT_DATA = DNS_TXT_DATAA;
        pub const DNS_SIG_DATA = DNS_SIG_DATAA;
        pub const DNS_NSEC_DATA = DNS_NSEC_DATAA;
        pub const DNS_NXT_DATA = DNS_NXT_DATAA;
        pub const DNS_SRV_DATA = DNS_SRV_DATAA;
        pub const DNS_NAPTR_DATA = DNS_NAPTR_DATAA;
        pub const DNS_TKEY_DATA = DNS_TKEY_DATAA;
        pub const DNS_TSIG_DATA = DNS_TSIG_DATAA;
        pub const DNS_WINSR_DATA = DNS_WINSR_DATAA;
        pub const DNS_RECORD = DNS_RECORDA;
        pub const _DnsRecordOpt = _DnsRecordOptA;
        pub const DnsQuery_ = DnsQuery_A;
        pub const DnsAcquireContextHandle_ = DnsAcquireContextHandle_A;
        pub const DnsModifyRecordsInSet_ = DnsModifyRecordsInSet_A;
        pub const DnsReplaceRecordSet = DnsReplaceRecordSetA;
        pub const DnsValidateName_ = DnsValidateName_A;
        pub const DnsNameCompare_ = DnsNameCompare_A;
    },
    .wide => struct {
        pub const DNS_PTR_DATA = DNS_PTR_DATAW;
        pub const DNS_SOA_DATA = DNS_SOA_DATAW;
        pub const DNS_MINFO_DATA = DNS_MINFO_DATAW;
        pub const DNS_MX_DATA = DNS_MX_DATAW;
        pub const DNS_TXT_DATA = DNS_TXT_DATAW;
        pub const DNS_SIG_DATA = DNS_SIG_DATAW;
        pub const DNS_NSEC_DATA = DNS_NSEC_DATAW;
        pub const DNS_NXT_DATA = DNS_NXT_DATAW;
        pub const DNS_SRV_DATA = DNS_SRV_DATAW;
        pub const DNS_NAPTR_DATA = DNS_NAPTR_DATAW;
        pub const DNS_TKEY_DATA = DNS_TKEY_DATAW;
        pub const DNS_TSIG_DATA = DNS_TSIG_DATAW;
        pub const DNS_WINSR_DATA = DNS_WINSR_DATAW;
        pub const DNS_RECORD = DNS_RECORDW;
        pub const _DnsRecordOpt = _DnsRecordOptW;
        pub const DnsQuery_ = DnsQuery_W;
        pub const DnsAcquireContextHandle_ = DnsAcquireContextHandle_W;
        pub const DnsModifyRecordsInSet_ = DnsModifyRecordsInSet_W;
        pub const DnsReplaceRecordSet = DnsReplaceRecordSetW;
        pub const DnsValidateName_ = DnsValidateName_W;
        pub const DnsNameCompare_ = DnsNameCompare_W;
    },
    else => if (@import("builtin").is_test) struct {
        pub const DNS_PTR_DATA = *opaque{};
        pub const DNS_SOA_DATA = *opaque{};
        pub const DNS_MINFO_DATA = *opaque{};
        pub const DNS_MX_DATA = *opaque{};
        pub const DNS_TXT_DATA = *opaque{};
        pub const DNS_SIG_DATA = *opaque{};
        pub const DNS_NSEC_DATA = *opaque{};
        pub const DNS_NXT_DATA = *opaque{};
        pub const DNS_SRV_DATA = *opaque{};
        pub const DNS_NAPTR_DATA = *opaque{};
        pub const DNS_TKEY_DATA = *opaque{};
        pub const DNS_TSIG_DATA = *opaque{};
        pub const DNS_WINSR_DATA = *opaque{};
        pub const DNS_RECORD = *opaque{};
        pub const _DnsRecordOpt = *opaque{};
        pub const DnsQuery_ = *opaque{};
        pub const DnsAcquireContextHandle_ = *opaque{};
        pub const DnsModifyRecordsInSet_ = *opaque{};
        pub const DnsReplaceRecordSet = *opaque{};
        pub const DnsValidateName_ = *opaque{};
        pub const DnsNameCompare_ = *opaque{};
    } else struct {
        pub const DNS_PTR_DATA = @compileError("'DNS_PTR_DATA' requires that UNICODE be set to true or false in the root module");
        pub const DNS_SOA_DATA = @compileError("'DNS_SOA_DATA' requires that UNICODE be set to true or false in the root module");
        pub const DNS_MINFO_DATA = @compileError("'DNS_MINFO_DATA' requires that UNICODE be set to true or false in the root module");
        pub const DNS_MX_DATA = @compileError("'DNS_MX_DATA' requires that UNICODE be set to true or false in the root module");
        pub const DNS_TXT_DATA = @compileError("'DNS_TXT_DATA' requires that UNICODE be set to true or false in the root module");
        pub const DNS_SIG_DATA = @compileError("'DNS_SIG_DATA' requires that UNICODE be set to true or false in the root module");
        pub const DNS_NSEC_DATA = @compileError("'DNS_NSEC_DATA' requires that UNICODE be set to true or false in the root module");
        pub const DNS_NXT_DATA = @compileError("'DNS_NXT_DATA' requires that UNICODE be set to true or false in the root module");
        pub const DNS_SRV_DATA = @compileError("'DNS_SRV_DATA' requires that UNICODE be set to true or false in the root module");
        pub const DNS_NAPTR_DATA = @compileError("'DNS_NAPTR_DATA' requires that UNICODE be set to true or false in the root module");
        pub const DNS_TKEY_DATA = @compileError("'DNS_TKEY_DATA' requires that UNICODE be set to true or false in the root module");
        pub const DNS_TSIG_DATA = @compileError("'DNS_TSIG_DATA' requires that UNICODE be set to true or false in the root module");
        pub const DNS_WINSR_DATA = @compileError("'DNS_WINSR_DATA' requires that UNICODE be set to true or false in the root module");
        pub const DNS_RECORD = @compileError("'DNS_RECORD' requires that UNICODE be set to true or false in the root module");
        pub const _DnsRecordOpt = @compileError("'_DnsRecordOpt' requires that UNICODE be set to true or false in the root module");
        pub const DnsQuery_ = @compileError("'DnsQuery_' requires that UNICODE be set to true or false in the root module");
        pub const DnsAcquireContextHandle_ = @compileError("'DnsAcquireContextHandle_' requires that UNICODE be set to true or false in the root module");
        pub const DnsModifyRecordsInSet_ = @compileError("'DnsModifyRecordsInSet_' requires that UNICODE be set to true or false in the root module");
        pub const DnsReplaceRecordSet = @compileError("'DnsReplaceRecordSet' requires that UNICODE be set to true or false in the root module");
        pub const DnsValidateName_ = @compileError("'DnsValidateName_' requires that UNICODE be set to true or false in the root module");
        pub const DnsNameCompare_ = @compileError("'DnsNameCompare_' requires that UNICODE be set to true or false in the root module");
    },
};

//
// type imports
//
const BOOL = @import("systemservices.zig").BOOL;
const HANDLE = @import("systemservices.zig").HANDLE;

test "" {
    const constant_export_count = 0;
    const type_export_count = 98;
    const func_count = 57;
    const unicode_alias_count = 21;
    const type_import_count = 2;
    @setEvalBranchQuota(0
        + constant_export_count
        + type_export_count
        + func_count
        + unicode_alias_count
        + type_import_count
        + 2 // TODO: why do I need these extra 2?
    );
    @import("std").testing.refAllDecls(@This());
}
